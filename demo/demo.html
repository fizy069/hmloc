<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="index.css">
  <title>HM<sup>ℓ</sup> demonstration</title>
</head>

<body>
  <h1>HM<sup>ℓ</sup> demonstration</h1>
  <div id="content">
    <textarea id="system-input" class="panel" spellcheck="false">
(* example 1 *)
val parse_version: string -> string
val show_major: string -> string

let appInfo = ("My Application", 1.5)

let process (name, vers) = name ^ show_major (parse_version vers)

let test = process appInfo

(* example 2 *)
let test =
  let f x = x in
    (f 1, f true)

(* example 3 *)
type ('a, 'b) either = Left of 'a | Right of 'b

let destructEither x = match x with
  | Left l -> l + 1
  | Right r -> r :: []

(* example 4 *)
let wrap x = x :: []
let rec t = wrap (if true then 1 else t)
  </textarea>
  <div id="system-output" class="panel"></div>
  </div>
  <script type="text/javascript" src="main.js"></script>
  <br />
  <p>
    This is a demo of the HM<sup>ℓ</sup> type system. Code on the left panel is type checked
    and on the left panel valid types and type unification errors are shown.
  </p>
  <p>
    The demo implements a frontend for OCaml syntax.
    It supports type declaration, ADT definition, top level let statements,
    and pattern matching. Note that it does not support
    list/string indexing, records nested pattern matching and modules.
  </p>
  <p>
    Some basic standard library functions for booleans, strings, lists, integers
    are pre-defined. We provide slightly relaxed OCaml syntax for declaring
    function signatures as needed.
  </p>
  <p>
    Some examples from the manuscript might report slightly different
    errors here because of changed formatting and layout design.
  </p>
</html>
