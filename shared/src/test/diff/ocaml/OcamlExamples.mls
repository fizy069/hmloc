:OcamlParser
:OcamlLoadLibrary

// 30 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╔══[WARNING] bool<> and [(true<bool> | (α57' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α57' & ~(true<bool>))) is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	     ^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[[list[α58']]]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[α58'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α58'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[list[α56']]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[α56'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α56'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α56']]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α56'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α56'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α60'
//│ ╟── α60' is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[[list[α58']]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α58'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α58'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α60'
//│ ╟── α60' is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                                      ^^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ digitsOfInt: int -> list[list[int]]

// 36 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else
      let remainder = n mod 10 in
      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α84')]] and [[[[[[int<>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α84') is here
//│ ║  l.108: 	      let remainder = n mod 10 in
//│ ║         	                      ^
//│ ╟── int<> is here
//│ ║  l.107: 	  if n < 0 then [] else
//│ ║         	     ^
//│ ╙── The following tvars cannot be resolved α78'
//│ ╔══[WARNING] bool<> and [(true<bool> | (α82' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α82' & ~(true<bool>))) is here
//│ ║  l.107: 	  if n < 0 then [] else
//│ ╙──       	     ^^^^^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α94' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α94' & ~(true<bool>))) is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^
//│ ╔══[WARNING] [[[list[α90']]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α90'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α90'] is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[[[list[α95']]]]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[α95'] is here
//│ ║  l.10: 	let (@): 'a list -> 'a list -> 'a list;
//│ ║        	                               ^^
//│ ╟── list[α95'] is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[list[α81']]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[α81'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α81'] is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[[[list[α95']]]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α95'] is here
//│ ║  l.10: 	let (@): 'a list -> 'a list -> 'a list;
//│ ║        	                               ^^
//│ ╟── list[α95'] is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α96', α105', α93'
//│ ╟── α96' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── α105' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α93' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                     ^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[list[α90']]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[α90'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α90'] is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α96', α105', α93'
//│ ╟── α96' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── α105' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α93' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                     ^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α81']]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α81'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α81'] is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α96', α104', α105', α93'
//│ ╟── α96' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── α104' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α105' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α93' is here
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                     ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `Cons[?a] | Nil`
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.10: 	let (@): 'a list -> 'a list -> 'a list;
//│ ║        	         ^^
//│ ╟── from union type:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ╙──     	                       ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.106: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.107: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.108: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                                      ^^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.107: 	  if n < 0 then [] else
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.108: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.106: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.107: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.108: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.107: 	  if n < 0 then [] else
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.108: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.106: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.107: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.108: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.106: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.107: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.108: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.109: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ digitsOfInt: nothing -> list[nothing]

// 38 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α139')]] and [[[[[[int<>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α139') is here
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── int<> is here
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╙── The following tvars cannot be resolved α122'
//│ ╔══[WARNING] [[[[[[int<>]]]]]] and [[([([(Int -> (Int -> Int))],)] -> α132')]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α132') is here
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                             ^
//│ ╙── The following tvars cannot be resolved α122'
//│ ╔══[WARNING] bool<> and [(true<bool> | (α126' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α126' & ~(true<bool>))) is here
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^^^^^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α134' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α134' & ~(true<bool>))) is here
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                            ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.315: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                                                                      ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.315: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.316: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                             ^
//│ digitsOfInt: nothing -> (list[nothing] | 'a)
//│   where
//│     'a :> list[list[nothing] | 'a]

// 309 mod
:unify
let pipe fs = let f a x = (fun n  -> a) x in let base n = n in List_fold_left f base fs;;
//│ pipe: list[?] -> 'a -> 'a

// 499
:unify
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let len1 = List_length l1 in
  let len2 = List_length l2 in
  if len1 > len2
  then (l1, ((clone 0 (len1 - len2)) @ l2))
  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ╔══[WARNING] bool<> and [(true<bool> | (α188' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α188' & ~(true<bool>))) is here
//│ ║  l.374: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ╙──       	                       ^^^^^^
//│ ╔══[WARNING] [[[[[[int<>]]]]]] and [[[Int]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.378: 	  if len1 > len2
//│ ║         	     ^^^^
//│ ╟── int<> is here
//│ ║  l.376: 	  let len1 = List_length l1 in
//│ ║         	             ^^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.7: 	let List_length: 'a list -> int;
//│ ║       	                            ^^^
//│ ╟── Int is here
//│ ║  l.376: 	  let len1 = List_length l1 in
//│ ╙──       	             ^^^^^^^^^^^^^^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α236' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α236' & ~(true<bool>))) is here
//│ ║  l.378: 	  if len1 > len2
//│ ╙──       	     ^^^^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padZero: list[?] -> list[?] -> (list[int], list[int],)

// 499 record types
:unify
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╔══[WARNING] [[[{_1: α276'}]]] and [[[{_0: α274'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α276'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: α274'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272'
//│ ╟── α272' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α282' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α282' & ~(true<bool>))) is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                            ^
//│ ╔══[WARNING] [[[{_0: α274'}]]] and [[[[[list[α271']]]]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α274'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[α271'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α271'] is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_1: α276'}]]] and [[[[[list[α271']]]]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α276'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[α271'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α271'] is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_0: α274'}]]] and [[[{_0: α274'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α274'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: α274'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_0: α274'}]]] and [[[{_1: α276'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α274'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: α276'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_1: α276'}]]] and [[[{_1: α276'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α276'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: α276'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[[[list[α271']]]]]] and [[[{_0: α274'}]]] cannot be unified but they flow into the same locations
//│ ╟── list[α271'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α271'] is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── {_0: α274'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', α281'
//│ ╟── α272' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α271']]]]]] and [[[{_1: α276'}]]] cannot be unified but they flow into the same locations
//│ ╟── list[α271'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α271'] is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── {_1: α276'} is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', α281'
//│ ╟── α272' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.408: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ removeZero: 'a -> (list[nothing] | 'b)
//│   where
//│     'a <: Cons[?] & {_0: int, _1: 'a} & 'b | Nil | 'b & ~#Cons & ~#Nil

// infix mod
:unifyDbg
let rec digitsOfInt n =
  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ [ERROR 1] ([([(Int -> (Int -> Int))],)] -> α308') != int<> unifying because [[([([(Int -> (Int -> Int))],)] -> α308')]] & [[[[[[int<>]]]]]] :> α303'
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α308')]] and [[[[[[int<>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α308') is here
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                                  ^
//│ ╟── int<> is here
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                      ^
//│ ╙── The following tvars cannot be resolved α303'
//│ [ERROR 0] bool<> != (true<bool> | (α314' & ~(true<bool>))) unifying because bool<> = [(true<bool> | (α314' & ~(true<bool>)))] because α306' = bool<> are result type in ([(int<>,)] -> α306') = (int<> -> bool<>) and α306' <: [(true<bool> | (α314' & ~(true<bool>)))]
//│ ╔══[WARNING] bool<> and [(true<bool> | (α314' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α314' & ~(true<bool>))) is here
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                      ^^^^^
//│ unified digitsOfInt302'
//│  digitsOfInt302' :> [(α303' -> α316')]
//│ unified α303'
//│  α303' <: [[[[[[int<>]]]]]]
//│  α303' <: [[([([(Int -> (Int -> Int))],)] -> α308')]]
//│ unified α304''
//│ unified α305'
//│  α305' :> [[(int<> -> bool<>)]]
//│  α305' <: [([(int<>,)] -> α306')]
//│ unified α306'
//│  α306' <: [(true<bool> | (α314' & ~(true<bool>)))]
//│  α306' = bool<> are result type in ([(int<>,)] -> α306') = (int<> -> bool<>)
//│ unified α307'
//│  α307' = α315' are TypeName(list)(0) arg type
//│ unified α308'
//│  α308' <: [([(int<>,)] -> α309')]
//│ unified α309'
//│  α309' <: [[α307']]
//│ unified α310'
//│ unified α311'
//│  α311' <: [([([α303'],)] -> α312')]
//│ unified α312'
//│  α312' <: [[[list[α307']]]]
//│ unified α313'
//│  α313' | [[list[α315']]] <: α316'
//│  α313' :> [[[list[α307']]]]
//│ unified α314'
//│  α314' :> [[[[(bool<> & ~(true<bool>))]]]]
//│ unified α315'
//│ unified α316'
//│  α316' :> [[list[α315']]]
//│  α316' :> α313'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                                                ^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not a function
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                                      ^^^
//│ ╟── but it flows into reference with expected type `?digitsOfInt -> ?a`
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                                                ^^^^
//│ digitsOfInt: nothing -> list[nothing]


// 2879
:unifyDbg
let sqsum xs =
  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ [ERROR 0] int<> != Float unifying because int<> = Float are arg type in ([(int<>,)] -> α329'') = (Float -> Float)
//│ ╔══[WARNING] int<> and Float cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Float is here
//│ ║  l.17: 	let ( ** ): float -> float -> float;
//│ ╙──      	                     ^^^^^
//│ [ERROR 0] Float != int<> unifying because Float = [[[[int<>]]]] because α329'' = Float are result type in ([(int<>,)] -> α329'') = (Float -> Float) and α329'' <: [[[[int<>]]]]
//│ ╔══[WARNING] Float and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── Float is here
//│ ║  l.17: 	let ( ** ): float -> float -> float;
//│ ║        	                              ^^^^^
//│ ╟── int<> is here
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	               ^^^^^^
//│ unified α325'
//│  list[α335'] = [α325'] are arg type in (list[α335'] -> α334') = ([([α325'],)] -> α341')
//│  α325' <: [[[[[[[list[α335']]]]]]]]
//│ unified α326''
//│  α326'' <: [[[[[[[Float]]]]]]]
//│ unified α327''
//│  α327'' <: [[[[[[[Float]]]]]]]
//│ unified α328''
//│  α328'' :> [[[(Float -> Float)]]]
//│  α328'' <: [([(int<>,)] -> α329'')]
//│ unified α329''
//│  α329'' <: [[[[int<>]]]]
//│  α329'' = Float are result type in ([(int<>,)] -> α329'') = (Float -> Float)
//│ unified α330''
//│  α330'' :> [[(int<> -> int<>)]]
//│  α330'' <: [([(α332'',)] -> α333'')]
//│ unified α331''
//│  α331'' :> [[[(Float -> Float)]]]
//│  α331'' <: [([(int<>,)] -> α332'')]
//│ unified α332''
//│  α332'' = Float are result type in ([(int<>,)] -> α332'') = (Float -> Float)
//│  α332'' = int<> are arg type in ([(α332'',)] -> α333'') = (int<> -> int<>)
//│ unified α333''
//│  α333'' = int<> are result type in ([(α332'',)] -> α333'') = (int<> -> int<>)
//│ unified α334'
//│  [int<>] = α334' are arg type in ([([int<>],)] -> α340') = (α334' -> (list[α335'] -> α334'))
//│  α334' :> [[[[[int<>]]]]]
//│  α334' <: [[α336']]
//│  α334' <: [[α341']]
//│ unified α335'
//│  α335' <: [[α337']]
//│ unified α336'
//│  α336' <: [[[[[[[Float]]]]]]]
//│  [[α336']] = [[[[[int<>]]]]] because α334' <: [[α336']] and α334' :> [[[[[int<>]]]]]
//│ unified α337'
//│  α337' <: [[[[[[[Float]]]]]]]
//│ unified α338'
//│  α338' :> [[[int<>]]]
//│  α338' <: [[α334']]
//│ unified α339'
//│  α339' :> [[[(α334' -> (list[α335'] -> α334'))]]]
//│  α339' <: [([([int<>],)] -> α340')]
//│ unified α340'
//│  α340' <: [([([α325'],)] -> α341')]
//│  α340' = (list[α335'] -> α334') are result type in ([([int<>],)] -> α340') = (α334' -> (list[α335'] -> α334'))
//│ unified α341'
//│  [[α341']] = [[[[[int<>]]]]] because α334' <: [[α341']] and α334' :> [[[[[int<>]]]]]
//│  [[α341']] & [[α336']] :> α334'
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.17: 	let ( ** ): float -> float -> float;
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^
//│ ╟── type `float` is not an instance of type `int`
//│ ║  l.17: 	let ( ** ): float -> float -> float;
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	               ^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                               ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.17: 	let ( ** ): float -> float -> float;
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^^^^^^^^^
//│ ╟── type `float` is not an instance of type `int`
//│ ║  l.17: 	let ( ** ): float -> float -> float;
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	                          ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^
//│ ╟── from type reference:
//│ ║  l.17: 	let ( ** ): float -> float -> float;
//│ ╙──      	            ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                ^
//│ ╟── but it flows into reference with expected type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                                      ^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.12: 	let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;
//│ ║        	                                         ^^
//│ ╟── from type reference:
//│ ║  l.17: 	let ( ** ): float -> float -> float;
//│ ╙──      	            ^^^^^
//│ sqsum: list[float] -> int

