:OcamlParser
:OcamlLoadLibrary

// 30 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.26: 	let (<): 'a -> 'a -> bool
//│ ║        	                     ^^^^
//│ ╟── true | ?b & ~true is used as operator application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	     ^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] int and list[?a] cannot be unified but flows into the same location
//│ ╟── int is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── list[?b] is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[?c] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──     	     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] int and list[?a] cannot be unified but flows into the same location
//│ ╟── int is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── list[?a] is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──     	     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[?a] is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── int is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── The following tvars cannot be resolved α73'
//│ ╟── ?b is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[?b] is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[?c] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── int is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── The following tvars cannot be resolved α73'
//│ ╟── ?d is used as application
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ digitsOfInt: anything -> list[list[int]]

// 36 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else
      let remainder = n mod 10 in
      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.26: 	let (<): 'a -> 'a -> bool
//│ ║        	                     ^^^^
//│ ╟── true | ?b & ~true is used as operator application
//│ ║  l.131: 	  if n < 0 then [] else
//│ ╙──       	     ^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] (int -> int -> int) -> ?a and int cannot be unified but flows into the same location
//│ ╟── (int -> int -> int) -> ?b is used as reference
//│ ║  l.132: 	      let remainder = n mod 10 in
//│ ║         	                      ^
//│ ╟── int is used as argument
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	             ^
//│ ╟── The following tvars cannot be resolved α112', [[[[α122']]]]
//│ ╟── ?c is used as reference
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── true | ?b & ~true is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[?a] is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── int is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] int and list[?a] cannot be unified but flows into the same location
//│ ╟── int is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── list[?a] is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──      	                               ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] int and list[?a] cannot be unified but flows into the same location
//│ ╟── int is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── list[?a] is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──     	     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 3] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[?a] is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	                               ^^
//│ ╟── int is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── The following tvars cannot be resolved α128', α131', α140'
//│ ╟── ?b is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── ?c is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── ?d is used as `case` expression
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 3] int and list[?a] cannot be unified but flows into the same location
//│ ╟── int is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── list[?a] is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── The following tvars cannot be resolved α128', α131', α140'
//│ ╟── ?b is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── ?c is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── ?d is used as `case` expression
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 4] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[?a] is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── int is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── The following tvars cannot be resolved α128', α131', α139', α140'
//│ ╟── ?b is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── ?c is used as application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── ?d is used as operator application
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ?e is used as `case` expression
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `Cons[?a] | Nil`
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `Cons[?a] | Nil`
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	         ^^
//│ ╟── from union type:
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──     	                       ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.130: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.131: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.132: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.131: 	  if n < 0 then [] else
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.132: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.130: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.131: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.132: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.131: 	  if n < 0 then [] else
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.132: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.130: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.131: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.132: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.130: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.131: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.132: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.133: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ digitsOfInt: ((int -> int -> int) -> int -> 'a) -> list['a]

// 38 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╔══[WARNING] [UNIFICATION ERROR 1] (int -> int -> int) -> ?a and int cannot be unified but flows into the same location
//│ ╟── (int -> int -> int) -> ?b is used as reference
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── int is used as reference
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╙── The following tvars cannot be resolved α193'
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and (int -> int -> int) -> ?a cannot be unified but flows into the same location
//│ ╟── int is used as reference
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── (int -> int -> int) -> ?b is used as reference
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                             ^
//│ ╙── The following tvars cannot be resolved α193'
//│ ╔══[WARNING] [UNIFICATION ERROR 2] int and (int -> int -> int) -> ?a cannot be unified but flows into the same location
//│ ╟── int is used as reference
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── int is used as type reference
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── (int -> int -> int) -> ?b is used as reference
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── The following tvars cannot be resolved α193', [[[[[α194']]]]]
//│ ╟── ?c is used as reference
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	     ^
//│ ╟── ?d is used as tuple type
//│ ║  l.26: 	let (<): 'a -> 'a -> bool
//│ ╙──      	         ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.26: 	let (<): 'a -> 'a -> bool
//│ ║        	                     ^^^^
//│ ╟── true | ?b & ~true is used as operator application
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── true | ?b & ~true is used as application
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                            ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.378: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                                                                      ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.378: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.379: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                             ^
//│ digitsOfInt: nothing -> 'a
//│   where
//│     'a :> list[nothing] | list['a]

// 309 mod
:unify
let pipe fs = let f a x = (fun n  -> a) x in let base n = n in List_fold_left f base fs;;
//│ pipe: list[?] -> 'a -> 'a

// 499
:unify
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let len1 = List_length l1 in
  let len2 = List_length l2 in
  if len1 > len2
  then (l1, ((clone 0 (len1 - len2)) @ l2))
  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.27: 	let (<=): 'a -> 'a -> bool
//│ ║        	                      ^^^^
//│ ╟── true | ?b & ~true is used as operator application
//│ ║  l.469: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ╙──       	                       ^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.28: 	let (>): 'a -> 'a -> bool
//│ ║        	                     ^^^^
//│ ╟── true | ?b & ~true is used as operator application
//│ ║  l.473: 	  if len1 > len2
//│ ╙──       	     ^^^^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padZero: list[?] -> list[?] -> (list[int], list[int],)

// 499 record types
:unify
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╔══[WARNING] [UNIFICATION ERROR 1] {_1: ?a} and {_0: ?b} cannot be unified but flows into the same location
//│ ╟── {_1: ?c} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: ?d} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α385'
//│ ╟── ?e is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.31: 	let (==): 'a -> 'a -> bool
//│ ║        	                      ^^^^
//│ ╟── true | ?b & ~true is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                            ^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] {_0: ?a} and list[?b] cannot be unified but flows into the same location
//│ ╟── {_0: ?c} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[?b] is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── list[?b] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── The following tvars cannot be resolved α385', [[[[[[α395']]]]]]
//│ ╟── ?d is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?e is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?f is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] {_1: ?a} and list[?b] cannot be unified but flows into the same location
//│ ╟── {_1: ?c} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[?b] is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── list[?b] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── The following tvars cannot be resolved α385', [[[[[[α395']]]]]]
//│ ╟── ?d is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?e is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?f is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] {_0: ?a} and {_0: ?b} cannot be unified but flows into the same location
//│ ╟── {_0: ?c} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: ?d} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α385', [[[[[[α395']]]]]]
//│ ╟── ?e is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?f is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?g is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] {_0: ?a} and {_1: ?b} cannot be unified but flows into the same location
//│ ╟── {_0: ?c} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: ?d} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α385', [[[[[[α395']]]]]]
//│ ╟── ?e is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?f is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?g is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] {_1: ?a} and {_1: ?b} cannot be unified but flows into the same location
//│ ╟── {_1: ?c} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: ?d} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α385', [[[[[[α395']]]]]]
//│ ╟── ?e is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?f is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?g is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] list[?a] and {_0: ?b} cannot be unified but flows into the same location
//│ ╟── list[?a] is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── {_0: ?c} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α385', α395'
//│ ╟── ?d is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?e is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] list[?a] and {_1: ?b} cannot be unified but flows into the same location
//│ ╟── list[?a] is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── list[?a] is used as applied type reference
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── {_1: ?c} is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α385', α395'
//│ ╟── ?d is used as refined scrutinee
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── ?e is used as application
//│ ║  l.496: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ removeZero: 'a -> (list[nothing] | 'b)
//│   where
//│     'a <: Cons[?] & {_0: anything, _1: 'a} & 'b | Nil | 'b & ~#Cons & ~#Nil

// infix mod
:unifyDbg
let rec digitsOfInt n =
  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ [ERROR 0] Bool != (true<bool> | (α608' & ~(true<bool>))) unifying because Bool = [(true<bool> | (α608' & ~(true<bool>)))] because α600' = Bool are result type in ([(Int,)] -> α600') = (α598' -> Bool) and α600' <: [(true<bool> | (α608' & ~(true<bool>)))]
//│ allVarPols: 
//│ norm[+] Bool
//│ | DNF: DNF(bool<>{})
//│ ~> bool<>
//│ allVarPols: +α622'
//│ norm[+] [(true<bool> | (α622' & ~(true<bool>)))]
//│ | DNF: DNF(true<bool>{} | α622'∧~(true<bool>))
//│ | norm[+] [[[[(bool<> & ~(true<bool>))]]]]
//│ | | DNF: DNF(bool<>{}∧~(true<bool>))
//│ | ~> (bool<> & ~(true<bool>))
//│ | factorize? true<bool> | α622' & ~(true<bool>)
//│ | | Factors α622' -> 1
//│ | yes: (true<bool> | (α622' & ~(true<bool>)))
//│ ~> (true<bool> | (α622' & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] Bool
//│ | DNF: DNF(bool<>{})
//│ ~> bool<>
//│ allVarPols: +α623'
//│ norm[+] (true<bool> | (α623' & ~(true<bool>)))
//│ | DNF: DNF(true<bool>{} | α623'∧~(true<bool>))
//│ | norm[+] [[[[(bool<> & ~(true<bool>))]]]]
//│ | | DNF: DNF(bool<>{}∧~(true<bool>))
//│ | ~> (bool<> & ~(true<bool>))
//│ | factorize? true<bool> | α623' & ~(true<bool>)
//│ | | Factors α623' -> 1
//│ | yes: (true<bool> | (α623' & ~(true<bool>)))
//│ ~> (true<bool> | (α623' & ~(true<bool>)))
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.28: 	let (>): 'a -> 'a -> bool
//│ ║        	                     ^^^^
//│ ╟── true | ?b & ~true is used as operator application
//│ ║  l.647: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                      ^^^^^
//│ unified digitsOfInt595'
//│  digitsOfInt595' :> [(α596' -> α610')]
//│ unified α596'
//│  α596' <: [[[[[α598']]]]]
//│  α596' <: [[([([(Int -> (Int -> Int))],)] -> α602')]]
//│ unified α597''
//│ unified α598'
//│  Int = α598' are arg type in ([(Int,)] -> α600') = (α598' -> Bool)
//│  α598' :> [[[[Int]]]]
//│  [[([([(Int -> (Int -> Int))],)] -> α602')]] & [[[[[α598']]]]] :> α596'
//│ unified α599'
//│  α599' :> [[[(α598' -> Bool)]]]
//│  α599' <: [([(Int,)] -> α600')]
//│ unified α600'
//│  α600' <: [(true<bool> | (α608' & ~(true<bool>)))]
//│  α600' = Bool are result type in ([(Int,)] -> α600') = (α598' -> Bool)
//│ unified α601'
//│  α601' = α609' are TypeName(list)(0) arg type
//│ unified α602'
//│  α602' <: [([(Int,)] -> α603')]
//│ unified α603'
//│  α603' <: [[α601']]
//│ unified α604'
//│ unified α605'
//│  α605' <: [([([α596'],)] -> α606')]
//│ unified α606'
//│  α606' <: [[[list[α601']]]]
//│ unified α607'
//│  α607' | [[list[α609']]] <: α610'
//│  α607' :> [[[list[α601']]]]
//│ unified α608'
//│  α608' :> [[[[(bool<> & ~(true<bool>))]]]]
//│ unified α609'
//│ unified α610'
//│  α610' :> [[list[α609']]]
//│  α610' :> α607'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.647: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                                                ^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not a function
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into reference with expected type `?digitsOfInt -> ?a`
//│ ║  l.647: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                                                ^^^^
//│ digitsOfInt: ((int -> int -> int) -> int -> 'a) -> list['a]


// 2879
:unifyDbg
let sqsum xs =
  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ [ERROR 0] Int != Float unifying because Int = Float are arg type in ([(Int,)] -> α628'') = (Float -> Float)
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] Float
//│ | DNF: DNF(float<>{})
//│ ~> float<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] Float
//│ | DNF: DNF(float<>{})
//│ ~> float<>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] int and float cannot be unified but flows into the same location
//│ ╟── int is used as integer literal
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── float is used as type reference
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ [ERROR 0] Float != Int unifying because Float = [[[[[Int]]]]] because α628'' = Float are result type in ([(Int,)] -> α628'') = (Float -> Float) and α628'' <: [[[[[Int]]]]]
//│ allVarPols: 
//│ norm[+] Float
//│ | DNF: DNF(float<>{})
//│ ~> float<>
//│ allVarPols: 
//│ norm[+] [[[[[Int]]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] Float
//│ | DNF: DNF(float<>{})
//│ ~> float<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] float and int cannot be unified but flows into the same location
//│ ╟── float is used as type reference
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── int is used as operator application
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── int is used as type reference
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	         ^^^
//│ unified α624'
//│  list[α634'] = [α624'] are arg type in (list[α634'] -> α633') = ([([α624'],)] -> α640')
//│  α624' <: [[[[[[[list[α634']]]]]]]]
//│ unified α625''
//│  α625'' <: [[[[[[[Float]]]]]]]
//│ unified α626''
//│  α626'' <: [[[[[[[Float]]]]]]]
//│ unified α627''
//│  α627'' :> [[[(Float -> Float)]]]
//│  α627'' <: [([(Int,)] -> α628'')]
//│ unified α628''
//│  α628'' <: [[[[[Int]]]]]
//│  α628'' = Float are result type in ([(Int,)] -> α628'') = (Float -> Float)
//│ unified α629''
//│  α629'' :> [[[(Int -> Int)]]]
//│  α629'' <: [([(α631'',)] -> α632'')]
//│ unified α630''
//│  α630'' :> [[[(Float -> Float)]]]
//│  α630'' <: [([(Int,)] -> α631'')]
//│ unified α631''
//│  α631'' = Float are result type in ([(Int,)] -> α631'') = (Float -> Float)
//│  α631'' = Int are arg type in ([(α631'',)] -> α632'') = (Int -> Int)
//│ unified α632''
//│  α632'' = Int are result type in ([(α631'',)] -> α632'') = (Int -> Int)
//│ unified α633'
//│  [Int] = α633' are arg type in ([([Int],)] -> α639') = (α633' -> (list[α634'] -> α633'))
//│  α633' :> [[[[[Int]]]]]
//│  α633' <: [[α635']]
//│  α633' <: [[α640']]
//│ unified α634'
//│  α634' <: [[α636']]
//│ unified α635'
//│  α635' <: [[[[[[[Float]]]]]]]
//│  [[α635']] = [[[[[Int]]]]] because α633' <: [[α635']] and α633' :> [[[[[Int]]]]]
//│ unified α636'
//│  α636' <: [[[[[[[Float]]]]]]]
//│ unified α637'
//│  α637' :> [[[Int]]]
//│  α637' <: [[α633']]
//│ unified α638'
//│  α638' :> [[[(α633' -> (list[α634'] -> α633'))]]]
//│  α638' <: [([([Int],)] -> α639')]
//│ unified α639'
//│  α639' <: [([([α624'],)] -> α640')]
//│  α639' = (list[α634'] -> α633') are result type in ([([Int],)] -> α639') = (α633' -> (list[α634'] -> α633'))
//│ unified α640'
//│  [[α640']] = [[[[[Int]]]]] because α633' <: [[α640']] and α633' :> [[[[[Int]]]]]
//│  [[α640']] & [[α635']] :> α633'
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                               ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `float`
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^
//│ ╟── from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	            ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                ^
//│ ╟── but it flows into reference with expected type `float`
//│ ║  l.735: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                                      ^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.39: 	let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│ ║        	                                         ^^
//│ ╟── from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	            ^^^^^
//│ sqsum: list[float] -> int

