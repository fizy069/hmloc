:OcamlParser
:OcamlLoadLibrary

// 30 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╔══[WARNING] bool<> and [(true<bool> | (α57' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α57' & ~(true<bool>))) is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	     ^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[[list[α58']]]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[α58'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α58'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[list[α56']]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[α56'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α56'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α56']]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α56'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α56'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α60'
//│ ╟── α60' is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[[list[α58']]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α58'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α58'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α60'
//│ ╟── α60' is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^

// 36 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else
      let remainder = n mod 10 in
      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α84')]] and [[[[[[int<>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α84') is here
//│ ║  l.65: 	      let remainder = n mod 10 in
//│ ║        	                      ^
//│ ╟── int<> is here
//│ ║  l.64: 	  if n < 0 then [] else
//│ ║        	     ^
//│ ╙── The following tvars cannot be resolved α78'
//│ ╔══[WARNING] bool<> and [(true<bool> | (α82' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α82' & ~(true<bool>))) is here
//│ ║  l.64: 	  if n < 0 then [] else
//│ ╙──      	     ^^^^^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α94' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α94' & ~(true<bool>))) is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	         ^^^^^
//│ ╔══[WARNING] [[[list[α90']]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α90'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α90'] is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                     ^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[[[list[α95']]]]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── list[α95'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                          ^^
//│ ╟── list[α95'] is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[list[α81']]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── list[α81'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α81'] is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[[[list[α95']]]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α95'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                          ^^
//│ ╟── list[α95'] is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α96', α105', α93'
//│ ╟── α96' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── α105' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α93' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                     ^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[list[α90']]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── list[α90'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α90'] is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                     ^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α96', α105', α93'
//│ ╟── α96' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── α105' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α93' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                     ^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α81']]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α81'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α81'] is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α96', α104', α105', α93'
//│ ╟── α96' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── α104' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α105' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α93' is here
//│ ║  l.66: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                     ^^^^^^^^^

// 38 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α139')]] and [[[[[[int<>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α139') is here
//│ ║  l.180: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── int<> is here
//│ ║  l.180: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╙── The following tvars cannot be resolved α122'
//│ ╔══[WARNING] [[[[[[int<>]]]]]] and [[([([(Int -> (Int -> Int))],)] -> α132')]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.180: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α132') is here
//│ ║  l.180: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                             ^
//│ ╙── The following tvars cannot be resolved α122'
//│ ╔══[WARNING] bool<> and [(true<bool> | (α126' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α126' & ~(true<bool>))) is here
//│ ║  l.180: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^^^^^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α134' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α134' & ~(true<bool>))) is here
//│ ║  l.180: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                            ^^^^^^^^^^^

// 309 mod
:unify
let pipe fs = let f a x = (fun n  -> a) x in let base n = n in List_fold_left f base fs;;

// 499
:unify
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let len1 = List_length l1 in
  let len2 = List_length l2 in
  if len1 > len2
  then (l1, ((clone 0 (len1 - len2)) @ l2))
  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ╔══[WARNING] bool<> and [(true<bool> | (α188' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α188' & ~(true<bool>))) is here
//│ ║  l.212: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ╙──       	                       ^^^^^^
//│ ╔══[WARNING] [[[[[[int<>]]]]]] and [[[Int]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.216: 	  if len1 > len2
//│ ║         	     ^^^^
//│ ╟── int<> is here
//│ ║  l.214: 	  let len1 = List_length l1 in
//│ ║         	             ^^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                    ^^^
//│ ╟── Int is here
//│ ║  l.214: 	  let len1 = List_length l1 in
//│ ╙──       	             ^^^^^^^^^^^^^^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α236' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α236' & ~(true<bool>))) is here
//│ ║  l.216: 	  if len1 > len2
//│ ╙──       	     ^^^^^^^^^^^

// 499 record types
:unify
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╔══[WARNING] [[[{_1: α276'}]]] and [[[{_0: α274'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α276'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: α274'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272'
//│ ╟── α272' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α282' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α282' & ~(true<bool>))) is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                            ^
//│ ╔══[WARNING] [[[{_0: α274'}]]] and [[[[[list[α271']]]]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α274'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[α271'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α271'] is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_1: α276'}]]] and [[[[[list[α271']]]]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α276'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[α271'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α271'] is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_0: α274'}]]] and [[[{_0: α274'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α274'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: α274'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_0: α274'}]]] and [[[{_1: α276'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α274'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: α276'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_1: α276'}]]] and [[[{_1: α276'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α276'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: α276'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', [[[[[[α281']]]]]]
//│ ╟── α272' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[[[list[α271']]]]]] and [[[{_0: α274'}]]] cannot be unified but they flow into the same locations
//│ ╟── list[α271'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α271'] is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── {_0: α274'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', α281'
//│ ╟── α272' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α271']]]]]] and [[[{_1: α276'}]]] cannot be unified but they flow into the same locations
//│ ╟── list[α271'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α271'] is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── {_1: α276'} is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α272', α281'
//│ ╟── α272' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α281' is here
//│ ║  l.244: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^

// infix mod
:unifyDbg
let rec digitsOfInt n =
  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ [ERROR 1] ([([(Int -> (Int -> Int))],)] -> α308') != int<> unifying because [[([([(Int -> (Int -> Int))],)] -> α308')]] & [[[[[[int<>]]]]]] :> α303'
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α308')]] and [[[[[[int<>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α308') is here
//│ ║  l.389: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                                  ^
//│ ╟── int<> is here
//│ ║  l.389: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                      ^
//│ ╙── The following tvars cannot be resolved α303'
//│ [ERROR 0] bool<> != (true<bool> | (α314' & ~(true<bool>))) unifying because bool<> = [(true<bool> | (α314' & ~(true<bool>)))] because α306' = bool<> are result type in ([(int<>,)] -> α306') = (int<> -> bool<>) and α306' <: [(true<bool> | (α314' & ~(true<bool>)))]
//│ ╔══[WARNING] bool<> and [(true<bool> | (α314' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α314' & ~(true<bool>))) is here
//│ ║  l.389: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                      ^^^^^
//│ unified digitsOfInt302'
//│  digitsOfInt302' :> [(α303' -> α316')]
//│ unified α303'
//│  α303' <: [[[[[[int<>]]]]]]
//│  α303' <: [[([([(Int -> (Int -> Int))],)] -> α308')]]
//│ unified α304''
//│ unified α305'
//│  α305' :> [[(int<> -> bool<>)]]
//│  α305' <: [([(int<>,)] -> α306')]
//│ unified α306'
//│  α306' <: [(true<bool> | (α314' & ~(true<bool>)))]
//│  α306' = bool<> are result type in ([(int<>,)] -> α306') = (int<> -> bool<>)
//│ unified α307'
//│  α307' = α315' are TypeName(list)(0) arg type
//│ unified α308'
//│  α308' <: [([(int<>,)] -> α309')]
//│ unified α309'
//│  α309' <: [[α307']]
//│ unified α310'
//│ unified α311'
//│  α311' <: [([([α303'],)] -> α312')]
//│ unified α312'
//│  α312' <: [[[list[α307']]]]
//│ unified α313'
//│  α313' | [[list[α315']]] <: α316'
//│  α313' :> [[[list[α307']]]]
//│ unified α314'
//│  α314' :> [[[[(bool<> & ~(true<bool>))]]]]
//│ unified α315'
//│ unified α316'
//│  α316' :> [[list[α315']]]
//│  α316' :> α313'


// 2879
:unifyDbg
let sqsum xs =
  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ [ERROR 0] int<> != Float unifying because int<> = Float are arg type in ([(int<>,)] -> α329'') = (Float -> Float)
//│ ╔══[WARNING] int<> and Float cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.441: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Float is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^^^^
//│ [ERROR 0] Float != int<> unifying because Float = [[[[int<>]]]] because α329'' = Float are result type in ([(int<>,)] -> α329'') = (Float -> Float) and α329'' <: [[[[int<>]]]]
//│ ╔══[WARNING] Float and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── Float is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^^^^
//│ ╟── int<> is here
//│ ║  l.441: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	               ^^^^^^
//│ unified α325'
//│  list[α335'] = [α325'] are arg type in (list[α335'] -> α334') = ([([α325'],)] -> α341')
//│  α325' <: [[[[[[[list[α335']]]]]]]]
//│ unified α326''
//│  α326'' <: [[[[[[[Float]]]]]]]
//│ unified α327''
//│  α327'' <: [[[[[[[Float]]]]]]]
//│ unified α328''
//│  α328'' :> [[[(Float -> Float)]]]
//│  α328'' <: [([(int<>,)] -> α329'')]
//│ unified α329''
//│  α329'' <: [[[[int<>]]]]
//│  α329'' = Float are result type in ([(int<>,)] -> α329'') = (Float -> Float)
//│ unified α330''
//│  α330'' :> [[(int<> -> int<>)]]
//│  α330'' <: [([(α332'',)] -> α333'')]
//│ unified α331''
//│  α331'' :> [[[(Float -> Float)]]]
//│  α331'' <: [([(int<>,)] -> α332'')]
//│ unified α332''
//│  α332'' = Float are result type in ([(int<>,)] -> α332'') = (Float -> Float)
//│  α332'' = int<> are arg type in ([(α332'',)] -> α333'') = (int<> -> int<>)
//│ unified α333''
//│  α333'' = int<> are result type in ([(α332'',)] -> α333'') = (int<> -> int<>)
//│ unified α334'
//│  [int<>] = α334' are arg type in ([([int<>],)] -> α340') = (α334' -> (list[α335'] -> α334'))
//│  α334' :> [[[[[int<>]]]]]
//│  α334' <: [[α336']]
//│  α334' <: [[α341']]
//│ unified α335'
//│  α335' <: [[α337']]
//│ unified α336'
//│  α336' <: [[[[[[[Float]]]]]]]
//│  [[α336']] = [[[[[int<>]]]]] because α334' <: [[α336']] and α334' :> [[[[[int<>]]]]]
//│ unified α337'
//│  α337' <: [[[[[[[Float]]]]]]]
//│ unified α338'
//│  α338' :> [[[int<>]]]
//│  α338' <: [[α334']]
//│ unified α339'
//│  α339' :> [[[(α334' -> (list[α335'] -> α334'))]]]
//│  α339' <: [([([int<>],)] -> α340')]
//│ unified α340'
//│  α340' <: [([([α325'],)] -> α341')]
//│  α340' = (list[α335'] -> α334') are result type in ([([int<>],)] -> α340') = (α334' -> (list[α335'] -> α334'))
//│ unified α341'
//│  [[α341']] = [[[[[int<>]]]]] because α334' <: [[α341']] and α334' :> [[[[[int<>]]]]]
//│  [[α341']] & [[α336']] :> α334'

