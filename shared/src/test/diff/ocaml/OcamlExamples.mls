:OcamlParser
:OcamlLoadLibrary

// 30 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and bool cannot be unified but flows into the same location
//│ ╟── Bool is here
//│ ║  l.26: 	let (<): 'a -> 'a -> bool
//│ ║        	                     ^^^^
//│ ╟── bool<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	     ^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[α70'] is here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── list[α70'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── Int is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[α71'] is here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── list[α71'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── Int is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into if-then-else false condition with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into if-then-else false condition with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into if-then-else true condition with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ digitsOfInt: anything -> list[list[int]]

// 36 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else
      let remainder = n mod 10 in
      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and bool cannot be unified but flows into the same location
//│ ╟── Bool is here
//│ ║  l.26: 	let (<): 'a -> 'a -> bool
//│ ║        	                     ^^^^
//│ ╟── bool<> is here
//│ ║  l.97: 	  if n < 0 then [] else
//│ ╙──      	     ^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] (int -> int -> int) -> ?a and int cannot be unified but flows into the same location
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α99') is here
//│ ║  l.98: 	      let remainder = n mod 10 in
//│ ║        	                      ^
//│ ╟── Int is here
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	             ^
//│ ╟── The following tvars cannot be resolved [[[[α102']]]], α92'
//│ ╟── α102' is here
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	         ^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[α97'] is here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── list[α97'] is here
//│ ║  l.97: 	  if n < 0 then [] else
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.98: 	      let remainder = n mod 10 in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── Int is here
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[α110'] is here
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	                               ^^
//│ ╟── list[α110'] is here
//│ ║  l.97: 	  if n < 0 then [] else
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.98: 	      let remainder = n mod 10 in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── Int is here
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] list[?a] and int cannot be unified but flows into the same location
//│ ╟── list[α106'] is here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── list[α106'] is here
//│ ║  l.97: 	  if n < 0 then [] else
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.98: 	      let remainder = n mod 10 in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── Int is here
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] int and list[?a] cannot be unified but flows into the same location
//│ ╟── Int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── list[α110'] is here
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	         ^^
//│ ╟── list[α110'] is here
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                                      ^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                      ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `Cons[?a] | Nil`
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `Cons[?a] | Nil`
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                      ^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	         ^^
//│ ╟── from union type:
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──     	                       ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.96: 	let rec digitsOfInt n =
//│ ║        	                    ^^^
//│ ║  l.97: 	  if n < 0 then [] else
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.98: 	      let remainder = n mod 10 in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into if-then-else true condition with expected type `int`
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                    ^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.96: 	let rec digitsOfInt n =
//│ ║        	                    ^^^
//│ ║  l.97: 	  if n < 0 then [] else
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.98: 	      let remainder = n mod 10 in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into if-then-else true condition with expected type `int`
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                    ^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.96: 	let rec digitsOfInt n =
//│ ║        	                    ^^^
//│ ║  l.97: 	  if n < 0 then [] else
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.98: 	      let remainder = n mod 10 in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into if-then-else false condition with expected type `int`
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.96: 	let rec digitsOfInt n =
//│ ║        	                    ^^^
//│ ║  l.97: 	  if n < 0 then [] else
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.98: 	      let remainder = n mod 10 in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into if-then-else true condition with expected type `int`
//│ ║  l.97: 	  if n < 0 then [] else
//│ ║        	                ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.99: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ digitsOfInt: ((int -> int -> int) -> int -> 'a) -> list['a]

// 38 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╔══[WARNING] [UNIFICATION ERROR 1] (int -> int -> int) -> ?a and int cannot be unified but flows into the same location
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α155') is here
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── Int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── Int is here
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╙── The following tvars cannot be resolved α137'
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and (int -> int -> int) -> ?a cannot be unified but flows into the same location
//│ ╟── Int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── Int is here
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α149') is here
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                             ^
//│ ╙── The following tvars cannot be resolved α137'
//│ ╔══[WARNING] [UNIFICATION ERROR 2] int and (int -> int -> int) -> ?a cannot be unified but flows into the same location
//│ ╟── Int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── Int is here
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α155') is here
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── The following tvars cannot be resolved α137', [[[[[α138']]]]]
//│ ╟── α138' is here
//│ ║  l.26: 	let (<): 'a -> 'a -> bool
//│ ║        	         ^^
//│ ╟── α138' is here
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and bool cannot be unified but flows into the same location
//│ ╟── Bool is here
//│ ║  l.26: 	let (<): 'a -> 'a -> bool
//│ ║        	                     ^^^^
//│ ╟── bool<> is here
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.282: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                                                                      ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.282: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.283: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                             ^
//│ digitsOfInt: nothing -> 'a
//│   where
//│     'a :> list['a]

// 309 mod
:unify
let pipe fs = let f a x = (fun n  -> a) x in let base n = n in List_fold_left f base fs;;
//│ pipe: list[?] -> 'a -> 'a

// 499
:unify
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let len1 = List_length l1 in
  let len2 = List_length l2 in
  if len1 > len2
  then (l1, ((clone 0 (len1 - len2)) @ l2))
  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and bool cannot be unified but flows into the same location
//│ ╟── Bool is here
//│ ║  l.27: 	let (<=): 'a -> 'a -> bool
//│ ║        	                      ^^^^
//│ ╟── bool<> is here
//│ ║  l.369: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ╙──       	                       ^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padZero: list[?] -> list[?] -> (list[int], list[int],)

// 499 record types
:unify
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╔══[WARNING] [UNIFICATION ERROR 0] list[?a] and error cannot be unified but flows into the same location
//│ ╟── list['a22'] is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── error<> is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                               ^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] error and list[?a] cannot be unified but flows into the same location
//│ ╟── error<> is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                               ^
//│ ╟── list[α304'] is here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── list[α304'] is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved [[[α303']]]
//│ ╟── α303' is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α303' is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                                        ^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] list[?a] and error cannot be unified but flows into the same location
//│ ╟── list[α304'] is here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── list[α304'] is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── error<> is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                               ^
//│ ╟── error<> is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved [[[α305']]]
//│ ╟── α305' is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α305' is here
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.389: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                               ^
//│ removeZero: (list[int] & 'a) -> (error | list[nothing] | 'a)

// infix mod
:unifyDbg
let rec digitsOfInt n =
  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ [ERROR 0] Bool != bool<> unifying because Bool = [[bool<>]] because α320' = Bool are result type in ([(Int,)] -> α320') = (α318' -> Bool) and α320' <: [[bool<>]]
//│ allVarPols: 
//│ norm[+] Bool
//│ | DNF: DNF(bool<>{})
//│ ~> bool<>
//│ allVarPols: 
//│ norm[+] [[bool<>]]
//│ | DNF: DNF(bool<>{})
//│ ~> bool<>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and bool cannot be unified but flows into the same location
//│ ╟── Bool is here
//│ ║  l.28: 	let (>): 'a -> 'a -> bool
//│ ║        	                     ^^^^
//│ ╟── bool<> is here
//│ ║  l.442: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                      ^^^^^
//│ unified digitsOfInt315'
//│  digitsOfInt315' :> [(α316' -> α321')]
//│ unified α316'
//│  α316' <: [[[[[α318']]]]]
//│  α316' <: [[([([(Int -> (Int -> Int))],)] -> α323')]]
//│ unified α317''
//│ unified α318'
//│  Int = α318' are arg type in ([(Int,)] -> α320') = (α318' -> Bool)
//│  α318' :> [[[[Int]]]]
//│  [[([([(Int -> (Int -> Int))],)] -> α323')]] & [[[[[α318']]]]] :> α316'
//│ unified α319'
//│  α319' :> [[[(α318' -> Bool)]]]
//│  α319' <: [([(Int,)] -> α320')]
//│ unified α320'
//│  α320' <: [[bool<>]]
//│  α320' = Bool are result type in ([(Int,)] -> α320') = (α318' -> Bool)
//│ unified α321'
//│  α321' :> [[[[list[α322']]]]]
//│  α321' :> [[[[list[α329']]]]]
//│ unified α322'
//│ unified α323'
//│  α323' <: [([(Int,)] -> α324')]
//│ unified α324'
//│  α324' <: [[α322']]
//│ unified α325'
//│ unified α326'
//│  α326' <: [([([α316'],)] -> α327')]
//│ unified α327'
//│  α327' <: [[[list[α322']]]]
//│ unified α328'
//│  α328' :> [[[list[α322']]]]
//│  α328' <: [[α321']]
//│ unified α329'
//│  α329' = α322' are TypeName(list)(0) arg type
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.442: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                                                ^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not a function
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into reference with expected type `?digitsOfInt -> ?a`
//│ ║  l.442: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                                                ^^^^
//│ digitsOfInt: ((int -> int -> int) -> int -> 'a) -> list['a]


// 2879
:unifyDbg
let sqsum xs =
  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ [ERROR 0] Int != Float unifying because Int = Float are arg type in ([(Int,)] -> α344'') = (Float -> Float)
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] Float
//│ | DNF: DNF(float<>{})
//│ ~> float<>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] int and float cannot be unified but flows into the same location
//│ ╟── Int is here
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Float is here
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ [ERROR 0] Float != Int unifying because Float = [[[[[Int]]]]] because α344'' = Float are result type in ([(Int,)] -> α344'') = (Float -> Float) and α344'' <: [[[[[Int]]]]]
//│ allVarPols: 
//│ norm[+] Float
//│ | DNF: DNF(float<>{})
//│ ~> float<>
//│ allVarPols: 
//│ norm[+] [[[[[Int]]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] float and int cannot be unified but flows into the same location
//│ ╟── Float is here
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── Int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	         ^^^
//│ ╟── Int is here
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	               ^^^^^^
//│ unified α340'
//│  list[α350'] = [α340'] are arg type in (list[α350'] -> α349') = ([([α340'],)] -> α356')
//│  α340' <: [[[[[[[list[α350']]]]]]]]
//│ unified α341''
//│  α341'' <: [[[[[[[Float]]]]]]]
//│ unified α342''
//│  α342'' <: [[[[[[[Float]]]]]]]
//│ unified α343''
//│  α343'' :> [[[(Float -> Float)]]]
//│  α343'' <: [([(Int,)] -> α344'')]
//│ unified α344''
//│  α344'' <: [[[[[Int]]]]]
//│  α344'' = Float are result type in ([(Int,)] -> α344'') = (Float -> Float)
//│ unified α345''
//│  α345'' :> [[[(Int -> Int)]]]
//│  α345'' <: [([(α347'',)] -> α348'')]
//│ unified α346''
//│  α346'' :> [[[(Float -> Float)]]]
//│  α346'' <: [([(Int,)] -> α347'')]
//│ unified α347''
//│  α347'' = Float are result type in ([(Int,)] -> α347'') = (Float -> Float)
//│  α347'' = Int are arg type in ([(α347'',)] -> α348'') = (Int -> Int)
//│ unified α348''
//│  α348'' = Int are result type in ([(α347'',)] -> α348'') = (Int -> Int)
//│ unified α349'
//│  [Int] = α349' are arg type in ([([Int],)] -> α355') = (α349' -> (list[α350'] -> α349'))
//│  α349' :> [[[[[Int]]]]]
//│  α349' <: [[α351']]
//│  α349' <: [[α356']]
//│ unified α350'
//│  α350' <: [[α352']]
//│ unified α351'
//│  α351' <: [[[[[[[Float]]]]]]]
//│  [[α351']] = [[[[[Int]]]]] because α349' <: [[α351']] and α349' :> [[[[[Int]]]]]
//│ unified α352'
//│  α352' <: [[[[[[[Float]]]]]]]
//│ unified α353'
//│  α353' :> [[[Int]]]
//│  α353' <: [[α349']]
//│ unified α354'
//│  α354' :> [[[(α349' -> (list[α350'] -> α349'))]]]
//│  α354' <: [([([Int],)] -> α355')]
//│ unified α355'
//│  α355' <: [([([α340'],)] -> α356')]
//│  α355' = (list[α350'] -> α349') are result type in ([([Int],)] -> α355') = (α349' -> (list[α350'] -> α349'))
//│ unified α356'
//│  [[α356']] = [[[[[Int]]]]] because α349' <: [[α356']] and α349' :> [[[[[Int]]]]]
//│  [[α356']] & [[α351']] :> α349'
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                               ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	              ^^^^^^^^^^^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `float`
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^
//│ ╟── from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	            ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                ^
//│ ╟── but it flows into reference with expected type `float`
//│ ║  l.508: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                                      ^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.39: 	let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│ ║        	                                         ^^
//│ ╟── from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	            ^^^^^
//│ sqsum: list[float] -> int

