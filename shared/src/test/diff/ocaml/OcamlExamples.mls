:OcamlParser
:OcamlLoadLibrary

// 30 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╔══[WARNING] Bool and [(true<bool> | (α65' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── Bool is here
//│ ║  l.14: 	let (<): 'a -> 'a -> bool;
//│ ║        	                     ^^^^
//│ ╟── (true<bool> | (α65' & ~(true<bool>))) is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	     ^^^^^
//│ ╔══[WARNING] [[[[[Int]]]]] and [[[[[[list[α66']]]]]]] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[α66'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α66'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[Int]]]]] and [[[[[list[α64']]]]]] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[α64'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α64'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] int<> and Int cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                                            ^^
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ╙──     	                  ^^^
//│ ╔══[WARNING] [[[[[list[α64']]]]]] and [[[[[Int]]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α64'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α64'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α68'
//│ ╟── α68' is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[[list[α66']]]]]]] and [[[[[Int]]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α66'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α66'] is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α68'
//│ ╟── α68' is here
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                                      ^^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ╙──     	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ╙──     	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.6: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ╙──     	           ^^^
//│ digitsOfInt: anything -> list[list[int]]

// 36 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else
      let remainder = n mod 10 in
      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[WARNING] Bool and [(true<bool> | (α92' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── Bool is here
//│ ║  l.14: 	let (<): 'a -> 'a -> bool;
//│ ║        	                     ^^^^
//│ ╟── (true<bool> | (α92' & ~(true<bool>))) is here
//│ ║  l.138: 	  if n < 0 then [] else
//│ ╙──       	     ^^^^^
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α94')]] and [[[int<>]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α94') is here
//│ ║  l.139: 	      let remainder = n mod 10 in
//│ ║         	                      ^
//│ ╟── int<> is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	             ^
//│ ╟── The following tvars cannot be resolved [[[[α97']]]], α87'
//│ ╟── α97' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α104' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α104' & ~(true<bool>))) is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^
//│ ╔══[WARNING] [[[list[α100']]]] and [[[[[Int]]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α100'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α100'] is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[Int]]]]] and [[[[[[[list[α105']]]]]]]] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[α105'] is here
//│ ║  l.24: 	let (@): 'a list -> 'a list -> 'a list;
//│ ║        	                               ^^
//│ ╟── list[α105'] is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[Int]]]]] and [[[[[list[α91']]]]]] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[α91'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α91'] is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] int<> and Int cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                                        ^^
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ╙──     	                  ^^^
//│ ╔══[WARNING] [[[[[[[list[α105']]]]]]]] and [[[[[Int]]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α105'] is here
//│ ║  l.24: 	let (@): 'a list -> 'a list -> 'a list;
//│ ║        	                               ^^
//│ ╟── list[α105'] is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α115', α103', α106'
//│ ╟── α115' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α103' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── α106' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[Int]]]]] and [[[list[α100']]]] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[α100'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α100'] is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α115', α103', α106'
//│ ╟── α115' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α103' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── α106' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α91']]]]]] and [[[[[Int]]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α91'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α91'] is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α114', α115', α103', α106'
//│ ╟── α114' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α115' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α103' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── α106' is here
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `Cons[?a] | Nil`
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	                         ^^^
//│ ╟── but it flows into operator application with expected type `Cons[?a] | Nil`
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.24: 	let (@): 'a list -> 'a list -> 'a list;
//│ ║        	         ^^
//│ ╟── from union type:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ╙──     	                       ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.137: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.138: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.139: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                                      ^^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.138: 	  if n < 0 then [] else
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.139: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ╙──     	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.137: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.138: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.139: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.138: 	  if n < 0 then [] else
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.139: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ╙──     	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.137: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.138: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.139: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ╙──     	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.137: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.138: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.139: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                       ^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.140: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ╙──     	           ^^^
//│ digitsOfInt: ((int -> int -> int) -> int -> 'a) -> list['a]

// 38 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α152')]] and [[[[[[[Int]]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α152') is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╙── The following tvars cannot be resolved α134'
//│ ╔══[WARNING] [[[[[[[Int]]]]]]] and [[([([(Int -> (Int -> Int))],)] -> α145')]] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α145') is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                             ^
//│ ╙── The following tvars cannot be resolved α134'
//│ ╔══[WARNING] [[[[[[[Int]]]]]]] and [[([([(Int -> (Int -> Int))],)] -> α152')]] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α152') is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── The following tvars cannot be resolved α134', [[[[[α135']]]]]
//│ ╟── α135' is here
//│ ║  l.14: 	let (<): 'a -> 'a -> bool;
//│ ║        	         ^^
//│ ╟── α135' is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α152')]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α152') is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── int<> is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	         ^
//│ ╟── int<> is here
//│ ║  l.14: 	let (<): 'a -> 'a -> bool;
//│ ║        	               ^^
//│ ╟── The following tvars cannot be resolved α134', [[[[[α135']]]]]
//│ ╟── α135' is here
//│ ║  l.14: 	let (<): 'a -> 'a -> bool;
//│ ║        	         ^^
//│ ╟── α135' is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^
//│ ╔══[WARNING] [[[[[[[Int]]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	           ^^^
//│ ╟── Int is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── int<> is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	         ^
//│ ╟── int<> is here
//│ ║  l.14: 	let (<): 'a -> 'a -> bool;
//│ ║        	               ^^
//│ ╟── The following tvars cannot be resolved α134', [[[[[α135']]]]]
//│ ╟── α135' is here
//│ ║  l.14: 	let (<): 'a -> 'a -> bool;
//│ ║        	         ^^
//│ ╟── α135' is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^
//│ ╔══[WARNING] Bool and [(true<bool> | (α139' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── Bool is here
//│ ║  l.14: 	let (<): 'a -> 'a -> bool;
//│ ║        	                     ^^^^
//│ ╟── (true<bool> | (α139' & ~(true<bool>))) is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^^^^^
//│ ╔══[WARNING] [[[int<>]]] and [[[[[Int]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                      ^
//│ ╟── Int is here
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	                         ^^^
//│ ╟── Int is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                            ^^^^^^
//│ ╙── The following tvars cannot be resolved α140'
//│ ╔══[WARNING] bool<> and [(true<bool> | (α147' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α147' & ~(true<bool>))) is here
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                            ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.392: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                                                                      ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.392: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.8: 	let ( / ): int -> int -> int;
//│ ║       	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.393: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                             ^
//│ digitsOfInt: nothing -> 'a
//│   where
//│     'a :> list[nothing] | list['a]

// 309 mod
:unify
let pipe fs = let f a x = (fun n  -> a) x in let base n = n in List_fold_left f base fs;;
//│ pipe: list[?] -> 'a -> 'a

// 499
:unify
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let len1 = List_length l1 in
  let len2 = List_length l2 in
  if len1 > len2
  then (l1, ((clone 0 (len1 - len2)) @ l2))
  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ╔══[WARNING] [[[[[[[[[[[[[[[Int]]]]]]]]]]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.6: 	let (-): int -> int -> int;
//│ ║       	                       ^^^
//│ ╟── Int is here
//│ ║  l.531: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║         	                       ^
//│ ╟── int<> is here
//│ ║  l.531: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║         	                            ^
//│ ╟── int<> is here
//│ ║  l.15: 	let (<=): 'a -> 'a -> bool;
//│ ║        	                ^^
//│ ╙── The following tvars cannot be resolved α204'
//│ ╔══[WARNING] Bool and [(true<bool> | (α208' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── Bool is here
//│ ║  l.15: 	let (<=): 'a -> 'a -> bool;
//│ ║        	                      ^^^^
//│ ╟── (true<bool> | (α208' & ~(true<bool>))) is here
//│ ║  l.531: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ╙──       	                       ^^^^^^
//│ ╔══[WARNING] int<> and Int cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.531: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║         	                                                              ^
//│ ╟── Int is here
//│ ║  l.6: 	let (-): int -> int -> int;
//│ ╙──     	                ^^^
//│ ╔══[WARNING] Bool and [(true<bool> | (α259' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── Bool is here
//│ ║  l.16: 	let (>): 'a -> 'a -> bool;
//│ ║        	                     ^^^^
//│ ╟── (true<bool> | (α259' & ~(true<bool>))) is here
//│ ║  l.535: 	  if len1 > len2
//│ ╙──       	     ^^^^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padZero: list[?] -> list[?] -> (list[int], list[int],)

// 499 record types
:unify
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╔══[WARNING] [[[{_1: α300'}]]] and [[[{_0: α298'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α300'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: α298'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α296'
//│ ╟── α296' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] Bool and [(true<bool> | (α307' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── Bool is here
//│ ║  l.19: 	let (==): 'a -> 'a -> bool;
//│ ║        	                      ^^^^
//│ ╟── (true<bool> | (α307' & ~(true<bool>))) is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                            ^
//│ ╔══[WARNING] [[[{_0: α298'}]]] and [[[[[list[α295']]]]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α298'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[α295'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α295'] is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved [[[[[[α306']]]]]], α296'
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α296' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_1: α300'}]]] and [[[[[list[α295']]]]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α300'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[α295'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α295'] is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved [[[[[[α306']]]]]], α296'
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α296' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_0: α298'}]]] and [[[{_0: α298'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α298'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: α298'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved [[[[[[α306']]]]]], α296'
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α296' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_0: α298'}]]] and [[[{_1: α300'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α298'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: α300'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved [[[[[[α306']]]]]], α296'
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α296' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_1: α300'}]]] and [[[{_1: α300'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α300'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: α300'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved [[[[[[α306']]]]]], α296'
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α296' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[[[list[α295']]]]]] and [[[{_0: α298'}]]] cannot be unified but they flow into the same locations
//│ ╟── list[α295'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α295'] is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── {_0: α298'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α306', α296'
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α296' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[[[list[α295']]]]]] and [[[{_1: α300'}]]] cannot be unified but they flow into the same locations
//│ ╟── list[α295'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	     ^^
//│ ╟── list[α295'] is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── {_1: α300'} is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α306', α296'
//│ ╟── α306' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α296' is here
//│ ║  l.579: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ removeZero: 'a -> (list[nothing] | 'b)
//│   where
//│     'a <: Cons[?] & {_0: anything, _1: 'a} & 'b | Nil | 'b & ~#Cons & ~#Nil

// infix mod
:unifyDbg
let rec digitsOfInt n =
  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ [ERROR 0] Bool != (true<bool> | (α341' & ~(true<bool>))) unifying because Bool = [(true<bool> | (α341' & ~(true<bool>)))] because α333' = Bool are result type in ([(int<>,)] -> α333') = (α331' -> Bool) and α333' <: [(true<bool> | (α341' & ~(true<bool>)))]
//│ ╔══[WARNING] Bool and [(true<bool> | (α341' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── Bool is here
//│ ║  l.16: 	let (>): 'a -> 'a -> bool;
//│ ║        	                     ^^^^
//│ ╟── (true<bool> | (α341' & ~(true<bool>))) is here
//│ ║  l.730: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                      ^^^^^
//│ unified digitsOfInt328'
//│  digitsOfInt328' :> [(α329' -> α343')]
//│ unified α329'
//│  α329' <: [[[[[α331']]]]]
//│  α329' <: [[([([(Int -> (Int -> Int))],)] -> α335')]]
//│ unified α330''
//│ unified α331'
//│  int<> = α331' are arg type in ([(int<>,)] -> α333') = (α331' -> Bool)
//│  α331' :> [[[[int<>]]]]
//│  [[([([(Int -> (Int -> Int))],)] -> α335')]] & [[[[[α331']]]]] :> α329'
//│ unified α332'
//│  α332' :> [[[(α331' -> Bool)]]]
//│  α332' <: [([(int<>,)] -> α333')]
//│ unified α333'
//│  α333' <: [(true<bool> | (α341' & ~(true<bool>)))]
//│  α333' = Bool are result type in ([(int<>,)] -> α333') = (α331' -> Bool)
//│ unified α334'
//│  α334' = α342' are TypeName(list)(0) arg type
//│ unified α335'
//│  α335' <: [([(int<>,)] -> α336')]
//│ unified α336'
//│  α336' <: [[α334']]
//│ unified α337'
//│ unified α338'
//│  α338' <: [([([α329'],)] -> α339')]
//│ unified α339'
//│  α339' <: [[[list[α334']]]]
//│ unified α340'
//│  α340' | [[list[α342']]] <: α343'
//│  α340' :> [[[list[α334']]]]
//│ unified α341'
//│  α341' :> [[[[(bool<> & ~(true<bool>))]]]]
//│ unified α342'
//│ unified α343'
//│  α343' :> [[list[α342']]]
//│  α343' :> α340'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.730: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                                                ^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not a function
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;
//│ ║       	                                      ^^^
//│ ╟── but it flows into reference with expected type `?digitsOfInt -> ?a`
//│ ║  l.730: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                                                ^^^^
//│ digitsOfInt: ((int -> int -> int) -> int -> 'a) -> list['a]


// 2879
:unifyDbg
let sqsum xs =
  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ [ERROR 0] int<> != Float unifying because int<> = Float are arg type in ([(int<>,)] -> α359'') = (Float -> Float)
//│ ╔══[WARNING] int<> and Float cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Float is here
//│ ║  l.31: 	let ( ** ): float -> float -> float;
//│ ╙──      	                     ^^^^^
//│ [ERROR 0] Float != Int unifying because Float = [[[[[Int]]]]] because α359'' = Float are result type in ([(int<>,)] -> α359'') = (Float -> Float) and α359'' <: [[[[[Int]]]]]
//│ ╔══[WARNING] Float and [[[[[Int]]]]] cannot be unified but they flow into the same locations
//│ ╟── Float is here
//│ ║  l.31: 	let ( ** ): float -> float -> float;
//│ ║        	                              ^^^^^
//│ ╟── Int is here
//│ ║  l.5: 	let (+): int -> int -> int;
//│ ║       	         ^^^
//│ ╟── Int is here
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	               ^^^^^^
//│ [ERROR 0] Int != Float unifying because Int = Float because α362'' = Int are arg type in ([(α362'',)] -> α363'') = (Int -> Int) and α362'' = Float are result type in ([(int<>,)] -> α362'') = (Float -> Float)
//│ ╔══[WARNING] Int and Float cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.5: 	let (+): int -> int -> int;
//│ ║       	                ^^^
//│ ╟── Float is here
//│ ║  l.31: 	let ( ** ): float -> float -> float;
//│ ╙──      	                              ^^^^^
//│ [ERROR 1] int<> != Int unifying because [[[[[int<>]]]]] | [[[[Int]]]] <: α364'
//│ ╔══[WARNING] [[[[[int<>]]]]] and [[[[Int]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                ^
//│ ╟── int<> is here
//│ ║  l.26: 	let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;
//│ ║        	                                         ^^
//│ ╟── Int is here
//│ ║  l.5: 	let (+): int -> int -> int;
//│ ║       	                       ^^^
//│ ╟── Int is here
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^^^^^^^^^
//│ ╙── The following tvars cannot be resolved α364'
//│ [ERROR 0] Int != int<> unifying because [[[[Int]]]] = [int<>] because α364' :> [[[[Int]]]] and [int<>] = α364' are arg type in ([([int<>],)] -> α370') = (α364' -> (list[α365'] -> α364'))
//│ ╔══[WARNING] [[[[Int]]]] and [int<>] cannot be unified but they flow into the same locations
//│ ╟── Int is here
//│ ║  l.5: 	let (+): int -> int -> int;
//│ ║       	                       ^^^
//│ ╟── Int is here
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                ^
//│ ╟── int<> is here
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	                                                                      ^^^^
//│ unified α355'
//│  list[α365'] = [α355'] are arg type in (list[α365'] -> α364') = ([([α355'],)] -> α371')
//│  α355' <: [[[[[[[list[α365']]]]]]]]
//│ unified α356''
//│  α356'' <: [[[[[[[Float]]]]]]]
//│ unified α357''
//│  α357'' <: [[[[[[[Float]]]]]]]
//│ unified α358''
//│  α358'' :> [[[(Float -> Float)]]]
//│  α358'' <: [([(int<>,)] -> α359'')]
//│ unified α359''
//│  α359'' <: [[[[[Int]]]]]
//│  α359'' = Float are result type in ([(int<>,)] -> α359'') = (Float -> Float)
//│ unified α360''
//│  α360'' :> [[[(Int -> Int)]]]
//│  α360'' <: [([(α362'',)] -> α363'')]
//│ unified α361''
//│  α361'' :> [[[(Float -> Float)]]]
//│  α361'' <: [([(int<>,)] -> α362'')]
//│ unified α362''
//│  α362'' = Float are result type in ([(int<>,)] -> α362'') = (Float -> Float)
//│  α362'' = Int are arg type in ([(α362'',)] -> α363'') = (Int -> Int)
//│ unified α363''
//│  α363'' = Int are result type in ([(α362'',)] -> α363'') = (Int -> Int)
//│ unified α364'
//│  [int<>] = α364' are arg type in ([([int<>],)] -> α370') = (α364' -> (list[α365'] -> α364'))
//│  α364' :> [[[[Int]]]]
//│  α364' :> [[[[[int<>]]]]]
//│  α364' <: [[α366']]
//│  α364' <: [[α371']]
//│ unified α365'
//│  α365' <: [[α367']]
//│ unified α366'
//│  α366' <: [[[[[[[Float]]]]]]]
//│  [[α366']] = [[[[Int]]]] because α364' <: [[α366']] and α364' :> [[[[Int]]]]
//│  [[α366']] = [[[[[int<>]]]]] because α364' <: [[α366']] and α364' :> [[[[[int<>]]]]]
//│ unified α367'
//│  α367' <: [[[[[[[Float]]]]]]]
//│ unified α368'
//│  α368' :> [[[Int]]]
//│  α368' <: [[α364']]
//│ unified α369'
//│  α369' :> [[[(α364' -> (list[α365'] -> α364'))]]]
//│  α369' <: [([([int<>],)] -> α370')]
//│ unified α370'
//│  α370' <: [([([α355'],)] -> α371')]
//│  α370' = (list[α365'] -> α364') are result type in ([([int<>],)] -> α370') = (α364' -> (list[α365'] -> α364'))
//│ unified α371'
//│  [[α371']] = [[[[Int]]]] because α364' <: [[α371']] and α364' :> [[[[Int]]]]
//│  [[α371']] = [[[[[int<>]]]]] because α364' <: [[α371']] and α364' :> [[[[[int<>]]]]]
//│  [[α371']] & [[α366']] :> α364'
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.31: 	let ( ** ): float -> float -> float;
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.31: 	let ( ** ): float -> float -> float;
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.5: 	let (+): int -> int -> int;
//│ ╙──     	         ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                               ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.31: 	let ( ** ): float -> float -> float;
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.31: 	let ( ** ): float -> float -> float;
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.5: 	let (+): int -> int -> int;
//│ ╙──     	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `float`
//│ ║  l.5: 	let (+): int -> int -> int;
//│ ║       	                       ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^
//│ ╟── from type reference:
//│ ║  l.31: 	let ( ** ): float -> float -> float;
//│ ╙──      	            ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                ^
//│ ╟── but it flows into reference with expected type `float`
//│ ║  l.790: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                                      ^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.26: 	let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;
//│ ║        	                                         ^^
//│ ╟── from type reference:
//│ ║  l.31: 	let ( ** ): float -> float -> float;
//│ ╙──      	            ^^^^^
//│ sqsum: list[float] -> int

