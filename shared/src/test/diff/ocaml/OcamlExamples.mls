:NoJS
:OcamlParser
:OcamlLoadLibrary

// 30 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╔══[WARNING] bool<> and [(true<bool> | (α60' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α60' & ~(true<bool>))) is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	     ^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[[list[α61']]]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[α61'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α61'] is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[list[α59']]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── list[α59'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α59'] is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α59']]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α59'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α59'] is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α63'
//│ ╟── α63' is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[[list[α61']]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α61'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α61'] is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α63'
//│ ╟── α63' is here
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.7: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                      ^^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.7: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                       ^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.7: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                       ^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╙──     	                           ^^^^^^^^^^^^^
//│ digitsOfInt: int -> list[list[int]]

// 36 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else
      let remainder = n mod 10 in
      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α87')]] and [[[[[[int<>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α87') is here
//│ ║  l.109: 	      let remainder = n mod 10 in
//│ ║         	                      ^
//│ ╟── int<> is here
//│ ║  l.108: 	  if n < 0 then [] else
//│ ║         	     ^
//│ ╙── The following tvars cannot be resolved α81'
//│ ╔══[WARNING] bool<> and [(true<bool> | (α85' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α85' & ~(true<bool>))) is here
//│ ║  l.108: 	  if n < 0 then [] else
//│ ╙──       	     ^^^^^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α97' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α97' & ~(true<bool>))) is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^
//│ ╔══[WARNING] [[[list[α93']]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α93'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α93'] is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[[[list[α98']]]]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[α98'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                          ^^
//│ ╟── list[α98'] is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[list[α84']]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[α84'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α84'] is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[[[list[α98']]]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α98'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                          ^^
//│ ╟── list[α98'] is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α96', α99', α108'
//│ ╟── α96' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── α99' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── α108' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[int<>]]]] and [[[list[α93']]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── list[α93'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α93'] is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α96', α99', α108'
//│ ╟── α96' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── α99' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── α108' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α84']]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── list[α84'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α84'] is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── int<> is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α96', α99', α107', α108'
//│ ╟── α96' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── α99' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── α107' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── α108' is here
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `Cons[?a] | Nil`
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                    ^^
//│ ╟── from union type:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	                       ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.107: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.108: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                      ^^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.108: 	  if n < 0 then [] else
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.107: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.108: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                       ^^
//│ ╟── but it flows into `case` expression with expected type `int`
//│ ║  l.108: 	  if n < 0 then [] else
//│ ║         	     ^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.107: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.108: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                       ^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                     ^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.107: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.108: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                       ^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.110: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                                       ^^^^^^^^^^^^^
//│ digitsOfInt: nothing -> list[nothing]

// 38 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α142')]] and [[[[[[int<>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α142') is here
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── int<> is here
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╙── The following tvars cannot be resolved α125'
//│ ╔══[WARNING] [[[[[[int<>]]]]]] and [[([([(Int -> (Int -> Int))],)] -> α135')]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α135') is here
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                             ^
//│ ╙── The following tvars cannot be resolved α125'
//│ ╔══[WARNING] bool<> and [(true<bool> | (α129' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α129' & ~(true<bool>))) is here
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	     ^^^^^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α137' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α137' & ~(true<bool>))) is here
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                            ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.316: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                                                                      ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.316: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.317: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                             ^
//│ digitsOfInt: nothing -> (list[nothing] | 'a)
//│   where
//│     'a :> list[list[nothing] | 'a]

// 309 mod
:unify
let pipe fs = let f a x = (fun n  -> a) x in let base n = n in List_fold_left f base fs;;
//│ pipe: list[?] -> 'a -> 'a

// 499
:unify
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let len1 = List_length l1 in
  let len2 = List_length l2 in
  if len1 > len2
  then (l1, ((clone 0 (len1 - len2)) @ l2))
  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ╔══[WARNING] bool<> and [(true<bool> | (α191' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α191' & ~(true<bool>))) is here
//│ ║  l.375: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ╙──       	                       ^^^^^^
//│ ╔══[WARNING] [[[[[[int<>]]]]]] and [[[Int]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.379: 	  if len1 > len2
//│ ║         	     ^^^^
//│ ╟── int<> is here
//│ ║  l.377: 	  let len1 = List_length l1 in
//│ ║         	             ^^^^^^^^^^^^^^
//│ ╟── Int is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                    ^^^
//│ ╟── Int is here
//│ ║  l.377: 	  let len1 = List_length l1 in
//│ ╙──       	             ^^^^^^^^^^^^^^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α239' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α239' & ~(true<bool>))) is here
//│ ║  l.379: 	  if len1 > len2
//│ ╙──       	     ^^^^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padZero: list[?] -> list[?] -> (list[int], list[int],)

// 499
:unify
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╔══[WARNING] [[[{_1: α279'}]]] and [[[{_0: α277'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α279'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: α277'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α275'
//│ ╟── α275' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] bool<> and [(true<bool> | (α285' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α285' & ~(true<bool>))) is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                            ^
//│ ╔══[WARNING] [[[{_0: α277'}]]] and [[[[[list[α274']]]]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α277'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[α274'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α274'] is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α275', [[[[[[α284']]]]]]
//│ ╟── α275' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_1: α279'}]]] and [[[[[list[α274']]]]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α279'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── list[α274'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α274'] is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── The following tvars cannot be resolved α275', [[[[[[α284']]]]]]
//│ ╟── α275' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_0: α277'}]]] and [[[{_0: α277'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α277'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_0: α277'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α275', [[[[[[α284']]]]]]
//│ ╟── α275' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_0: α277'}]]] and [[[{_1: α279'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_0: α277'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: α279'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α275', [[[[[[α284']]]]]]
//│ ╟── α275' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[{_1: α279'}]]] and [[[{_1: α279'}]]] cannot be unified but they flow into the same locations
//│ ╟── {_1: α279'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── {_1: α279'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α275', [[[[[[α284']]]]]]
//│ ╟── α275' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] [[[[[list[α274']]]]]] and [[[{_0: α277'}]]] cannot be unified but they flow into the same locations
//│ ╟── list[α274'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α274'] is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── {_0: α277'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α275', α284'
//│ ╟── α275' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ ╔══[WARNING] [[[[[list[α274']]]]]] and [[[{_1: α279'}]]] cannot be unified but they flow into the same locations
//│ ╟── list[α274'] is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α274'] is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                                    ^^^^^^^^^^^^
//│ ╟── {_1: α279'} is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── The following tvars cannot be resolved α275', α284'
//│ ╟── α275' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α284' is here
//│ ║  l.409: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                                    ^^^^^^^^^^^^
//│ removeZero: 'a -> (list[nothing] | 'b)
//│   where
//│     'a <: Cons[?] & {_0: int, _1: 'a} & 'b | Nil | 'b & ~#Cons & ~#Nil

:unifyDbg
let rec digitsOfInt n =
  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ [ERROR 1] ([([(Int -> (Int -> Int))],)] -> α311') != int<> unifying because [[([([(Int -> (Int -> Int))],)] -> α311')]] & [[[[[[int<>]]]]]] :> α306'
//│ ╔══[WARNING] [[([([(Int -> (Int -> Int))],)] -> α311')]] and [[[[[[int<>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α311') is here
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                                  ^
//│ ╟── int<> is here
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                      ^
//│ ╙── The following tvars cannot be resolved α306'
//│ [ERROR 0] bool<> != (true<bool> | (α317' & ~(true<bool>))) unifying because bool<> = [(true<bool> | (α317' & ~(true<bool>)))] because α309' = bool<> are result type in ([(int<>,)] -> α309') = (int<> -> bool<>) and α309' <: [(true<bool> | (α317' & ~(true<bool>)))]
//│ ╔══[WARNING] bool<> and [(true<bool> | (α317' & ~(true<bool>)))] cannot be unified but they flow into the same locations
//│ ╟── (true<bool> | (α317' & ~(true<bool>))) is here
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                      ^^^^^
//│ unified digitsOfInt305'
//│  digitsOfInt305' :> [(α306' -> α319')]
//│ unified α306'
//│  α306' <: [[[[[[int<>]]]]]]
//│  α306' <: [[([([(Int -> (Int -> Int))],)] -> α311')]]
//│ unified α307''
//│ unified α308'
//│  α308' :> [[(int<> -> bool<>)]]
//│  α308' <: [([(int<>,)] -> α309')]
//│ unified α309'
//│  α309' <: [(true<bool> | (α317' & ~(true<bool>)))]
//│  α309' = bool<> are result type in ([(int<>,)] -> α309') = (int<> -> bool<>)
//│ unified α310'
//│  α310' = α318' are TypeName(list)(0) arg type
//│ unified α311'
//│  α311' <: [([(int<>,)] -> α312')]
//│ unified α312'
//│  α312' <: [[α310']]
//│ unified α313'
//│ unified α314'
//│  α314' <: [([([α306'],)] -> α315')]
//│ unified α315'
//│  α315' <: [[[list[α310']]]]
//│ unified α316'
//│  α316' | [[list[α318']]] <: α319'
//│  α316' :> [[[list[α310']]]]
//│ unified α317'
//│  α317' :> [[[[(bool<> & ~(true<bool>))]]]]
//│ unified α318'
//│ unified α319'
//│  α319' :> [[list[α318']]]
//│  α319' :> α316'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                                                ^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not a function
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                      ^^^
//│ ╟── but it flows into reference with expected type `?digitsOfInt -> ?a`
//│ ║  l.556: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                                                ^^^^
//│ digitsOfInt: nothing -> list[nothing]


// 2879
:unifyDbg
let sqsum xs =
  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ [ERROR 0] int<> != Float unifying because int<> = Float are arg type in ([(int<>,)] -> α332'') = (Float -> Float)
//│ ╔══[WARNING] int<> and Float cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Float is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^^^^
//│ [ERROR 0] Float != int<> unifying because Float = [[[[int<>]]]] because α332'' = Float are result type in ([(int<>,)] -> α332'') = (Float -> Float) and α332'' <: [[[[int<>]]]]
//│ ╔══[WARNING] Float and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── Float is here
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^^^^
//│ ╟── int<> is here
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	               ^^^^^^
//│ unified α328'
//│  list[α338'] = [α328'] are arg type in (list[α338'] -> α337') = ([([α328'],)] -> α344')
//│  α328' <: [[[[[[[list[α338']]]]]]]]
//│ unified α329''
//│  α329'' <: [[[[[[[Float]]]]]]]
//│ unified α330''
//│  α330'' <: [[[[[[[Float]]]]]]]
//│ unified α331''
//│  α331'' :> [[[(Float -> Float)]]]
//│  α331'' <: [([(int<>,)] -> α332'')]
//│ unified α332''
//│  α332'' <: [[[[int<>]]]]
//│  α332'' = Float are result type in ([(int<>,)] -> α332'') = (Float -> Float)
//│ unified α333''
//│  α333'' :> [[(int<> -> int<>)]]
//│  α333'' <: [([(α335'',)] -> α336'')]
//│ unified α334''
//│  α334'' :> [[[(Float -> Float)]]]
//│  α334'' <: [([(int<>,)] -> α335'')]
//│ unified α335''
//│  α335'' = Float are result type in ([(int<>,)] -> α335'') = (Float -> Float)
//│  α335'' = int<> are arg type in ([(α335'',)] -> α336'') = (int<> -> int<>)
//│ unified α336''
//│  α336'' = int<> are result type in ([(α335'',)] -> α336'') = (int<> -> int<>)
//│ unified α337'
//│  [int<>] = α337' are arg type in ([([int<>],)] -> α343') = (α337' -> (list[α338'] -> α337'))
//│  α337' :> [[[[[int<>]]]]]
//│  α337' <: [[α339']]
//│  α337' <: [[α344']]
//│ unified α338'
//│  α338' <: [[α340']]
//│ unified α339'
//│  α339' <: [[[[[[[Float]]]]]]]
//│  [[α339']] = [[[[[int<>]]]]] because α337' <: [[α339']] and α337' :> [[[[[int<>]]]]]
//│ unified α340'
//│  α340' <: [[[[[[[Float]]]]]]]
//│ unified α341'
//│  α341' :> [[[int<>]]]
//│  α341' <: [[α337']]
//│ unified α342'
//│  α342' :> [[[(α337' -> (list[α338'] -> α337'))]]]
//│  α342' <: [([([int<>],)] -> α343')]
//│ unified α343'
//│  α343' <: [([([α328'],)] -> α344')]
//│  α343' = (list[α338'] -> α337') are result type in ([([int<>],)] -> α343') = (α337' -> (list[α338'] -> α337'))
//│ unified α344'
//│  [[α344']] = [[[[[int<>]]]]] because α337' <: [[α344']] and α337' :> [[[[[int<>]]]]]
//│  [[α344']] & [[α339']] :> α337'
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^
//│ ╟── type `float` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	               ^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                               ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^^^^^^^^^
//│ ╟── type `float` is not an instance of type `int`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	                          ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^
//│ ╟── from type reference:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                ^
//│ ╟── but it flows into reference with expected type `float`
//│ ║  l.618: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                                      ^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^
//│ ╟── from type reference:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^^^^
//│ sqsum: list[float] -> int

