:OcamlParser
:OcamlLoadLibrary

// 30 mod
// TODO: repeated provs and application should point to whole expression
:unify
let rec digitsOfInt n =
  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╔══[WARNING] Type `list[?a]` does not match `int`
//│ ╟── list[?a] ---> int
//│ ╟── `list[?a]` is found here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── `list[?a]` is found here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── `then` branch has type `list[?a]`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                ^^
//│ ╟── this if-then-else expression has type `list[?a]`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                          ^^^^^^^^^^^^^^^
//│ ╟── argument `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                          ^^^^^^^^^^^^^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[WARNING] Type `list[?a]` does not match `int`
//│ ╟── list[?a] ---> int
//│ ╟── `list[?a]` is found here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── `list[?a]` is found here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── `else` branch has type `list[?a]`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `list[?a]`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                          ^^^^^^^^^^^^^^^
//│ ╟── argument `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                          ^^^^^^^^^^^^^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.7: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into `else` branch has type with expected type `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                          ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.7: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into `else` branch has type with expected type `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                          ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.7: 	let rec digitsOfInt n =
//│ ║       	                    ^^^
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into `then` branch has type with expected type `int`
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                          ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ digitsOfInt: anything -> list[list[int]]

// TODO: handle infix operation
// TODO: show that if-then-else return type is return type of function
// Simpler error message for this one
// 36 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else
      let remainder = n mod 10 in
      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[WARNING] Type `(int -> int -> int) -> ?a` does not match `int`
//│ ╟── ?b <--- ?c ---> int
//│ ╟── argument `?b`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	     ^
//│ ╟── reference `?b`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	     ^
//│ ╟── argument `int`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	         ^
//│ ╟── integer literal `int`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	         ^
//│ ╟── integer literal `int`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ╙──       	         ^
//│ ╔══[WARNING] Type `list[?a]` does not match `int`
//│ ╟── list[?a] ---> int
//│ ╟── `list[?a]` is found here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── `list[?a]` is found here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── `then` branch has type `list[?a]`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	                ^^
//│ ╟── this if-then-else expression has type `list[?a]`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.121: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application `int`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── argument `int`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[WARNING] Type `list[?a]` does not match `int`
//│ ╟── list[?a] ---> int
//│ ╟── `list[?a]` is found here
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	                               ^^
//│ ╟── `list[?a]` is found here
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	                               ^^
//│ ╟── `else` branch has type `list[?a]`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `list[?a]`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `list[?a]`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.121: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application `int`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── argument `int`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[WARNING] Type `list[?a]` does not match `int`
//│ ╟── list[?a] ---> int
//│ ╟── `list[?a]` is found here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── `list[?a]` is found here
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	     ^^
//│ ╟── `then` branch has type `list[?a]`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                    ^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `list[?a]`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `list[?a]`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.121: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application `int`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── argument `int`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `Nil | Cons[?a]`
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `Nil | Cons[?a]`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                     ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	         ^^
//│ ╟── from union type:
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──     	                       ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.119: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.121: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into `then` branch has type with expected type `int`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                    ^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.119: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.121: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into `then` branch has type with expected type `int`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                    ^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.119: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.121: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into `else` branch has type with expected type `int`
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.119: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.121: 	      let remainder = n mod 10 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Cons[?a]` is not an instance of `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                       ^^
//│ ╟── but it flows into `then` branch has type with expected type `int`
//│ ║  l.120: 	  if n < 0 then [] else
//│ ║         	                ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.122: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                                      ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ digitsOfInt: ((int -> int -> int) -> int -> 'a) -> list['a]

// 38 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╔══[WARNING] Type `(int -> int -> int) -> ?a` does not match `int`
//│ ╟── (int -> int -> int) -> ?a <--- ?b ---> int
//│ ╟── reference `(int -> int -> int) -> ?a`
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                                      ^
//│ ╟── reference `int`
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── argument `int`
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[WARNING] Type `int` does not match `(int -> int -> int) -> ?a`
//│ ╟── int <--- ?b ---> (int -> int -> int) -> ?a
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── `int` is found here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	           ^^^
//│ ╟── argument `int`
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── reference `int`
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^
//│ ╟── reference `(int -> int -> int) -> ?a`
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                             ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.339: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                        ^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                                                                      ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.339: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                        ^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.340: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                             ^
//│ digitsOfInt: nothing -> 'a
//│   where
//│     'a :> list['a]

// 309 mod
:unify
let pipe fs = let f a x = (fun n  -> a) x in let base n = n in List_fold_left f base fs;;
//│ pipe: list[?] -> 'a -> 'a

// 499
:unify
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let len1 = List_length l1 in
  let len2 = List_length l2 in
  if len1 > len2
  then (l1, ((clone 0 (len1 - len2)) @ l2))
  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ clone: 'a -> int -> list['a]
//│ padZero: list[?] -> list[?] -> (list[int], list[int],)

// 499 record types
:unify
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ removeZero: (list[int & 'a] & 'b) -> (list['a] | 'b)

// infix mod
:unify
let rec digitsOfInt n =
  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╔══[WARNING] Type `(int -> int -> int) -> ?a` does not match `int`
//│ ╟── ?b <--- ?c ---> int
//│ ╟── argument `?b`
//│ ║  l.433: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                      ^
//│ ╟── reference `?b`
//│ ║  l.433: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                      ^
//│ ╟── argument `int`
//│ ║  l.433: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                          ^
//│ ╟── integer literal `int`
//│ ║  l.433: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                          ^
//│ ╟── integer literal `int`
//│ ║  l.433: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.433: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ║         	                                                ^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not a function
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into reference with expected type `?digitsOfInt -> ?a`
//│ ║  l.433: 	  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ ╙──       	                                                ^^^^
//│ digitsOfInt: ((int -> int -> int) -> int -> 'a) -> list['a]


// 2879
:unify
let sqsum xs =
  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╔══[WARNING] Type `float` does not match `int`
//│ ╟── int ---> float
//│ ╟── integer literal `int`
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── argument `int`
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── `float` is found here
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	              ^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	              ^^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	              ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                         ^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                               ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	              ^^^^^^^^^^^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                         ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `float`
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^
//│ ╟── from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	            ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `float`
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                ^
//│ ╟── but it flows into reference with expected type `float`
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                                      ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.466: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^
//│ ╟── from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	            ^^^^^
//│ sqsum: list[float] -> int

