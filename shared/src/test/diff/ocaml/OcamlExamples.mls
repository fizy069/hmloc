:OcamlParser
:OcamlLoadLibrary

// 30 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:723)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:651)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.typeLetRhs(Typer.scala:415)
//│ 	at: mlscript.DiffTests.$anonfun$new$45(DiffTests.scala:589)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)

// 36 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else
      let remainder = n mod 10 in
      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:723)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:651)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.typeLetRhs(Typer.scala:415)
//│ 	at: mlscript.DiffTests.$anonfun$new$45(DiffTests.scala:589)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)

// 38 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:723)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:651)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.typeLetRhs(Typer.scala:415)
//│ 	at: mlscript.DiffTests.$anonfun$new$45(DiffTests.scala:589)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)

// 309 mod
:unify
let pipe fs = let f a x = (fun n  -> a) x in let base n = n in List_fold_left f base fs;;
//│ pipe: list[?] -> 'a -> 'a

// 499
:unify
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let len1 = List_length l1 in
  let len2 = List_length l2 in
  if len1 > len2
  then (l1, ((clone 0 (len1 - len2)) @ l2))
  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:723)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:651)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:651)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)

// 499 record types
:unify
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:723)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:651)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.typeLetRhs(Typer.scala:415)
//│ 	at: mlscript.DiffTests.$anonfun$new$45(DiffTests.scala:589)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)

// infix mod
:unifyDbg
let rec digitsOfInt n =
  let numL = [] in if n > 0 then (n mod 10) :: (numL digitsOfInt n) else numL;;
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:723)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:689)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:651)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:735)


// 2879
:unifyDbg
let sqsum xs =
  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ [ERROR 0] Int != Float unifying because Int = Float are arg type in ([(Int,)] -> α106'') = (Float -> Float)
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] Float
//│ | DNF: DNF(float<>{})
//│ ~> float<>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] int and float cannot be unified but flows into the same location
//│ ╟── Int is here
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Float is here
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ [ERROR 0] Float != Int unifying because Float = [[[[[Int]]]]] because α106'' = Float are result type in ([(Int,)] -> α106'') = (Float -> Float) and α106'' <: [[[[[Int]]]]]
//│ allVarPols: 
//│ norm[+] Float
//│ | DNF: DNF(float<>{})
//│ ~> float<>
//│ allVarPols: 
//│ norm[+] [[[[[Int]]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] float and int cannot be unified but flows into the same location
//│ ╟── Float is here
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── Int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	         ^^^
//│ ╟── Int is here
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ╙──       	               ^^^^^^
//│ unified α102'
//│  list[α112'] = [α102'] are arg type in (list[α112'] -> α111') = ([([α102'],)] -> α118')
//│  α102' <: [[[[[[[list[α112']]]]]]]]
//│ unified α103''
//│  α103'' <: [[[[[[[Float]]]]]]]
//│ unified α104''
//│  α104'' <: [[[[[[[Float]]]]]]]
//│ unified α105''
//│  α105'' :> [[[(Float -> Float)]]]
//│  α105'' <: [([(Int,)] -> α106'')]
//│ unified α106''
//│  α106'' <: [[[[[Int]]]]]
//│  α106'' = Float are result type in ([(Int,)] -> α106'') = (Float -> Float)
//│ unified α107''
//│  α107'' :> [[[(Int -> Int)]]]
//│  α107'' <: [([(α109'',)] -> α110'')]
//│ unified α108''
//│  α108'' :> [[[(Float -> Float)]]]
//│  α108'' <: [([(Int,)] -> α109'')]
//│ unified α109''
//│  α109'' = Float are result type in ([(Int,)] -> α109'') = (Float -> Float)
//│  α109'' = Int are arg type in ([(α109'',)] -> α110'') = (Int -> Int)
//│ unified α110''
//│  α110'' = Int are result type in ([(α109'',)] -> α110'') = (Int -> Int)
//│ unified α111'
//│  [Int] = α111' are arg type in ([([Int],)] -> α117') = (α111' -> (list[α112'] -> α111'))
//│  α111' :> [[[[[Int]]]]]
//│  α111' <: [[α113']]
//│  α111' <: [[α118']]
//│ unified α112'
//│  α112' <: [[α114']]
//│ unified α113'
//│  α113' <: [[[[[[[Float]]]]]]]
//│  [[α113']] = [[[[[Int]]]]] because α111' <: [[α113']] and α111' :> [[[[[Int]]]]]
//│ unified α114'
//│  α114' <: [[[[[[[Float]]]]]]]
//│ unified α115'
//│  α115' :> [[[Int]]]
//│  α115' <: [[α111']]
//│ unified α116'
//│  α116' :> [[[(α111' -> (list[α112'] -> α111'))]]]
//│  α116' <: [([([Int],)] -> α117')]
//│ unified α117'
//│  α117' <: [([([α102'],)] -> α118')]
//│  α117' = (list[α112'] -> α111') are result type in ([([Int],)] -> α117') = (α111' -> (list[α112'] -> α111'))
//│ unified α118'
//│  [[α118']] = [[[[[Int]]]]] because α111' <: [[α118']] and α111' :> [[[[[Int]]]]]
//│  [[α118']] & [[α113']] :> α111'
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                    ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                               ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^^^^^^^^^^^^^^^^^
//│ ╟── type `float` is not an instance of `int`
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ║        	                              ^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                          ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `float`
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	               ^
//│ ╟── from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	            ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                ^
//│ ╟── but it flows into reference with expected type `float`
//│ ║  l.116: 	  let f a x = (a ** 2) + (x ** 2) in let base = 0 in List_fold_left f base xs;;
//│ ║         	                                                                      ^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.39: 	let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│ ║        	                                         ^^
//│ ╟── from type reference:
//│ ║  l.48: 	let ( ** ): float -> float -> float
//│ ╙──      	            ^^^^^
//│ sqsum: list[float] -> int

