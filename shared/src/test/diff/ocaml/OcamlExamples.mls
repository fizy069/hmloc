:NoJS
:OcamlParser
:OcamlLoadLibrary

// 30 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ╔══[WARNING] Unification error (level 1): list[α63'] and list[α61'] cannot be unified
//│ ╟── list[α63'] flows into α57'
//│ ╟── list[α63'] is used as argument
//│ ║  l.8: 	  if n < 0 then [] else [[(digitsOfInt n) / 10]];;
//│ ║       	                           ^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α63'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α61'] flows into α57'
//│ ╟── list[α61'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ /!!!\ Uncaught error: java.lang.Exception: No common type variable in unification error
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$reportUnificationError$8(Typer.scala:1101)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.Typer$UnificationStore.reportUnificationError(Typer.scala:1101)
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$unify$3(Typer.scala:1088)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.Typer$UnificationStore.unify(Typer.scala:1051)
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$traverseTypeBounds$11(Typer.scala:1137)
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$traverseTypeBounds$11$adapted(Typer.scala:1137)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)

// 36 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else
      let remainder = n mod 10 in
      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[WARNING] Unification error (level 2): int<> and ([([(Int -> (Int -> Int))],)] -> α90') cannot be unified
//│ ╟── int<> flows into α94'
//│ ╟── int<> is used as argument
//│ ║  l.38: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	             ^
//│ ╟── α82' flows into α94'
//│ ╟── α94' is used as reference
//│ ║  l.38: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	         ^
//│ ╟── α82' flows into ([([(Int -> (Int -> Int))],)] -> α90')
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α90') is used as reference
//│ ║  l.37: 	      let remainder = n mod 10 in
//│ ╙──      	                      ^
//│ ╔══[WARNING] Unification error (level 1): list[α103'] and list[α98'] cannot be unified
//│ ╟── list[α103'] flows into α83'
//│ ╟── list[α103'] is used as argument
//│ ║  l.37: 	      let remainder = n mod 10 in
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.38: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α103'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                          ^^
//│ ╟── list[α98'] flows into α83'
//│ ╟── list[α98'] is used as argument
//│ ║  l.37: 	      let remainder = n mod 10 in
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.38: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α98'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α103'] and list[α87'] cannot be unified
//│ ╟── list[α103'] flows into α83'
//│ ╟── list[α103'] is used as argument
//│ ║  l.37: 	      let remainder = n mod 10 in
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.38: 	      if n = 0 then [remainder] else ((digitsOfInt n) / 10) @ [remainder];;
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α103'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                                          ^^
//│ ╟── list[α87'] flows into α83'
//│ ╟── list[α87'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ /!!!\ Uncaught error: java.lang.Exception: No common type variable in unification error
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$reportUnificationError$8(Typer.scala:1101)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.Typer$UnificationStore.reportUnificationError(Typer.scala:1101)
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$unify$3(Typer.scala:1088)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.Typer$UnificationStore.unify(Typer.scala:1051)
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$traverseTypeBounds$11(Typer.scala:1137)
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$traverseTypeBounds$11$adapted(Typer.scala:1137)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)

// 38 mod
:unify
let rec digitsOfInt n =
  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╔══[WARNING] Unification error (level 0): int<> and ([([(Int -> (Int -> Int))],)] -> α148') cannot be unified
//│ ╟── int<> flows into α127'
//│ ╟── int<> is used as argument
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── α127' flows into ([([(Int -> (Int -> Int))],)] -> α148')
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α148') is used as reference
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                                                                      ^
//│ ╔══[WARNING] Unification error (level 0): int<> and ([([(Int -> (Int -> Int))],)] -> α141') cannot be unified
//│ ╟── int<> flows into α127'
//│ ╟── int<> is used as argument
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── α127' flows into ([([(Int -> (Int -> Int))],)] -> α141')
//│ ╟── ([([(Int -> (Int -> Int))],)] -> α141') is used as reference
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                             ^
//│ ╔══[WARNING] Unification error (level 1): list[α144'] and list[α132'] cannot be unified
//│ ╟── list[α144'] flows into α128'
//│ ╟── list[α144'] is used as argument
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α144'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α132'] flows into α128'
//│ ╟── list[α132'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α144'] and list[α132'] cannot be unified
//│ ╟── list[α144'] flows into α128'
//│ ╟── list[α144'] is used as argument
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α144'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α132'] flows into α128'
//│ ╟── list[α132'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α132'] and list[α144'] cannot be unified
//│ ╟── list[α132'] flows into α128'
//│ ╟── list[α132'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α144'] flows into α128'
//│ ╟── list[α144'] is used as argument
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α144'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α132'] and list[α144'] cannot be unified
//│ ╟── list[α132'] flows into α128'
//│ ╟── list[α132'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α144'] flows into α128'
//│ ╟── list[α144'] is used as argument
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α144'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α144'] and list[α132'] cannot be unified
//│ ╟── list[α144'] flows into α128'
//│ ╟── list[α144'] is used as argument
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α144'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α132'] flows into α128'
//│ ╟── list[α132'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α144'] and list[α132'] cannot be unified
//│ ╟── list[α144'] flows into α128'
//│ ╟── list[α144'] is used as argument
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α144'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α132'] flows into α128'
//│ ╟── list[α132'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.99: 	let rec digitsOfInt n =
//│ ║        	                    ^^^
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                                                                      ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.99: 	let rec digitsOfInt n =
//│ ║        	                    ^^^
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not a function
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ║         	                                                                         ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.100: 	  if n < 0 then [] else if (n / 10) = 0 then n mod 10 else (digitsOfInt (n / 10)) :: (n mod 10);;
//│ ╙──       	                                             ^
//│ digitsOfInt: nothing -> 'a
//│   where
//│     'a :> list['a]

// 309 mod
:unify
let pipe fs = let f a x = (fun n  -> a) x in let base n = n in List_fold_left f base fs;;
//│ pipe: list[?] -> 'a -> 'a

// 499
:unify
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let len1 = List_length l1 in
  let len2 = List_length l2 in
  if len1 > len2
  then (l1, ((clone 0 (len1 - len2)) @ l2))
  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ╔══[WARNING] Unification error (level 1): list[α201'] and list[α199'] cannot be unified
//│ ╟── list[α201'] flows into α195'
//│ ╟── list[α201'] is used as argument
//│ ║  l.224: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║         	                                           ^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α201'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α199'] flows into α195'
//│ ╟── list[α199'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α199'] and list[α201'] cannot be unified
//│ ╟── list[α199'] flows into α195'
//│ ╟── list[α199'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α201'] flows into α195'
//│ ╟── list[α201'] is used as argument
//│ ║  l.224: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║         	                                           ^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α201'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α199'] and list[α201'] cannot be unified
//│ ╟── list[α199'] flows into α195'
//│ ╟── list[α199'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α201'] flows into α195'
//│ ╟── list[α201'] is used as argument
//│ ║  l.224: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║         	                                           ^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α201'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α201'] and list[α199'] cannot be unified
//│ ╟── list[α201'] flows into α195'
//│ ╟── list[α201'] is used as argument
//│ ║  l.224: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║         	                                           ^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α201'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α199'] flows into α195'
//│ ╟── list[α199'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α201'] and list[α199'] cannot be unified
//│ ╟── list[α201'] flows into α195'
//│ ╟── list[α201'] is used as argument
//│ ║  l.224: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║         	                                           ^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[α201'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	     ^^
//│ ╟── list[α199'] flows into α195'
//│ ╟── list[α199'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	     ^^
//│ ╔══[WARNING] Unification error (level 1): list[α249'] and list[α220'] cannot be unified
//│ ╟── α216' flows into list[α249']
//│ ╟── list[α249'] is used as reference
//│ ║  l.230: 	  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ║         	                                   ^^
//│ ╟── list[α249'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                               ^^
//│ ╟── α216' flows into list[α220']
//│ ╟── list[α220'] is used as reference
//│ ║  l.226: 	  let len1 = List_length l1 in
//│ ║         	                         ^^
//│ ╟── list[α220'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	                                                                                                                                                                                                         ^^
//│ ╔══[WARNING] Unification error (level 1): list[α230'] and list[α223'] cannot be unified
//│ ╟── α217' flows into list[α230']
//│ ╟── list[α230'] is used as reference
//│ ║  l.229: 	  then (l1, ((clone 0 (len1 - len2)) @ l2))
//│ ║         	                                       ^^
//│ ╟── list[α230'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ║       	                                                                                                                                                                                                                                                                                                                               ^^
//│ ╟── α217' flows into list[α223']
//│ ╟── list[α223'] is used as reference
//│ ║  l.227: 	  let len2 = List_length l2 in
//│ ║         	                         ^^
//│ ╟── list[α223'] is used as applied type reference
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;let abs: int -> int;let mod: int -> int -> int;let List_length: 'a list -> int;let List_mem: 'a -> 'a list -> bool;let List_append: 'a list -> 'a list -> 'a list;let (@): 'a list -> 'a list -> 'a list;let List_map: ('a -> 'b) -> 'a list -> 'b list;let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a;let (+.): float -> float -> float;let (-.): float -> float -> float;let ( *. ): float -> float -> float;let ( /. ): float -> float -> float;let ( ** ): float -> float -> float;let atan: float -> float;let sin: float -> float;let cos: float -> float;let tan: float -> float;;
//│ ╙──     	                                                                                                                                                                                                         ^^
//│ ╔══[WARNING] Unification error (level 1): ([α216'], α247',) and (α266', [α217'],) cannot be unified
//│ ╟── ([α216'], α247',) flows into α224'
//│ ╟── ([α216'], α247',) is used as argument
//│ ║  l.229: 	  then (l1, ((clone 0 (len1 - len2)) @ l2))
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ([α216'], α247',) is used as tuple literal
//│ ║  l.229: 	  then (l1, ((clone 0 (len1 - len2)) @ l2))
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── (α266', [α217'],) flows into α224'
//│ ╟── (α266', [α217'],) is used as argument
//│ ║  l.230: 	  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── (α266', [α217'],) is used as tuple literal
//│ ║  l.230: 	  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] Unification error (level 1): (α266', [α217'],) and ([α216'], α247',) cannot be unified
//│ ╟── (α266', [α217'],) flows into α224'
//│ ╟── (α266', [α217'],) is used as argument
//│ ║  l.230: 	  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── (α266', [α217'],) is used as tuple literal
//│ ║  l.230: 	  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ([α216'], α247',) flows into α224'
//│ ╟── ([α216'], α247',) is used as argument
//│ ║  l.229: 	  then (l1, ((clone 0 (len1 - len2)) @ l2))
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ([α216'], α247',) is used as tuple literal
//│ ║  l.229: 	  then (l1, ((clone 0 (len1 - len2)) @ l2))
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] Unification error (level 1): (α266', [α217'],) and ([α216'], α247',) cannot be unified
//│ ╟── (α266', [α217'],) flows into α224'
//│ ╟── (α266', [α217'],) is used as argument
//│ ║  l.230: 	  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── (α266', [α217'],) is used as tuple literal
//│ ║  l.230: 	  else (((clone 0 (len2 - len1)) @ l1), l2);;
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ([α216'], α247',) flows into α224'
//│ ╟── ([α216'], α247',) is used as argument
//│ ║  l.229: 	  then (l1, ((clone 0 (len1 - len2)) @ l2))
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ([α216'], α247',) is used as tuple literal
//│ ║  l.229: 	  then (l1, ((clone 0 (len1 - len2)) @ l2))
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ /!!!\ Uncaught error: java.lang.Exception: No common type variable in unification error
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$reportUnificationError$8(Typer.scala:1101)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.Typer$UnificationStore.reportUnificationError(Typer.scala:1101)
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$unify$3(Typer.scala:1088)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.Typer$UnificationStore.unify(Typer.scala:1051)
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$traverseTypeBounds$11(Typer.scala:1137)
//│ 	at: mlscript.Typer$UnificationStore.$anonfun$traverseTypeBounds$11$adapted(Typer.scala:1137)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)

// 499
:unify
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╔══[WARNING] Unification error (level 1): {_1: α287'} and {_0: α285'} cannot be unified
//│ ╟── α283' flows into {_1: α287'}
//│ ╟── {_1: α287'} is used as refined scrutinee
//│ ║  l.381: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α283' is used as refined scrutinee
//│ ║  l.381: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α283' flows into {_0: α285'}
//│ ╟── {_0: α285'} is used as refined scrutinee
//│ ║  l.381: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	        ^
//│ ╟── α283' is used as refined scrutinee
//│ ║  l.381: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	        ^
//│ ╔══[WARNING] Unification error (level 0): bool<> and (true<bool> | (α293' & ~(true<bool>))) cannot be unified
//│ ╟── bool<> flows into α290'
//│ ╟── α290' is used as application
//│ ║  l.381: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                            ^
//│ ╟── bool<> is used as application
//│ ║  l.381: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                            ^
//│ ╟── α290' flows into (true<bool> | (α293' & ~(true<bool>)))
//│ ╟── (true<bool> | (α293' & ~(true<bool>))) is used as application
//│ ║  l.381: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ║         	                            ^
//│ ╟── α290' is used as application
//│ ║  l.381: 	  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;
//│ ╙──       	                            ^
//│ removeZero: 'a -> (list[nothing] | 'b | 'c)
//│   where
//│     'a <: Cons[?] & 'b | Nil | 'c & ~#Cons & ~#Nil
//│     'b <: {_0: int, _1: 'a}
