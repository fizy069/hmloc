// FIXME: unification error not
// :e
:unify
let h y = (not y, (if true then y else 5))
//│ h: (bool & 'a) -> (bool, int | 'a,)




// * FIXME we should say "if-then-else expression has type `?a` but `int` flows into it"
// :e
:unify
let h y = (not y, (if true then y else 5))
//│ h: (bool & 'a) -> (bool, int | 'a,)


// FIXME no error!?
:e
:unify
let confluence z = if true then z else 5
confluence true
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟── this `else` branch has type `int`
//│ ║  l.20: 	let confluence z = if true then z else 5
//│ ║        	                                       ^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.20: 	let confluence z = if true then z else 5
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `bool`
//│ ║  l.20: 	let confluence z = if true then z else 5
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `bool`
//│ ║  l.20: 	let confluence z = if true then z else 5
//│ ║        	                                ^
//│ ╟── this variable has type `bool`
//│ ║  l.20: 	let confluence z = if true then z else 5
//│ ║        	               ^
//│ ╟── this reference has type `bool`
//│ ║  l.21: 	confluence true
//│ ╙──      	           ^^^^
//│ confluence: 'a -> (int | 'a)
//│ res: bool | int

let mkpair x y = (x, confluence y)
let conflict x = mkpair (not x) x
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟── this `else` branch has type `int`
//│ ║  l.20: 	let confluence z = if true then z else 5
//│ ║        	                                       ^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.20: 	let confluence z = if true then z else 5
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `bool`
//│ ║  l.46: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── this reference has type `bool`
//│ ║  l.46: 	let conflict x = mkpair (not x) x
//│ ║        	                             ^
//│ ╟── `bool` comes from this type expression
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	         ^^^^
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)
//│ conflict: (bool & 'a) -> (bool, int | 'a,)



// FIXME: unification error not
// :e
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10]
//│ digitsOfInt: nothing -> list[nothing]

let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t)
//│ addNumbs: list[int] -> int

// FIXME
// :e
:tex
let digits n = digitsOfInt (abs n)
//│ digits: int -> list[nothing]

:e
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── this `else` branch has type `bool`
//│ ║  l.88: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true
//│ ║        	                                                         ^^^^^
//│ ╟── this if-then-else expression has type `bool`
//│ ║  l.88: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `int`
//│ ║  l.86: 	  match digits n with
//│ ║        	  ^^^^^^^^^^^^^^^^^^^
//│ ║  l.87: 	  | [] -> 0 ...
//│ ║        	^^^^^^^^^^^
//│ ╟── this integer literal has type `int`
//│ ║  l.87: 	  | [] -> 0
//│ ╙──      	          ^
//│ additivePersistence: int -> (bool | int)



