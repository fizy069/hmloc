:NoJS
:OcamlParser
:OcamlLoadLibrary

type ('a, 'b) Tuple2 = Tup2 of 'a * 'b
//│ Defined type alias Tuple2[+'a, +'b]
//│ Defined class Tup2[+'a, +'b]
//│ Tup2: ('_0, '_1,) -> Tup2['_0, '_1]

type exp = EInt of int | Var of string 
       | Plus of exp * exp | Times of exp * exp
type stmt = Skip | Assign of string * exp
         | Seq of stmt * stmt 
         | If of exp * stmt * stmt
         | While of exp * stmt 
         | SaveHeap of string
         | RestoreHeap of string
type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ Defined type alias exp
//│ Defined class EInt
//│ Defined class Var
//│ Defined class Plus
//│ Defined class Times
//│ Defined type alias stmt
//│ Defined class Skip
//│ Defined class Assign
//│ Defined class Seq
//│ Defined class If
//│ Defined class While
//│ Defined class SaveHeap
//│ Defined class RestoreHeap
//│ Defined type alias heapVar
//│ Defined class HeapInt
//│ Defined class Heap
//│ Defined type alias heap
//│ EInt: (int & '_0) -> (EInt with {_0: '_0})
//│ Var: (string & '_0) -> (Var with {_0: '_0})
//│ Plus: (exp & '_0, exp & '_1,) -> (Plus with {_0: '_0, _1: '_1})
//│ Times: (exp & '_0, exp & '_1,) -> (Times with {_0: '_0, _1: '_1})
//│ Skip: Skip
//│ Assign: (string & '_0, exp & '_1,) -> (Assign with {_0: '_0, _1: '_1})
//│ Seq: (stmt & '_0, stmt & '_1,) -> (Seq with {_0: '_0, _1: '_1})
//│ If: (exp & '_0, stmt & '_1, stmt & '_2,) -> (If with {_0: '_0, _1: '_1, _2: '_2})
//│ While: (exp & '_0, stmt & '_1,) -> (While with {_0: '_0, _1: '_1})
//│ SaveHeap: (string & '_0) -> (SaveHeap with {_0: '_0})
//│ RestoreHeap: (string & '_0) -> (RestoreHeap with {_0: '_0})
//│ HeapInt: (int & '_0) -> (HeapInt with {_0: '_0})
//│ Heap: (heap & '_0) -> (Heap with {_0: '_0})

// FIXME
let rec lookup (h:heap) str =
  match h with
  (* FOUND ERROR: this should return an int *)
    [] -> HeapInt(0) (* ############### *)
  | Tup2(s,i)::tl -> if s=str then i else lookup tl str
//│ lookup: heap -> anything -> (HeapInt & {_0: 0} | int)

let update h str i = Tup2(str,i)::h
//│ update: (list['a] & '_1) -> '_0 -> '_10 -> (Cons['a | Tup2['_0, '_10]] with {_0: Tup2['_0, '_10], _1: '_1})

let rec interp_e (h:heap) (e:exp) =
 match e with
  EInt i       ->i
 |Var str     ->lookup h str
 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.61: 	let rec interp_e (h:heap) (e:exp) =
//│ ║        	                  ^^^^^^^^^^^^^^^^^
//│ ║  l.62: 	 match e with
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.63: 	  EInt i       ->i
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	 |Var str     ->lookup h str
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `HeapInt & {_0: ?_0}` does not match type `?a`
//│ ║  l.54: 	    [] -> HeapInt(0) (* ############### *)
//│ ║        	          ^^^^^^^^^
//│ ╟── but it flows into application with expected type `?b`
//│ ║  l.64: 	 |Var str     ->lookup h str
//│ ║        	                ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.66: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ╙──      	                                 ^^^^^^^^^^^^^
//│ interp_e: heap -> exp -> (HeapInt & {_0: 0} | int)

let rec test (h:heap) (s:stmt) = update h
//│ test: heap -> stmt -> '_0 -> '_1 -> (Cons[Tup2['_0, '_1] | Tuple2[string, int]] with {_0: Tup2['_0, '_1], _1: heap})

// FIXME
let rec interp_s (h:heap) (s:stmt) =
  match s with
   Skip -> h
  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
                 interp_s h2 s2
  |If(e,s1,s2) -> if (interp_e h e) <> 0
                  then interp_s h s1 
                  else interp_s h s2
  |Assign(str,e) -> update h str (interp_e h e)
  |While(e,s1) -> if (interp_e h e) <> 0
                  then let h2 = interp_s h s1 in
                       interp_s h2 s
                  else h
  |SaveHeap(str) -> []
  |RestoreHeap(str) -> []
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.95: 	let rec interp_s (h:heap) (s:stmt) =
//│ ║        	                  ^^^^^^^^^^^^^^^^^^
//│ ║  l.96: 	  match s with
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.97: 	   Skip -> h
//│ ║        	^^^^^^^^^^^^
//│ ║  l.98: 	  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	                 interp_s h2 s2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.100: 	  |If(e,s1,s2) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.101: 	                  then interp_s h s1 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.102: 	                  else interp_s h s2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.103: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.104: 	  |While(e,s1) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.105: 	                  then let h2 = interp_s h s1 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.106: 	                       interp_s h2 s
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.107: 	                  else h
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.108: 	  |SaveHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	  |RestoreHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `HeapInt & {_0: ?_0}` does not match type `?a`
//│ ║  l.54: 	    [] -> HeapInt(0) (* ############### *)
//│ ║        	          ^^^^^^^^^
//│ ╟── but it flows into application with expected type `?b`
//│ ║  l.103: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ║         	                                  ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.105: 	                  then let h2 = interp_s h s1 in
//│ ║         	                                ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.18: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ╙──      	                                                                  ^^^
//│ interp_s: heap -> stmt -> ((Cons[Tup2[string, HeapInt & {_0: 0} | int] | Tuple2[string, int]] with {_0: Tup2[string, HeapInt & {_0: 0} | int], _1: heap}) | Nil | heap)

let mt_heap = [] 
//│ mt_heap: Nil

// FIXME
let interp_prog s = 
  lookup (interp_s mt_heap s) "ans"
//│ interp_prog: stmt -> (HeapInt & {_0: 0} | int)


(******************** Test Program in IMP **************************)

(* ############### *)
let testProgram1 = Skip
let testProgram1 = Seq (testProgram1, (Assign ("x",EInt 1)))
let testProgram1 = Seq (testProgram1, (SaveHeap ("myheap1")))
let testProgram1 = Seq (testProgram1, (Assign ("x",EInt 12)))
let testProgram1 = Seq (testProgram1, (RestoreHeap ("myheap1")))
let testProgram1 = Seq (testProgram1, (Assign ("ans",Var "x")))
//│ testProgram1: Skip
//│ testProgram1: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}
//│ testProgram1: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}
//│ testProgram1: Seq with {_0: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}, _1: Assign with {_0: "x", _1: EInt & {_0: 12}}}
//│ testProgram1: Seq with {_0: Seq with {_0: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}, _1: Assign with {_0: "x", _1: EInt & {_0: 12}}}, _1: RestoreHeap & {_0: "myheap1"}}
//│ testProgram1: Seq with {_0: Seq with {_0: Seq with {_0: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}, _1: Assign with {_0: "x", _1: EInt & {_0: 12}}}, _1: RestoreHeap & {_0: "myheap1"}}, _1: Assign with {_0: "ans", _1: Var & {_0: "x"}}}

(* ############### *)
let testProgram2 = Skip
let testProgram2 = Seq (testProgram2, (Assign ("x",EInt 1)))
let testProgram2 = Seq (testProgram2, (SaveHeap ("myheap1")))
let testProgram2 = Seq (testProgram2, (Assign ("ans",Var "myheap1")))
//│ testProgram2: Skip
//│ testProgram2: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}
//│ testProgram2: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}
//│ testProgram2: Seq with {_0: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}, _1: Assign with {_0: "ans", _1: Var & {_0: "myheap1"}}}

(* ################ *)
let testProgram3 = Skip
let testProgram3 = Seq (testProgram3, (Assign ("x",EInt 1)))
let testProgram3 = Seq (testProgram3, (SaveHeap ("myheap1")))
let testProgram3 = Seq (testProgram3, (Assign ("x",EInt 12)))
let testProgram3 = Seq (testProgram3, (RestoreHeap ("myheapnot")))
let testProgram3 = Seq (testProgram3, (Assign ("ans",Var "x")))
//│ testProgram3: Skip
//│ testProgram3: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}
//│ testProgram3: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}
//│ testProgram3: Seq with {_0: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}, _1: Assign with {_0: "x", _1: EInt & {_0: 12}}}
//│ testProgram3: Seq with {_0: Seq with {_0: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}, _1: Assign with {_0: "x", _1: EInt & {_0: 12}}}, _1: RestoreHeap & {_0: "myheapnot"}}
//│ testProgram3: Seq with {_0: Seq with {_0: Seq with {_0: Seq with {_0: Seq with {_0: Skip, _1: Assign with {_0: "x", _1: EInt & {_0: 1}}}, _1: SaveHeap & {_0: "myheap1"}}, _1: Assign with {_0: "x", _1: EInt & {_0: 12}}}, _1: RestoreHeap & {_0: "myheapnot"}}, _1: Assign with {_0: "ans", _1: Var & {_0: "x"}}}

