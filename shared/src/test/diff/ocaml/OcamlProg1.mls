
:OcamlParser
:OcamlLoadLibrary

// FIXME: TODO remove this once implicit tuples can be destructured
type ('a, 'b) Tuple2 = Tup2 of 'a * 'b
//│ Defined type alias Tuple2[+'a, +'b]
//│ Defined class Tup2[+'a, +'b]
//│ Tup2: ('a, 'b,) -> Tuple2['a, 'b]

type exp = Int of int | Var of string 
       | Plus of exp * exp | Times of exp * exp
type stmt = Skip | Assign of string * exp
         | Seq of stmt * stmt 
         | If of exp * stmt * stmt
         | While of exp * stmt 
         | SaveHeap of string
         | RestoreHeap of string
type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ Defined type alias exp
//│ Defined class Int
//│ Defined class Var
//│ Defined class Plus
//│ Defined class Times
//│ Defined type alias stmt
//│ Defined class Skip
//│ Defined class Assign
//│ Defined class Seq
//│ Defined class If
//│ Defined class While
//│ Defined class SaveHeap
//│ Defined class RestoreHeap
//│ Defined type alias heapVar
//│ Defined class HeapInt
//│ Defined class Heap
//│ Defined type alias heap
//│ Int: int -> exp
//│ Var: string -> exp
//│ Plus: (exp, exp,) -> exp
//│ Times: (exp, exp,) -> exp
//│ Skip: stmt
//│ Assign: (string, exp,) -> stmt
//│ Seq: (stmt, stmt,) -> stmt
//│ If: (exp, stmt, stmt,) -> stmt
//│ While: (exp, stmt,) -> stmt
//│ SaveHeap: string -> stmt
//│ RestoreHeap: string -> stmt
//│ HeapInt: int -> heapVar
//│ Heap: heap -> heapVar

let rec lookup (h:heap) str =
  match h with
  (* FOUND ERROR: this should return an int *)
    [] -> HeapInt(0) (* ############### *)
  | Tup2(s,i)::tl -> if s=str then i else lookup tl str
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$36(Typer.scala:810)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$36$adapted(Typer.scala:798)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$29(Typer.scala:798)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:764)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:827)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:655)

let update h str i = Tup2(str,i)::h
//│ update: list['a] -> 'b -> 'c -> list[Tuple2['b, 'c] | 'a]

let rec interp_e (h:heap) (e:exp) =
 match e with
  Int i       ->i
 |Var str     ->lookup h str
 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ╔══[ERROR] identifier not found: i
//│ ║  l.73: 	  Int i       ->i
//│ ╙──      	                ^
//│ ╔══[ERROR] identifier not found: str
//│ ║  l.74: 	 |Var str     ->lookup h str
//│ ╙──      	                         ^^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.75: 	 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
//│ ╙──      	                            ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.75: 	 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
//│ ╙──      	                                            ^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.76: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ╙──      	                            ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.76: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ╙──      	                                            ^^
//│ interp_e: heap -> exp -> (error | int)

let rec test (h:heap) (s:stmt) = update h
//│ test: heap -> stmt -> 'a -> 'b -> list[Tuple2[string | 'a, int | 'b]]

let rec interp_s (h:heap) (s:stmt) =
  match s with
   Skip -> h
  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
                 interp_s h2 s2
  |If(e,s1,s2) -> if (interp_e h e) <> 0
                  then interp_s h s1 
                  else interp_s h s2
  |Assign(str,e) -> update h str (interp_e h e)
  |While(e,s1) -> if (interp_e h e) <> 0
                  then let h2 = interp_s h s1 in
                       interp_s h2 s
                  else h
  |SaveHeap(str) -> []
  |RestoreHeap(str) -> []
//│ ╔══[ERROR] identifier not found: s1
//│ ║  l.103: 	  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
//│ ╙──       	                                     ^^
//│ ╔══[ERROR] identifier not found: s2
//│ ║  l.104: 	                 interp_s h2 s2
//│ ╙──       	                             ^^
//│ ╔══[ERROR] identifier not found: e
//│ ║  l.105: 	  |If(e,s1,s2) -> if (interp_e h e) <> 0
//│ ╙──       	                                 ^
//│ ╔══[ERROR] identifier not found: s1
//│ ║  l.106: 	                  then interp_s h s1 
//│ ╙──       	                                  ^^
//│ ╔══[ERROR] identifier not found: s2
//│ ║  l.107: 	                  else interp_s h s2
//│ ╙──       	                                  ^^
//│ ╔══[ERROR] identifier not found: str
//│ ║  l.108: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ╙──       	                             ^^^
//│ ╔══[ERROR] identifier not found: e
//│ ║  l.108: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ╙──       	                                             ^
//│ ╔══[ERROR] identifier not found: e
//│ ║  l.109: 	  |While(e,s1) -> if (interp_e h e) <> 0
//│ ╙──       	                                 ^
//│ ╔══[ERROR] identifier not found: s1
//│ ║  l.110: 	                  then let h2 = interp_s h s1 in
//│ ╙──       	                                           ^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.100: 	let rec interp_s (h:heap) (s:stmt) =
//│ ║         	                  ^^^^^^^^^^^^^^^^^^
//│ ║  l.101: 	  match s with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.102: 	   Skip -> h
//│ ║         	^^^^^^^^^^^^
//│ ║  l.103: 	  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.104: 	                 interp_s h2 s2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.105: 	  |If(e,s1,s2) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.106: 	                  then interp_s h s1 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.107: 	                  else interp_s h s2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.108: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	  |While(e,s1) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	                  then let h2 = interp_s h s1 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.111: 	                       interp_s h2 s
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.112: 	                  else h
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.113: 	  |SaveHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.114: 	  |RestoreHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `string`
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ║        	                                                          ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ╙──      	                                                          ^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.100: 	let rec interp_s (h:heap) (s:stmt) =
//│ ║         	                  ^^^^^^^^^^^^^^^^^^
//│ ║  l.101: 	  match s with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.102: 	   Skip -> h
//│ ║         	^^^^^^^^^^^^
//│ ║  l.103: 	  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.104: 	                 interp_s h2 s2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.105: 	  |If(e,s1,s2) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.106: 	                  then interp_s h s1 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.107: 	                  else interp_s h s2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.108: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	  |While(e,s1) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	                  then let h2 = interp_s h s1 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.111: 	                       interp_s h2 s
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.112: 	                  else h
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.113: 	  |SaveHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.114: 	  |RestoreHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `int`
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ║        	                                                                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ╙──      	                                                                  ^^^
//│ interp_s: heap -> stmt -> (heap | list[Tuple2[error | string, error | int]])

let mt_heap = [] 
//│ mt_heap: list[nothing]

// FIXME
let interp_prog s = 
  lookup (interp_s mt_heap s) "ans"
//│ interp_prog: stmt -> nothing


(******************** Test Program in IMP **************************)

(* ############### *)
let testProgram1 = Skip
let testProgram1 = Seq (testProgram1, (Assign ("x",Int 1)))
let testProgram1 = Seq (testProgram1, (SaveHeap ("myheap1")))
let testProgram1 = Seq (testProgram1, (Assign ("x",Int 12)))
let testProgram1 = Seq (testProgram1, (RestoreHeap ("myheap1")))
let testProgram1 = Seq (testProgram1, (Assign ("ans",Var "x")))
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt

(* ############### *)
let testProgram2 = Skip
let testProgram2 = Seq (testProgram2, (Assign ("x",Int 1)))
let testProgram2 = Seq (testProgram2, (SaveHeap ("myheap1")))
let testProgram2 = Seq (testProgram2, (Assign ("ans",Var "myheap1")))
//│ testProgram2: stmt
//│ testProgram2: stmt
//│ testProgram2: stmt
//│ testProgram2: stmt

(* ################ *)
let testProgram3 = Skip
let testProgram3 = Seq (testProgram3, (Assign ("x",Int 1)))
let testProgram3 = Seq (testProgram3, (SaveHeap ("myheap1")))
let testProgram3 = Seq (testProgram3, (Assign ("x",Int 12)))
let testProgram3 = Seq (testProgram3, (RestoreHeap ("myheapnot")))
let testProgram3 = Seq (testProgram3, (Assign ("ans",Var "x")))
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
