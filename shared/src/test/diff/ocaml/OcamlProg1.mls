
:OcamlParser
:OcamlLoadLibrary

// FIXME: TODO remove this once implicit tuples can be destructured
type ('a, 'b) Tuple2 = Tup2 of 'a * 'b
//│ Defined type alias Tuple2[+'a, +'b]
//│ Defined class Tup2[+'a, +'b]
//│ Tup2: ('a, 'b,) -> Tuple2['a, 'b]

type exp = Int of int | Var of string 
       | Plus of exp * exp | Times of exp * exp
type stmt = Skip | Assign of string * exp
         | Seq of stmt * stmt 
         | If of exp * stmt * stmt
         | While of exp * stmt 
         | SaveHeap of string
         | RestoreHeap of string
type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ Defined type alias exp
//│ Defined class Int
//│ Defined class Var
//│ Defined class Plus
//│ Defined class Times
//│ Defined type alias stmt
//│ Defined class Skip
//│ Defined class Assign
//│ Defined class Seq
//│ Defined class If
//│ Defined class While
//│ Defined class SaveHeap
//│ Defined class RestoreHeap
//│ Defined type alias heapVar
//│ Defined class HeapInt
//│ Defined class Heap
//│ Defined type alias heap
//│ Int: int -> exp
//│ Var: string -> exp
//│ Plus: (exp, exp,) -> exp
//│ Times: (exp, exp,) -> exp
//│ Skip: stmt
//│ Assign: (string, exp,) -> stmt
//│ Seq: (stmt, stmt,) -> stmt
//│ If: (exp, stmt, stmt,) -> stmt
//│ While: (exp, stmt,) -> stmt
//│ SaveHeap: string -> stmt
//│ RestoreHeap: string -> stmt
//│ HeapInt: int -> heapVar
//│ Heap: heap -> heapVar

let rec lookup (h:heap) str =
  match h with
  (* FOUND ERROR: this should return an int *)
    [] -> HeapInt(0) (* ############### *)
  | Tup2(s,i)::tl -> if s=str then i else lookup tl str
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Cannot handle case expression ((:: (Tup2 '(' s, i, ')') tl) then if eq s str(True) then i then (False) then lookup tl str,1)
//│ 	at: mlscript.utils.package$.lastWords(package.scala:185)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$29(Typer.scala:845)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:765)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:854)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:656)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:854)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:656)

let update h str i = Tup2(str,i)::h
//│ ╔══[ERROR] identifier not found: ::
//│ ║  l.68: 	let update h str i = Tup2(str,i)::h
//│ ╙──      	                                ^^
//│ update: error -> anything -> anything -> error

match error with
  Int i       -> i
//│ res: int

let rec interp_e (h:heap) (e:exp) =
 match e with
  Int i       ->i
 |Var str     ->lookup h str
 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ interp_e: heap -> exp -> int

let rec test (h:heap) (s:stmt) = update h
//│ test: heap -> stmt -> anything -> anything -> error

let rec interp_s (h:heap) (s:stmt) =
  match s with
   Skip -> h
  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
                 interp_s h2 s2
  |If(e,s1,s2) -> if (interp_e h e) <> 0
                  then interp_s h s1 
                  else interp_s h s2
  |Assign(str,e) -> update h str (interp_e h e)
  |While(e,s1) -> if (interp_e h e) <> 0
                  then let h2 = interp_s h s1 in
                       interp_s h2 s
                  else h
  |SaveHeap(str) -> []
  |RestoreHeap(str) -> []
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Unsupported arg: '(' str ')'
//│ 	at: mlscript.utils.package$.lastWords(package.scala:185)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$38(Typer.scala:837)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$38$adapted(Typer.scala:823)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$29(Typer.scala:823)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:765)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:854)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:656)

let mt_heap = [] 
//│ mt_heap: list[nothing]

// FIXME
let interp_prog s = 
  lookup (interp_s mt_heap s) "ans"
//│ interp_prog: anything -> nothing


(******************** Test Program in IMP **************************)

(* ############### *)
let testProgram1 = Skip
let testProgram1 = Seq (testProgram1, (Assign ("x",Int 1)))
let testProgram1 = Seq (testProgram1, (SaveHeap ("myheap1")))
let testProgram1 = Seq (testProgram1, (Assign ("x",Int 12)))
let testProgram1 = Seq (testProgram1, (RestoreHeap ("myheap1")))
let testProgram1 = Seq (testProgram1, (Assign ("ans",Var "x")))
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt

(* ############### *)
let testProgram2 = Skip
let testProgram2 = Seq (testProgram2, (Assign ("x",Int 1)))
let testProgram2 = Seq (testProgram2, (SaveHeap ("myheap1")))
let testProgram2 = Seq (testProgram2, (Assign ("ans",Var "myheap1")))
//│ testProgram2: stmt
//│ testProgram2: stmt
//│ testProgram2: stmt
//│ testProgram2: stmt

(* ################ *)
let testProgram3 = Skip
let testProgram3 = Seq (testProgram3, (Assign ("x",Int 1)))
let testProgram3 = Seq (testProgram3, (SaveHeap ("myheap1")))
let testProgram3 = Seq (testProgram3, (Assign ("x",Int 12)))
let testProgram3 = Seq (testProgram3, (RestoreHeap ("myheapnot")))
let testProgram3 = Seq (testProgram3, (Assign ("ans",Var "x")))
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
