
:OcamlParser
:OcamlLoadLibrary

// FIXME: TODO remove this once implicit tuples can be destructured
type ('a, 'b) Tuple2 = Tup2 of 'a * 'b
//│ Defined type alias Tuple2[+'a, +'b]
//│ Defined class Tup2[+'a, +'b]
//│ Tup2: ('a, 'b,) -> Tuple2['a, 'b]

type exp = Int of int | Var of string 
       | Plus of exp * exp | Times of exp * exp
type stmt = Skip | Assign of string * exp
         | Seq of stmt * stmt 
         | If of exp * stmt * stmt
         | While of exp * stmt 
         | SaveHeap of string
         | RestoreHeap of string
type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ Defined type alias exp
//│ Defined class Int
//│ Defined class Var
//│ Defined class Plus
//│ Defined class Times
//│ Defined type alias stmt
//│ Defined class Skip
//│ Defined class Assign
//│ Defined class Seq
//│ Defined class If
//│ Defined class While
//│ Defined class SaveHeap
//│ Defined class RestoreHeap
//│ Defined type alias heapVar
//│ Defined class HeapInt
//│ Defined class Heap
//│ Defined type alias heap
//│ Int: int -> exp
//│ Var: string -> exp
//│ Plus: (exp, exp,) -> exp
//│ Times: (exp, exp,) -> exp
//│ Skip: stmt
//│ Assign: (string, exp,) -> stmt
//│ Seq: (stmt, stmt,) -> stmt
//│ If: (exp, stmt, stmt,) -> stmt
//│ While: (exp, stmt,) -> stmt
//│ SaveHeap: string -> stmt
//│ RestoreHeap: string -> stmt
//│ HeapInt: int -> heapVar
//│ Heap: heap -> heapVar

let rec lookup (h:heap) str =
  match h with
  (* FOUND ERROR: this should return an int *)
    [] -> HeapInt(0) (* ############### *)
  | Tup2(s,i)::tl -> if s=str then i else lookup tl str
//│ ╔══[ERROR] identifier not found: s
//│ ║  l.55: 	  | Tup2(s,i)::tl -> if s=str then i else lookup tl str
//│ ╙──      	         ^
//│ ╔══[ERROR] identifier not found: i
//│ ║  l.55: 	  | Tup2(s,i)::tl -> if s=str then i else lookup tl str
//│ ╙──      	           ^
//│ ╔══[ERROR] identifier not found: s
//│ ║  l.55: 	  | Tup2(s,i)::tl -> if s=str then i else lookup tl str
//│ ╙──      	                        ^
//│ ╔══[ERROR] identifier not found: i
//│ ║  l.55: 	  | Tup2(s,i)::tl -> if s=str then i else lookup tl str
//│ ╙──      	                                   ^
//│ ╔══[ERROR] identifier not found: tl
//│ ║  l.55: 	  | Tup2(s,i)::tl -> if s=str then i else lookup tl str
//│ ╙──      	                                                 ^^
//│ lookup: heap -> anything -> (error | heapVar)

let update h str i = Tup2(str,i)::h
//│ update: list['a] -> 'b -> 'c -> list[Tuple2['b, 'c] | 'a]

let rec interp_e (h:heap) (e:exp) =
 match e with
  Int i       ->i
 |Var str     ->lookup h str
 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ╔══[ERROR] identifier not found: i
//│ ║  l.78: 	  Int i       ->i
//│ ╙──      	                ^
//│ ╔══[ERROR] identifier not found: str
//│ ║  l.79: 	 |Var str     ->lookup h str
//│ ╙──      	                         ^^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.80: 	 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
//│ ╙──      	                            ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.80: 	 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
//│ ╙──      	                                            ^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.81: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ╙──      	                            ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.81: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ╙──      	                                            ^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.76: 	let rec interp_e (h:heap) (e:exp) =
//│ ║        	                  ^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	 match e with
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.78: 	  Int i       ->i
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	 |Var str     ->lookup h str
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Heap` is not an instance of type `int`
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ║        	                                ^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.79: 	 |Var str     ->lookup h str
//│ ║        	                ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.81: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ║        	                                 ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.18: 	let ( * ): int -> int -> int
//│ ╙──      	                  ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.76: 	let rec interp_e (h:heap) (e:exp) =
//│ ║        	                  ^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	 match e with
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.78: 	  Int i       ->i
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	 |Var str     ->lookup h str
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	 |Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `HeapInt` is not an instance of type `int`
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ║        	               ^^^^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.79: 	 |Var str     ->lookup h str
//│ ║        	                ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.81: 	 |Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
//│ ║        	                                 ^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.18: 	let ( * ): int -> int -> int
//│ ╙──      	                  ^^^
//│ interp_e: heap -> exp -> (error | int | heapVar)

let rec test (h:heap) (s:stmt) = update h
//│ test: heap -> stmt -> 'a -> 'b -> list[Tuple2[string | 'a, int | 'b]]

let rec interp_s (h:heap) (s:stmt) =
  match s with
   Skip -> h
  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
                 interp_s h2 s2
  |If(e,s1,s2) -> if (interp_e h e) <> 0
                  then interp_s h s1 
                  else interp_s h s2
  |Assign(str,e) -> update h str (interp_e h e)
  |While(e,s1) -> if (interp_e h e) <> 0
                  then let h2 = interp_s h s1 in
                       interp_s h2 s
                  else h
  |SaveHeap(str) -> []
  |RestoreHeap(str) -> []
//│ ╔══[ERROR] identifier not found: s1
//│ ║  l.158: 	  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
//│ ╙──       	                                     ^^
//│ ╔══[ERROR] identifier not found: s2
//│ ║  l.159: 	                 interp_s h2 s2
//│ ╙──       	                             ^^
//│ ╔══[ERROR] identifier not found: e
//│ ║  l.160: 	  |If(e,s1,s2) -> if (interp_e h e) <> 0
//│ ╙──       	                                 ^
//│ ╔══[ERROR] identifier not found: s1
//│ ║  l.161: 	                  then interp_s h s1 
//│ ╙──       	                                  ^^
//│ ╔══[ERROR] identifier not found: s2
//│ ║  l.162: 	                  else interp_s h s2
//│ ╙──       	                                  ^^
//│ ╔══[ERROR] identifier not found: str
//│ ║  l.163: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ╙──       	                             ^^^
//│ ╔══[ERROR] identifier not found: e
//│ ║  l.163: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ╙──       	                                             ^
//│ ╔══[ERROR] identifier not found: e
//│ ║  l.164: 	  |While(e,s1) -> if (interp_e h e) <> 0
//│ ╙──       	                                 ^
//│ ╔══[ERROR] identifier not found: s1
//│ ║  l.165: 	                  then let h2 = interp_s h s1 in
//│ ╙──       	                                           ^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.155: 	let rec interp_s (h:heap) (s:stmt) =
//│ ║         	                  ^^^^^^^^^^^^^^^^^^
//│ ║  l.156: 	  match s with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.157: 	   Skip -> h
//│ ║         	^^^^^^^^^^^^
//│ ║  l.158: 	  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.159: 	                 interp_s h2 s2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.160: 	  |If(e,s1,s2) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.161: 	                  then interp_s h s1 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.162: 	                  else interp_s h s2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.163: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.164: 	  |While(e,s1) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.165: 	                  then let h2 = interp_s h s1 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.166: 	                       interp_s h2 s
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.167: 	                  else h
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.168: 	  |SaveHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.169: 	  |RestoreHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Heap` is not an instance of type `int`
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ║        	                                ^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.163: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ║         	                                  ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ╙──      	                                                                  ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.155: 	let rec interp_s (h:heap) (s:stmt) =
//│ ║         	                  ^^^^^^^^^^^^^^^^^^
//│ ║  l.156: 	  match s with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.157: 	   Skip -> h
//│ ║         	^^^^^^^^^^^^
//│ ║  l.158: 	  |Seq(s1,s2) -> let h2 = interp_s h s1 in 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.159: 	                 interp_s h2 s2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.160: 	  |If(e,s1,s2) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.161: 	                  then interp_s h s1 
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.162: 	                  else interp_s h s2
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.163: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.164: 	  |While(e,s1) -> if (interp_e h e) <> 0
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.165: 	                  then let h2 = interp_s h s1 in
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.166: 	                       interp_s h2 s
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.167: 	                  else h
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.168: 	  |SaveHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.169: 	  |RestoreHeap(str) -> []
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `HeapInt` is not an instance of type `int`
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ║        	               ^^^^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.163: 	  |Assign(str,e) -> update h str (interp_e h e)
//│ ║         	                                  ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ╙──      	                                                                  ^^^
//│ interp_s: heap -> stmt -> (heap | list[Tuple2[error | string, error | int | heapVar]])

let mt_heap = [] 
//│ mt_heap: list[nothing]

// FIXME
let interp_prog s = 
  lookup (interp_s mt_heap s) "ans"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.284: 	  lookup (interp_s mt_heap s) "ans"
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Heap` is not an instance of type `int`
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ║        	                                ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.19: 	type heapVar = HeapInt of int | Heap of heap and heap = ((string, int) Tuple2) list
//│ ╙──      	                                                                  ^^^
//│ interp_prog: stmt -> (error | heapVar)


(******************** Test Program in IMP **************************)

(* ############### *)
let testProgram1 = Skip
let testProgram1 = Seq (testProgram1, (Assign ("x",Int 1)))
let testProgram1 = Seq (testProgram1, (SaveHeap ("myheap1")))
let testProgram1 = Seq (testProgram1, (Assign ("x",Int 12)))
let testProgram1 = Seq (testProgram1, (RestoreHeap ("myheap1")))
let testProgram1 = Seq (testProgram1, (Assign ("ans",Var "x")))
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt
//│ testProgram1: stmt

(* ############### *)
let testProgram2 = Skip
let testProgram2 = Seq (testProgram2, (Assign ("x",Int 1)))
let testProgram2 = Seq (testProgram2, (SaveHeap ("myheap1")))
let testProgram2 = Seq (testProgram2, (Assign ("ans",Var "myheap1")))
//│ testProgram2: stmt
//│ testProgram2: stmt
//│ testProgram2: stmt
//│ testProgram2: stmt

(* ################ *)
let testProgram3 = Skip
let testProgram3 = Seq (testProgram3, (Assign ("x",Int 1)))
let testProgram3 = Seq (testProgram3, (SaveHeap ("myheap1")))
let testProgram3 = Seq (testProgram3, (Assign ("x",Int 12)))
let testProgram3 = Seq (testProgram3, (RestoreHeap ("myheapnot")))
let testProgram3 = Seq (testProgram3, (Assign ("ans",Var "x")))
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
//│ testProgram3: stmt
