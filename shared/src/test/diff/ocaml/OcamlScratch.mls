:OcamlParser
:OcamlLoadLibrary


type Bool = True | False
//│ Defined type alias Bool
//│ Defined class True
//│ Defined class False
//│ True: Bool
//│ False: Bool

:unifyDbg
let test x =
  match x with True -> 0 | False -> 1
//│ unified α64'
//│  α64' <: [[((true<> & α65') | ((false<> & α66') & ~(true<>)))]]
//│ unified α65'
//│ unified α66'
//│ unified α67'
//│  α67' :> Int
//│ test: bool -> int

:unifyDbg
let test x =
  match x with True -> 0 | False -> "oops"
//│ [ERROR 1] Int != String unifying because Int | String <: α75'
//│ ╔══[WARNING] [UNIFICATION ERROR 1] Int and String cannot be unified but flows into the same location
//│ ╟── Int is used as integer literal
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                       ^
//│ ╟── String is used as string literal
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                                    ^^^^^^
//│ ╟── The following tvars cannot be resolved α75'
//│ ╟── α75' is used as `case` expression
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ╙──      	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ unified α72'
//│  α72' <: [[((true<> & α73') | ((false<> & α74') & ~(true<>)))]]
//│ unified α73'
//│ unified α74'
//│ unified α75'
//│  α75' :> String
//│  α75' :> Int
//│ test: bool -> (int | string)



:unifyDbg
let temp x = if x then 0 else "oops"
//│ [ERROR 1] Int != String unifying because Int | String <: α83'
//│ ╔══[WARNING] [UNIFICATION ERROR 1] Int and String cannot be unified but flows into the same location
//│ ╟── Int is used as integer literal
//│ ║  l.50: 	let temp x = if x then 0 else "oops"
//│ ║        	                       ^
//│ ╟── String is used as string literal
//│ ║  l.50: 	let temp x = if x then 0 else "oops"
//│ ║        	                              ^^^^^^
//│ ╟── The following tvars cannot be resolved α83'
//│ ╟── α83' is used as `case` expression
//│ ║  l.50: 	let temp x = if x then 0 else "oops"
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^^
//│ unified α80'
//│  α80' <: [[((true<bool> & α81') | (α82' & ~(true<bool>)))]]
//│ unified α81'
//│ unified α82'
//│ unified α83'
//│  α83' :> String
//│  α83' :> Int
//│ temp: anything -> (int | string)


let temp x y z = if x then y else z
//│ temp: anything -> 'a -> 'a -> 'a

temp true 1 2
//│ res: int

:unifyDbg
temp true 1 "oops"
//│ [ERROR 0] ((true<bool> & α113) | (α114 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α113) | (α114 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α112 <: [[((true<bool> & α113) | (α114 & ~(true<bool>)))]] and α112 :> [[[[[[true<bool>]]]]]]
//│ ╔══[WARNING] [UNIFICATION ERROR 0] [[((true<bool> & α113) | (α114 & ~(true<bool>)))]] and [[[[[[true<bool>]]]]]] cannot be unified but flows into the same location
//│ ╟── ((true<bool> & α113) | (α114 & ~(true<bool>))) is used as reference
//│ ║  l.73: 	let temp x y z = if x then y else z
//│ ║        	                    ^
//│ ╟── true<bool> is used as argument
//│ ║  l.80: 	temp true 1 "oops"
//│ ╙──      	     ^^^^
//│ [ERROR 1] Int != String unifying because [[[[Int]]]] = [[[[String]]]] because [[[[[α120]]]]] = [[[[Int]]]] because α115 <: [[[[[α120]]]]] and α115 :> [[[[Int]]]] and [[[[[α120]]]]] = [[[[String]]]] because α116 <: [[[[[α120]]]]] and α116 :> [[[[String]]]]
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[Int]]]] and [[[[String]]]] cannot be unified but flows into the same location
//│ ╟── Int is used as argument
//│ ║  l.80: 	temp true 1 "oops"
//│ ║        	          ^
//│ ╟── String is used as argument
//│ ║  l.80: 	temp true 1 "oops"
//│ ║        	            ^^^^^^
//│ ╟── The following tvars cannot be resolved [[[[[α120]]]]]
//│ ╟── α120 is used as reference
//│ ║  l.73: 	let temp x y z = if x then y else z
//│ ║        	                           ^
//│ ╟── α120 is used as application
//│ ║  l.80: 	temp true 1 "oops"
//│ ╙──      	^^^^^^^^^^^^^^^^^^
//│ [ERROR 1] String != Int unifying because [[[[String]]]] = [[[[Int]]]] because α116 :> [[[[String]]]] and [[[[Int]]]] = [α116] because α115 :> [[[[Int]]]] and [α115] | [α116] <: α117
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[String]]]] and [[[[Int]]]] cannot be unified but flows into the same location
//│ ╟── String is used as argument
//│ ║  l.80: 	temp true 1 "oops"
//│ ║        	            ^^^^^^
//│ ╟── Int is used as argument
//│ ║  l.80: 	temp true 1 "oops"
//│ ║        	          ^
//│ ╟── The following tvars cannot be resolved α117
//│ ╟── α117 is used as `case` expression
//│ ║  l.73: 	let temp x y z = if x then y else z
//│ ╙──      	                    ^^^^^^^^^^^^^^^
//│ unified α112
//│  α112 :> [[[[[[true<bool>]]]]]]
//│  α112 <: [[((true<bool> & α113) | (α114 & ~(true<bool>)))]]
//│ unified α113
//│  α113 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ unified α114
//│ unified α115
//│  [α115] | [α116] <: α117
//│  [[[[Int]]]] = [α115] because [[[[[α120]]]]] = [[[[Int]]]] because α115 <: [[[[[α120]]]]] and α115 :> [[[[Int]]]] and [[[α120]]] = [α115] because α117 <: [[[α120]]] and α117 :> [α115]
//│  [[[[String]]]] = [α115] because [[[[[α120]]]]] = [[[[String]]]] because α116 <: [[[[[α120]]]]] and α116 :> [[[[String]]]] and [[[α120]]] = [α115] because α117 <: [[[α120]]] and α117 :> [α115]
//│  α115 :> [[[[Int]]]]
//│  α115 <: [[[[[α120]]]]]
//│ unified α116
//│  [[[[String]]]] = [α116] because [[[[[α120]]]]] = [[[[String]]]] because α116 <: [[[[[α120]]]]] and α116 :> [[[[String]]]] and [[[[[α120]]]]] = [α116] because α115 <: [[[[[α120]]]]] and [α115] | [α116] <: α117
//│  [[[[Int]]]] = [α116] because α115 :> [[[[Int]]]] and [α115] | [α116] <: α117
//│  α116 :> [[[[String]]]]
//│  α116 <: [[[[[α120]]]]]
//│ unified α117
//│  α117 :> [α116]
//│  α117 :> [α115]
//│  α117 <: [[[α120]]]
//│ unified α118
//│  α118 :> [[[(α115 -> (α116 -> α117))]]]
//│  α118 <: [([(Int,)] -> α119)]
//│ unified α119
//│  α119 <: [([(String,)] -> α120)]
//│  α119 = (α116 -> α117) are result type in ([(Int,)] -> α119) = (α115 -> (α116 -> α117))
//│ unified α120
//│  [[[[[α120]]]]] = [α116] because α115 <: [[[[[α120]]]]] and [α115] | [α116] <: α117
//│  [[[α120]]] = [α115] because α117 <: [[[α120]]] and α117 :> [α115]
//│  [[[[[α120]]]]] = [[[[String]]]] because α116 <: [[[[[α120]]]]] and α116 :> [[[[String]]]]
//│  [[[[[α120]]]]] = [[[[Int]]]] because α115 <: [[[[[α120]]]]] and α115 :> [[[[Int]]]]
//│ res: int | string


let temp x y = if x then x else y
//│ temp: (true & 'a | ~true) -> 'a -> 'a

:unifyDbg
temp true 1
//│ [ERROR 0] ((true<bool> & α135) | (α136 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α135) | (α136 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α134 <: [[((true<bool> & α135) | (α136 & ~(true<bool>)))]] and α134 :> [[[[[[true<bool>]]]]]]
//│ ╔══[WARNING] [UNIFICATION ERROR 0] [[((true<bool> & α135) | (α136 & ~(true<bool>)))]] and [[[[[[true<bool>]]]]]] cannot be unified but flows into the same location
//│ ╟── ((true<bool> & α135) | (α136 & ~(true<bool>))) is used as reference
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true<bool> is used as argument
//│ ║  l.155: 	temp true 1
//│ ╙──       	     ^^^^
//│ [ERROR 1] true<bool> != Int unifying because [[[[[[[[[true<bool>]]]]]]]]] = [[[[Int]]]] because [[[[[α140]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α135 <: [[[[[α140]]]]] and α135 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[[[α140]]]]] = [[[[Int]]]] because α137 <: [[[[[α140]]]]] and α137 :> [[[[Int]]]]
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[[[[[[true<bool>]]]]]]]]] and [[[[Int]]]] cannot be unified but flows into the same location
//│ ╟── true<bool> is used as reference
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true<bool> is used as reference
//│ ║  l.155: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── Int is used as argument
//│ ║  l.155: 	temp true 1
//│ ║         	          ^
//│ ╟── The following tvars cannot be resolved [[[[[α140]]]]]
//│ ╟── α140 is used as refined scrutinee
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── α140 is used as application
//│ ║  l.155: 	temp true 1
//│ ╙──       	^^^^^^^^^^^
//│ [ERROR 1] Int != true<bool> unifying because [[[[Int]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α137 :> [[[[Int]]]] and [[[[[[[[[true<bool>]]]]]]]]] = [α137] because α135 :> [[[[[[[[[true<bool>]]]]]]]]] and [α135] | [α137] <: α138
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[Int]]]] and [[[[[[[[[true<bool>]]]]]]]]] cannot be unified but flows into the same location
//│ ╟── Int is used as argument
//│ ║  l.155: 	temp true 1
//│ ║         	          ^
//│ ╟── true<bool> is used as reference
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true<bool> is used as reference
//│ ║  l.155: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── The following tvars cannot be resolved α138
//│ ╟── α138 is used as `case` expression
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ╙──       	                  ^^^^^^^^^^^^^^^
//│ unified α134
//│  α134 :> [[[[[[true<bool>]]]]]]
//│  α134 <: [[((true<bool> & α135) | (α136 & ~(true<bool>)))]]
//│ unified α135
//│  [α135] = α138 because [[[α140]]] = [α135] because α138 <: [[[α140]]] and α138 :> [α135] and α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138)
//│  [α135] = [[[[Int]]]] because α138 :> [α135] and [[[[Int]]]] = α138 because α137 :> [[[[Int]]]] and [α137] = α138 because [[[[[α140]]]]] = [α137] because α135 <: [[[[[α140]]]]] and [α135] | [α137] <: α138 and α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138)
//│  [α135] | [α137] <: α138
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α135] because [[[[[α140]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α135 <: [[[[[α140]]]]] and α135 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[α140]]] = [α135] because α138 <: [[[α140]]] and α138 :> [α135]
//│  [[[[Int]]]] = [α135] because [[[[[α140]]]]] = [[[[Int]]]] because α137 <: [[[[[α140]]]]] and α137 :> [[[[Int]]]] and [[[α140]]] = [α135] because α138 <: [[[α140]]] and α138 :> [α135]
//│  α135 :> [[[[[[[[[true<bool>]]]]]]]]]
//│  α135 <: [[[[[α140]]]]]
//│ unified α136
//│ unified α137
//│  [α137] = [[[[[[[[[true<bool>]]]]]]]]] because α138 :> [α137] and α138 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[Int]]]] = α138 because α137 :> [[[[Int]]]] and [α137] = α138 because [[[[[α140]]]]] = [α137] because α135 <: [[[[[α140]]]]] and [α135] | [α137] <: α138 and α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138) and [[[[[[[[[true<bool>]]]]]]]]] = α138 because α135 :> [[[[[[[[[true<bool>]]]]]]]]] and [α135] = α138 because [[[α140]]] = [α135] because α138 <: [[[α140]]] and α138 :> [α135] and α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138)
//│  [α137] = α138 because [[[[[α140]]]]] = [α137] because α135 <: [[[[[α140]]]]] and [α135] | [α137] <: α138 and α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138)
//│  [[[[Int]]]] = [α137] because [[[[[α140]]]]] = [[[[Int]]]] because α137 <: [[[[[α140]]]]] and α137 :> [[[[Int]]]] and [[[[[α140]]]]] = [α137] because α135 <: [[[[[α140]]]]] and [α135] | [α137] <: α138
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α137] because α135 :> [[[[[[[[[true<bool>]]]]]]]]] and [α135] | [α137] <: α138
//│  α137 :> [[[[Int]]]]
//│  α137 <: [[[[[α140]]]]]
//│ unified α138
//│  [[[[[[[[[true<bool>]]]]]]]]] = α138 because α135 :> [[[[[[[[[true<bool>]]]]]]]]] and [α135] = α138 because [[[α140]]] = [α135] because α138 <: [[[α140]]] and α138 :> [α135] and α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138)
//│  α138 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[Int]]]] = α138 because α137 :> [[[[Int]]]] and [α137] = α138 because [[[[[α140]]]]] = [α137] because α135 <: [[[[[α140]]]]] and [α135] | [α137] <: α138 and α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138) and [[[[[[[[[true<bool>]]]]]]]]] = α138 because α135 :> [[[[[[[[[true<bool>]]]]]]]]] and [α135] = α138 because [[[α140]]] = [α135] because α138 <: [[[α140]]] and α138 :> [α135] and α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138)
//│  [[[[Int]]]] = α138 because α137 :> [[[[Int]]]] and [α137] = α138 because [[[[[α140]]]]] = [α137] because α135 <: [[[[[α140]]]]] and [α135] | [α137] <: α138 and α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138)
//│  α138 :> [α137]
//│  α138 :> [α135]
//│  α138 <: [[[α140]]]
//│ unified α139
//│  α139 :> [[[(α137 -> α138)]]]
//│  α139 <: [([(Int,)] -> α140)]
//│ unified α140
//│  α140 = α138 are result type in ([(Int,)] -> α140) = (α137 -> α138)
//│  [[[[[α140]]]]] = [α137] because α135 <: [[[[[α140]]]]] and [α135] | [α137] <: α138
//│  [[[α140]]] = [α135] because α138 <: [[[α140]]] and α138 :> [α135]
//│  [[[[[α140]]]]] = [[[[Int]]]] because α137 <: [[[[[α140]]]]] and α137 :> [[[[Int]]]]
//│  [[[[[α140]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α135 <: [[[[[α140]]]]] and α135 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ res: int | true



let addF x f arg = x + f arg
//│ addF: int -> ('a -> int) -> 'a -> int

:unify
let rec findOddAndAddThem xs = match xs with
  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
  | [] -> 0
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[{_1: α161'}]]] and [[[{_0: α159'}]]] cannot be unified but flows into the same location
//│ ╟── {_1: α161'} is used as refined scrutinee
//│ ║  l.240: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── {_0: α159'} is used as refined scrutinee
//│ ║  l.240: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── The following tvars cannot be resolved α157'
//│ ╟── α157' is used as refined scrutinee
//│ ║  l.240: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[((cons<> & α157') | ((nil<> & α182') & ~(cons<>)))]] and [[[[[[[[Int]]]]]]]] cannot be unified but flows into the same location
//│ ╟── ((cons<> & α157') | ((nil<> & α182') & ~(cons<>))) is used as reference
//│ ║  l.240: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── Int is used as reference
//│ ║  l.240: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── Int is used as type reference
//│ ║  l.20: 	let mod: int -> int -> int
//│ ║        	         ^^^
//│ ╟── The following tvars cannot be resolved α161'
//│ ╟── α161' is used as reference
//│ ║  l.240: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] Bool and [(true<bool> | (α178' & ~(true<bool>)))] cannot be unified but flows into the same location
//│ ╟── Bool is used as type reference
//│ ║  l.29: 	let (==): 'a -> 'a -> bool
//│ ║        	                      ^^^^
//│ ╟── (true<bool> | (α178' & ~(true<bool>))) is used as operator application
//│ ║  l.241: 	  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
//│ ╙──       	                   ^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[[[[[Int]]]]]]]] and [[((cons<> & α157') | ((nil<> & α182') & ~(cons<>)))]] cannot be unified but flows into the same location
//│ ╟── Int is used as reference
//│ ║  l.240: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── Int is used as type reference
//│ ║  l.20: 	let mod: int -> int -> int
//│ ║        	         ^^^
//│ ╟── ((cons<> & α157') | ((nil<> & α182') & ~(cons<>))) is used as reference
//│ ║  l.240: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── The following tvars cannot be resolved α161'
//│ ╟── α161' is used as reference
//│ ║  l.240: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ findOddAndAddThem: 'a -> int
//│   where
//│     'a <: (Cons[?] with {_0: int, _1: int & 'a}) | Nil
