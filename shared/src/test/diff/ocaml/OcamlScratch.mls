:OcamlParser
:OcamlLoadLibrary


type Bool = True | False
//│ Defined type alias Bool
//│ Defined class True
//│ Defined class False
//│ True: Bool
//│ False: Bool

:unifyDbg
let test x =
  match x with True -> 0 | False -> 1
//│ unified α62'
//│  α62' <: [[((true<> & α63') | ((false<> & α64') & ~(true<>)))]]
//│ unified α63'
//│ unified α64'
//│ unified α65'
//│  α65' :> int<>
//│ test: bool -> int

:unifyDbg
let test x =
  match x with True -> 0 | False -> "oops"
//│ [ERROR 1] int<> != string<> unifying because int<> | string<> <: α73'
//│ ╔══[WARNING] int<> and string<> cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                       ^
//│ ╟── string<> is here
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                                    ^^^^^^
//│ ╟── The following tvars cannot be resolved α73'
//│ ╟── α73' is here
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ╙──      	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ unified α70'
//│  α70' <: [[((true<> & α71') | ((false<> & α72') & ~(true<>)))]]
//│ unified α71'
//│ unified α72'
//│ unified α73'
//│  α73' :> string<>
//│  α73' :> int<>
//│ test: bool -> (int | string)



:unifyDbg
let temp x = if x then 0 else "oops"
//│ [ERROR 1] int<> != string<> unifying because int<> | string<> <: α81'
//│ ╔══[WARNING] int<> and string<> cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.50: 	let temp x = if x then 0 else "oops"
//│ ║        	                       ^
//│ ╟── string<> is here
//│ ║  l.50: 	let temp x = if x then 0 else "oops"
//│ ║        	                              ^^^^^^
//│ ╟── The following tvars cannot be resolved α81'
//│ ╟── α81' is here
//│ ║  l.50: 	let temp x = if x then 0 else "oops"
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^^
//│ unified α78'
//│  α78' <: [[((true<bool> & α79') | (α80' & ~(true<bool>)))]]
//│ unified α79'
//│ unified α80'
//│ unified α81'
//│  α81' :> string<>
//│  α81' :> int<>
//│ temp: anything -> (int | string)


let temp x y z = if x then y else z
//│ temp: anything -> 'a -> 'a -> 'a

temp true 1 2
//│ res: int

:unifyDbg
temp true 1 "oops"
//│ [ERROR 0] ((true<bool> & α111) | (α112 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α111) | (α112 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α110 <: [[((true<bool> & α111) | (α112 & ~(true<bool>)))]] and α110 :> [[[[[[true<bool>]]]]]]
//│ ╔══[WARNING] [[((true<bool> & α111) | (α112 & ~(true<bool>)))]] and [[[[[[true<bool>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ((true<bool> & α111) | (α112 & ~(true<bool>))) is here
//│ ║  l.73: 	let temp x y z = if x then y else z
//│ ║        	                    ^
//│ ╟── true<bool> is here
//│ ║  l.80: 	temp true 1 "oops"
//│ ╙──      	     ^^^^
//│ [ERROR 1] int<> != string<> unifying because [[[[int<>]]]] = [[[[string<>]]]] because [[[[[α118]]]]] = [[[[int<>]]]] because α113 <: [[[[[α118]]]]] and α113 :> [[[[int<>]]]] and [[[[[α118]]]]] = [[[[string<>]]]] because α114 <: [[[[[α118]]]]] and α114 :> [[[[string<>]]]]
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[string<>]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.80: 	temp true 1 "oops"
//│ ║        	          ^
//│ ╟── string<> is here
//│ ║  l.80: 	temp true 1 "oops"
//│ ║        	            ^^^^^^
//│ ╟── The following tvars cannot be resolved [[[[[α118]]]]]
//│ ╟── α118 is here
//│ ║  l.80: 	temp true 1 "oops"
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── α118 is here
//│ ║  l.73: 	let temp x y z = if x then y else z
//│ ╙──      	                           ^
//│ [ERROR 1] string<> != int<> unifying because [[[[string<>]]]] = [[[[int<>]]]] because α114 :> [[[[string<>]]]] and [[[[int<>]]]] = [α114] because α113 :> [[[[int<>]]]] and [α113] | [α114] <: α115
//│ ╔══[WARNING] [[[[string<>]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── string<> is here
//│ ║  l.80: 	temp true 1 "oops"
//│ ║        	            ^^^^^^
//│ ╟── int<> is here
//│ ║  l.80: 	temp true 1 "oops"
//│ ║        	          ^
//│ ╟── The following tvars cannot be resolved α115
//│ ╟── α115 is here
//│ ║  l.73: 	let temp x y z = if x then y else z
//│ ╙──      	                    ^^^^^^^^^^^^^^^
//│ unified α110
//│  α110 :> [[[[[[true<bool>]]]]]]
//│  α110 <: [[((true<bool> & α111) | (α112 & ~(true<bool>)))]]
//│ unified α111
//│  α111 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ unified α112
//│ unified α113
//│  [α113] | [α114] <: α115
//│  [[[[int<>]]]] = [α113] because [[[[[α118]]]]] = [[[[int<>]]]] because α113 <: [[[[[α118]]]]] and α113 :> [[[[int<>]]]] and [[[α118]]] = [α113] because α115 <: [[[α118]]] and α115 :> [α113]
//│  [[[[string<>]]]] = [α113] because [[[[[α118]]]]] = [[[[string<>]]]] because α114 <: [[[[[α118]]]]] and α114 :> [[[[string<>]]]] and [[[α118]]] = [α113] because α115 <: [[[α118]]] and α115 :> [α113]
//│  α113 :> [[[[int<>]]]]
//│  α113 <: [[[[[α118]]]]]
//│ unified α114
//│  [[[[string<>]]]] = [α114] because [[[[[α118]]]]] = [[[[string<>]]]] because α114 <: [[[[[α118]]]]] and α114 :> [[[[string<>]]]] and [[[[[α118]]]]] = [α114] because α113 <: [[[[[α118]]]]] and [α113] | [α114] <: α115
//│  [[[[int<>]]]] = [α114] because α113 :> [[[[int<>]]]] and [α113] | [α114] <: α115
//│  α114 :> [[[[string<>]]]]
//│  α114 <: [[[[[α118]]]]]
//│ unified α115
//│  α115 :> [α114]
//│  α115 :> [α113]
//│  α115 <: [[[α118]]]
//│ unified α116
//│  α116 :> [[[(α113 -> (α114 -> α115))]]]
//│  α116 <: [([(int<>,)] -> α117)]
//│ unified α117
//│  α117 <: [([(string<>,)] -> α118)]
//│  α117 = (α114 -> α115) are result type in ([(int<>,)] -> α117) = (α113 -> (α114 -> α115))
//│ unified α118
//│  [[[[[α118]]]]] = [α114] because α113 <: [[[[[α118]]]]] and [α113] | [α114] <: α115
//│  [[[α118]]] = [α113] because α115 <: [[[α118]]] and α115 :> [α113]
//│  [[[[[α118]]]]] = [[[[string<>]]]] because α114 <: [[[[[α118]]]]] and α114 :> [[[[string<>]]]]
//│  [[[[[α118]]]]] = [[[[int<>]]]] because α113 <: [[[[[α118]]]]] and α113 :> [[[[int<>]]]]
//│ res: int | string


let temp x y = if x then x else y
//│ temp: (true & 'a | ~true) -> 'a -> 'a

:unifyDbg
temp true 1
//│ [ERROR 0] ((true<bool> & α133) | (α134 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α133) | (α134 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α132 <: [[((true<bool> & α133) | (α134 & ~(true<bool>)))]] and α132 :> [[[[[[true<bool>]]]]]]
//│ ╔══[WARNING] [[((true<bool> & α133) | (α134 & ~(true<bool>)))]] and [[[[[[true<bool>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ((true<bool> & α133) | (α134 & ~(true<bool>))) is here
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true<bool> is here
//│ ║  l.155: 	temp true 1
//│ ╙──       	     ^^^^
//│ [ERROR 1] true<bool> != int<> unifying because [[[[[[[[[true<bool>]]]]]]]]] = [[[[int<>]]]] because [[[[[α138]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α133 <: [[[[[α138]]]]] and α133 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[[[α138]]]]] = [[[[int<>]]]] because α135 <: [[[[[α138]]]]] and α135 :> [[[[int<>]]]]
//│ ╔══[WARNING] [[[[[[[[[true<bool>]]]]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── true<bool> is here
//│ ║  l.155: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── true<bool> is here
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── int<> is here
//│ ║  l.155: 	temp true 1
//│ ║         	          ^
//│ ╟── The following tvars cannot be resolved [[[[[α138]]]]]
//│ ╟── α138 is here
//│ ║  l.155: 	temp true 1
//│ ║         	^^^^^^^^^^^
//│ ╟── α138 is here
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ╙──       	                  ^
//│ [ERROR 1] int<> != true<bool> unifying because [[[[int<>]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α135 :> [[[[int<>]]]] and [[[[[[[[[true<bool>]]]]]]]]] = [α135] because α133 :> [[[[[[[[[true<bool>]]]]]]]]] and [α133] | [α135] <: α136
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[[[[[true<bool>]]]]]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.155: 	temp true 1
//│ ║         	          ^
//│ ╟── true<bool> is here
//│ ║  l.155: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── true<bool> is here
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── The following tvars cannot be resolved α136
//│ ╟── α136 is here
//│ ║  l.151: 	let temp x y = if x then x else y
//│ ╙──       	                  ^^^^^^^^^^^^^^^
//│ unified α132
//│  α132 :> [[[[[[true<bool>]]]]]]
//│  α132 <: [[((true<bool> & α133) | (α134 & ~(true<bool>)))]]
//│ unified α133
//│  [α133] = α136 because [[[α138]]] = [α133] because α136 <: [[[α138]]] and α136 :> [α133] and α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136)
//│  [α133] = [[[[int<>]]]] because α136 :> [α133] and [[[[int<>]]]] = α136 because α135 :> [[[[int<>]]]] and [α135] = α136 because [[[[[α138]]]]] = [α135] because α133 <: [[[[[α138]]]]] and [α133] | [α135] <: α136 and α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136)
//│  [α133] | [α135] <: α136
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α133] because [[[[[α138]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α133 <: [[[[[α138]]]]] and α133 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[α138]]] = [α133] because α136 <: [[[α138]]] and α136 :> [α133]
//│  [[[[int<>]]]] = [α133] because [[[[[α138]]]]] = [[[[int<>]]]] because α135 <: [[[[[α138]]]]] and α135 :> [[[[int<>]]]] and [[[α138]]] = [α133] because α136 <: [[[α138]]] and α136 :> [α133]
//│  α133 :> [[[[[[[[[true<bool>]]]]]]]]]
//│  α133 <: [[[[[α138]]]]]
//│ unified α134
//│ unified α135
//│  [α135] = [[[[[[[[[true<bool>]]]]]]]]] because α136 :> [α135] and α136 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[int<>]]]] = α136 because α135 :> [[[[int<>]]]] and [α135] = α136 because [[[[[α138]]]]] = [α135] because α133 <: [[[[[α138]]]]] and [α133] | [α135] <: α136 and α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136) and [[[[[[[[[true<bool>]]]]]]]]] = α136 because α133 :> [[[[[[[[[true<bool>]]]]]]]]] and [α133] = α136 because [[[α138]]] = [α133] because α136 <: [[[α138]]] and α136 :> [α133] and α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136)
//│  [α135] = α136 because [[[[[α138]]]]] = [α135] because α133 <: [[[[[α138]]]]] and [α133] | [α135] <: α136 and α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136)
//│  [[[[int<>]]]] = [α135] because [[[[[α138]]]]] = [[[[int<>]]]] because α135 <: [[[[[α138]]]]] and α135 :> [[[[int<>]]]] and [[[[[α138]]]]] = [α135] because α133 <: [[[[[α138]]]]] and [α133] | [α135] <: α136
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α135] because α133 :> [[[[[[[[[true<bool>]]]]]]]]] and [α133] | [α135] <: α136
//│  α135 :> [[[[int<>]]]]
//│  α135 <: [[[[[α138]]]]]
//│ unified α136
//│  [[[[[[[[[true<bool>]]]]]]]]] = α136 because α133 :> [[[[[[[[[true<bool>]]]]]]]]] and [α133] = α136 because [[[α138]]] = [α133] because α136 <: [[[α138]]] and α136 :> [α133] and α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136)
//│  α136 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[int<>]]]] = α136 because α135 :> [[[[int<>]]]] and [α135] = α136 because [[[[[α138]]]]] = [α135] because α133 <: [[[[[α138]]]]] and [α133] | [α135] <: α136 and α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136) and [[[[[[[[[true<bool>]]]]]]]]] = α136 because α133 :> [[[[[[[[[true<bool>]]]]]]]]] and [α133] = α136 because [[[α138]]] = [α133] because α136 <: [[[α138]]] and α136 :> [α133] and α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136)
//│  [[[[int<>]]]] = α136 because α135 :> [[[[int<>]]]] and [α135] = α136 because [[[[[α138]]]]] = [α135] because α133 <: [[[[[α138]]]]] and [α133] | [α135] <: α136 and α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136)
//│  α136 :> [α135]
//│  α136 :> [α133]
//│  α136 <: [[[α138]]]
//│ unified α137
//│  α137 :> [[[(α135 -> α136)]]]
//│  α137 <: [([(int<>,)] -> α138)]
//│ unified α138
//│  α138 = α136 are result type in ([(int<>,)] -> α138) = (α135 -> α136)
//│  [[[[[α138]]]]] = [α135] because α133 <: [[[[[α138]]]]] and [α133] | [α135] <: α136
//│  [[[α138]]] = [α133] because α136 <: [[[α138]]] and α136 :> [α133]
//│  [[[[[α138]]]]] = [[[[int<>]]]] because α135 <: [[[[[α138]]]]] and α135 :> [[[[int<>]]]]
//│  [[[[[α138]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α133 <: [[[[[α138]]]]] and α133 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ res: int | true
