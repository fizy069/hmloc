:OcamlParser

type a = int
//│ Defined type alias a

1 : a
//│ res: a

true : bool
//│ res: bool

match true with true -> 1 | false -> 2
//│ res: int

// :d
:dp
type ('a, 'b) either = Left of ('a * 'a) | Right of 'b
//│ Parsed: TypeDef(Als, TypeName(either), List(TypeName('a), TypeName('b)), Union(AppliedType(TypeName(Right),List(TypeName('b))),Union(AppliedType(TypeName(Left),List(TypeName('a))),AppliedType(TypeName(Left),List(TypeName('a))))), List())
//│ TypeDef(Cls, TypeName(Left), List(TypeName('a)), Record(List((_0,Field(None,Tuple(List((None,Field(None,TypeName('a))), (None,Field(None,TypeName('a))))))))), List(_0)) of adt: Some((TypeName(either),List(0)))
//│ TypeDef(Cls, TypeName(Right), List(TypeName('b)), Record(List((_0,Field(None,TypeName('b))))), List(_0)) of adt: Some((TypeName(either),List(1)))
//│ Def(false, Left, PolyType(List(TypeName('a), TypeName('b)),Function(Tuple(List((None,Field(None,Tuple(List((None,Field(None,TypeName('a))), (None,Field(None,TypeName('a))))))))),AppliedType(TypeName(either),List(TypeName('a), TypeName('b))))), true)
//│ Def(false, Right, PolyType(List(TypeName('a), TypeName('b)),Function(Tuple(List((None,Field(None,TypeName('b))))),AppliedType(TypeName(either),List(TypeName('a), TypeName('b))))), true)
//│ Defined type alias either[+'a, +'b]
//│ Defined class Left[+'a]
//│ Defined class Right[+'b]
//│ Left: ('a, 'a,) -> either['a, nothing]
//│ Right: 'a -> either[nothing, 'a]

:d
Left
//│ 0. Typing term Left
//│ 0. : (((α46, α46,),) -> either[α46,α47])
//│ ⬤ Typed as: (((α46, α46,),) -> either[α46,α47])
//│  where: 
//│ res: ('a, 'a,) -> either['a, nothing]

// :d
// :dp
// :unifyDbg
// let test x =
//  match x with True -> 0 | False -> 1

// :d
:dp
let text x =
  match x with Left l -> l | Right r -> r
//│ Parsed: Def(false, text, Lam(Tup(_: Var(x)), If(Var(x), List(IfThen(App(Var(Left), Tup(_: Var(l))), Var(l), IfThen(App(Var(Right), Tup(_: Var(r))), Var(r)))), true)
//│ text: either['a, 'b] -> ('b | ('a, 'a,),)

:d
let f x = let (a, b) = x in a + b
//│ 1. Typing term x, => if x('(' a, b, ')') then + (a,) (b,)
//│ | 1. Typing pattern x,
//│ | | 1. Typing pattern x
//│ | | 1. : α64'
//│ | 1. : (α64',)
//│ | 1. Typing term if x('(' a, b, ')') then + (a,) (b,)
//│ | | If(Var(x), List(IfThen(Bra(rcd = false, Tup(_: Var(a), _: Var(b))), App(App(Var(+), Tup(_: Var(a))), Tup(_: Var(b)))))
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: match case without any arms
//│ 	at: mlscript.utils.package$.lastWords(package.scala:185)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:744)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:827)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:655)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:827)
//│ 	at: mlscript.Typer.typeLetRhs(Typer.scala:422)
//│ 	at: mlscript.DiffTests.$anonfun$new$45(DiffTests.scala:589)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)

// :d
:unifyDbg
if 1 == 2 then Left true else Right false
//│ unified α65
//│  α65 :> [[((Int,) -> Bool)]]
//│  α65 <: [([(Int,)] -> α66)]
//│ unified α66
//│  α66 = Bool are result type in ([(Int,)] -> α66) = ((Int,) -> Bool)
//│ unified α67
//│  α67 :> [[[[either[α68,α69]]]]]
//│  α67 :> [[[[either[α72,α71]]]]]
//│ unified α68
//│ unified α69
//│  α69 = [[[[[Bool]]]]] because α71 = α69 are TypeName(either)(1) arg type and α71 :> [[[[[Bool]]]]]
//│ unified α70
//│  α70 :> [[[either[α68,α69]]]]
//│  α70 <: [[α67]]
//│ unified α71
//│  α71 :> [[[[[Bool]]]]]
//│  α71 = α69 are TypeName(either)(1) arg type
//│ unified α72
//│  α72 = α68 are TypeName(either)(0) arg type
//│ unified α73
//│  α73 :> [[[either[α72,α71]]]]
//│  α73 <: [[α67]]
//│ ╔══[ERROR] Type mismatch in if-then-else true condition:
//│ ║  l.73: 	if 1 == 2 then Left true else Right false
//│ ║        	               ^^^^^^^^^
//│ ╟── reference of type `bool` is not a 2-element tuple
//│ ║  l.73: 	if 1 == 2 then Left true else Right false
//│ ║        	                    ^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.17: 	type ('a, 'b) either = Left of ('a * 'a) | Right of 'b
//│ ╙──      	                                ^^^^^^^
//│ res: either[nothing, bool]

// :d
// succ

let f x = x
//│ f: 'a -> 'a

:d
f(true, false)
//│ 0. Typing term f (true, false,)
//│ | 0. Typing term f
//│ | 0. : ((α83,) -> [α83])
//│ | 0. Typing term true, false,
//│ | | 0. Typing term true
//│ | | 0. : Bool
//│ | | 0. Typing term false
//│ | | 0. : Bool
//│ | 0. : (Bool, Bool,)
//│ | CONSTRAIN ((α83,) -> [α83]) <! ((Bool, Bool,) -> α84)
//│ |   where 
//│ | C ((α83,) -> [α83]) <! ((Bool, Bool,) -> α84)    (0) where FunctionType <: FunctionType}
//│ | | C (Bool, Bool,) <! (α83,)    (1) where TupleType <: TupleType}
//│ | | | allVarPols: -α83
//│ | | | norm[-] (α83,)
//│ | | | | DNF: DNF((α83,){})
//│ | | | | norm[-] α83
//│ | | | | | DNF: DNF(α83)
//│ | | | | ~> α83
//│ | | | ~> (α83,)
//│ | | | allVarPols: 
//│ | | | norm[+] (Bool, Bool,)
//│ | | | | DNF: DNF((Bool, Bool,){})
//│ | | | | norm[+] Bool
//│ | | | | | DNF: DNF(bool<>{})
//│ | | | | ~> bool<>
//│ | | | | norm[+] Bool
//│ | | | | | DNF: DNF(bool<>{})
//│ | | | | ~> bool<>
//│ | | | ~> (bool<>, bool<>,)
//│ | | C [α83] <! α84    (2) where ProvType <: TypeVariable}
//│ | | | C α83 <! α84    (2) where TypeVariable <: TypeVariable}
//│ 0. : α84
//│ ⬤ Typed as: α84
//│  where: 
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.114: 	f(true, false)
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(bool, bool,)` does not match type `(?a,)`
//│ ║  l.114: 	f(true, false)
//│ ╙──       	  ^^^^^^^^^^^
//│ res: nothing

:d
f((true, false))
//│ 0. Typing term f (true, false,)
//│ | 0. Typing term f
//│ | 0. : ((α86,) -> [α86])
//│ | 0. Typing term true, false,
//│ | | 0. Typing term true
//│ | | 0. : Bool
//│ | | 0. Typing term false
//│ | | 0. : Bool
//│ | 0. : (Bool, Bool,)
//│ | CONSTRAIN ((α86,) -> [α86]) <! ((Bool, Bool,) -> α87)
//│ |   where 
//│ | C ((α86,) -> [α86]) <! ((Bool, Bool,) -> α87)    (0) where FunctionType <: FunctionType}
//│ | | C (Bool, Bool,) <! (α86,)    (1) where TupleType <: TupleType}
//│ | | | allVarPols: -α86
//│ | | | norm[-] (α86,)
//│ | | | | DNF: DNF((α86,){})
//│ | | | | norm[-] α86
//│ | | | | | DNF: DNF(α86)
//│ | | | | ~> α86
//│ | | | ~> (α86,)
//│ | | | allVarPols: 
//│ | | | norm[+] (Bool, Bool,)
//│ | | | | DNF: DNF((Bool, Bool,){})
//│ | | | | norm[+] Bool
//│ | | | | | DNF: DNF(bool<>{})
//│ | | | | ~> bool<>
//│ | | | | norm[+] Bool
//│ | | | | | DNF: DNF(bool<>{})
//│ | | | | ~> bool<>
//│ | | | ~> (bool<>, bool<>,)
//│ | | C [α86] <! α87    (2) where ProvType <: TypeVariable}
//│ | | | C α86 <! α87    (2) where TypeVariable <: TypeVariable}
//│ 0. : α87
//│ ⬤ Typed as: α87
//│  where: 
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.159: 	f((true, false))
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(bool, bool,)` does not match type `(?a,)`
//│ ║  l.159: 	f((true, false))
//│ ╙──       	   ^^^^^^^^^^^
//│ res: nothing

:d
Left((true, false))
//│ 0. Typing term Left (true, false,)
//│ | 0. Typing term Left
//│ | 0. : (((α89, α89,),) -> either[α89,α90])
//│ | 0. Typing term true, false,
//│ | | 0. Typing term true
//│ | | 0. : Bool
//│ | | 0. Typing term false
//│ | | 0. : Bool
//│ | 0. : (Bool, Bool,)
//│ | CONSTRAIN (((α89, α89,),) -> either[α89,α90]) <! ((Bool, Bool,) -> α91)
//│ |   where 
//│ | C (((α89, α89,),) -> either[α89,α90]) <! ((Bool, Bool,) -> α91)    (0) where FunctionType <: FunctionType}
//│ | | C (Bool, Bool,) <! ((α89, α89,),)    (1) where TupleType <: TupleType}
//│ | | | allVarPols: -α89
//│ | | | norm[-] ((α89, α89,),)
//│ | | | | DNF: DNF(((α89, α89,),){})
//│ | | | | norm[-] (α89, α89,)
//│ | | | | | DNF: DNF((α89, α89,){})
//│ | | | | | norm[-] α89
//│ | | | | | | DNF: DNF(α89)
//│ | | | | | ~> α89
//│ | | | | | norm[-] α89
//│ | | | | | | DNF: DNF(α89)
//│ | | | | | ~> α89
//│ | | | | ~> (α89, α89,)
//│ | | | ~> ((α89, α89,),)
//│ | | | allVarPols: 
//│ | | | norm[+] (Bool, Bool,)
//│ | | | | DNF: DNF((Bool, Bool,){})
//│ | | | | norm[+] Bool
//│ | | | | | DNF: DNF(bool<>{})
//│ | | | | ~> bool<>
//│ | | | | norm[+] Bool
//│ | | | | | DNF: DNF(bool<>{})
//│ | | | | ~> bool<>
//│ | | | ~> (bool<>, bool<>,)
//│ | | C either[α89,α90] <! α91    (2) where TypeRef <: TypeVariable}
//│ 0. : α91
//│ ⬤ Typed as: α91
//│  where: 
//│ 		α91 :> either[α89,α90]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.204: 	Left((true, false))
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(bool, bool,)` does not match type `((?a, ?a,),)`
//│ ║  l.204: 	Left((true, false))
//│ ║         	      ^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.17: 	type ('a, 'b) either = Left of ('a * 'a) | Right of 'b
//│ ╙──      	                                ^^^^^^^
//│ res: either[nothing, nothing]

:unifyDbg
if 1 == 2 then Left((true, false)) else Right false
//│ unified α95
//│  α95 :> [[((Int,) -> Bool)]]
//│  α95 <: [([(Int,)] -> α96)]
//│ unified α96
//│  α96 = Bool are result type in ([(Int,)] -> α96) = ((Int,) -> Bool)
//│ unified α97
//│  α97 :> [[[[either[α98,α99]]]]]
//│  α97 :> [[[[either[α102,α101]]]]]
//│ unified α98
//│ unified α99
//│  α99 = [[[[[Bool]]]]] because α101 = α99 are TypeName(either)(1) arg type and α101 :> [[[[[Bool]]]]]
//│ unified α100
//│  α100 :> [[[either[α98,α99]]]]
//│  α100 <: [[α97]]
//│ unified α101
//│  α101 :> [[[[[Bool]]]]]
//│  α101 = α99 are TypeName(either)(1) arg type
//│ unified α102
//│  α102 = α98 are TypeName(either)(0) arg type
//│ unified α103
//│  α103 :> [[[either[α102,α101]]]]
//│  α103 <: [[α97]]
//│ ╔══[ERROR] Type mismatch in if-then-else true condition:
//│ ║  l.258: 	if 1 == 2 then Left((true, false)) else Right false
//│ ║         	               ^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(bool, bool,)` does not match type `((?a, ?a,),)`
//│ ║  l.258: 	if 1 == 2 then Left((true, false)) else Right false
//│ ║         	                     ^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.17: 	type ('a, 'b) either = Left of ('a * 'a) | Right of 'b
//│ ╙──      	                                ^^^^^^^
//│ res: either[nothing, bool]

:unifyDbg
//let test x =
//  match x with True -> 0 | False -> "oops"



:unifyDbg
//let temp x = if x then 0 else "oops"


//let temp x y z = if x then y else z

//temp true 1 2

:unifyDbg
//temp true 1 "oops"


//let temp x y = if x then x else y

:unifyDbg
//temp true 1



//let addF x f arg = x + f arg

:unify
//let rec findOddAndAddThem xs = match xs with
//  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
//  | [] -> 0

