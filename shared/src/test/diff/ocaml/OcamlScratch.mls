
:OcamlParser
:OcamlLoadLibrary


type Bool = True | False
//│ Defined type alias Bool
//│ Defined class True
//│ Defined class False
//│ True: Bool
//│ False: Bool

:unifyDbg
let test x =
  match x with True -> 0 | False -> 1
//│ unified α55'
//│  α55' <: [[((true<> & α56') | ((false<> & α57') & ~(true<>)))]]
//│ unified α56'
//│ unified α57'
//│ unified α58'
//│  α58' :> int<>
//│ test: bool -> int

:unifyDbg
let test x =
  match x with True -> 0 | False -> "oops"
//│ [ERROR 1] int<> != string<> unifying because int<> | string<> <: α66'
//│ ╔══[WARNING] int<> and string<> cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.26: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                       ^
//│ ╟── string<> is here
//│ ║  l.26: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                                    ^^^^^^
//│ ╟── The following tvars cannot be resolved α66'
//│ ╟── α66' is here
//│ ║  l.26: 	  match x with True -> 0 | False -> "oops"
//│ ╙──      	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ unified α63'
//│  α63' <: [[((true<> & α64') | ((false<> & α65') & ~(true<>)))]]
//│ unified α64'
//│ unified α65'
//│ unified α66'
//│  α66' :> string<>
//│  α66' :> int<>
//│ test: bool -> (int | string)



:unifyDbg
let temp x = if x then 0 else "oops"
//│ [ERROR 1] int<> != string<> unifying because int<> | string<> <: α74'
//│ ╔══[WARNING] int<> and string<> cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.51: 	let temp x = if x then 0 else "oops"
//│ ║        	                       ^
//│ ╟── string<> is here
//│ ║  l.51: 	let temp x = if x then 0 else "oops"
//│ ║        	                              ^^^^^^
//│ ╟── The following tvars cannot be resolved α74'
//│ ╟── α74' is here
//│ ║  l.51: 	let temp x = if x then 0 else "oops"
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^^
//│ unified α71'
//│  α71' <: [[((true<bool> & α72') | (α73' & ~(true<bool>)))]]
//│ unified α72'
//│ unified α73'
//│ unified α74'
//│  α74' :> string<>
//│  α74' :> int<>
//│ temp: anything -> (int | string)


let temp x y z = if x then y else z
//│ temp: anything -> 'a -> 'a -> 'a

temp true 1 2
//│ res: int

:unifyDbg
temp true 1 "oops"
//│ [ERROR 0] ((true<bool> & α104) | (α105 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α104) | (α105 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α103 <: [[((true<bool> & α104) | (α105 & ~(true<bool>)))]] and α103 :> [[[[[[true<bool>]]]]]]
//│ ╔══[WARNING] [[((true<bool> & α104) | (α105 & ~(true<bool>)))]] and [[[[[[true<bool>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ((true<bool> & α104) | (α105 & ~(true<bool>))) is here
//│ ║  l.74: 	let temp x y z = if x then y else z
//│ ║        	                    ^
//│ ╟── true<bool> is here
//│ ║  l.81: 	temp true 1 "oops"
//│ ╙──      	     ^^^^
//│ [ERROR 1] int<> != string<> unifying because [[[[int<>]]]] = [[[[string<>]]]] because [[[[[α111]]]]] = [[[[int<>]]]] because α106 <: [[[[[α111]]]]] and α106 :> [[[[int<>]]]] and [[[[[α111]]]]] = [[[[string<>]]]] because α107 <: [[[[[α111]]]]] and α107 :> [[[[string<>]]]]
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[string<>]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.81: 	temp true 1 "oops"
//│ ║        	          ^
//│ ╟── string<> is here
//│ ║  l.81: 	temp true 1 "oops"
//│ ║        	            ^^^^^^
//│ ╟── The following tvars cannot be resolved [[[[[α111]]]]]
//│ ╟── α111 is here
//│ ║  l.81: 	temp true 1 "oops"
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── α111 is here
//│ ║  l.74: 	let temp x y z = if x then y else z
//│ ╙──      	                           ^
//│ [ERROR 1] string<> != int<> unifying because [[[[string<>]]]] = [[[[int<>]]]] because α107 :> [[[[string<>]]]] and [[[[int<>]]]] = [α107] because α106 :> [[[[int<>]]]] and [α106] | [α107] <: α108
//│ ╔══[WARNING] [[[[string<>]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── string<> is here
//│ ║  l.81: 	temp true 1 "oops"
//│ ║        	            ^^^^^^
//│ ╟── int<> is here
//│ ║  l.81: 	temp true 1 "oops"
//│ ║        	          ^
//│ ╟── The following tvars cannot be resolved α108
//│ ╟── α108 is here
//│ ║  l.74: 	let temp x y z = if x then y else z
//│ ╙──      	                    ^^^^^^^^^^^^^^^
//│ unified α103
//│  α103 :> [[[[[[true<bool>]]]]]]
//│  α103 <: [[((true<bool> & α104) | (α105 & ~(true<bool>)))]]
//│ unified α104
//│  α104 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ unified α105
//│ unified α106
//│  [α106] | [α107] <: α108
//│  [[[[int<>]]]] = [α106] because [[[[[α111]]]]] = [[[[int<>]]]] because α106 <: [[[[[α111]]]]] and α106 :> [[[[int<>]]]] and [[[α111]]] = [α106] because α108 <: [[[α111]]] and α108 :> [α106]
//│  [[[[string<>]]]] = [α106] because [[[[[α111]]]]] = [[[[string<>]]]] because α107 <: [[[[[α111]]]]] and α107 :> [[[[string<>]]]] and [[[α111]]] = [α106] because α108 <: [[[α111]]] and α108 :> [α106]
//│  α106 :> [[[[int<>]]]]
//│  α106 <: [[[[[α111]]]]]
//│ unified α107
//│  [[[[string<>]]]] = [α107] because [[[[[α111]]]]] = [[[[string<>]]]] because α107 <: [[[[[α111]]]]] and α107 :> [[[[string<>]]]] and [[[[[α111]]]]] = [α107] because α106 <: [[[[[α111]]]]] and [α106] | [α107] <: α108
//│  [[[[int<>]]]] = [α107] because α106 :> [[[[int<>]]]] and [α106] | [α107] <: α108
//│  α107 :> [[[[string<>]]]]
//│  α107 <: [[[[[α111]]]]]
//│ unified α108
//│  α108 :> [α107]
//│  α108 :> [α106]
//│  α108 <: [[[α111]]]
//│ unified α109
//│  α109 :> [[[(α106 -> (α107 -> α108))]]]
//│  α109 <: [([(int<>,)] -> α110)]
//│ unified α110
//│  α110 <: [([(string<>,)] -> α111)]
//│  α110 = (α107 -> α108) are result type in ([(int<>,)] -> α110) = (α106 -> (α107 -> α108))
//│ unified α111
//│  [[[[[α111]]]]] = [α107] because α106 <: [[[[[α111]]]]] and [α106] | [α107] <: α108
//│  [[[α111]]] = [α106] because α108 <: [[[α111]]] and α108 :> [α106]
//│  [[[[[α111]]]]] = [[[[string<>]]]] because α107 <: [[[[[α111]]]]] and α107 :> [[[[string<>]]]]
//│  [[[[[α111]]]]] = [[[[int<>]]]] because α106 <: [[[[[α111]]]]] and α106 :> [[[[int<>]]]]
//│ res: int | string


let temp x y = if x then x else y
//│ temp: (true & 'a | ~true) -> 'a -> 'a

:unifyDbg
temp true 1
//│ [ERROR 0] ((true<bool> & α126) | (α127 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α126) | (α127 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α125 <: [[((true<bool> & α126) | (α127 & ~(true<bool>)))]] and α125 :> [[[[[[true<bool>]]]]]]
//│ ╔══[WARNING] [[((true<bool> & α126) | (α127 & ~(true<bool>)))]] and [[[[[[true<bool>]]]]]] cannot be unified but they flow into the same locations
//│ ╟── ((true<bool> & α126) | (α127 & ~(true<bool>))) is here
//│ ║  l.152: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true<bool> is here
//│ ║  l.156: 	temp true 1
//│ ╙──       	     ^^^^
//│ [ERROR 1] true<bool> != int<> unifying because [[[[[[[[[true<bool>]]]]]]]]] = [[[[int<>]]]] because [[[[[α131]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α126 <: [[[[[α131]]]]] and α126 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[[[α131]]]]] = [[[[int<>]]]] because α128 <: [[[[[α131]]]]] and α128 :> [[[[int<>]]]]
//│ ╔══[WARNING] [[[[[[[[[true<bool>]]]]]]]]] and [[[[int<>]]]] cannot be unified but they flow into the same locations
//│ ╟── true<bool> is here
//│ ║  l.156: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── true<bool> is here
//│ ║  l.152: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── int<> is here
//│ ║  l.156: 	temp true 1
//│ ║         	          ^
//│ ╟── The following tvars cannot be resolved [[[[[α131]]]]]
//│ ╟── α131 is here
//│ ║  l.156: 	temp true 1
//│ ║         	^^^^^^^^^^^
//│ ╟── α131 is here
//│ ║  l.152: 	let temp x y = if x then x else y
//│ ╙──       	                  ^
//│ [ERROR 1] int<> != true<bool> unifying because [[[[int<>]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α128 :> [[[[int<>]]]] and [[[[[[[[[true<bool>]]]]]]]]] = [α128] because α126 :> [[[[[[[[[true<bool>]]]]]]]]] and [α126] | [α128] <: α129
//│ ╔══[WARNING] [[[[int<>]]]] and [[[[[[[[[true<bool>]]]]]]]]] cannot be unified but they flow into the same locations
//│ ╟── int<> is here
//│ ║  l.156: 	temp true 1
//│ ║         	          ^
//│ ╟── true<bool> is here
//│ ║  l.156: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── true<bool> is here
//│ ║  l.152: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── The following tvars cannot be resolved α129
//│ ╟── α129 is here
//│ ║  l.152: 	let temp x y = if x then x else y
//│ ╙──       	                  ^^^^^^^^^^^^^^^
//│ unified α125
//│  α125 :> [[[[[[true<bool>]]]]]]
//│  α125 <: [[((true<bool> & α126) | (α127 & ~(true<bool>)))]]
//│ unified α126
//│  [α126] = α129 because [[[α131]]] = [α126] because α129 <: [[[α131]]] and α129 :> [α126] and α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129)
//│  [α126] = [[[[int<>]]]] because α129 :> [α126] and [[[[int<>]]]] = α129 because α128 :> [[[[int<>]]]] and [α128] = α129 because [[[[[α131]]]]] = [α128] because α126 <: [[[[[α131]]]]] and [α126] | [α128] <: α129 and α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129)
//│  [α126] | [α128] <: α129
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α126] because [[[[[α131]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α126 <: [[[[[α131]]]]] and α126 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[α131]]] = [α126] because α129 <: [[[α131]]] and α129 :> [α126]
//│  [[[[int<>]]]] = [α126] because [[[[[α131]]]]] = [[[[int<>]]]] because α128 <: [[[[[α131]]]]] and α128 :> [[[[int<>]]]] and [[[α131]]] = [α126] because α129 <: [[[α131]]] and α129 :> [α126]
//│  α126 :> [[[[[[[[[true<bool>]]]]]]]]]
//│  α126 <: [[[[[α131]]]]]
//│ unified α127
//│ unified α128
//│  [α128] = [[[[[[[[[true<bool>]]]]]]]]] because α129 :> [α128] and α129 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[int<>]]]] = α129 because α128 :> [[[[int<>]]]] and [α128] = α129 because [[[[[α131]]]]] = [α128] because α126 <: [[[[[α131]]]]] and [α126] | [α128] <: α129 and α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129) and [[[[[[[[[true<bool>]]]]]]]]] = α129 because α126 :> [[[[[[[[[true<bool>]]]]]]]]] and [α126] = α129 because [[[α131]]] = [α126] because α129 <: [[[α131]]] and α129 :> [α126] and α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129)
//│  [α128] = α129 because [[[[[α131]]]]] = [α128] because α126 <: [[[[[α131]]]]] and [α126] | [α128] <: α129 and α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129)
//│  [[[[int<>]]]] = [α128] because [[[[[α131]]]]] = [[[[int<>]]]] because α128 <: [[[[[α131]]]]] and α128 :> [[[[int<>]]]] and [[[[[α131]]]]] = [α128] because α126 <: [[[[[α131]]]]] and [α126] | [α128] <: α129
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α128] because α126 :> [[[[[[[[[true<bool>]]]]]]]]] and [α126] | [α128] <: α129
//│  α128 :> [[[[int<>]]]]
//│  α128 <: [[[[[α131]]]]]
//│ unified α129
//│  [[[[[[[[[true<bool>]]]]]]]]] = α129 because α126 :> [[[[[[[[[true<bool>]]]]]]]]] and [α126] = α129 because [[[α131]]] = [α126] because α129 <: [[[α131]]] and α129 :> [α126] and α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129)
//│  α129 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[int<>]]]] = α129 because α128 :> [[[[int<>]]]] and [α128] = α129 because [[[[[α131]]]]] = [α128] because α126 <: [[[[[α131]]]]] and [α126] | [α128] <: α129 and α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129) and [[[[[[[[[true<bool>]]]]]]]]] = α129 because α126 :> [[[[[[[[[true<bool>]]]]]]]]] and [α126] = α129 because [[[α131]]] = [α126] because α129 <: [[[α131]]] and α129 :> [α126] and α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129)
//│  [[[[int<>]]]] = α129 because α128 :> [[[[int<>]]]] and [α128] = α129 because [[[[[α131]]]]] = [α128] because α126 <: [[[[[α131]]]]] and [α126] | [α128] <: α129 and α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129)
//│  α129 :> [α128]
//│  α129 :> [α126]
//│  α129 <: [[[α131]]]
//│ unified α130
//│  α130 :> [[[(α128 -> α129)]]]
//│  α130 <: [([(int<>,)] -> α131)]
//│ unified α131
//│  α131 = α129 are result type in ([(int<>,)] -> α131) = (α128 -> α129)
//│  [[[[[α131]]]]] = [α128] because α126 <: [[[[[α131]]]]] and [α126] | [α128] <: α129
//│  [[[α131]]] = [α126] because α129 <: [[[α131]]] and α129 :> [α126]
//│  [[[[[α131]]]]] = [[[[int<>]]]] because α128 <: [[[[[α131]]]]] and α128 :> [[[[int<>]]]]
//│  [[[[[α131]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α126 <: [[[[[α131]]]]] and α126 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ res: int | true


