let wrap x = Cons(x, Nil)
//│ wrap: 'a -> list['a]


// *** GOAL ***
// ╔══[WARNING] Type `int` does not match `bool`
// ╟── int ---> int list ---> ?a <--- bool list <--- bool
// ╟── integer literal `int`
// ║  l.101: 	if true then wrap 1 else wrap true
// ║         	                  ^
// ╟── integer literal `int`
// ║  l.101: 	if true then wrap 1 else wrap true
// ║         	                  ^
// ╟── argument `int`
// ║  l.101: 	if true then wrap 1 else wrap true
// ║         	                  ^
// ╟── reference `int`
// ║  l.97: 	let wrap x = Cons(x, Nil)
// ║        	                  ^
// ╟── argument `bool`
// ║  l.101: 	if true then wrap 1 else wrap true
// ║         	                              ^^^^
// ╟── reference `bool`
// ║  l.101: 	if true then wrap 1 else wrap true
// ╙──       	                              ^^^^

// * We don't care about in-and-outs
// ╟── int ---> int list ---> int --> int list ---> ...

:unify
if true then wrap 1 else wrap true
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ╟── this reference has type `bool`
//│ ║  l.31: 	if true then wrap 1 else wrap true
//│ ║        	                              ^^^^
//│ ╟── this <nested> has type `bool`
//│ ╟── this reference has type `bool`
//│ ║  l.1: 	let wrap x = Cons(x, Nil)
//│ ║       	                  ^
//│ ╟── this variable has type `bool`
//│ ║  l.1: 	let wrap x = Cons(x, Nil)
//│ ║       	         ^
//│ ╟── this variable has type `int`
//│ ║  l.1: 	let wrap x = Cons(x, Nil)
//│ ║       	         ^
//│ ╟── this reference has type `int`
//│ ║  l.1: 	let wrap x = Cons(x, Nil)
//│ ║       	                  ^
//│ ╟── this <nested> has type `int`
//│ ╟── this integer literal has type `int`
//│ ║  l.31: 	if true then wrap 1 else wrap true
//│ ╙──      	                  ^
//│ res: list[bool | int]


:unify
if true then wrap (if true then 1 else false) else wrap true
//│ res: list[bool | int]


:unify
let test z = if true then wrap z else wrap true
//│ test: 'a -> list[bool | 'a]


:unify
let rec t = test (if true then 1 else t)
//│ ╔══[ERROR] Type `int` does not match `?a list`
//│ ║  
//│ ╟── this `then` branch has type `int`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	                               ^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	                                      ^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this <nested> has type `?a list`
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.64: 	let test z = if true then wrap z else wrap true
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.64: 	let test z = if true then wrap z else wrap true
//│ ║        	                                      ^^^^^^^^^
//│ ╟── this <nested> has type `?a list`
//│ ╟── this application has type `?a list`
//│ ║  l.1: 	let wrap x = Cons(x, Nil)
//│ ║       	             ^^^^^^^^^^^^
//│ ╟── this <nested> has type `?a list`
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin:1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──           	     ^^^^^^^
//│ ╔══[ERROR] Type `int` does not match `?a list`
//│ ║  
//│ ╟── this `then` branch has type `int`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	                               ^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	                                      ^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.69: 	let rec t = test (if true then 1 else t)
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this <nested> has type `?a list`
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.64: 	let test z = if true then wrap z else wrap true
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a list`
//│ ║  l.64: 	let test z = if true then wrap z else wrap true
//│ ║        	                          ^^^^^^
//│ ╟── this <nested> has type `?a list`
//│ ╟── this application has type `?a list`
//│ ║  l.1: 	let wrap x = Cons(x, Nil)
//│ ║       	             ^^^^^^^^^^^^
//│ ╟── this <nested> has type `?a list`
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin:1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──           	     ^^^^^^^
//│ t: 't
//│   where
//│     't :> list[bool | int | 't]




let wrap x = not x
//│ wrap: bool -> bool

:unify
let test z = wrap z
//│ test: bool -> bool

// TODO fix flow
:ex
test 1
//│ res: bool



:unify
let clone x n =
  let rec helper acc n' =
    if acc <= 0 then acc else helper (acc + 1) (n' - 1) in
  helper x (n - 1)
//│ clone: int -> int -> int


:e
:unify
let rec digitsOfInt n =
  ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[ERROR] Type `error` does not match `error`
//│ ║  
//│ ╟── this expression has type `error`
//│ ╟── this reference has type `error`
//│ ║  l.166: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                            ^^^^^^^^^
//│ ╟── this <nested> has type `error`
//│ ╟── this <nested> has type `error`
//│ ╟── this reference has type `error`
//│ ║  l.166: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                            ^^^^^^^^^
//│ ╙── this expression has type `error`
//│ ╔══[ERROR] identifier not found: remainder
//│ ║  
//│ ║  l.166: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                            ^^^^^^^^^
//│ digitsOfInt: anything -> list[error]
