:OcamlParser
:OcamlLoadLibrary


type Bool = True | False
//│ Defined type alias Bool
//│ Defined class True
//│ Defined class False
//│ True: Bool
//│ False: Bool

:unifyDbg
let test x =
  match x with True -> 0 | False -> 1
//│ unified α64'
//│  α64' <: [[((true<> & α65') | ((false<> & α66') & ~(true<>)))]]
//│ unified α65'
//│ unified α66'
//│ unified α67'
//│  α67' :> Int
//│ test: bool -> int

:unifyDbg
let test x =
  match x with True -> 0 | False -> "oops"
//│ [ERROR 1] Int != String unifying because Int | String <: α75'
//│ allVarPols: +α80'
//│ norm[+] α80'
//│ | DNF: DNF(α80')
//│ | norm[+] Int
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] String
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ ~> α80'
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and string cannot be unified but flows into the same location
//│ ╟── int is used as integer literal
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                       ^
//│ ╟── string is used as string literal
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                                    ^^^^^^
//│ ╟── The following tvars cannot be resolved α75'
//│ ╟── ?a is used as `case` expression
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ╙──      	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ unified α72'
//│  α72' <: [[((true<> & α73') | ((false<> & α74') & ~(true<>)))]]
//│ unified α73'
//│ unified α74'
//│ unified α75'
//│  α75' :> String
//│  α75' :> Int
//│ test: bool -> (int | string)



:unifyDbg
let temp x = if x then 0 else "oops"
//│ [ERROR 1] Int != String unifying because Int | String <: α84'
//│ allVarPols: +α89'
//│ norm[+] α89'
//│ | DNF: DNF(α89')
//│ | norm[+] Int
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] String
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ ~> α89'
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and string cannot be unified but flows into the same location
//│ ╟── int is used as integer literal
//│ ║  l.76: 	let temp x = if x then 0 else "oops"
//│ ║        	                       ^
//│ ╟── string is used as string literal
//│ ║  l.76: 	let temp x = if x then 0 else "oops"
//│ ║        	                              ^^^^^^
//│ ╟── The following tvars cannot be resolved α84'
//│ ╟── ?a is used as `case` expression
//│ ║  l.76: 	let temp x = if x then 0 else "oops"
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^^
//│ unified α81'
//│  α81' <: [[((true<bool> & α82') | (α83' & ~(true<bool>)))]]
//│ unified α82'
//│ unified α83'
//│ unified α84'
//│  α84' :> String
//│  α84' :> Int
//│ temp: anything -> (int | string)


let temp x y z = if x then y else z
//│ temp: anything -> 'a -> 'a -> 'a

temp true 1 2
//│ res: int

:unifyDbg
temp true 1 "oops"
//│ [ERROR 0] ((true<bool> & α115) | (α116 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α115) | (α116 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α114 <: [[((true<bool> & α115) | (α116 & ~(true<bool>)))]] and α114 :> [[[[[[true<bool>]]]]]]
//│ allVarPols: +α116, +α124
//│ norm[+] [[((true<bool> & α124) | (α116 & ~(true<bool>)))]]
//│ | DNF: DNF(true<bool>{}∧α124 | α116∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | factorize? true<bool> & α124 | α116 & ~(true<bool>)
//│ | | Factors α116 -> 1, α124 -> 1
//│ | yes: ((true<bool> & α124) | (α116 & ~(true<bool>)))
//│ ~> ((true<bool> & α124) | (α116 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] [[[[[[true<bool>]]]]]]
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: +α116, +α125
//│ norm[+] ((true<bool> & α125) | (α116 & ~(true<bool>)))
//│ | DNF: DNF(true<bool>{}∧α125 | α116∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | factorize? true<bool> & α125 | α116 & ~(true<bool>)
//│ | | Factors α116 -> 1, α125 -> 1
//│ | yes: ((true<bool> & α125) | (α116 & ~(true<bool>)))
//│ ~> ((true<bool> & α125) | (α116 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] true & ?a | ?b & ~true and true cannot be unified but flows into the same location
//│ ╟── true & ?c | ?b & ~true is used as reference
//│ ║  l.125: 	let temp x y z = if x then y else z
//│ ║         	                    ^
//│ ╟── true is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ╙──       	     ^^^^
//│ [ERROR 1] Int != String unifying because [[[[Int]]]] = [[[[String]]]] because [[[[[α122]]]]] = [[[[Int]]]] because α117 <: [[[[[α122]]]]] and α117 :> [[[[Int]]]] and [[[[[α122]]]]] = [[[[String]]]] because α118 <: [[[[[α122]]]]] and α118 :> [[[[String]]]]
//│ allVarPols: +α126
//│ norm[+] α126
//│ | DNF: DNF(α126)
//│ | norm[+] [[[[[[[[String]]]]]]]]
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ ~> α126
//│ allVarPols: +α127
//│ norm[+] α127
//│ | DNF: DNF(α127)
//│ | norm[+] [[[[[[[[String]]]]]]]]
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ ~> α127
//│ allVarPols: 
//│ norm[+] [[[[Int]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] [[[[String]]]]
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and string cannot be unified but flows into the same location
//│ ╟── int is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ║         	          ^
//│ ╟── string is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ║         	            ^^^^^^
//│ ╟── The following tvars cannot be resolved [[[[[α122]]]]]
//│ ╟── ?a is used as reference
//│ ║  l.125: 	let temp x y z = if x then y else z
//│ ║         	                           ^
//│ ╟── ?b is used as application
//│ ║  l.132: 	temp true 1 "oops"
//│ ╙──       	^^^^^^^^^^^^^^^^^^
//│ [ERROR 1] String != Int unifying because [[[[String]]]] = [[[[Int]]]] because α118 :> [[[[String]]]] and [[[[Int]]]] = [α118] because α117 :> [[[[Int]]]] and [α117] | [α118] <: α119
//│ allVarPols: +α128, +α129, +α131
//│ norm[+] α128
//│ | DNF: DNF(α128)
//│ | norm[+] [α129]
//│ | | DNF: DNF(α129)
//│ | | norm[+] [[[[Int]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[-] [[[[[α130]]]]]
//│ | | | DNF: DNF(α130)
//│ | | | norm[+] [[[[[[[[String]]]]]]]]
//│ | | | | DNF: DNF(string<>{})
//│ | | | ~> string<>
//│ | | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | | DNF: DNF(int<>{})
//│ | | | ~> int<>
//│ | | ~> α130
//│ | ~> α129
//│ | norm[+] [α131]
//│ | | DNF: DNF(α131)
//│ | | norm[+] [[[[String]]]]
//│ | | | DNF: DNF(string<>{})
//│ | | ~> string<>
//│ | | norm[-] [[[[[α130]]]]]
//│ | | | DNF: DNF(α130)
//│ | | ~> α130
//│ | ~> α131
//│ | norm[-] [[[α130]]]
//│ | | DNF: DNF(α130)
//│ | ~> α130
//│ ~> α128
//│ allVarPols: 
//│ norm[+] [[[[String]]]]
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] [[[[Int]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] string and int cannot be unified but flows into the same location
//│ ╟── string is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ║         	            ^^^^^^
//│ ╟── int is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ║         	          ^
//│ ╟── The following tvars cannot be resolved α119
//│ ╟── ?a is used as `case` expression
//│ ║  l.125: 	let temp x y z = if x then y else z
//│ ╙──       	                    ^^^^^^^^^^^^^^^
//│ unified α114
//│  α114 :> [[[[[[true<bool>]]]]]]
//│  α114 <: [[((true<bool> & α115) | (α116 & ~(true<bool>)))]]
//│ unified α115
//│  α115 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ unified α116
//│ unified α117
//│  [α117] | [α118] <: α119
//│  [[[[Int]]]] = [α117] because [[[[[α122]]]]] = [[[[Int]]]] because α117 <: [[[[[α122]]]]] and α117 :> [[[[Int]]]] and [[[α122]]] = [α117] because α119 <: [[[α122]]] and α119 :> [α117]
//│  [[[[String]]]] = [α117] because [[[[[α122]]]]] = [[[[String]]]] because α118 <: [[[[[α122]]]]] and α118 :> [[[[String]]]] and [[[α122]]] = [α117] because α119 <: [[[α122]]] and α119 :> [α117]
//│  α117 :> [[[[Int]]]]
//│  α117 <: [[[[[α122]]]]]
//│ unified α118
//│  [[[[String]]]] = [α118] because [[[[[α122]]]]] = [[[[String]]]] because α118 <: [[[[[α122]]]]] and α118 :> [[[[String]]]] and [[[[[α122]]]]] = [α118] because α117 <: [[[[[α122]]]]] and [α117] | [α118] <: α119
//│  [[[[Int]]]] = [α118] because α117 :> [[[[Int]]]] and [α117] | [α118] <: α119
//│  α118 :> [[[[String]]]]
//│  α118 <: [[[[[α122]]]]]
//│ unified α119
//│  α119 :> [α118]
//│  α119 :> [α117]
//│  α119 <: [[[α122]]]
//│ unified α120
//│  α120 :> [[[(α117 -> (α118 -> α119))]]]
//│  α120 <: [([(Int,)] -> α121)]
//│ unified α121
//│  α121 <: [([(String,)] -> α122)]
//│  α121 = (α118 -> α119) are result type in ([(Int,)] -> α121) = (α117 -> (α118 -> α119))
//│ unified α122
//│  [[[[[α122]]]]] = [α118] because α117 <: [[[[[α122]]]]] and [α117] | [α118] <: α119
//│  [[[α122]]] = [α117] because α119 <: [[[α122]]] and α119 :> [α117]
//│  [[[[[α122]]]]] = [[[[String]]]] because α118 <: [[[[[α122]]]]] and α118 :> [[[[String]]]]
//│  [[[[[α122]]]]] = [[[[Int]]]] because α117 <: [[[[[α122]]]]] and α117 :> [[[[Int]]]]
//│ res: int | string


let temp x y = if x then x else y
//│ temp: (true & 'a | ~true) -> 'a -> 'a

:unifyDbg
temp true 1
//│ [ERROR 0] ((true<bool> & α145) | (α146 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α145) | (α146 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α144 <: [[((true<bool> & α145) | (α146 & ~(true<bool>)))]] and α144 :> [[[[[[true<bool>]]]]]]
//│ allVarPols: +α146, +α152
//│ norm[+] [[((true<bool> & α152) | (α146 & ~(true<bool>)))]]
//│ | DNF: DNF(true<bool>{}∧α152 | α146∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | norm[-] [[[[[α153]]]]]
//│ | | DNF: DNF(α153)
//│ | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | | DNF: DNF(true<bool>{})
//│ | | ~> true<bool>
//│ | ~> α153
//│ | factorize? true<bool> & α152 | α146 & ~(true<bool>)
//│ | | Factors α146 -> 1, α152 -> 1
//│ | yes: ((true<bool> & α152) | (α146 & ~(true<bool>)))
//│ ~> ((true<bool> & α152) | (α146 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] [[[[[[true<bool>]]]]]]
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: +α146, +α154
//│ norm[+] ((true<bool> & α154) | (α146 & ~(true<bool>)))
//│ | DNF: DNF(true<bool>{}∧α154 | α146∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | norm[-] [[[[[α155]]]]]
//│ | | DNF: DNF(α155)
//│ | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | | DNF: DNF(true<bool>{})
//│ | | ~> true<bool>
//│ | ~> α155
//│ | factorize? true<bool> & α154 | α146 & ~(true<bool>)
//│ | | Factors α146 -> 1, α154 -> 1
//│ | yes: ((true<bool> & α154) | (α146 & ~(true<bool>)))
//│ ~> ((true<bool> & α154) | (α146 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] true & ?a | ?b & ~true and true cannot be unified but flows into the same location
//│ ╟── true & ?c | ?b & ~true is used as reference
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true is used as argument
//│ ║  l.318: 	temp true 1
//│ ╙──       	     ^^^^
//│ [ERROR 1] true<bool> != Int unifying because [[[[[[[[[true<bool>]]]]]]]]] = [[[[Int]]]] because [[[[[α150]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α145 <: [[[[[α150]]]]] and α145 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[[[α150]]]]] = [[[[Int]]]] because α147 <: [[[[[α150]]]]] and α147 :> [[[[Int]]]]
//│ allVarPols: +α156
//│ norm[+] α156
//│ | DNF: DNF(α156)
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ ~> α156
//│ allVarPols: +α157
//│ norm[+] α157
//│ | DNF: DNF(α157)
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ ~> α157
//│ allVarPols: 
//│ norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] [[[[Int]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] true and int cannot be unified but flows into the same location
//│ ╟── true is used as reference
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true is used as reference
//│ ║  l.318: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── int is used as argument
//│ ║  l.318: 	temp true 1
//│ ║         	          ^
//│ ╟── The following tvars cannot be resolved [[[[[α150]]]]]
//│ ╟── ?a is used as refined scrutinee
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── ?b is used as application
//│ ║  l.318: 	temp true 1
//│ ╙──       	^^^^^^^^^^^
//│ [ERROR 1] Int != true<bool> unifying because [[[[Int]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α147 :> [[[[Int]]]] and [[[[[[[[[true<bool>]]]]]]]]] = [α147] because α145 :> [[[[[[[[[true<bool>]]]]]]]]] and [α145] | [α147] <: α148
//│ allVarPols: +α158, +α159, +α161
//│ norm[+] α158
//│ | DNF: DNF(α158)
//│ | norm[+] [α159]
//│ | | DNF: DNF(α159)
//│ | | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | | DNF: DNF(true<bool>{})
//│ | | ~> true<bool>
//│ | | norm[-] [[[[[α160]]]]]
//│ | | | DNF: DNF(α160)
//│ | | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | | DNF: DNF(int<>{})
//│ | | | ~> int<>
//│ | | | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | | | DNF: DNF(true<bool>{})
//│ | | | ~> true<bool>
//│ | | ~> α160
//│ | ~> α159
//│ | norm[+] [α161]
//│ | | DNF: DNF(α161)
//│ | | norm[+] [[[[Int]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[-] [[[[[α160]]]]]
//│ | | | DNF: DNF(α160)
//│ | | ~> α160
//│ | ~> α161
//│ | norm[-] [[[α160]]]
//│ | | DNF: DNF(α160)
//│ | ~> α160
//│ ~> α158
//│ allVarPols: 
//│ norm[+] [[[[Int]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and true cannot be unified but flows into the same location
//│ ╟── int is used as argument
//│ ║  l.318: 	temp true 1
//│ ║         	          ^
//│ ╟── true is used as reference
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true is used as reference
//│ ║  l.318: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── The following tvars cannot be resolved α148
//│ ╟── ?a is used as `case` expression
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ╙──       	                  ^^^^^^^^^^^^^^^
//│ unified α144
//│  α144 :> [[[[[[true<bool>]]]]]]
//│  α144 <: [[((true<bool> & α145) | (α146 & ~(true<bool>)))]]
//│ unified α145
//│  [α145] = α148 because [[[α150]]] = [α145] because α148 <: [[[α150]]] and α148 :> [α145] and α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148)
//│  [α145] = [[[[Int]]]] because α148 :> [α145] and [[[[Int]]]] = α148 because α147 :> [[[[Int]]]] and [α147] = α148 because [[[[[α150]]]]] = [α147] because α145 <: [[[[[α150]]]]] and [α145] | [α147] <: α148 and α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148)
//│  [α145] | [α147] <: α148
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α145] because [[[[[α150]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α145 <: [[[[[α150]]]]] and α145 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[α150]]] = [α145] because α148 <: [[[α150]]] and α148 :> [α145]
//│  [[[[Int]]]] = [α145] because [[[[[α150]]]]] = [[[[Int]]]] because α147 <: [[[[[α150]]]]] and α147 :> [[[[Int]]]] and [[[α150]]] = [α145] because α148 <: [[[α150]]] and α148 :> [α145]
//│  α145 :> [[[[[[[[[true<bool>]]]]]]]]]
//│  α145 <: [[[[[α150]]]]]
//│ unified α146
//│ unified α147
//│  [α147] = [[[[[[[[[true<bool>]]]]]]]]] because α148 :> [α147] and α148 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[Int]]]] = α148 because α147 :> [[[[Int]]]] and [α147] = α148 because [[[[[α150]]]]] = [α147] because α145 <: [[[[[α150]]]]] and [α145] | [α147] <: α148 and α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148) and [[[[[[[[[true<bool>]]]]]]]]] = α148 because α145 :> [[[[[[[[[true<bool>]]]]]]]]] and [α145] = α148 because [[[α150]]] = [α145] because α148 <: [[[α150]]] and α148 :> [α145] and α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148)
//│  [α147] = α148 because [[[[[α150]]]]] = [α147] because α145 <: [[[[[α150]]]]] and [α145] | [α147] <: α148 and α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148)
//│  [[[[Int]]]] = [α147] because [[[[[α150]]]]] = [[[[Int]]]] because α147 <: [[[[[α150]]]]] and α147 :> [[[[Int]]]] and [[[[[α150]]]]] = [α147] because α145 <: [[[[[α150]]]]] and [α145] | [α147] <: α148
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α147] because α145 :> [[[[[[[[[true<bool>]]]]]]]]] and [α145] | [α147] <: α148
//│  α147 :> [[[[Int]]]]
//│  α147 <: [[[[[α150]]]]]
//│ unified α148
//│  [[[[[[[[[true<bool>]]]]]]]]] = α148 because α145 :> [[[[[[[[[true<bool>]]]]]]]]] and [α145] = α148 because [[[α150]]] = [α145] because α148 <: [[[α150]]] and α148 :> [α145] and α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148)
//│  α148 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[Int]]]] = α148 because α147 :> [[[[Int]]]] and [α147] = α148 because [[[[[α150]]]]] = [α147] because α145 <: [[[[[α150]]]]] and [α145] | [α147] <: α148 and α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148) and [[[[[[[[[true<bool>]]]]]]]]] = α148 because α145 :> [[[[[[[[[true<bool>]]]]]]]]] and [α145] = α148 because [[[α150]]] = [α145] because α148 <: [[[α150]]] and α148 :> [α145] and α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148)
//│  [[[[Int]]]] = α148 because α147 :> [[[[Int]]]] and [α147] = α148 because [[[[[α150]]]]] = [α147] because α145 <: [[[[[α150]]]]] and [α145] | [α147] <: α148 and α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148)
//│  α148 :> [α147]
//│  α148 :> [α145]
//│  α148 <: [[[α150]]]
//│ unified α149
//│  α149 :> [[[(α147 -> α148)]]]
//│  α149 <: [([(Int,)] -> α150)]
//│ unified α150
//│  α150 = α148 are result type in ([(Int,)] -> α150) = (α147 -> α148)
//│  [[[[[α150]]]]] = [α147] because α145 <: [[[[[α150]]]]] and [α145] | [α147] <: α148
//│  [[[α150]]] = [α145] because α148 <: [[[α150]]] and α148 :> [α145]
//│  [[[[[α150]]]]] = [[[[Int]]]] because α147 <: [[[[[α150]]]]] and α147 :> [[[[Int]]]]
//│  [[[[[α150]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α145 <: [[[[[α150]]]]] and α145 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ res: int | true



let addF x f arg = x + f arg
//│ addF: int -> ('a -> int) -> 'a -> int

:unify
let rec findOddAndAddThem xs = match xs with
  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
  | [] -> 0
//│ ╔══[WARNING] [UNIFICATION ERROR 1] {_1: ?a} and {_0: ?b} cannot be unified but flows into the same location
//│ ╟── {_1: ?c} is used as refined scrutinee
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── {_0: ?d} is used as refined scrutinee
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── The following tvars cannot be resolved α177'
//│ ╟── ?e is used as refined scrutinee
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] Cons[?] & ?a | Nil & ?b and int cannot be unified but flows into the same location
//│ ╟── Cons[?] & ?c | Nil & ?b is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── int is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── int is used as type reference
//│ ║  l.21: 	let mod: int -> int -> int
//│ ║        	         ^^^
//│ ╟── The following tvars cannot be resolved α181'
//│ ╟── ?d is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.30: 	let (==): 'a -> 'a -> bool
//│ ║        	                      ^^^^
//│ ╟── true | ?b & ~true is used as operator application
//│ ║  l.541: 	  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
//│ ╙──       	                   ^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and Cons[?] & ?a | Nil & ?b cannot be unified but flows into the same location
//│ ╟── int is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── int is used as type reference
//│ ║  l.21: 	let mod: int -> int -> int
//│ ║        	         ^^^
//│ ╟── Cons[?] & ?c | Nil & ?b is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── The following tvars cannot be resolved α181'
//│ ╟── ?d is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ findOddAndAddThem: 'a -> int
//│   where
//│     'a <: (Cons[?] with {_0: int, _1: int & 'a}) | Nil
