:OcamlParser
:OcamlLoadLibrary


let wrap x = Cons(x, Nil)
//│ wrap: 'a -> list['a]


// *** GOAL ***
// ╔══[WARNING] Type `int` does not match `bool`
// ╟── int ---> int list ---> ?a <--- bool list <--- bool
// ╟── integer literal `int`
// ║  l.101: 	if true then wrap 1 else wrap true
// ║         	                  ^
// ╟── integer literal `int`
// ║  l.101: 	if true then wrap 1 else wrap true
// ║         	                  ^
// ╟── argument `int`
// ║  l.101: 	if true then wrap 1 else wrap true
// ║         	                  ^
// ╟── reference `int`
// ║  l.97: 	let wrap x = Cons(x, Nil)
// ║        	                  ^
// ╟── argument `bool`
// ║  l.101: 	if true then wrap 1 else wrap true
// ║         	                              ^^^^
// ╟── reference `bool`
// ║  l.101: 	if true then wrap 1 else wrap true
// ╙──       	                              ^^^^

// * We don't care about in-and-outs
// ╟── int ---> int list ---> int --> int list ---> ...

:unify
if true then wrap 1 else wrap true
//│ ╔══[ERROR] Cannot unify bool and int
//│ ╟──        bool ---> ?a <--- int 
//│ ╟── ?a is the type of variable; bool flows here
//│ ║  l.5: 	let wrap x = Cons(x, Nil)
//│ ║       	         ^
//│ ╟── int is the type of integer literal; ?a flows here
//│ ║  l.35: 	if true then wrap 1 else wrap true
//│ ╙──      	                  ^
//│ res: list[bool | int]


:unify
if true then wrap (if true then 1 else false) else wrap true
//│ ╔══[ERROR] Cannot unify int and bool
//│ ╟──        int ---> ?a <--- bool 
//│ ╟── int is the type of `then` branch
//│ ║  l.48: 	if true then wrap (if true then 1 else false) else wrap true
//│ ║        	                                ^
//│ ╟── ?a is the type of if-then-else `expression`; int flows here
//│ ║  l.48: 	if true then wrap (if true then 1 else false) else wrap true
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── bool is the type of `else` branch; ?a flows here
//│ ║  l.48: 	if true then wrap (if true then 1 else false) else wrap true
//│ ╙──      	                                       ^^^^^
//│ ╔══[ERROR] Cannot unify bool and int
//│ ╟──        bool ---> ?a <--- int 
//│ ╟── ?a is the type of variable; bool flows here
//│ ║  l.5: 	let wrap x = Cons(x, Nil)
//│ ╙──     	         ^
//│ ╔══[ERROR] Cannot unify bool and int
//│ ╟──        bool ---> ?a <--- int 
//│ ╟── ?a is the type of variable; bool flows here
//│ ║  l.5: 	let wrap x = Cons(x, Nil)
//│ ║       	         ^
//│ ╟── int is the type of if-then-else `expression`; ?a flows here
//│ ║  l.48: 	if true then wrap (if true then 1 else false) else wrap true
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── int is the type of `then` branch
//│ ║  l.48: 	if true then wrap (if true then 1 else false) else wrap true
//│ ╙──      	                                ^
//│ res: list[bool | int]


:unify
let test z = if true then wrap z else wrap true
//│ test: 'a -> list[bool | 'a]


:unify
let rec t = test (if true then 1 else t)
//│ ╔══[ERROR] Cannot unify int and bool
//│ ╟──        int ---> ?a <--- bool 
//│ ╟── ?a is the type of variable; int flows here
//│ ║  l.5: 	let wrap x = Cons(x, Nil)
//│ ║       	         ^
//│ ╟── bool is the type of reference; ?a flows here
//│ ║  l.80: 	let test z = if true then wrap z else wrap true
//│ ╙──      	                                           ^^^^
//│ t: 't
//│   where
//│     't :> list[bool | int | 't]




let wrap x = not x
//│ wrap: bool -> bool

:unify
let test z = wrap z
//│ test: bool -> bool

// TODO fix flow
:ex
test 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.110: 	test 1
//│ ║         	^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `bool`
//│ ║  l.110: 	test 1
//│ ║         	     ^
//│ ╟── Note: constraint arises from variable:
//│ ║  l.105: 	let test z = wrap z
//│ ║         	         ^
//│ ╟── from type reference:
//│ ║  l.56: 	let not: bool -> bool
//│ ║        	         ^^^^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from integer literal of type `int`
//│ ║  l.110: 	test 1
//│ ║         	     ^
//│ ╟── [info] flowing from <nested> of type `int`
//│ ╟── [info] flowing into type `bool`
//│ ║  l.56: 	let not: bool -> bool
//│ ║        	         ^^^^
//│ ╟── [info] flowing into type `bool`
//│ ║  l.56: 	let not: bool -> bool
//│ ║        	         ^^^^
//│ ╟── [info] flowing into <nested> of type `bool`
//│ ╟── [info] flowing into reference of type `bool`
//│ ║  l.101: 	let wrap x = not x
//│ ║         	                 ^
//│ ╟── [info] flowing into variable of type `bool`
//│ ║  l.101: 	let wrap x = not x
//│ ║         	         ^
//│ ╟── [info] flowing into variable of type `?a`
//│ ║  l.101: 	let wrap x = not x
//│ ║         	         ^
//│ ╟── [info] flowing into variable of type `?a`
//│ ║  l.101: 	let wrap x = not x
//│ ║         	         ^
//│ ╟── [info] flowing into <nested> of type `?a`
//│ ╟── [info] flowing into reference of type `?a`
//│ ║  l.105: 	let test z = wrap z
//│ ║         	                  ^
//│ ╟── [info] flowing into variable of type `?b`
//│ ║  l.105: 	let test z = wrap z
//│ ╙──       	         ^
//│ res: bool



:unify
let clone x n =
  let rec helper acc n' =
    if acc <= 0 then acc else helper (acc + 1) (n' - 1) in
  helper x (n - 1)
//│ clone: int -> int -> int



:unify
let rec digitsOfInt n =
  ((digitsOfInt n) / 10) @ [remainder];;
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.169: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `?a list`
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `?a list`
//│ ║  l.169: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──      	         ^^^^^^^
//│ ╔══[ERROR] Cannot unify int and ?a list
//│ ╟── int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── int is here
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── int is the type of operator application
//│ ║  l.169: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── list[?a] -> list[?a] -> list[?a] is the type of reference
//│ ║  l.169: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	                         ^
//│ ╟── list[?a] -> list[?a] -> list[?a] is here
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ?a list is here
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──      	         ^^^^^^^
//│ ╔══[ERROR] identifier not found: remainder
//│ ║  l.169: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──       	                            ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.168: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.169: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `?a list` is not an instance of `int`
//│ ║  l.37: 	let (@): 'a list -> 'a list -> 'a list
//│ ║        	                               ^^^^^^^
//│ ╟── but it flows into operator application with expected type `int`
//│ ║  l.169: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.169: 	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ║         	   ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ╙──      	           ^^^
//│ digitsOfInt: anything -> list[error]
