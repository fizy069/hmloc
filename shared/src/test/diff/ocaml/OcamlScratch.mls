:OcamlParser

:dp
type ('a, 'b) either = Left of 'a | Right of 'b
//│ Parsed: TypeDef(Als, TypeName(either), List(TypeName('a), TypeName('b)), Union(AppliedType(TypeName(Right),List(TypeName('b))),Union(AppliedType(TypeName(Left),List(TypeName('a))),AppliedType(TypeName(Left),List(TypeName('a))))), List())
//│ TypeDef(Cls, TypeName(Left), List(TypeName('a)), Record(List((_0,Field(None,TypeName('a))))), List(_0)) of adt: Some((TypeName(either),List(0)))
//│ TypeDef(Cls, TypeName(Right), List(TypeName('b)), Record(List((_0,Field(None,TypeName('b))))), List(_0)) of adt: Some((TypeName(either),List(1)))
//│ Def(false, Left, PolyType(List(TypeName('a), TypeName('b)),Function(Tuple(List((None,Field(None,TypeName('a))))),AppliedType(TypeName(either),List(TypeName('a), TypeName('b))))), true)
//│ Def(false, Right, PolyType(List(TypeName('a), TypeName('b)),Function(Tuple(List((None,Field(None,TypeName('b))))),AppliedType(TypeName(either),List(TypeName('a), TypeName('b))))), true)
//│ Defined type alias either[+'a, +'b]
//│ Defined class Left[+'a]
//│ Defined class Right[+'b]
//│ Left: 'a -> either['a, nothing]
//│ Right: 'a -> either[nothing, 'a]

type Bool = True | False
//│ Defined type alias Bool
//│ Defined class True
//│ Defined class False
//│ True: Bool
//│ False: Bool

:unifyDbg
//let test x =
//  match x with True -> 0 | False -> 1

:unifyDbg
//let test x =
//  match x with True -> 0 | False -> "oops"



:unifyDbg
//let temp x = if x then 0 else "oops"


//let temp x y z = if x then y else z

//temp true 1 2

:unifyDbg
//temp true 1 "oops"


//let temp x y = if x then x else y

:unifyDbg
//temp true 1



//let addF x f arg = x + f arg

:unify
//let rec findOddAndAddThem xs = match xs with
//  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
//  | [] -> 0
