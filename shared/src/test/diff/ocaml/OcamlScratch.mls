:OcamlParser

:d
:dp
type ('a, 'b) either = Left of ('a * 'a) | Right of 'b
//│ Parsed: TypeDef(Als, TypeName(either), List(TypeName('a), TypeName('b)), Union(AppliedType(TypeName(Right),List(TypeName('b))),Union(AppliedType(TypeName(Left),List(TypeName('a))),AppliedType(TypeName(Left),List(TypeName('a))))), List())
//│ TypeDef(Cls, TypeName(Left), List(TypeName('a)), Record(List((_0,Field(None,Tuple(List((None,Field(None,TypeName('a))), (None,Field(None,TypeName('a))))))))), List(_0)) of adt: Some((TypeName(either),List(0)))
//│ TypeDef(Cls, TypeName(Right), List(TypeName('b)), Record(List((_0,Field(None,TypeName('b))))), List(_0)) of adt: Some((TypeName(either),List(1)))
//│ Def(false, Left, PolyType(List(TypeName('a), TypeName('b)),Function(Tuple(List((None,Field(None,Tuple(List((None,Field(None,TypeName('a))), (None,Field(None,TypeName('a))))))))),AppliedType(TypeName(either),List(TypeName('a), TypeName('b))))), true)
//│ Def(false, Right, PolyType(List(TypeName('a), TypeName('b)),Function(Tuple(List((None,Field(None,TypeName('b))))),AppliedType(TypeName(either),List(TypeName('a), TypeName('b))))), true)
//│ 0. Typing type Union(AppliedType(TypeName(Right),List(TypeName('b))),Union(AppliedType(TypeName(Left),List(TypeName('a))),AppliedType(TypeName(Left),List(TypeName('a)))))
//│ | vars=Map('a -> 'a22', 'b -> 'b23') newDefsInfo=Map(either -> (Als,2), Left -> (Cls,1), Right -> (Cls,1))
//│ => (Right['b23'] | (Left['a22'] | Left['a22'])) | 
//│ 0. Typing type Record(List((_0,Field(None,Tuple(List((None,Field(None,TypeName('a))), (None,Field(None,TypeName('a)))))))))
//│ | vars=Map('a -> 'a25') newDefsInfo=Map(either -> (Als,2), Left -> (Cls,1), Right -> (Cls,1))
//│ => {_0: ('a25', 'a25',)} | 
//│ 0. Typing type Record(List((_0,Field(None,TypeName('b)))))
//│ | vars=Map('b -> 'b27') newDefsInfo=Map(either -> (Als,2), Left -> (Cls,1), Right -> (Cls,1))
//│ => {_0: 'b27'} | 
//│ Defined type alias either[+'a, +'b]
//│ Defined class Left[+'a]
//│ Defined class Right[+'b]
//│ 1. Typing type Function(Tuple(List((None,Field(None,Tuple(List((None,Field(None,TypeName('a))), (None,Field(None,TypeName('a))))))))),AppliedType(TypeName(either),List(TypeName('a), TypeName('b))))
//│ | vars=Map('a -> α31', 'b -> α32') newDefsInfo=Map()
//│ => ((α31', α31',) -> either[α31',α32']) | 
//│ ⬤ Typed as: ((α31', α31',) -> either[α31',α32'])
//│  where: 
//│ 1. Typing type Function(Tuple(List((None,Field(None,TypeName('b))))),AppliedType(TypeName(either),List(TypeName('a), TypeName('b))))
//│ | vars=Map('a -> α37', 'b -> α38') newDefsInfo=Map()
//│ => (α38' -> either[α37',α38']) | 
//│ ⬤ Typed as: (α38' -> either[α37',α38'])
//│  where: 
//│ Left: ('a, 'a,) -> either['a, nothing]
//│ Right: 'a -> either[nothing, 'a]

:d
Left
//│ 0. Typing term Left
//│ 0. : ((α43, α43,) -> either[α43,α44])
//│ ⬤ Typed as: ((α43, α43,) -> either[α43,α44])
//│  where: 
//│ res: ('a, 'a,) -> either['a, nothing]

// :d
// :dp
// :unifyDbg
// let test x =
//  match x with True -> 0 | False -> 1

:d
:dp
let text x =
  match x with Left l -> l | Right r -> r
//│ Parsed: Def(false, text, Lam(Tup(_: Var(x)), If(Var(x), List(IfThen(App(Var(Left), Tup(_: Var(l))), Var(l), IfThen(App(Var(Right), Tup(_: Var(r))), Var(r)))), true)
//│ 1. Typing term x, => if x(Left (l,)) then l then (Right (r,)) then r
//│ | 1. Typing pattern x,
//│ | | 1. Typing pattern x
//│ | | 1. : α49'
//│ | 1. : (α49',)
//│ | 1. Typing term if x(Left (l,)) then l then (Right (r,)) then r
//│ | | If(Var(x), List(IfThen(App(Var(Left), Tup(_: Var(l))), Var(l), IfThen(App(Var(Right), Tup(_: Var(r))), Var(r)))
//│ | | ADT name: TypeName(either)
//│ | | ADT type: either['a50','b51']
//│ | | 1. Typing term x
//│ | | 1. : α49'
//│ | | CONSTRAIN α49' <! either['a50','b51']
//│ | |   where 
//│ | | C α49' <! either['a50','b51']    (0) where TypeVariable <: TypeRef}
//│ | | Typing case 0 (Left)
//│ | | ctor type: ((α31', α31',) -> either[α31',α32'])
//│ | | fieldTypes: List((('a50', 'a50',),))
//│ | | Typing field l (0)
//│ | | Field l : (('a50', 'a50',),)
//│ | | 1. Typing term l
//│ | | 1. : (('a50', 'a50',),)
//│ | | CONSTRAIN (('a50', 'a50',),) <! α52'
//│ | |   where 
//│ | | C (('a50', 'a50',),) <! α52'    (0) where TupleType <: TypeVariable}
//│ | | Typing case 1 (Right)
//│ | | ctor type: (α38' -> either[α37',α38'])
//│ | | fieldTypes: List(('b51',))
//│ | | Typing field r (1)
//│ | | Field r : ('b51',)
//│ | | 1. Typing term r
//│ | | 1. : ('b51',)
//│ | | CONSTRAIN ('b51',) <! α52'
//│ | |   where 
//│ 		α52' :> (('a50', 'a50',),)
//│ | | C ('b51',) <! α52'    (0) where TupleType <: TypeVariable}
//│ | 1. : α52'
//│ 1. : (α49' -> α52')
//│ ⬤ Typed as: (α49' -> α52')
//│  where: 
//│ 		α49' <: either['a50','b51']
//│ 		α52' :> ('b51',) | (('a50', 'a50',),)
//│ text: either['a, 'b] -> ('b | ('a, 'a,),)

:d
let f x = let (a, b) = x in a + b
//│ 1. Typing term x, => if x('(' a, b, ')') then + (a,) (b,)
//│ | 1. Typing pattern x,
//│ | | 1. Typing pattern x
//│ | | 1. : α61'
//│ | 1. : (α61',)
//│ | 1. Typing term if x('(' a, b, ')') then + (a,) (b,)
//│ | | If(Var(x), List(IfThen(Bra(rcd = false, Tup(_: Var(a), _: Var(b))), App(App(Var(+), Tup(_: Var(a))), Tup(_: Var(b)))))
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: match case without any arms
//│ 	at: mlscript.utils.package$.lastWords(package.scala:185)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:740)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:823)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:651)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:823)
//│ 	at: mlscript.Typer.typeLetRhs(Typer.scala:418)
//│ 	at: mlscript.DiffTests.$anonfun$new$45(DiffTests.scala:589)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)

:d
:unifyDbg
if 1 == 2 then Left true else Right false
//│ 0. Typing term if == (1,) (2,)(True) then Left (true,) then (False) then Right (false,)
//│ | If(App(App(Var(==), Tup(_: IntLit(1))), Tup(_: IntLit(2))), List(IfThen(Var(True), App(Var(Left), Tup(_: Var(true))), IfThen(Var(False), App(Var(Right), Tup(_: Var(false)))))
//│ | 0. Typing term == (1,) (2,)
//│ | | 0. Typing term == (1,)
//│ | | | 0. Typing term ==
//│ | | | 0. : (int<> -> (int<> -> bool<>))
//│ | | | 0. Typing term 1,
//│ | | | | 0. Typing term 1
//│ | | | | 0. : Int
//│ | | | 0. : (Int,)
//│ | | | CONSTRAIN (int<> -> (int<> -> bool<>)) <! (Int -> α62)
//│ | | |   where 
//│ | | | C (int<> -> (int<> -> bool<>)) <! (Int -> α62)    (0) where FunctionType <: FunctionType}
//│ | | | | C (Int,) <! (int<>,)    (1) where TupleType <: TupleType}
//│ | | | | | C Int <! int<>    (2) where TypeRef <: ClassTag}
//│ | | | | | | C int<> <! int<>    (3) where ClassTag <: ClassTag}
//│ | | | | C (int<> -> bool<>) <! α62    (3) where FunctionType <: TypeVariable}
//│ | | 0. : α62
//│ | | 0. Typing term 2,
//│ | | | 0. Typing term 2
//│ | | | 0. : Int
//│ | | 0. : (Int,)
//│ | | CONSTRAIN α62 <! (Int -> α63)
//│ | |   where 
//│ 		α62 :> (int<> -> bool<>)
//│ | | C α62 <! (Int -> α63)    (0) where TypeVariable <: FunctionType}
//│ | | | C (int<> -> bool<>) <! (Int -> α63)    (1) where FunctionType <: FunctionType}
//│ | | | | C (Int,) <! (int<>,)    (2) where TupleType <: TupleType}
//│ | | | | | C Int <! int<>    (3) where TypeRef <: ClassTag}
//│ | | | | | | C int<> <! int<>    (4) where ClassTag <: ClassTag}
//│ | | | | C bool<> <! α63    (4) where ClassTag <: TypeVariable}
//│ | 0. : α63
//│ | CONSTRAIN α63 <! bool<>
//│ |   where 
//│ 		α63 :> bool<>
//│ | C α63 <! bool<>    (0) where TypeVariable <: ClassTag}
//│ | | C bool<> <! bool<>    (1) where ClassTag <: ClassTag}
//│ | 0. Typing term Left (true,)
//│ | | 0. Typing term Left
//│ | | 0. : ((α65, α65,) -> either[α65,α66])
//│ | | 0. Typing term true,
//│ | | | 0. Typing term true
//│ | | | 0. : true<bool>
//│ | | 0. : (true<bool>,)
//│ | | CONSTRAIN ((α65, α65,) -> either[α65,α66]) <! (true<bool> -> α67)
//│ | |   where 
//│ | | C ((α65, α65,) -> either[α65,α66]) <! (true<bool> -> α67)    (0) where FunctionType <: FunctionType}
//│ | | | C (true<bool>,) <! ((α65, α65,),)    (1) where TupleType <: TupleType}
//│ | | | | C true<bool> <! (α65, α65,)    (2) where ClassTag <: TupleType}
//│ | | | | | allVarPols: 
//│ | | | | | norm[+] true<bool>
//│ | | | | | | DNF: DNF(true<bool>{})
//│ | | | | | ~> true<bool>
//│ | | | C either[α65,α66] <! α67    (3) where TypeRef <: TypeVariable}
//│ | 0. : α67
//│ | CONSTRAIN α67 <! α64
//│ |   where 
//│ 		α67 :> either[α65,α66]
//│ | C α67 <! α64    (0) where TypeVariable <: TypeVariable}
//│ | | C either[α65,α66] <! α64    (1) where TypeRef <: TypeVariable}
//│ | 0. Typing term Right (false,)
//│ | | 0. Typing term Right
//│ | | 0. : (α68 -> either[α69,α68])
//│ | | 0. Typing term false,
//│ | | | 0. Typing term false
//│ | | | 0. : false<bool>
//│ | | 0. : (false<bool>,)
//│ | | CONSTRAIN (α68 -> either[α69,α68]) <! (false<bool> -> α70)
//│ | |   where 
//│ | | C (α68 -> either[α69,α68]) <! (false<bool> -> α70)    (0) where FunctionType <: FunctionType}
//│ | | | C (false<bool>,) <! (α68,)    (1) where TupleType <: TupleType}
//│ | | | | C false<bool> <! α68    (2) where ClassTag <: TypeVariable}
//│ | | | C either[α69,α68] <! α70    (3) where TypeRef <: TypeVariable}
//│ | 0. : α70
//│ | CONSTRAIN α70 <! α64
//│ |   where 
//│ 		α64 :> either[α65,α66]
//│ 		α68 :> false<bool>
//│ 		α70 :> either[α69,α68]
//│ | C α70 <! α64    (0) where TypeVariable <: TypeVariable}
//│ | | C either[α69,α68] <! α64    (1) where TypeRef <: TypeVariable}
//│ 0. : α64
//│ ⬤ Typed as: α64
//│  where: 
//│ 		α64 :> either[α69,α68] | either[α65,α66]
//│ 		α68 :> false<bool>
//│ [ERROR 0] Int != int<> unifying because Int = int<> are arg type in (Int -> α63) = (int<> -> bool<>)
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] int<>
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] int and int cannot be unified but flows into the same location
//│ ╟── Int is here
//│ ║  l.126: 	if 1 == 2 then Left true else Right false
//│ ╙──       	        ^
//│ unified α62
//│  α62 :> (int<> -> bool<>)
//│  α62 <: (Int -> α63)
//│ unified α63
//│  α63 = bool<> are result type in (Int -> α63) = (int<> -> bool<>)
//│ unified α64
//│  α64 :> either[α65,α66]
//│  α64 :> either[α69,α68]
//│ unified α65
//│ unified α66
//│  α66 = false<bool> because α68 = α66 are TypeName(either)(1) arg type and α68 :> false<bool>
//│ unified α67
//│  α67 :> either[α65,α66]
//│  α67 <: α64
//│ unified α68
//│  α68 :> false<bool>
//│  α68 = α66 are TypeName(either)(1) arg type
//│ unified α69
//│  α69 = α65 are TypeName(either)(0) arg type
//│ unified α70
//│  α70 :> either[α69,α68]
//│  α70 <: α64
//│ ╔══[ERROR] Type mismatch in if-then-else true condition:
//│ ║  l.126: 	if 1 == 2 then Left true else Right false
//│ ║         	               ^^^^^^^^^
//│ ╟── type `true` is not a 2-element tuple
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.5: 	type ('a, 'b) either = Left of ('a * 'a) | Right of 'b
//│ ╙──     	                                ^^^^^^^
//│ res: either[nothing, false]

:unifyDbg
//let test x =
//  match x with True -> 0 | False -> "oops"



:unifyDbg
//let temp x = if x then 0 else "oops"


//let temp x y z = if x then y else z

//temp true 1 2

:unifyDbg
//temp true 1 "oops"


//let temp x y = if x then x else y

:unifyDbg
//temp true 1



//let addF x f arg = x + f arg

:unify
//let rec findOddAndAddThem xs = match xs with
//  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
//  | [] -> 0

