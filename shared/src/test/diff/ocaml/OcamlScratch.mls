:OcamlParser
:OcamlLoadLibrary


type Bool = True | False
//│ Defined type alias Bool
//│ Defined class True
//│ Defined class False
//│ True: Bool
//│ False: Bool

:unifyDbg
let test x =
  match x with True -> 0 | False -> 1
//│ unified α67'
//│  α67' <: [[((true<> & α68') | ((false<> & α69') & ~(true<>)))]]
//│ unified α68'
//│ unified α69'
//│ unified α70'
//│  α70' :> Int
//│ test: bool -> int

:unifyDbg
let test x =
  match x with True -> 0 | False -> "oops"
//│ [ERROR 1] Int != String unifying because Int | String <: α78'
//│ allVarPols: +α83'
//│ norm[+] α83'
//│ | DNF: DNF(α83')
//│ | norm[+] Int
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] String
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ ~> α83'
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and string cannot be unified but flows into the same location
//│ ╟── int is used as integer literal
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                       ^
//│ ╟── string is used as string literal
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                                    ^^^^^^
//│ ╟── The following tvars cannot be resolved α78'
//│ ╟── ?a is used as `case` expression
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ╙──      	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ unified α75'
//│  α75' <: [[((true<> & α76') | ((false<> & α77') & ~(true<>)))]]
//│ unified α76'
//│ unified α77'
//│ unified α78'
//│  α78' :> String
//│  α78' :> Int
//│ test: bool -> (int | string)



:unifyDbg
let temp x = if x then 0 else "oops"
//│ [ERROR 1] Int != String unifying because Int | String <: α87'
//│ allVarPols: +α92'
//│ norm[+] α92'
//│ | DNF: DNF(α92')
//│ | norm[+] Int
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] String
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ ~> α92'
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and string cannot be unified but flows into the same location
//│ ╟── int is used as integer literal
//│ ║  l.76: 	let temp x = if x then 0 else "oops"
//│ ║        	                       ^
//│ ╟── string is used as string literal
//│ ║  l.76: 	let temp x = if x then 0 else "oops"
//│ ║        	                              ^^^^^^
//│ ╟── The following tvars cannot be resolved α87'
//│ ╟── ?a is used as `case` expression
//│ ║  l.76: 	let temp x = if x then 0 else "oops"
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^^
//│ unified α84'
//│  α84' <: [[((true<bool> & α85') | (α86' & ~(true<bool>)))]]
//│ unified α85'
//│ unified α86'
//│ unified α87'
//│  α87' :> String
//│  α87' :> Int
//│ temp: anything -> (int | string)


let temp x y z = if x then y else z
//│ temp: anything -> 'a -> 'a -> 'a

temp true 1 2
//│ res: int

:unifyDbg
temp true 1 "oops"
//│ [ERROR 0] ((true<bool> & α118) | (α119 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α118) | (α119 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α117 <: [[((true<bool> & α118) | (α119 & ~(true<bool>)))]] and α117 :> [[[[[[true<bool>]]]]]]
//│ allVarPols: +α119, +α127
//│ norm[+] [[((true<bool> & α127) | (α119 & ~(true<bool>)))]]
//│ | DNF: DNF(true<bool>{}∧α127 | α119∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | factorize? true<bool> & α127 | α119 & ~(true<bool>)
//│ | | Factors α119 -> 1, α127 -> 1
//│ | yes: ((true<bool> & α127) | (α119 & ~(true<bool>)))
//│ ~> ((true<bool> & α127) | (α119 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] [[[[[[true<bool>]]]]]]
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: +α119, +α128
//│ norm[+] ((true<bool> & α128) | (α119 & ~(true<bool>)))
//│ | DNF: DNF(true<bool>{}∧α128 | α119∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | factorize? true<bool> & α128 | α119 & ~(true<bool>)
//│ | | Factors α128 -> 1, α119 -> 1
//│ | yes: ((true<bool> & α128) | (α119 & ~(true<bool>)))
//│ ~> ((true<bool> & α128) | (α119 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] true & ?a | ?b & ~true and true cannot be unified but flows into the same location
//│ ╟── true & ?c | ?b & ~true is used as reference
//│ ║  l.125: 	let temp x y z = if x then y else z
//│ ║         	                    ^
//│ ╟── true is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ╙──       	     ^^^^
//│ [ERROR 1] Int != String unifying because [[[[Int]]]] = [[[[String]]]] because [[[[[α125]]]]] = [[[[Int]]]] because α120 <: [[[[[α125]]]]] and α120 :> [[[[Int]]]] and [[[[[α125]]]]] = [[[[String]]]] because α121 <: [[[[[α125]]]]] and α121 :> [[[[String]]]]
//│ allVarPols: +α129
//│ norm[+] α129
//│ | DNF: DNF(α129)
//│ | norm[+] [[[[[[[[String]]]]]]]]
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ ~> α129
//│ allVarPols: +α130
//│ norm[+] α130
//│ | DNF: DNF(α130)
//│ | norm[+] [[[[[[[[String]]]]]]]]
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ ~> α130
//│ allVarPols: 
//│ norm[+] [[[[Int]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] [[[[String]]]]
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and string cannot be unified but flows into the same location
//│ ╟── int is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ║         	          ^
//│ ╟── string is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ║         	            ^^^^^^
//│ ╟── The following tvars cannot be resolved [[[[[α125]]]]]
//│ ╟── ?a is used as reference
//│ ║  l.125: 	let temp x y z = if x then y else z
//│ ║         	                           ^
//│ ╟── ?b is used as application
//│ ║  l.132: 	temp true 1 "oops"
//│ ╙──       	^^^^^^^^^^^^^^^^^^
//│ [ERROR 1] String != Int unifying because [[[[String]]]] = [[[[Int]]]] because α121 :> [[[[String]]]] and [[[[Int]]]] = [α121] because α120 :> [[[[Int]]]] and [α120] | [α121] <: α122
//│ allVarPols: +α131, +α132, +α134
//│ norm[+] α131
//│ | DNF: DNF(α131)
//│ | norm[+] [α132]
//│ | | DNF: DNF(α132)
//│ | | norm[+] [[[[Int]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[-] [[[[[α133]]]]]
//│ | | | DNF: DNF(α133)
//│ | | | norm[+] [[[[[[[[String]]]]]]]]
//│ | | | | DNF: DNF(string<>{})
//│ | | | ~> string<>
//│ | | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | | DNF: DNF(int<>{})
//│ | | | ~> int<>
//│ | | ~> α133
//│ | ~> α132
//│ | norm[+] [α134]
//│ | | DNF: DNF(α134)
//│ | | norm[+] [[[[String]]]]
//│ | | | DNF: DNF(string<>{})
//│ | | ~> string<>
//│ | | norm[-] [[[[[α133]]]]]
//│ | | | DNF: DNF(α133)
//│ | | ~> α133
//│ | ~> α134
//│ | norm[-] [[[α133]]]
//│ | | DNF: DNF(α133)
//│ | ~> α133
//│ ~> α131
//│ allVarPols: 
//│ norm[+] [[[[String]]]]
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] [[[[Int]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] string and int cannot be unified but flows into the same location
//│ ╟── string is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ║         	            ^^^^^^
//│ ╟── int is used as argument
//│ ║  l.132: 	temp true 1 "oops"
//│ ║         	          ^
//│ ╟── The following tvars cannot be resolved α122
//│ ╟── ?a is used as `case` expression
//│ ║  l.125: 	let temp x y z = if x then y else z
//│ ╙──       	                    ^^^^^^^^^^^^^^^
//│ unified α117
//│  α117 :> [[[[[[true<bool>]]]]]]
//│  α117 <: [[((true<bool> & α118) | (α119 & ~(true<bool>)))]]
//│ unified α118
//│  α118 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ unified α119
//│ unified α120
//│  [α120] | [α121] <: α122
//│  [[[[Int]]]] = [α120] because [[[[[α125]]]]] = [[[[Int]]]] because α120 <: [[[[[α125]]]]] and α120 :> [[[[Int]]]] and [[[α125]]] = [α120] because α122 <: [[[α125]]] and α122 :> [α120]
//│  [[[[String]]]] = [α120] because [[[[[α125]]]]] = [[[[String]]]] because α121 <: [[[[[α125]]]]] and α121 :> [[[[String]]]] and [[[α125]]] = [α120] because α122 <: [[[α125]]] and α122 :> [α120]
//│  α120 :> [[[[Int]]]]
//│  α120 <: [[[[[α125]]]]]
//│ unified α121
//│  [[[[String]]]] = [α121] because [[[[[α125]]]]] = [[[[String]]]] because α121 <: [[[[[α125]]]]] and α121 :> [[[[String]]]] and [[[[[α125]]]]] = [α121] because α120 <: [[[[[α125]]]]] and [α120] | [α121] <: α122
//│  [[[[Int]]]] = [α121] because α120 :> [[[[Int]]]] and [α120] | [α121] <: α122
//│  α121 :> [[[[String]]]]
//│  α121 <: [[[[[α125]]]]]
//│ unified α122
//│  α122 :> [α121]
//│  α122 :> [α120]
//│  α122 <: [[[α125]]]
//│ unified α123
//│  α123 :> [[[(α120 -> (α121 -> α122))]]]
//│  α123 <: [([(Int,)] -> α124)]
//│ unified α124
//│  α124 <: [([(String,)] -> α125)]
//│  α124 = (α121 -> α122) are result type in ([(Int,)] -> α124) = (α120 -> (α121 -> α122))
//│ unified α125
//│  [[[[[α125]]]]] = [α121] because α120 <: [[[[[α125]]]]] and [α120] | [α121] <: α122
//│  [[[α125]]] = [α120] because α122 <: [[[α125]]] and α122 :> [α120]
//│  [[[[[α125]]]]] = [[[[String]]]] because α121 <: [[[[[α125]]]]] and α121 :> [[[[String]]]]
//│  [[[[[α125]]]]] = [[[[Int]]]] because α120 <: [[[[[α125]]]]] and α120 :> [[[[Int]]]]
//│ res: int | string


let temp x y = if x then x else y
//│ temp: (true & 'a | ~true) -> 'a -> 'a

:unifyDbg
temp true 1
//│ [ERROR 0] ((true<bool> & α148) | (α149 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α148) | (α149 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α147 <: [[((true<bool> & α148) | (α149 & ~(true<bool>)))]] and α147 :> [[[[[[true<bool>]]]]]]
//│ allVarPols: +α149, +α155
//│ norm[+] [[((true<bool> & α155) | (α149 & ~(true<bool>)))]]
//│ | DNF: DNF(true<bool>{}∧α155 | α149∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | norm[-] [[[[[α156]]]]]
//│ | | DNF: DNF(α156)
//│ | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | | DNF: DNF(true<bool>{})
//│ | | ~> true<bool>
//│ | ~> α156
//│ | factorize? true<bool> & α155 | α149 & ~(true<bool>)
//│ | | Factors α149 -> 1, α155 -> 1
//│ | yes: ((true<bool> & α155) | (α149 & ~(true<bool>)))
//│ ~> ((true<bool> & α155) | (α149 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] [[[[[[true<bool>]]]]]]
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: +α149, +α157
//│ norm[+] ((true<bool> & α157) | (α149 & ~(true<bool>)))
//│ | DNF: DNF(true<bool>{}∧α157 | α149∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | norm[-] [[[[[α158]]]]]
//│ | | DNF: DNF(α158)
//│ | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | | DNF: DNF(true<bool>{})
//│ | | ~> true<bool>
//│ | ~> α158
//│ | factorize? true<bool> & α157 | α149 & ~(true<bool>)
//│ | | Factors α149 -> 1, α157 -> 1
//│ | yes: ((true<bool> & α157) | (α149 & ~(true<bool>)))
//│ ~> ((true<bool> & α157) | (α149 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] true & ?a | ?b & ~true and true cannot be unified but flows into the same location
//│ ╟── true & ?c | ?b & ~true is used as reference
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true is used as argument
//│ ║  l.318: 	temp true 1
//│ ╙──       	     ^^^^
//│ [ERROR 1] true<bool> != Int unifying because [[[[[[[[[true<bool>]]]]]]]]] = [[[[Int]]]] because [[[[[α153]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α148 <: [[[[[α153]]]]] and α148 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[[[α153]]]]] = [[[[Int]]]] because α150 <: [[[[[α153]]]]] and α150 :> [[[[Int]]]]
//│ allVarPols: +α159
//│ norm[+] α159
//│ | DNF: DNF(α159)
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ ~> α159
//│ allVarPols: +α160
//│ norm[+] α160
//│ | DNF: DNF(α160)
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ ~> α160
//│ allVarPols: 
//│ norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] [[[[Int]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] true and int cannot be unified but flows into the same location
//│ ╟── true is used as reference
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true is used as reference
//│ ║  l.318: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── int is used as argument
//│ ║  l.318: 	temp true 1
//│ ║         	          ^
//│ ╟── The following tvars cannot be resolved [[[[[α153]]]]]
//│ ╟── ?a is used as refined scrutinee
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── ?b is used as application
//│ ║  l.318: 	temp true 1
//│ ╙──       	^^^^^^^^^^^
//│ [ERROR 1] Int != true<bool> unifying because [[[[Int]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α150 :> [[[[Int]]]] and [[[[[[[[[true<bool>]]]]]]]]] = [α150] because α148 :> [[[[[[[[[true<bool>]]]]]]]]] and [α148] | [α150] <: α151
//│ allVarPols: +α161, +α162, +α164
//│ norm[+] α161
//│ | DNF: DNF(α161)
//│ | norm[+] [α162]
//│ | | DNF: DNF(α162)
//│ | | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | | DNF: DNF(true<bool>{})
//│ | | ~> true<bool>
//│ | | norm[-] [[[[[α163]]]]]
//│ | | | DNF: DNF(α163)
//│ | | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | | DNF: DNF(int<>{})
//│ | | | ~> int<>
//│ | | | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | | | DNF: DNF(true<bool>{})
//│ | | | ~> true<bool>
//│ | | ~> α163
//│ | ~> α162
//│ | norm[+] [α164]
//│ | | DNF: DNF(α164)
//│ | | norm[+] [[[[Int]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[-] [[[[[α163]]]]]
//│ | | | DNF: DNF(α163)
//│ | | ~> α163
//│ | ~> α164
//│ | norm[-] [[[α163]]]
//│ | | DNF: DNF(α163)
//│ | ~> α163
//│ ~> α161
//│ allVarPols: 
//│ norm[+] [[[[Int]]]]
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and true cannot be unified but flows into the same location
//│ ╟── int is used as argument
//│ ║  l.318: 	temp true 1
//│ ║         	          ^
//│ ╟── true is used as reference
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true is used as reference
//│ ║  l.318: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── The following tvars cannot be resolved α151
//│ ╟── ?a is used as `case` expression
//│ ║  l.314: 	let temp x y = if x then x else y
//│ ╙──       	                  ^^^^^^^^^^^^^^^
//│ unified α147
//│  α147 :> [[[[[[true<bool>]]]]]]
//│  α147 <: [[((true<bool> & α148) | (α149 & ~(true<bool>)))]]
//│ unified α148
//│  [α148] = α151 because [[[α153]]] = [α148] because α151 <: [[[α153]]] and α151 :> [α148] and α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151)
//│  [α148] = [[[[Int]]]] because α151 :> [α148] and [[[[Int]]]] = α151 because α150 :> [[[[Int]]]] and [α150] = α151 because [[[[[α153]]]]] = [α150] because α148 <: [[[[[α153]]]]] and [α148] | [α150] <: α151 and α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151)
//│  [α148] | [α150] <: α151
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α148] because [[[[[α153]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α148 <: [[[[[α153]]]]] and α148 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[α153]]] = [α148] because α151 <: [[[α153]]] and α151 :> [α148]
//│  [[[[Int]]]] = [α148] because [[[[[α153]]]]] = [[[[Int]]]] because α150 <: [[[[[α153]]]]] and α150 :> [[[[Int]]]] and [[[α153]]] = [α148] because α151 <: [[[α153]]] and α151 :> [α148]
//│  α148 :> [[[[[[[[[true<bool>]]]]]]]]]
//│  α148 <: [[[[[α153]]]]]
//│ unified α149
//│ unified α150
//│  [α150] = [[[[[[[[[true<bool>]]]]]]]]] because α151 :> [α150] and α151 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[Int]]]] = α151 because α150 :> [[[[Int]]]] and [α150] = α151 because [[[[[α153]]]]] = [α150] because α148 <: [[[[[α153]]]]] and [α148] | [α150] <: α151 and α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151) and [[[[[[[[[true<bool>]]]]]]]]] = α151 because α148 :> [[[[[[[[[true<bool>]]]]]]]]] and [α148] = α151 because [[[α153]]] = [α148] because α151 <: [[[α153]]] and α151 :> [α148] and α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151)
//│  [α150] = α151 because [[[[[α153]]]]] = [α150] because α148 <: [[[[[α153]]]]] and [α148] | [α150] <: α151 and α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151)
//│  [[[[Int]]]] = [α150] because [[[[[α153]]]]] = [[[[Int]]]] because α150 <: [[[[[α153]]]]] and α150 :> [[[[Int]]]] and [[[[[α153]]]]] = [α150] because α148 <: [[[[[α153]]]]] and [α148] | [α150] <: α151
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α150] because α148 :> [[[[[[[[[true<bool>]]]]]]]]] and [α148] | [α150] <: α151
//│  α150 :> [[[[Int]]]]
//│  α150 <: [[[[[α153]]]]]
//│ unified α151
//│  [[[[[[[[[true<bool>]]]]]]]]] = α151 because α148 :> [[[[[[[[[true<bool>]]]]]]]]] and [α148] = α151 because [[[α153]]] = [α148] because α151 <: [[[α153]]] and α151 :> [α148] and α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151)
//│  α151 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[Int]]]] = α151 because α150 :> [[[[Int]]]] and [α150] = α151 because [[[[[α153]]]]] = [α150] because α148 <: [[[[[α153]]]]] and [α148] | [α150] <: α151 and α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151) and [[[[[[[[[true<bool>]]]]]]]]] = α151 because α148 :> [[[[[[[[[true<bool>]]]]]]]]] and [α148] = α151 because [[[α153]]] = [α148] because α151 <: [[[α153]]] and α151 :> [α148] and α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151)
//│  [[[[Int]]]] = α151 because α150 :> [[[[Int]]]] and [α150] = α151 because [[[[[α153]]]]] = [α150] because α148 <: [[[[[α153]]]]] and [α148] | [α150] <: α151 and α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151)
//│  α151 :> [α150]
//│  α151 :> [α148]
//│  α151 <: [[[α153]]]
//│ unified α152
//│  α152 :> [[[(α150 -> α151)]]]
//│  α152 <: [([(Int,)] -> α153)]
//│ unified α153
//│  α153 = α151 are result type in ([(Int,)] -> α153) = (α150 -> α151)
//│  [[[[[α153]]]]] = [α150] because α148 <: [[[[[α153]]]]] and [α148] | [α150] <: α151
//│  [[[α153]]] = [α148] because α151 <: [[[α153]]] and α151 :> [α148]
//│  [[[[[α153]]]]] = [[[[Int]]]] because α150 <: [[[[[α153]]]]] and α150 :> [[[[Int]]]]
//│  [[[[[α153]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α148 <: [[[[[α153]]]]] and α148 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ res: int | true



let addF x f arg = x + f arg
//│ addF: int -> ('a -> int) -> 'a -> int

:unify
let rec findOddAndAddThem xs = match xs with
  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
  | [] -> 0
//│ ╔══[WARNING] [UNIFICATION ERROR 1] {_1: ?a} and {_0: ?b} cannot be unified but flows into the same location
//│ ╟── {_1: ?c} is used as refined scrutinee
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── {_0: ?d} is used as refined scrutinee
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── The following tvars cannot be resolved α180'
//│ ╟── ?e is used as refined scrutinee
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] Cons[?] & ?a | Nil & ?b and int cannot be unified but flows into the same location
//│ ╟── Cons[?] & ?c | Nil & ?b is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── int is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── int is used as type reference
//│ ║  l.22: 	let mod: int -> int -> int
//│ ║        	         ^^^
//│ ╟── The following tvars cannot be resolved α184'
//│ ╟── ?d is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool and true | ?a & ~true cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.31: 	let (==): 'a -> 'a -> bool
//│ ║        	                      ^^^^
//│ ╟── true | ?b & ~true is used as operator application
//│ ║  l.541: 	  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
//│ ╙──       	                   ^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and Cons[?] & ?a | Nil & ?b cannot be unified but flows into the same location
//│ ╟── int is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── int is used as type reference
//│ ║  l.22: 	let mod: int -> int -> int
//│ ║        	         ^^^
//│ ╟── Cons[?] & ?c | Nil & ?b is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── The following tvars cannot be resolved α184'
//│ ╟── ?d is used as reference
//│ ║  l.540: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ findOddAndAddThem: 'a -> int
//│   where
//│     'a <: (Cons[?] with {_0: int, _1: int & 'a}) | Nil
