:OcamlParser
:OcamlLoadLibrary


type Bool = True | False
//│ Defined type alias Bool
//│ Defined class True
//│ Defined class False
//│ True: Bool
//│ False: Bool

:unifyDbg
let test x =
  match x with True -> 0 | False -> 1
//│ unified α64'
//│  α64' <: [[((true<> & α65') | ((false<> & α66') & ~(true<>)))]]
//│ unified α65'
//│ unified α66'
//│ unified α67'
//│  α67' :> Int
//│ test: bool -> int

:unifyDbg
let test x =
  match x with True -> 0 | False -> "oops"
//│ [ERROR 1] Int != String unifying because Int | String <: α75'
//│ allVarPols: +α80'
//│ norm[+] α80'
//│ | DNF: DNF(α80')
//│ | norm[+] Int
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] String
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ ~> α80'
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] Int and String cannot be unified but flows into the same location
//│ ╟── int is used as integer literal
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                       ^
//│ ╟── string is used as string literal
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ║        	                                    ^^^^^^
//│ ╟── The following tvars cannot be resolved α75'
//│ ╟── ?a is used as `case` expression
//│ ║  l.25: 	  match x with True -> 0 | False -> "oops"
//│ ╙──      	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ unified α72'
//│  α72' <: [[((true<> & α73') | ((false<> & α74') & ~(true<>)))]]
//│ unified α73'
//│ unified α74'
//│ unified α75'
//│  α75' :> String
//│  α75' :> Int
//│ test: bool -> (int | string)



:unifyDbg
let temp x = if x then 0 else "oops"
//│ [ERROR 1] Int != String unifying because Int | String <: α84'
//│ allVarPols: +α89'
//│ norm[+] α89'
//│ | DNF: DNF(α89')
//│ | norm[+] Int
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] String
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ ~> α89'
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] Int and String cannot be unified but flows into the same location
//│ ╟── int is used as integer literal
//│ ║  l.68: 	let temp x = if x then 0 else "oops"
//│ ║        	                       ^
//│ ╟── string is used as string literal
//│ ║  l.68: 	let temp x = if x then 0 else "oops"
//│ ║        	                              ^^^^^^
//│ ╟── The following tvars cannot be resolved α84'
//│ ╟── ?a is used as `case` expression
//│ ║  l.68: 	let temp x = if x then 0 else "oops"
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^^
//│ unified α81'
//│  α81' <: [[((true<bool> & α82') | (α83' & ~(true<bool>)))]]
//│ unified α82'
//│ unified α83'
//│ unified α84'
//│  α84' :> String
//│  α84' :> Int
//│ temp: anything -> (int | string)


let temp x y z = if x then y else z
//│ temp: anything -> 'a -> 'a -> 'a

temp true 1 2
//│ res: int

:unifyDbg
temp true 1 "oops"
//│ [ERROR 0] ((true<bool> & α115) | (α116 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α115) | (α116 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α114 <: [[((true<bool> & α115) | (α116 & ~(true<bool>)))]] and α114 :> [[[[[[true<bool>]]]]]]
//│ allVarPols: +α116, +α124
//│ norm[+] ((true<bool> & α124) | (α116 & ~(true<bool>)))
//│ | DNF: DNF(true<bool>{}∧α124 | α116∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | factorize? true<bool> & α124 | α116 & ~(true<bool>)
//│ | | Factors α116 -> 1, α124 -> 1
//│ | yes: ((true<bool> & α124) | (α116 & ~(true<bool>)))
//│ ~> ((true<bool> & α124) | (α116 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] [[((true<bool> & α115) | (α116 & ~(true<bool>)))]] and [[[[[[true<bool>]]]]]] cannot be unified but flows into the same location
//│ ╟── true & ?a | ?b & ~true is used as reference
//│ ║  l.109: 	let temp x y z = if x then y else z
//│ ║         	                    ^
//│ ╟── true is used as argument
//│ ║  l.116: 	temp true 1 "oops"
//│ ╙──       	     ^^^^
//│ [ERROR 1] Int != String unifying because [[[[Int]]]] = [[[[String]]]] because [[[[[α122]]]]] = [[[[Int]]]] because α117 <: [[[[[α122]]]]] and α117 :> [[[[Int]]]] and [[[[[α122]]]]] = [[[[String]]]] because α118 <: [[[[[α122]]]]] and α118 :> [[[[String]]]]
//│ allVarPols: +α125
//│ norm[+] α125
//│ | DNF: DNF(α125)
//│ | norm[+] [[[[[[[[String]]]]]]]]
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ ~> α125
//│ allVarPols: +α126
//│ norm[+] α126
//│ | DNF: DNF(α126)
//│ | norm[+] [[[[[[[[String]]]]]]]]
//│ | | DNF: DNF(string<>{})
//│ | ~> string<>
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ ~> α126
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[Int]]]] and [[[[String]]]] cannot be unified but flows into the same location
//│ ╟── int is used as argument
//│ ║  l.116: 	temp true 1 "oops"
//│ ║         	          ^
//│ ╟── string is used as argument
//│ ║  l.116: 	temp true 1 "oops"
//│ ║         	            ^^^^^^
//│ ╟── The following tvars cannot be resolved [[[[[α122]]]]]
//│ ╟── ?a is used as reference
//│ ║  l.109: 	let temp x y z = if x then y else z
//│ ║         	                           ^
//│ ╟── ?b is used as application
//│ ║  l.116: 	temp true 1 "oops"
//│ ╙──       	^^^^^^^^^^^^^^^^^^
//│ [ERROR 1] String != Int unifying because [[[[String]]]] = [[[[Int]]]] because α118 :> [[[[String]]]] and [[[[Int]]]] = [α118] because α117 :> [[[[Int]]]] and [α117] | [α118] <: α119
//│ allVarPols: +α127, +α128, +α130
//│ norm[+] α127
//│ | DNF: DNF(α127)
//│ | norm[+] [α128]
//│ | | DNF: DNF(α128)
//│ | | norm[+] [[[[Int]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[-] [[[[[α129]]]]]
//│ | | | DNF: DNF(α129)
//│ | | | norm[+] [[[[[[[[String]]]]]]]]
//│ | | | | DNF: DNF(string<>{})
//│ | | | ~> string<>
//│ | | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | | DNF: DNF(int<>{})
//│ | | | ~> int<>
//│ | | ~> α129
//│ | ~> α128
//│ | norm[+] [α130]
//│ | | DNF: DNF(α130)
//│ | | norm[+] [[[[String]]]]
//│ | | | DNF: DNF(string<>{})
//│ | | ~> string<>
//│ | | norm[-] [[[[[α129]]]]]
//│ | | | DNF: DNF(α129)
//│ | | ~> α129
//│ | ~> α130
//│ | norm[-] [[[α129]]]
//│ | | DNF: DNF(α129)
//│ | ~> α129
//│ ~> α127
//│ allVarPols: 
//│ norm[+] String
//│ | DNF: DNF(string<>{})
//│ ~> string<>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[String]]]] and [[[[Int]]]] cannot be unified but flows into the same location
//│ ╟── string is used as argument
//│ ║  l.116: 	temp true 1 "oops"
//│ ║         	            ^^^^^^
//│ ╟── int is used as argument
//│ ║  l.116: 	temp true 1 "oops"
//│ ║         	          ^
//│ ╟── The following tvars cannot be resolved α119
//│ ╟── ?a is used as `case` expression
//│ ║  l.109: 	let temp x y z = if x then y else z
//│ ╙──       	                    ^^^^^^^^^^^^^^^
//│ unified α114
//│  α114 :> [[[[[[true<bool>]]]]]]
//│  α114 <: [[((true<bool> & α115) | (α116 & ~(true<bool>)))]]
//│ unified α115
//│  α115 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ unified α116
//│ unified α117
//│  [α117] | [α118] <: α119
//│  [[[[Int]]]] = [α117] because [[[[[α122]]]]] = [[[[Int]]]] because α117 <: [[[[[α122]]]]] and α117 :> [[[[Int]]]] and [[[α122]]] = [α117] because α119 <: [[[α122]]] and α119 :> [α117]
//│  [[[[String]]]] = [α117] because [[[[[α122]]]]] = [[[[String]]]] because α118 <: [[[[[α122]]]]] and α118 :> [[[[String]]]] and [[[α122]]] = [α117] because α119 <: [[[α122]]] and α119 :> [α117]
//│  α117 :> [[[[Int]]]]
//│  α117 <: [[[[[α122]]]]]
//│ unified α118
//│  [[[[String]]]] = [α118] because [[[[[α122]]]]] = [[[[String]]]] because α118 <: [[[[[α122]]]]] and α118 :> [[[[String]]]] and [[[[[α122]]]]] = [α118] because α117 <: [[[[[α122]]]]] and [α117] | [α118] <: α119
//│  [[[[Int]]]] = [α118] because α117 :> [[[[Int]]]] and [α117] | [α118] <: α119
//│  α118 :> [[[[String]]]]
//│  α118 <: [[[[[α122]]]]]
//│ unified α119
//│  α119 :> [α118]
//│  α119 :> [α117]
//│  α119 <: [[[α122]]]
//│ unified α120
//│  α120 :> [[[(α117 -> (α118 -> α119))]]]
//│  α120 <: [([(Int,)] -> α121)]
//│ unified α121
//│  α121 <: [([(String,)] -> α122)]
//│  α121 = (α118 -> α119) are result type in ([(Int,)] -> α121) = (α117 -> (α118 -> α119))
//│ unified α122
//│  [[[[[α122]]]]] = [α118] because α117 <: [[[[[α122]]]]] and [α117] | [α118] <: α119
//│  [[[α122]]] = [α117] because α119 <: [[[α122]]] and α119 :> [α117]
//│  [[[[[α122]]]]] = [[[[String]]]] because α118 <: [[[[[α122]]]]] and α118 :> [[[[String]]]]
//│  [[[[[α122]]]]] = [[[[Int]]]] because α117 <: [[[[[α122]]]]] and α117 :> [[[[Int]]]]
//│ res: int | string


let temp x y = if x then x else y
//│ temp: (true & 'a | ~true) -> 'a -> 'a

:unifyDbg
temp true 1
//│ [ERROR 0] ((true<bool> & α144) | (α145 & ~(true<bool>))) != true<bool> unifying because [[((true<bool> & α144) | (α145 & ~(true<bool>)))]] = [[[[[[true<bool>]]]]]] because α143 <: [[((true<bool> & α144) | (α145 & ~(true<bool>)))]] and α143 :> [[[[[[true<bool>]]]]]]
//│ allVarPols: +α145, +α151
//│ norm[+] ((true<bool> & α151) | (α145 & ~(true<bool>)))
//│ | DNF: DNF(true<bool>{}∧α151 | α145∧~(true<bool>))
//│ | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ | norm[-] [[[[[α152]]]]]
//│ | | DNF: DNF(α152)
//│ | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | | DNF: DNF(true<bool>{})
//│ | | ~> true<bool>
//│ | ~> α152
//│ | factorize? true<bool> & α151 | α145 & ~(true<bool>)
//│ | | Factors α145 -> 1, α151 -> 1
//│ | yes: ((true<bool> & α151) | (α145 & ~(true<bool>)))
//│ ~> ((true<bool> & α151) | (α145 & ~(true<bool>)))
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ ╔══[WARNING] [UNIFICATION ERROR 0] [[((true<bool> & α144) | (α145 & ~(true<bool>)))]] and [[[[[[true<bool>]]]]]] cannot be unified but flows into the same location
//│ ╟── true & ?a | ?b & ~true is used as reference
//│ ║  l.268: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true is used as argument
//│ ║  l.272: 	temp true 1
//│ ╙──       	     ^^^^
//│ [ERROR 1] true<bool> != Int unifying because [[[[[[[[[true<bool>]]]]]]]]] = [[[[Int]]]] because [[[[[α149]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α144 <: [[[[[α149]]]]] and α144 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[[[α149]]]]] = [[[[Int]]]] because α146 <: [[[[[α149]]]]] and α146 :> [[[[Int]]]]
//│ allVarPols: +α153
//│ norm[+] α153
//│ | DNF: DNF(α153)
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ ~> α153
//│ allVarPols: +α154
//│ norm[+] α154
//│ | DNF: DNF(α154)
//│ | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | DNF: DNF(int<>{})
//│ | ~> int<>
//│ | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | DNF: DNF(true<bool>{})
//│ | ~> true<bool>
//│ ~> α154
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[[[[[[true<bool>]]]]]]]]] and [[[[Int]]]] cannot be unified but flows into the same location
//│ ╟── true is used as reference
//│ ║  l.268: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true is used as reference
//│ ║  l.272: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── int is used as argument
//│ ║  l.272: 	temp true 1
//│ ║         	          ^
//│ ╟── The following tvars cannot be resolved [[[[[α149]]]]]
//│ ╟── ?a is used as refined scrutinee
//│ ║  l.268: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── ?b is used as application
//│ ║  l.272: 	temp true 1
//│ ╙──       	^^^^^^^^^^^
//│ [ERROR 1] Int != true<bool> unifying because [[[[Int]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α146 :> [[[[Int]]]] and [[[[[[[[[true<bool>]]]]]]]]] = [α146] because α144 :> [[[[[[[[[true<bool>]]]]]]]]] and [α144] | [α146] <: α147
//│ allVarPols: +α155, +α156, +α158
//│ norm[+] α155
//│ | DNF: DNF(α155)
//│ | norm[+] [α156]
//│ | | DNF: DNF(α156)
//│ | | norm[+] [[[[[[[[[true<bool>]]]]]]]]]
//│ | | | DNF: DNF(true<bool>{})
//│ | | ~> true<bool>
//│ | | norm[-] [[[[[α157]]]]]
//│ | | | DNF: DNF(α157)
//│ | | | norm[+] [[[[[[[[Int]]]]]]]]
//│ | | | | DNF: DNF(int<>{})
//│ | | | ~> int<>
//│ | | | norm[+] [[[[[[[[[[[[true<bool>]]]]]]]]]]]]
//│ | | | | DNF: DNF(true<bool>{})
//│ | | | ~> true<bool>
//│ | | ~> α157
//│ | ~> α156
//│ | norm[+] [α158]
//│ | | DNF: DNF(α158)
//│ | | norm[+] [[[[Int]]]]
//│ | | | DNF: DNF(int<>{})
//│ | | ~> int<>
//│ | | norm[-] [[[[[α157]]]]]
//│ | | | DNF: DNF(α157)
//│ | | ~> α157
//│ | ~> α158
//│ | norm[-] [[[α157]]]
//│ | | DNF: DNF(α157)
//│ | ~> α157
//│ ~> α155
//│ allVarPols: 
//│ norm[+] Int
//│ | DNF: DNF(int<>{})
//│ ~> int<>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ allVarPols: 
//│ norm[+] true<bool>
//│ | DNF: DNF(true<bool>{})
//│ ~> true<bool>
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[Int]]]] and [[[[[[[[[true<bool>]]]]]]]]] cannot be unified but flows into the same location
//│ ╟── int is used as argument
//│ ║  l.272: 	temp true 1
//│ ║         	          ^
//│ ╟── true is used as reference
//│ ║  l.268: 	let temp x y = if x then x else y
//│ ║         	                  ^
//│ ╟── true is used as reference
//│ ║  l.272: 	temp true 1
//│ ║         	     ^^^^
//│ ╟── The following tvars cannot be resolved α147
//│ ╟── ?a is used as `case` expression
//│ ║  l.268: 	let temp x y = if x then x else y
//│ ╙──       	                  ^^^^^^^^^^^^^^^
//│ unified α143
//│  α143 :> [[[[[[true<bool>]]]]]]
//│  α143 <: [[((true<bool> & α144) | (α145 & ~(true<bool>)))]]
//│ unified α144
//│  [α144] = α147 because [[[α149]]] = [α144] because α147 <: [[[α149]]] and α147 :> [α144] and α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147)
//│  [α144] = [[[[Int]]]] because α147 :> [α144] and [[[[Int]]]] = α147 because α146 :> [[[[Int]]]] and [α146] = α147 because [[[[[α149]]]]] = [α146] because α144 <: [[[[[α149]]]]] and [α144] | [α146] <: α147 and α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147)
//│  [α144] | [α146] <: α147
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α144] because [[[[[α149]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α144 <: [[[[[α149]]]]] and α144 :> [[[[[[[[[true<bool>]]]]]]]]] and [[[α149]]] = [α144] because α147 <: [[[α149]]] and α147 :> [α144]
//│  [[[[Int]]]] = [α144] because [[[[[α149]]]]] = [[[[Int]]]] because α146 <: [[[[[α149]]]]] and α146 :> [[[[Int]]]] and [[[α149]]] = [α144] because α147 <: [[[α149]]] and α147 :> [α144]
//│  α144 :> [[[[[[[[[true<bool>]]]]]]]]]
//│  α144 <: [[[[[α149]]]]]
//│ unified α145
//│ unified α146
//│  [α146] = [[[[[[[[[true<bool>]]]]]]]]] because α147 :> [α146] and α147 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[Int]]]] = α147 because α146 :> [[[[Int]]]] and [α146] = α147 because [[[[[α149]]]]] = [α146] because α144 <: [[[[[α149]]]]] and [α144] | [α146] <: α147 and α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147) and [[[[[[[[[true<bool>]]]]]]]]] = α147 because α144 :> [[[[[[[[[true<bool>]]]]]]]]] and [α144] = α147 because [[[α149]]] = [α144] because α147 <: [[[α149]]] and α147 :> [α144] and α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147)
//│  [α146] = α147 because [[[[[α149]]]]] = [α146] because α144 <: [[[[[α149]]]]] and [α144] | [α146] <: α147 and α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147)
//│  [[[[Int]]]] = [α146] because [[[[[α149]]]]] = [[[[Int]]]] because α146 <: [[[[[α149]]]]] and α146 :> [[[[Int]]]] and [[[[[α149]]]]] = [α146] because α144 <: [[[[[α149]]]]] and [α144] | [α146] <: α147
//│  [[[[[[[[[true<bool>]]]]]]]]] = [α146] because α144 :> [[[[[[[[[true<bool>]]]]]]]]] and [α144] | [α146] <: α147
//│  α146 :> [[[[Int]]]]
//│  α146 <: [[[[[α149]]]]]
//│ unified α147
//│  [[[[[[[[[true<bool>]]]]]]]]] = α147 because α144 :> [[[[[[[[[true<bool>]]]]]]]]] and [α144] = α147 because [[[α149]]] = [α144] because α147 <: [[[α149]]] and α147 :> [α144] and α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147)
//│  α147 = [[[[[[[[[true<bool>]]]]]]]]] because [[[[Int]]]] = α147 because α146 :> [[[[Int]]]] and [α146] = α147 because [[[[[α149]]]]] = [α146] because α144 <: [[[[[α149]]]]] and [α144] | [α146] <: α147 and α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147) and [[[[[[[[[true<bool>]]]]]]]]] = α147 because α144 :> [[[[[[[[[true<bool>]]]]]]]]] and [α144] = α147 because [[[α149]]] = [α144] because α147 <: [[[α149]]] and α147 :> [α144] and α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147)
//│  [[[[Int]]]] = α147 because α146 :> [[[[Int]]]] and [α146] = α147 because [[[[[α149]]]]] = [α146] because α144 <: [[[[[α149]]]]] and [α144] | [α146] <: α147 and α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147)
//│  α147 :> [α146]
//│  α147 :> [α144]
//│  α147 <: [[[α149]]]
//│ unified α148
//│  α148 :> [[[(α146 -> α147)]]]
//│  α148 <: [([(Int,)] -> α149)]
//│ unified α149
//│  α149 = α147 are result type in ([(Int,)] -> α149) = (α146 -> α147)
//│  [[[[[α149]]]]] = [α146] because α144 <: [[[[[α149]]]]] and [α144] | [α146] <: α147
//│  [[[α149]]] = [α144] because α147 <: [[[α149]]] and α147 :> [α144]
//│  [[[[[α149]]]]] = [[[[Int]]]] because α146 <: [[[[[α149]]]]] and α146 :> [[[[Int]]]]
//│  [[[[[α149]]]]] = [[[[[[[[[true<bool>]]]]]]]]] because α144 <: [[[[[α149]]]]] and α144 :> [[[[[[[[[true<bool>]]]]]]]]]
//│ res: int | true



let addF x f arg = x + f arg
//│ addF: int -> ('a -> int) -> 'a -> int

:unify
let rec findOddAndAddThem xs = match xs with
  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
  | [] -> 0
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[{_1: α178'}]]] and [[[{_0: α176'}]]] cannot be unified but flows into the same location
//│ ╟── {_1: ?a} is used as refined scrutinee
//│ ║  l.455: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── {_0: ?b} is used as refined scrutinee
//│ ║  l.455: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── The following tvars cannot be resolved α174'
//│ ╟── ?c is used as refined scrutinee
//│ ║  l.455: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[((cons<> & α174') | ((nil<> & α199') & ~(cons<>)))]] and [[[[[[[[Int]]]]]]]] cannot be unified but flows into the same location
//│ ╟── Cons[?] & ?a | Nil & ?b is used as reference
//│ ║  l.455: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── int is used as reference
//│ ║  l.455: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── int is used as type reference
//│ ║  l.21: 	let mod: int -> int -> int
//│ ║        	         ^^^
//│ ╟── The following tvars cannot be resolved α178'
//│ ╟── ?c is used as reference
//│ ║  l.455: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] Bool and [(true<bool> | (α195' & ~(true<bool>)))] cannot be unified but flows into the same location
//│ ╟── bool is used as type reference
//│ ║  l.30: 	let (==): 'a -> 'a -> bool
//│ ║        	                      ^^^^
//│ ╟── true | ?a & ~true is used as operator application
//│ ║  l.456: 	  | x :: xs -> if (mod xs 2 == 0) then addF x findOddAndAddThem xs else findOddAndAddThem xs
//│ ╙──       	                   ^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 1] [[[[[[[[Int]]]]]]]] and [[((cons<> & α174') | ((nil<> & α199') & ~(cons<>)))]] cannot be unified but flows into the same location
//│ ╟── int is used as reference
//│ ║  l.455: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── int is used as type reference
//│ ║  l.21: 	let mod: int -> int -> int
//│ ║        	         ^^^
//│ ╟── Cons[?] & ?a | Nil & ?b is used as reference
//│ ║  l.455: 	let rec findOddAndAddThem xs = match xs with
//│ ║         	                                     ^^
//│ ╟── The following tvars cannot be resolved α178'
//│ ╟── ?c is used as reference
//│ ║  l.455: 	let rec findOddAndAddThem xs = match xs with
//│ ╙──       	                                     ^^
//│ findOddAndAddThem: 'a -> int
//│   where
//│     'a <: (Cons[?] with {_0: int, _1: int & 'a}) | Nil
