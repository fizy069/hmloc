let x: int list
let y: string list -> int list
let f = y
//│ x: list[int]
//│ y: list[string] -> list[int]
//│ f: list[string] -> list[int]


y x
//│ res: list[int]

let h y = (not y, (if y then y else 5))
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ║       	                                    ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a` and it flows from `?b`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ║       	                             ^
//│ ╟── this variable has type `?b`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ║       	      ^
//│ ╟── this if-then-else condition has type `?b` and it flows into `bool`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ╙──     	                      ^
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ║       	                                    ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a` and it flows from `?b`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ║       	                             ^
//│ ╟── this variable has type `?b`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ║       	      ^
//│ ╟── this reference has type `?b` and it flows into `bool`
//│ ║  l.1: 	let h y = (not y, (if y then y else 5))
//│ ║       	               ^
//│ ╟── this type reference has type `bool`
//│ ║  builtin: 	let not: bool -> bool
//│ ╙──         	         ^^^^
//│ h: (bool & 'a) -> (bool, int | 'a,)


// 1. Typing term y => not y, if y(true) then y then (false) then 5,
// | 1. Typing pattern y
// | 1. : α55'
// | 1. Typing term not y, if y(true) then y then (false) then 5,
// | | 1. Typing term not y
// | | | 1. Typing term not
// | | | 1. : [(bool -> bool)]
// | | | 1. Typing term y
// | | | 1. : [α55']
// | | | CONSTRAIN [(bool -> bool)] <! ([α55'] -> α57')
// | | |   where 
// | | | C [(bool -> bool)] <! ([α55'] -> α57')    (0) where ProvType <: FunctionType}
// | | | | C (bool -> bool) <! ([α55'] -> α57')    (0) where FunctionType <: FunctionType}
// | | | | | [nested] [[α55']]
// | | | | | C [α55'] <! bool    (1) where ProvType <: TypeRef}
// | | | | | | C α55' <! bool    (1) where TypeVariable <: TypeRef}
// | | | | | [nested] [bool]
// | | | | | C bool <! α57'    (2) where TypeRef <: TypeVariable}
// | | 1. : α57'
// | | 1. Typing term if y(true) then y then (false) then 5
// | | | If(Var(y), List(IfThen(Var(true), Var(y), IfThen(Var(false), IntLit(5)))
// | | | 1. Typing term y
// | | | 1. : [α55']
// | | | CONSTRAIN [α55'] <! bool
// | | |   where 
// 		α55' <: [[[[bool]]]]
// | | | C [α55'] <! bool    (0) where ProvType <: TypeRef}
// | | | | C α55' <! bool    (0) where TypeVariable <: TypeRef}
// | | | 1. Typing term y
// | | | 1. : [α55']
// | | | CONSTRAIN [α55'] <! α58'
// | | |   where 
// 		α55' <: [[[bool]]] & [[[[bool]]]]
// | | | C [α55'] <! α58'    (0) where ProvType <: TypeVariable}
// | | | | C α55' <! α58'    (0) where TypeVariable <: TypeVariable}
// | | | | | symmetric
// | | | 1. Typing term 5
// | | | 1. : int
// | | | CONSTRAIN int <! α58'
// | | |   where 
// 		α55' <: [[[α58']]] & [[[bool]]] & [[[[bool]]]]
// 		α58' :> [[[α55']]]
// | | | C int <! α58'    (0) where TypeRef <: TypeVariable}
// | | 1. : α58'
// | 1. : (α57', α58',)
// 1. : (α55' -> (α57', α58',))
// ⬤ Typed as: (α55' -> (α57', α58',))
//  where: 
// 		α55' <: [[[α58']]] & [[[bool]]] & [[[[bool]]]]
// 		α57' :> [[[bool]]]
// 		α58' :> [[int]] | [[[α55']]]
// ╔══[ERROR] Type `int` does not match `bool`
// ║  
// ╟──        int ---> ?a <--- ?b ---> bool 
// ║  
// ╟── this `else` branch has type `int` and it flows into `?a`
// ║  l.1: 	let h y = (not y, (if y then y else 5))
// ║       	                                    ^
// ╟── this if-then-else expression has type `?a`
// ║  l.1: 	let h y = (not y, (if y then y else 5))
// ║       	                  ^^^^^^^^^^^^^^^^^^^^
// ╟── this `then` branch has type `?a` and it flows from `?b`
// ║  l.1: 	let h y = (not y, (if y then y else 5))
// ║       	                             ^
// ╟── this variable has type `?b`
// ║  l.1: 	let h y = (not y, (if y then y else 5))
// ║       	      ^
// ╟── this if-then-else condition has type `?b` and it flows into `bool`
// ║  l.1: 	let h y = (not y, (if y then y else 5))
// ╙──     	                      ^
// h: (bool & 'a) -> (bool, int | 'a,)


//  0. Typing term y x
//  | 0. Typing term y
//  | 0. : [(list[string] -> list[int])]
//  | 0. Typing term x
//  | 0. : [list[int]]
//  | CONSTRAIN [(list[string] -> list[int])] <! ([list[int]] -> α53)
//  |   where 
//  | C [(list[string] -> list[int])] <! ([list[int]] -> α53)    (0) where ProvType <: FunctionType}
//  | | C (list[string] -> list[int]) <! ([list[int]] -> α53)    (0) where FunctionType <: FunctionType}
//  | | | [nested] [[list[int]]]
//  | | | C [list[int]] <! list[string]    (1) where ProvType <: TypeRef}
//  | | | | C list[int] <! list[string]    (1) where TypeRef <: TypeRef}
//  | | | | | [nested] [int]
//  | | | | | C int <! string    (2) where TypeRef <: TypeRef}
//  | | | [nested] [list[int]]
//  | | | C list[int] <! α53    (3) where TypeRef <: TypeVariable}
//  0. : α53
//  ⬤ Typed as: α53
//   where: 
//  		α53 :> [[[list[int]]]]
//  res: list[int]

