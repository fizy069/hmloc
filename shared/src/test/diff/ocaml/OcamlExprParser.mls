
:ParseOnly
:OcamlParser

// equality check
let a = b = c
let d = e = f = g
//│ Desugared: def a: eq b c
//│ Desugared: def d: eq e (eq f g)

1.0
2.0 :: 3.223
//│ Desugared: 1.0
//│ Desugared: :: 2.0 3.223

// list values
// substitute :: with Cons
1 :: 2
1 :: 2 :: 3
[1, 2, 3, 4]
[]
let a = []
//│ Desugared: :: 1 2
//│ Desugared: :: 1 (:: 2 3)
//│ Desugared: Cons (1, 2, 3, 4,, Nil,)
//│ Desugared: Nil
//│ Desugared: def a: Nil

// substitute <> with ==
1 <> 1
1 <> 2
[1] <> [1, 2]
//│ Desugared: <> 1 1
//│ Desugared: <> 1 2
//│ Desugared: <> (Cons (1, Nil,)) (Cons (1, 2,, Nil,))

// FIXME where the substituted operation is not the top level operation
a + 1 <> 1 + 1
//│ Desugared: + a (<> 1 (+ 1 1))

// let without in as definitions
let a = 1
let a = a + 1
let a = a + a + 1
//│ Desugared: def a: 1
//│ Desugared: def a: + a 1
//│ Desugared: def a: + (+ a a) 1

// match case with operations and nested let statements
let check e = match e with
  Something a b c -> here
 | Nothing d e f -> nothere
let rec interp_e (h:heap) (e:exp) =
  match e with
  Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
  | Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
let check e =
 match e with
   Something here -> let nothere = here in nothere
 | Nothing -> beat it
let check e =
  match e with
   a :: b -> []
   | [] -> Nil
//│ Desugared: def check: e => if e(Something a b c) then here then (Nothing d e f) then nothere
//│ Desugared: rec def interp_e: '(' h : TypeName(heap) ')' => '(' e : TypeName(exp) ')' => if e(Plus '(' e1, e2, ')') then + '(' interp_e h e1 ')' '(' interp_e h e2 ')' then (Times '(' e1, e2, ')') then * '(' interp_e h e1 ')' '(' interp_e h e2 ')'
//│ Desugared: def check: e => if e(Something here) then let nothere = here in nothere then (Nothing) then beat it
//│ Desugared: def check: e => if e(:: a b) then Nil then (Nil) then Nil

match n < 0 with
  | true -> 1
  | false -> 0
//│ Desugared: if < n 0(true) then 1 then (false) then 0

// define lambdas using fun
fun (env: env) _ -> []
let interp2 = interp (fun (env:env) opt ->
  match opt with
     None -> 0)
//│ Desugared: '(' env : TypeName(env) ')' _ => Nil
//│ Desugared: def interp2: interp '(' '(' env : TypeName(env) ')' opt => if opt(None) then 0 ')'

// TODO floats and floating point operators
2.0
let b = 3.0
let c = 3.0 +. 4.0 *. 6.0
//│ Desugared: 2.0
//│ Desugared: def b: 3.0
//│ Desugared: def c: +. 3.0 (*. 4.0 6.0)

// make tuples from comma separated terms
1, 2, 3
let mktup = 1, 2, 3
let mktup = 1, (2, 3)
let mktup = [1, 2, 3], 4, (5, 6)
app 2 3 4
app 2,3 4 // TODO should this be tupled or not is this correct?
app (2,3) 4 // TODO is the extra tupling correct?
//│ Desugared: 1, 2, 3,
//│ Desugared: def mktup: 1, 2, 3,
//│ Desugared: def mktup: 1, '(' 2, 3, ')',
//│ Desugared: def mktup: Cons (1, 2, 3,, Nil,), 4, '(' 5, 6, ')',
//│ Desugared: app 2 3 4
//│ Desugared: app 2, 3 4,

let a = 1
let b = 2
[a, b]
[a, b, [a, b]]
[a, b, [a, b], 12]
[a, b, [a + b / 2]]
//│ Desugared: def a: 1
//│ Desugared: def b: 2
//│ Desugared: Cons (a, b,, Nil,)
//│ Desugared: Cons (a, b, Cons (a, b,, Nil,),, Nil,)
//│ Desugared: Cons (a, b, Cons (a, b,, Nil,), 12,, Nil,)
//│ Desugared: Cons (a, b, Cons (+ a (/ b 2), Nil,),, Nil,)

// TODO sequential let
let _ = 
  pr ansL; print_newline (); 
  pr ansS; print_newline ();
  pr ansI; print_newline (); 
//│ Desugared: def _: pr ansL
//│ Desugared: print_newline ()
//│ Desugared: pr ansS
//│ Desugared: print_newline ()
//│ Desugared: pr ansI
//│ Desugared: print_newline ()

// comments

(* ### **)

(* ### **)
1
//│ Desugared: 1

(* ### 
  ###**)

1 (* ### **)
let val = 0 (* ############### *)
let val = 2 (* IGNORE THIS *)
let val = 4 (**** IRREGULAR *)
//│ Desugared: 1
//│ Desugared: def val: 0
//│ Desugared: def val: 2
//│ Desugared: def val: 4

// create classes for exceptions
exception Unimplemented
exception AlreadyDone
raise Unimplemented
raise AlreadyDone
//│ Desugared: def Unimplemented: {}
//│ Desugared: def AlreadyDone: {}
//│ Desugared: raise Unimplemented
//│ Desugared: raise AlreadyDone

// Ocaml specific operators
let (::) a b = Cons a b
let head xs = match xs with
  x :: xs -> x
  | _ -> raise Error
//│ Desugared: def ::: a => b => Cons a b
//│ Desugared: def head: xs => if xs(:: x xs) then x then else raise Error

// FIXME
let head xs = match xs with
  (::) x xs -> x
  | _ -> raise Error
//│ /!\ Parse error: Expected ")":2:4, found "::) x xs -" at l.171:4:   (::) x xs -> x

:dp
type h = H of int
//│ Parsed: TypeDef(Als, TypeName(h), List(), Union(TypeName(H),TypeName(H)), List())
//│ TypeDef(Cls, TypeName(H), List(), Record(List((_0,TypeName(int)))), List(_0)) of adt: Some((TypeName(h),List()))
//│ Def(false, H, PolyType(List(),Function(TypeName(int),TypeName(h))), true)
//│ Desugared: type alias h = H
//│ Desugared: class H(_0): {_0: int}
//│ Desugared: def H: [] -> int -> h

// type definitions
type heapVar = HeapInt of int | Heap of heap and heap = (string * int) List
type exp = Int of int | Var of string | Plus of exp * exp | Times of exp * exp
type stmt = Skip | Assign of string * exp
         | Seq of stmt * stmt 
         | If of exp * stmt * stmt
         | While of exp * stmt 
         | SaveHeap of string
         | RestoreHeap of string
//│ Desugared: type alias heapVar = Heap | HeapInt
//│ Desugared: class HeapInt(_0): {_0: int}
//│ Desugared: class Heap(_0): {_0: heap}
//│ Desugared: type alias heap = List[(string, int,)]
//│ Desugared: type alias exp = Times | Plus | Var | Int
//│ Desugared: class Int(_0): {_0: int}
//│ Desugared: class Var(_0): {_0: string}
//│ Desugared: class Plus(_0, _1): {_0: exp, _1: exp}
//│ Desugared: class Times(_0, _1): {_0: exp, _1: exp}
//│ Desugared: type alias stmt = RestoreHeap | SaveHeap | While | If | Seq | Assign | Skip
//│ Desugared: class Skip: {}
//│ Desugared: class Assign(_0, _1): {_0: string, _1: exp}
//│ Desugared: class Seq(_0, _1): {_0: stmt, _1: stmt}
//│ Desugared: class If(_0, _1, _2): {_0: exp, _1: stmt, _2: stmt}
//│ Desugared: class While(_0, _1): {_0: exp, _1: stmt}
//│ Desugared: class SaveHeap(_0): {_0: string}
//│ Desugared: class RestoreHeap(_0): {_0: string}
//│ Desugared: def HeapInt: [] -> int -> heapVar
//│ Desugared: def Heap: [] -> heap -> heapVar
//│ Desugared: def Int: [] -> int -> exp
//│ Desugared: def Var: [] -> string -> exp
//│ Desugared: def Plus: [] -> (exp, exp,) -> exp
//│ Desugared: def Times: [] -> (exp, exp,) -> exp
//│ Desugared: def Skip: [] -> stmt
//│ Desugared: def Assign: [] -> (string, exp,) -> stmt
//│ Desugared: def Seq: [] -> (stmt, stmt,) -> stmt
//│ Desugared: def If: [] -> (exp, stmt, stmt,) -> stmt
//│ Desugared: def While: [] -> (exp, stmt,) -> stmt
//│ Desugared: def SaveHeap: [] -> string -> stmt
//│ Desugared: def RestoreHeap: [] -> string -> stmt

:dp
// parameterized type definitions
type 'a heap = HeapA of 'a
type ('a, 'b) heapb = HeapB of 'a
type ('a, 'b) heapc = HeapC of 'a list
type 'a list = Cons of 'a * 'a list | Nil
//│ Parsed: TypeDef(Als, TypeName(heap), List(TypeName('a)), Union(AppliedType(TypeName(HeapA),List(TypeName('a))),AppliedType(TypeName(HeapA),List(TypeName('a)))), List())
//│ TypeDef(Cls, TypeName(HeapA), List(TypeName('a)), Record(List((_0,TypeName('a)))), List(_0)) of adt: Some((TypeName(heap),List(0)))
//│ Def(false, HeapA, PolyType(List(TypeName('a)),Function(TypeName('a),AppliedType(TypeName(heap),List(TypeName('a))))), true)
//│ TypeDef(Als, TypeName(heapb), List(TypeName('a), TypeName('b)), Union(AppliedType(TypeName(HeapB),List(TypeName('a))),AppliedType(TypeName(HeapB),List(TypeName('a)))), List())
//│ TypeDef(Cls, TypeName(HeapB), List(TypeName('a)), Record(List((_0,TypeName('a)))), List(_0)) of adt: Some((TypeName(heapb),List(0)))
//│ Def(false, HeapB, PolyType(List(TypeName('a), TypeName('b)),Function(TypeName('a),AppliedType(TypeName(heapb),List(TypeName('a), TypeName('b))))), true)
//│ TypeDef(Als, TypeName(heapc), List(TypeName('a), TypeName('b)), Union(AppliedType(TypeName(HeapC),List(TypeName('a))),AppliedType(TypeName(HeapC),List(TypeName('a)))), List())
//│ TypeDef(Cls, TypeName(HeapC), List(TypeName('a)), Record(List((_0,AppliedType(TypeName(list),List(TypeName('a)))))), List(_0)) of adt: Some((TypeName(heapc),List(0)))
//│ Def(false, HeapC, PolyType(List(TypeName('a), TypeName('b)),Function(AppliedType(TypeName(list),List(TypeName('a))),AppliedType(TypeName(heapc),List(TypeName('a), TypeName('b))))), true)
//│ TypeDef(Als, TypeName(list), List(TypeName('a)), Union(TypeName(Nil),Union(AppliedType(TypeName(Cons),List(TypeName('a))),AppliedType(TypeName(Cons),List(TypeName('a))))), List())
//│ TypeDef(Cls, TypeName(Cons), List(TypeName('a)), Record(List((_0,TypeName('a)), (_1,AppliedType(TypeName(list),List(TypeName('a)))))), List(_0, _1)) of adt: Some((TypeName(list),List(0)))
//│ TypeDef(Cls, TypeName(Nil), List(), Record(List()), List()) of adt: Some((TypeName(list),List()))
//│ Def(false, Cons, PolyType(List(TypeName('a)),Function(Tuple(List(TypeName('a), AppliedType(TypeName(list),List(TypeName('a))))),AppliedType(TypeName(list),List(TypeName('a))))), true)
//│ Def(false, Nil, PolyType(List(TypeName('a)),AppliedType(TypeName(list),List(TypeName('a)))), true)
//│ Desugared: type alias heap['a] = HeapA['a]
//│ Desugared: class HeapA['a](_0): {_0: 'a}
//│ Desugared: type alias heapb['a, 'b] = HeapB['a]
//│ Desugared: class HeapB['a](_0): {_0: 'a}
//│ Desugared: type alias heapc['a, 'b] = HeapC['a]
//│ Desugared: class HeapC['a](_0): {_0: list['a]}
//│ Desugared: type alias list['a] = Nil | Cons['a]
//│ Desugared: class Cons['a](_0, _1): {_0: 'a, _1: list['a]}
//│ Desugared: class Nil: {}
//│ Desugared: def HeapA: ['a] -> 'a -> heap['a]
//│ Desugared: def HeapB: ['a, 'b] -> 'a -> heapb['a, 'b]
//│ Desugared: def HeapC: ['a, 'b] -> list['a] -> heapc['a, 'b]
//│ Desugared: def Cons: ['a] -> ('a, list['a],) -> list['a]
//│ Desugared: def Nil: ['a] -> list['a]

// parallel type definitions
type ('a) bigHeap =
  NoHeap of 'a list
  | NonHeap of otherList
  | NonsHeap of (otherList * 'a) list
  and otherList = int list
//│ Desugared: type alias bigHeap['a] = NonsHeap['a] | NonHeap | NoHeap['a]
//│ Desugared: class NoHeap['a](_0): {_0: list['a]}
//│ Desugared: class NonHeap(_0): {_0: otherList}
//│ Desugared: class NonsHeap['a](_0): {_0: list[(otherList, 'a,)]}
//│ Desugared: type alias otherList = list[int]
//│ Desugared: def NoHeap: ['a] -> list['a] -> bigHeap['a]
//│ Desugared: def NonHeap: ['a] -> otherList -> bigHeap['a]
//│ Desugared: def NonsHeap: ['a] -> list[(otherList, 'a,)] -> bigHeap['a]

type biglist = int option list
type listoflists = int list list
type stringintlist = ((string * int) list * int) list
//│ Desugared: type alias biglist = list[option[int]]
//│ Desugared: type alias listoflists = list[list[int]]
//│ Desugared: type alias stringintlist = list[(list[(string, int,)], int,)]

:dp
type ('a, 'b) paramlist = (('a * int) list * 'b) list
//│ Parsed: TypeDef(Als, TypeName(paramlist), List(TypeName('a), TypeName('b)), AppliedType(TypeName(list),List(Tuple(List(AppliedType(TypeName(list),List(Tuple(List(TypeName('a), TypeName(int))))), TypeName('b))))), List())
//│ Desugared: type alias paramlist['a, 'b] = list[(list[('a, int,)], 'b,)]

type ('a, 'b) paramlist = ('a * int) list
//│ Desugared: type alias paramlist['a, 'b] = list[('a, int,)]

type ('a, 'b) heapC = HeapC of ('a * 'b)
//│ Desugared: type alias heapC['a, 'b] = HeapC['a, 'b]
//│ Desugared: class HeapC['a, 'b](_0): {_0: ('a, 'b,)}
//│ Desugared: def HeapC: ['a, 'b] -> ('a, 'b,) -> heapC['a, 'b]

type ('a, 'b) heapB = HeapB of 'a * 'b
//│ Desugared: type alias heapB['a, 'b] = HeapB['a, 'b]
//│ Desugared: class HeapB['a, 'b](_0, _1): {_0: 'a, _1: 'b}
//│ Desugared: def HeapB: ['a, 'b] -> ('a, 'b,) -> heapB['a, 'b]

type 'a list = Cons of 'a * 'a list | Nil
let (::) a b = Cons {_0 = a; _1 = b}
type 'a option = None | Some of 'a
let raise a = nothing
//│ Desugared: type alias list['a] = Nil | Cons['a]
//│ Desugared: class Cons['a](_0, _1): {_0: 'a, _1: list['a]}
//│ Desugared: class Nil: {}
//│ Desugared: type alias option['a] = Some['a] | None
//│ Desugared: class None: {}
//│ Desugared: class Some['a](_0): {_0: 'a}
//│ Desugared: def Cons: ['a] -> ('a, list['a],) -> list['a]
//│ Desugared: def Nil: ['a] -> list['a]
//│ Desugared: def ::: a => b => Cons {_0: a, _1: b}
//│ Desugared: def None: ['a] -> option['a]
//│ Desugared: def Some: ['a] -> 'a -> option['a]
//│ Desugared: def raise: a => nothing

fun (env: env) _ -> []
//│ Desugared: '(' env : TypeName(env) ')' _ => Nil

let List_length: 'a list -> int
let List_mem: 'a -> 'a list -> bool
let List_append: 'a list -> 'a list -> 'a list
//│ Desugared: def List_length: ['a] -> list['a] -> int
//│ Desugared: def List_mem: ['a] -> 'a -> list['a] -> bool
//│ Desugared: def List_append: ['a] -> list['a] -> list['a] -> list['a]

Cons(1, Nil) @ Cons(2, Nil)
//│ Desugared: @ (Cons '(' 1, Nil, ')') (Cons '(' 2, Nil, ')')

let rev_bind: ('a -> 'b list) -> 'a list -> 'b list
let big_fun: 'a -> 'b -> 'c -> 'd
//│ Desugared: def rev_bind: ['a, 'b] -> ('a -> list['b]) -> list['a] -> list['b]
//│ Desugared: def big_fun: ['a, 'b, 'c, 'd] -> 'a -> 'b -> 'c -> 'd

let List_map: ('a -> 'b) -> 'a list -> 'b list
let List_fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│ Desugared: def List_map: ['a, 'b] -> ('a -> 'b) -> list['a] -> list['b]
//│ Desugared: def List_fold_left: ['a, 'b] -> ('a -> 'b -> 'a) -> 'a -> list['b] -> 'a


:dp
let List_length: 'a list -> int
let List_mem: 'a -> 'a list -> bool
let List_append: 'a list -> 'a list -> 'a list
let (@): 'a list -> 'a list -> 'a list
//│ Parsed: Def(false, List_length, PolyType(List(TypeName('a)),Function(AppliedType(TypeName(list),List(TypeName('a))),TypeName(int))), true)
//│ Def(false, List_mem, PolyType(List(TypeName('a)),Function(TypeName('a),Function(AppliedType(TypeName(list),List(TypeName('a))),TypeName(bool)))), true)
//│ Def(false, List_append, PolyType(List(TypeName('a)),Function(AppliedType(TypeName(list),List(TypeName('a))),Function(AppliedType(TypeName(list),List(TypeName('a))),AppliedType(TypeName(list),List(TypeName('a)))))), true)
//│ Def(false, @, PolyType(List(TypeName('a)),Function(AppliedType(TypeName(list),List(TypeName('a))),Function(AppliedType(TypeName(list),List(TypeName('a))),AppliedType(TypeName(list),List(TypeName('a)))))), true)
//│ Desugared: def List_length: ['a] -> list['a] -> int
//│ Desugared: def List_mem: ['a] -> 'a -> list['a] -> bool
//│ Desugared: def List_append: ['a] -> list['a] -> list['a] -> list['a]
//│ Desugared: def @: ['a] -> list['a] -> list['a] -> list['a]

let (+.): float -> float -> float
let (-.): float -> float -> float
let ( *. ): float -> float -> float
let ( /. ): float -> float -> float
let ( ** ): float -> float -> float
//│ Desugared: def +.: [] -> float -> float -> float
//│ Desugared: def -.: [] -> float -> float -> float
//│ Desugared: def *.: [] -> float -> float -> float
//│ Desugared: def /.: [] -> float -> float -> float
//│ Desugared: def **: [] -> float -> float -> float

// TODO precedence is not correct
:dp
1.0 +. 1.0 -. 1.0 *. 2.0 /. 3.0 ** 5.0
//│ Parsed: App(App(Var(-.), App(App(Var(+.), DecLit(1.0)), DecLit(1.0))), App(App(Var(**), App(App(Var(/.), App(App(Var(*.), DecLit(1.0)), DecLit(2.0))), DecLit(3.0))), DecLit(5.0)))
//│ Desugared: -. (+. 1.0 1.0) (** (/. (*. 1.0 2.0) 3.0) 5.0)

:dp
type heapVar = Heap of heap and heap = (string * int) List
//│ Parsed: TypeDef(Als, TypeName(heapVar), List(), Union(TypeName(Heap),TypeName(Heap)), List())
//│ TypeDef(Cls, TypeName(Heap), List(), Record(List((_0,TypeName(heap)))), List(_0)) of adt: Some((TypeName(heapVar),List()))
//│ Def(false, Heap, PolyType(List(),Function(TypeName(heap),TypeName(heapVar))), true)
//│ TypeDef(Als, TypeName(heap), List(), AppliedType(TypeName(List),List(Tuple(List(TypeName(string), TypeName(int))))), List())
//│ Desugared: type alias heapVar = Heap
//│ Desugared: class Heap(_0): {_0: heap}
//│ Desugared: type alias heap = List[(string, int,)]
//│ Desugared: def Heap: [] -> heap -> heapVar

:dp
let check a b =
  let (sum, sub) = (a + b, a - b) in sum * sub
//│ Parsed: Def(false, check, Lam(Var(a), Lam(Var(b), If(Bra(rcd = false, Tup(App(App(Var(+), Var(a)), Var(b)), App(App(Var(-), Var(a)), Var(b)))), List(IfThen(Bra(rcd = false, Tup(Var(sum), Var(sub))), App(App(Var(*), Var(sum)), Var(sub)))))), true)
//│ Desugared: def check: a => b => if '(' + a b, - a b, ')'('(' sum, sub, ')') then * sum sub
