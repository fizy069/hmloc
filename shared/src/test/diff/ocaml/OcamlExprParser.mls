:NoJS
:ParseOnly
:OcamlParser

// equality check
let a = b = c
let d = e = f = g
//│ Desugared: def a: == b c
//│ Desugared: def d: == e (== f g)

// list values
1 :: 2
[1, 2, 3, 4]
[]
let a = []
//│ Desugared: :: (1,) (2,)
//│ Desugared: Cons ({_0: 1, _1: Cons ({_0: 2, _1: Cons ({_0: 3, _1: Cons ({_0: 4, _1: Nil ({},)},)},)},)},)
//│ Desugared: Nil ({},)
//│ Desugared: def a: Nil ({},)

// let without in as definitions
let a = 1
let a = a + 1
let a = a + a + 1
//│ Desugared: def a: 1
//│ Desugared: def a: + (a,) (1,)
//│ Desugared: def a: + (+ (a,) (a,),) (1,)

// match case with operations and nested let statements
let check e = match e with
  Something a b c -> here
 | Nothing d e f -> nothere
let rec interp_e (h:heap) (e:exp) =
  match e with
  Plus(e1,e2) ->(interp_e h e1)+(interp_e h e2)
  | Times(e1,e2)->(interp_e h e1)*(interp_e h e2)
let check e =
 match e with
   Something here -> let nothere = here in nothere
 | Nothing -> beat it
let check e =
  match e with
   a :: b -> []
   | [] -> Nil
//│ Desugared: def check: e, => if e is ‹(Something (a,) (b,) (c,)) then here; (Nothing (d,) (e,) (f,)) then nothere›
//│ Desugared: rec def interp_e: '(' h : TypeName(heap) ')', => '(' e : TypeName(exp) ')', => if e is ‹(Plus ('(' e1, e2, ')',)) then + ('(' interp_e (h,) (e1,) ')',) ('(' interp_e (h,) (e2,) ')',); (Times ('(' e1, e2, ')',)) then * ('(' interp_e (h,) (e1,) ')',) ('(' interp_e (h,) (e2,) ')',)›
//│ Desugared: def check: e, => if e is ‹(Something (here,)) then let nothere = here in nothere; (Nothing) then beat (it,)›
//│ Desugared: def check: e, => if e is ‹(:: (a,) (b,)) then Nil ({},); (Nil ({},)) then Nil›

// define lambdas using fun
fun (env: env) _ -> []
let interp2 = interp (fun (env:env) opt ->
  match opt with
     None -> 0)
//│ Desugared: '(' env : TypeName(env) ')' (_,), => Nil ({},)
//│ Desugared: def interp2: interp ('(' '(' env : TypeName(env) ')' (opt,), => if opt is ‹(None) then 0› ')',)

// TODO floats and floating point operators
2.0
let b = 3.0
let c = 3.0 +. 4.0 *. 6.0
//│ /!\ Parse error: Expected (Index ~ filter | Index ~ "("):1:3, found "0;let b = " at l.59:3: 2.0

// make tuples from comma separated terms
1, 2, 3
let mktup = 1, 2, 3
let mktup = 1, (2, 3)
let mktup = [1, 2, 3], 4, (5, 6)
app 2 3 4
app 2,3 4 // TODO should this be tupled or not is this correct?
app (2,3) 4 // TODO is the extra tupling correct?
//│ Desugared: 1, 2, 3,
//│ Desugared: def mktup: 1, 2, 3,
//│ Desugared: def mktup: 1, '(' 2, 3, ')',
//│ Desugared: def mktup: Cons ({_0: 1, _1: Cons ({_0: 2, _1: Cons ({_0: 3, _1: Nil ({},)},)},)},), 4, '(' 5, 6, ')',
//│ Desugared: app (2,) (3,) (4,)
//│ Desugared: app (2,), 3 (4,),

// TODO sequential let
let _ = 
  pr ansL; print_newline (); 
  pr ansS; print_newline ();
  pr ansI; print_newline (); 
//│ Desugared: def _: pr (ansL,)
//│ Desugared: print_newline ()
//│ Desugared: pr (ansS,)
//│ Desugared: print_newline ()
//│ Desugared: pr (ansI,)
//│ Desugared: print_newline ()


// INPROGRESS comments
(* ### *)
1 (* ### *)
let val = 0 (* ############### *)
let val = 2 (* IGNORE THIS *)
let val = 4 (**** IRREGULAR *)
//│ /!\ Parse error: Expected ")":1:2, found "* ### *);1" at l.93:2: (* ### *)

// create classes for exceptions
exception Unimplemented
exception AlreadyDone
raise Unimplemented
raise AlreadyDone
//│ Desugared: def Unimplemented: {}
//│ Desugared: def AlreadyDone: {}
//│ Desugared: raise (Unimplemented,)
//│ Desugared: raise (AlreadyDone,)

// Ocaml specific operators
// TODO: prefix operators
let (::) a b = Cons a b
let head xs = match xs with
  :: x xs -> x
  | _ -> raise Error
//│ /!\ Parse error: Expected end-of-input:2:3, found ":: x xs ->" at l.114:3:   :: x xs -> x

// type definitions
type heapVar = HeapInt of int | Heap of heap and heap = (string * int) List
type exp = EInt of int | Var of string | Plus of exp * exp | Times of exp * exp
type stmt = Skip | Assign of string * exp
         | Seq of stmt * stmt 
         | If of exp * stmt * stmt
         | While of exp * stmt 
         | SaveHeap of string
         | RestoreHeap of string
//│ Desugared: type alias heap = List[]
//│ Desugared: type alias heapVar = HeapInt | Heap
//│ Desugared: class HeapInt: {_0: int}
//│ Desugared: class Heap: {_0: heap}
//│ Desugared: type alias exp = EInt | Var | Plus | Times
//│ Desugared: class EInt: {_0: int}
//│ Desugared: class Var: {_0: string}
//│ Desugared: class Plus: {_0: exp, _1: exp}
//│ Desugared: class Times: {_0: exp, _1: exp}
//│ Desugared: type alias stmt = Skip | Assign | Seq | If | While | SaveHeap | RestoreHeap
//│ Desugared: class Skip: {}
//│ Desugared: class Assign: {_0: string, _1: exp}
//│ Desugared: class Seq: {_0: stmt, _1: stmt}
//│ Desugared: class If: {_0: exp, _1: stmt, _2: stmt}
//│ Desugared: class While: {_0: exp, _1: stmt}
//│ Desugared: class SaveHeap: {_0: string}
//│ Desugared: class RestoreHeap: {_0: string}

// parameterized type definitions
// type 'a list = Cons of 'a * 'a list | Nil
