:AllowTypeErrors

// file 246
let rec cloneHelper x n l =
  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;
let rec clone x n = if n < 1 then [] else cloneHelper x n [];;
let padZero l1 l2 =
  let diff = (List.length l1) - (List.length l2) in
  if diff < 0
  then (((clone 0 (-1 * diff)) @ l1), l2)
  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = padZero l1 l2 in
    let base = List.combine l1 l2 in
    let args = failwith "to be implemented" in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.10: 	  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
//│ ║        	                                                                ^^
//│ ╟── this variable has type `?a list`
//│ ║  l.9: 	let rec removeZero l =
//│ ║       	                   ^
//│ ╟── this `else` branch has type `?a list` and it flows into `?b`
//│ ║  l.10: 	  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
//│ ║        	                                                                        ^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.10: 	  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
//│ ║        	                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a0 list` and it flows into `?b`
//│ ║  l.10: 	  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
//│ ╙──      	                       ^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list ---> ?c <--- ?b list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?c`
//│ ║  l.10: 	  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
//│ ║        	                                                                ^^
//│ ╟── this variable has type `?c`
//│ ║  l.9: 	let rec removeZero l =
//│ ║       	                   ^
//│ ╟── this application has type `?c`
//│ ║  l.17: 	  removeZero (add (padZero l1 l2));;
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?c`
//│ ║  l.16: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?c`
//│ ║  l.16: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                                ^^^
//│ ╟── this 1 element of this tuple has type `?c`
//│ ║  l.16: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this operator application has type `?c` and it flows from `?b list`
//│ ║  l.8: 	  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ ║       	                             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list ---> ?c <--- ?b list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?c`
//│ ║  l.10: 	  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
//│ ║        	                       ^^
//│ ╟── this match expression has type `?c`
//│ ║  l.10: 	  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?c`
//│ ║  l.10: 	  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
//│ ║        	                                                                        ^
//│ ╟── this variable has type `?c`
//│ ║  l.9: 	let rec removeZero l =
//│ ║       	                   ^
//│ ╟── this application has type `?c`
//│ ║  l.17: 	  removeZero (add (padZero l1 l2));;
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?c`
//│ ║  l.16: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?c`
//│ ║  l.16: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                                ^^^
//│ ╟── this 1 element of this tuple has type `?c`
//│ ║  l.16: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this operator application has type `?c` and it flows from `?b list`
//│ ║  l.8: 	  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ ║       	                             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.UnificationSolver.makeMessagesUR$1(UnificationSolver.scala:244)
//│ 	at: mlscript.UnificationSolver.createErrorMessage(UnificationSolver.scala:275)
//│ 	at: mlscript.UnificationSolver.createErrorMessage$(UnificationSolver.scala:179)
//│ 	at: mlscript.TypeDefs.createErrorMessage(TypeDefs.scala:11)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:169)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:168)
//│ 	at: scala.collection.Iterator$$anon$7.hasNext(Iterator.scala:525)
//│ 	at: scala.collection.immutable.List.prependedAll(List.scala:152)
//│ 	at: scala.collection.IterableOnceOps.toList(IterableOnce.scala:1288)

// file 67 mod
type expr =
    VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;
let pi = 4.0 *. (atan 1.0);;
let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y);;
//│ Defined type alias expr
//│ Defined class VarX
//│ Defined class VarY
//│ Defined class Sine
//│ Defined class Cosine
//│ Defined class Average
//│ Defined class Times
//│ Defined class Thresh
//│ ╔══[ERROR] Type `expr * ?a * ?b` does not match `?c * ?a * ?b`
//│ ║  
//│ ╟── this function argument has type `expr * ?a * ?b`
//│ ║  l.21: 	      else eval (e4, x, y);;
//│ ║        	                ^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?a * ?b`
//│ ║  l.10: 	let rec eval (e,x,y) =
//│ ╙──      	             ^^^^^^^
//│ ╔══[ERROR] Type `int` does not match `float`
//│ ║  
//│ ╟── this function argument has type `int`
//│ ║  l.16: 	  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
//│ ║        	                                                                  ^
//│ ╟── `float` comes from this type expression
//│ ║  builtin: 	let ( /. ): float -> float -> float
//│ ╙──         	                     ^^^^^
//│ VarX: expr
//│ VarY: expr
//│ Sine: expr -> expr
//│ Cosine: expr -> expr
//│ Average: (expr, expr,) -> expr
//│ Times: (expr, expr,) -> expr
//│ Thresh: (expr, expr, expr, expr,) -> expr
//│ pi: float
//│ eval: (expr, float & 'a & 'b & 'c & 'd, float & 'a & 'b & 'c & 'd,) -> 'b
//│   where
//│     'a <: float & 'b & 'c & 'd
//│     'b :> float | 'd
//│        <: float & 'a & 'c & 'd
//│     'd :> 'c
//│        <: float & 'a & 'b & 'c
//│     'c :> 'd
//│        <: float & 'a & 'b & 'd

// FIXME file 1087 mod
let sqsum xs =
  let f a x = match x with | [] -> 0 | h::t -> 1 in
  let base = List.hd xs in List.fold_left f base xs;;
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list <--- ?c ---> ?b list 
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│ ║           	                                               ^^^^^^^
//│ ╟── this reference has type `?a list` and it flows from `?c`
//│ ║  l.3: 	  let base = List.hd xs in List.fold_left f base xs;;
//│ ║       	                                                 ^^
//│ ╟── this variable has type `?c`
//│ ║  l.1: 	let sqsum xs =
//│ ║       	          ^^
//│ ╟── this reference has type `?c` and it flows into `?b list`
//│ ║  l.3: 	  let base = List.hd xs in List.fold_left f base xs;;
//│ ║       	                     ^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let List.hd: 'a list -> 'a
//│ ╙──         	             ^^^^^^^
//│ sqsum: list[list[?] & 'a] -> (int | 'a)


// file 26 mod
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;
let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ ╔══[ERROR] Type `string` does not match `?a -> ?b`
//│ ║  
//│ ╟── `string` comes from this type expression
//│ ║  builtin: 	let (^): string -> string -> string
//│ ║           	                             ^^^^^^
//│ ╟── this operator application has type `string`
//│ ║  l.5: 	      let f a x = a ^ (sep ^ x) in
//│ ║       	                  ^^^^^^^^^^^^^
//│ ╟── this application has type `string`
//│ ║  l.6: 	      let base = h in let l = t in List.fold_left f base l;;
//│ ║       	                                   ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `string`
//│ ║  l.2: 	  match sl with
//│ ║       	  ^^^^^^^^^^^^^
//│ ║  l.3: 	  | [] -> "" ...
//│ ║       	^^^^^^^^^^^^
//│ ╟── this application has type `string`
//│ ║  l.7: 	let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ ╙──     	                               ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `(?b -> ?c) -> ?b list -> ?c list` does not match `?a list`
//│ ║  
//│ ╟── `(?b -> ?c) -> ?b list -> ?c list` comes from this type expression
//│ ║  builtin: 	let List.map: ('a -> 'b) -> 'a list -> 'b list
//│ ║           	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `(?b -> ?c) -> ?b list -> ?c list`
//│ ║  l.7: 	let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ ║       	                                              ^^^^^^^^
//│ ╟── this pattern has type `?a list`
//│ ║  l.3: 	  | [] -> ""
//│ ╙──     	    ^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.6: 	      let base = h in let l = t in List.fold_left f base l;;
//│ ║       	                              ^
//│ ╟── this function argument has type `?a list`
//│ ║  l.6: 	      let base = h in let l = t in List.fold_left f base l;;
//│ ║       	                                                         ^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│ ╙──         	                                               ^^^^^^^
//│ sepConcat: string -> list[string] -> string
//│ stringOfList: anything -> anything -> string

// FIXME string indexing
// file 2376
let getHead h = match h with | [] -> [] | h::t -> h;;
let getTail t = match t with | [] -> [] | h::t -> t;;
let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
let rec matchHeads x y =
  match x with
  | [] -> true
  | h::t ->
      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
let explode s =
  let rec go i =
    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
  go 0;;
let palindrome w =
  match explode w with
  | [] -> true
  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list ---> ?c <--- ?b list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?c`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	                       ^^
//│ ╟── this match expression has type `?c`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?c` and it flows from `?b list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	                                    ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	                       ^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                                   ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ╙──     	                               ^^
//│ ╔══[ERROR] Type `?b list` does not match `?a list`
//│ ║  
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ║           	                               ^^^^^^^
//│ ╟── this operator application has type `?b list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	                                    ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?b list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?b list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                                   ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?a list`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ╙──     	                               ^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	                       ^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                                   ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.2: 	let getTail t = match t with | [] -> [] | h::t -> t;;
//│ ╙──     	                               ^^
//│ ╔══[ERROR] Type `?b list` does not match `?a list`
//│ ║  
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ║           	                               ^^^^^^^
//│ ╟── this operator application has type `?b list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	                                    ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?b list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?b list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                                   ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?a list`
//│ ║  l.2: 	let getTail t = match t with | [] -> [] | h::t -> t;;
//│ ╙──     	                               ^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list <--- ?b ---> ?a0 list 
//│ ║  
//│ ╟── this pattern has type `?a list`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ║       	                               ^^
//│ ╟── this reference has type `?a list`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ║       	                      ^
//│ ╟── this variable has type `?a list`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ║       	            ^
//│ ╟── this reference has type `?a list` and it flows from `?b`
//│ ║  l.9: 	      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
//│ ║       	                                ^
//│ ╟── this variable has type `?b`
//│ ║  l.5: 	let rec matchHeads x y =
//│ ║       	                     ^
//│ ╟── this reference has type `?b`
//│ ║  l.9: 	      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
//│ ║       	                                                              ^
//│ ╟── this variable has type `?b`
//│ ║  l.2: 	let getTail t = match t with | [] -> [] | h::t -> t;;
//│ ║       	            ^
//│ ╟── this reference has type `?b` and it flows into `?a0 list`
//│ ║  l.2: 	let getTail t = match t with | [] -> [] | h::t -> t;;
//│ ║       	                      ^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.2: 	let getTail t = match t with | [] -> [] | h::t -> t;;
//│ ╙──     	                               ^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?b`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                   ^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a0 list` and it flows into `?b`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ╙──      	                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.13: 	  go 0;;
//│ ║        	  ^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                                                ^^^^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ╙──     	                 ^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this `then` branch has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                   ^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.13: 	  go 0;;
//│ ║        	  ^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                                                ^^^^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ╙──     	                 ^^
//│ ╔══[ERROR] Type `string` does not match `?a Array`
//│ ║  
//│ ╟──        string <--- ?b ---> ?a Array 
//│ ║  
//│ ╟── `string` comes from this type expression
//│ ║  builtin: 	let String_length: string -> int
//│ ║           	                   ^^^^^^
//│ ╟── this reference has type `string` and it flows from `?b`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                           ^
//│ ╟── this variable has type `?b`
//│ ║  l.10: 	let explode s =
//│ ║        	            ^
//│ ╟── this reference has type `?b` and it flows into `?a Array`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                            ^
//│ ╟── this array access has type `?a Array`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ╙──      	                                           ^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?b`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                   ^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a0 list` and it flows into `?b`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ╙──      	                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.13: 	  go 0;;
//│ ║        	  ^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                       ^^^^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.7: 	  | [] -> true
//│ ╙──     	    ^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this `then` branch has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                   ^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.13: 	  go 0;;
//│ ║        	  ^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                       ^^^^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.7: 	  | [] -> true
//│ ╙──     	    ^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.13: 	  go 0;;
//│ ║        	  ^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                       ^^^^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ╙──     	                               ^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this `then` branch has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                   ^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.13: 	  go 0;;
//│ ║        	  ^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                       ^^^^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ╙──     	                               ^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list <--- ?b ---> ?a0 list 
//│ ║  
//│ ╟── this pattern has type `?a list`
//│ ║  l.7: 	  | [] -> true
//│ ║       	    ^^
//│ ╟── this reference has type `?a list` and it flows from `?b`
//│ ║  l.6: 	  match x with
//│ ║       	        ^
//│ ╟── this variable has type `?b`
//│ ║  l.5: 	let rec matchHeads x y =
//│ ║       	                   ^
//│ ╟── this reference has type `?b`
//│ ║  l.9: 	      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
//│ ║       	                  ^
//│ ╟── this variable has type `?b`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ║       	            ^
//│ ╟── this reference has type `?b` and it flows into `?a0 list`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ║       	                      ^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.1: 	let getHead h = match h with | [] -> [] | h::t -> h;;
//│ ╙──     	                               ^^
//│ ╔══[ERROR] Type `string` does not match `?a Array`
//│ ║  
//│ ╟──        string <--- ?b ---> ?a Array 
//│ ║  
//│ ╟── `string` comes from this type expression
//│ ║  builtin: 	let String_length: string -> int
//│ ║           	                   ^^^^^^
//│ ╟── this reference has type `string` and it flows from `?b`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                           ^
//│ ╟── this variable has type `?b`
//│ ║  l.10: 	let explode s =
//│ ║        	            ^
//│ ╟── this reference has type `?b` and it flows into `?a Array`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ║        	                                            ^
//│ ╟── this array access has type `?a Array`
//│ ║  l.12: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ╙──      	                                           ^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	                       ^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.4: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list` and it flows into `?b`
//│ ║  l.17: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ║        	                                   ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `?b`
//│ ║  l.5: 	let rec matchHeads x y =
//│ ║       	                     ^
//│ ╟── this application has type `?b`
//│ ║  l.9: 	      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
//│ ║       	                                                     ^^^^^^^^^^^
//│ ╟── this match expression has type `?b` and it flows from `?a0 list`
//│ ║  l.2: 	let getTail t = match t with | [] -> [] | h::t -> t;;
//│ ║       	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a0 list`
//│ ║  l.2: 	let getTail t = match t with | [] -> [] | h::t -> t;;
//│ ╙──     	                                     ^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing


// file 1563
let rec sumListHelper total xs =
  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
let rec digitsOfIntHelper n =
  if n < 1
  then []
  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
let rec digitsOfInt n = digitsOfIntHelper n;;
let rec sumList xs = sumListHelper 0 xs;;
let rec additivePersistence n = sumList digitsOfInt n;;
//│ ╔══[ERROR] Type `int` does not match `?a -> ?b`
//│ ║  
//│ ╟── this function argument has type `int`
//│ ║  l.8: 	let rec sumList xs = sumListHelper 0 xs;;
//│ ║       	                                   ^
//│ ╟── this variable has type `int`
//│ ║  l.1: 	let rec sumListHelper total xs =
//│ ║       	                      ^^^^^
//│ ╟── this reference has type `int`
//│ ║  l.2: 	  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ ║       	                        ^^^^^
//│ ╟── this match expression has type `int`
//│ ║  l.2: 	  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `int`
//│ ║  l.2: 	  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ ║       	                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `int`
//│ ║  l.2: 	  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `int`
//│ ║  l.8: 	let rec sumList xs = sumListHelper 0 xs;;
//│ ║       	                     ^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `int`
//│ ║  l.9: 	let rec additivePersistence n = sumList digitsOfInt n;;
//│ ╙──     	                                ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list ---> ?c <--- ?b list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?c`
//│ ║  l.5: 	  then []
//│ ║       	       ^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.4: 	  if n < 1
//│ ║       	  ^^^^^^^^
//│ ║  l.5: 	  then [] ...
//│ ║       	^^^^^^^^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?c` and it flows from `?b list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?b`
//│ ║  l.5: 	  then []
//│ ║       	       ^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.4: 	  if n < 1
//│ ║       	  ^^^^^^^^
//│ ║  l.5: 	  then [] ...
//│ ║       	^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b` and it flows from `?a0 list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a0 list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ╙──     	                                                                      ^^^
//│ ╔══[ERROR] Type `?b list` does not match `?a list`
//│ ║  
//│ ╟──        ?b list ---> ?c <--- ?a list 
//│ ║  
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ║           	                               ^^^^^^^
//│ ╟── this `then` branch has type `?b list` and it flows into `?c`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a list` and it flows into `?c`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ╙──     	                                                                      ^^^
//│ ╔══[ERROR] Type `?b -> ?c` does not match `?a list`
//│ ║  
//│ ╟── this function has type `?b -> ?c`
//│ ║  l.7: 	let rec digitsOfInt n = digitsOfIntHelper n;;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this recursive binding has type `?b -> ?c`
//│ ║  l.7: 	let rec digitsOfInt n = digitsOfIntHelper n;;
//│ ║       	        ^^^^^^^^^^^
//│ ╟── this pattern has type `?a list`
//│ ║  l.2: 	  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ ╙──     	                  ^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list ---> ?c <--- ?b list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?c`
//│ ║  l.5: 	  then []
//│ ║       	       ^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.4: 	  if n < 1
//│ ║       	  ^^^^^^^^
//│ ║  l.5: 	  then [] ...
//│ ║       	^^^^^^^^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?c` and it flows from `?b list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?b`
//│ ║  l.5: 	  then []
//│ ║       	       ^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.4: 	  if n < 1
//│ ║       	  ^^^^^^^^
//│ ║  l.5: 	  then [] ...
//│ ║       	^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b` and it flows from `?a0 list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a0 list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ╙──     	                                                                      ^^^
//│ ╔══[ERROR] Type `?b list` does not match `?a list`
//│ ║  
//│ ╟──        ?b list ---> ?c <--- ?a list 
//│ ║  
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ║           	                               ^^^^^^^
//│ ╟── this `then` branch has type `?b list` and it flows into `?c`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a list` and it flows into `?c`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ╙──     	                                                                      ^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	                                                                      ^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	         ^^^^^^^
//│ ╔══[ERROR] Type `?b * ?a list` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `?b * ?a list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ╙──     	                                                                       ^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ║       	                                                       ^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                    ^^^^^^^
//│ ╔══[ERROR] Type `?b * ?a list` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `?b * ?a list`
//│ ║  l.6: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
//│ ╙──     	                                                       ^^^^^^^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.UnificationSolver.makeMessagesUR$1(UnificationSolver.scala:229)
//│ 	at: mlscript.UnificationSolver.createErrorMessage(UnificationSolver.scala:275)
//│ 	at: mlscript.UnificationSolver.createErrorMessage$(UnificationSolver.scala:179)
//│ 	at: mlscript.TypeDefs.createErrorMessage(TypeDefs.scala:11)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:169)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:168)
//│ 	at: scala.collection.Iterator$$anon$7.hasNext(Iterator.scala:525)
//│ 	at: scala.collection.immutable.List.prependedAll(List.scala:152)
//│ 	at: scala.collection.IterableOnceOps.toList(IterableOnce.scala:1288)

// file 8776
// TODO list indexing here. skip this example?
let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
let getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;
let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
let rec matchHeads x =
  match explode x with
  | h::t ->
      if (getHeads (explode x)) = []
      then true
      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                                                  ^^
//│ ╟── this match expression has type `?b`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a0 list` and it flows into `?b`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ╙──     	                                                               ^
//│ ╔══[ERROR] Type `?a list` does not match `?b Array`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                                                  ^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.10: 	      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ ║        	                                                 ^^^^^^^^^^^^
//│ ╟── this array access has type `?b Array`
//│ ║  l.-530: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ╙──        	                                           ^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b Array`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                                                               ^
//│ ╟── this match expression has type `?a list`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.10: 	      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ ║        	                                                 ^^^^^^^^^^^^
//│ ╟── this array access has type `?b Array`
//│ ║  l.-530: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ╙──        	                                           ^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b Array`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                                                               ^
//│ ╟── this match expression has type `?a list`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.10: 	      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ ║        	                                                 ^^^^^^^^^^^^
//│ ╟── this array access has type `?b Array`
//│ ║  l.-530: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ╙──        	                                           ^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b Array`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                                                  ^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.4: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.10: 	      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ ║        	                                                 ^^^^^^^^^^^^
//│ ╟── this array access has type `?b Array`
//│ ║  l.-530: 	    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│ ╙──        	                                           ^^^^^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing

// TODO: parse correctly
let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?b`
//│ ║  l.3: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ║       	                                   ^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.3: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a0 list` and it flows into `?b`
//│ ║  l.3: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ╙──     	                                           ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?b | undefined * ?c` does not match `?a * ?a list`
//│ ║  
//│ ╟── this function argument has type `?b | undefined * ?c`
//│ ║  l.3: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ╙──     	                                           ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `error` does not match `int`
//│ ║  
//│ ╟──        error ---> ?a <--- ?b ---> ?c <--- ?d ---> int 
//│ ║  
//│ ╟── this application has type `error` and it flows into `?a`
//│ ║  l.3: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ║       	            ^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?e` and it flows from `?b`
//│ ║  l.3: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ║       	       ^
//│ ╟── this variable has type `?b`
//│ ║  l.2: 	  let rec go i =
//│ ║       	             ^
//│ ╟── this reference has type `?b` and it flows into `?c`
//│ ║  l.3: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ║       	                                                           ^
//│ ╟── this function argument has type `?d` and it flows into `?c`
//│ ║  l.3: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ║       	                                                          ^^^^^^^
//│ ╟── `?d` comes from this type expression and it flows into `int`
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	         ^^^
//│ ╔══[ERROR] identifier not found: String.length
//│ ║  
//│ ║  l.884: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ╙──       	             ^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: s.
//│ ║  
//│ ║  l.884: 	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ╙──       	                                            ^^
//│ explode: error -> list[undefined]

// file 89
// TODO: parse properly
let rec digitsOfInt n =
  let return = [n mod 10] in
  if (n / 10) <> 0
  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)
  else return;;
let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t)
let rec digitalRoot n =
  let digits = digitsOfInt n in
  let s = sumList digits in
  if (n / 10) <> 0
  then (print_int n; print_endline " "; digitalRoot)
  else digits;;
//│ /!\ Parse error: Expected ")":4:29, found "; (digitsO" at l.941:29:   then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)

// file 2361
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
let digits n = digitsOfInt (abs n);;
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.8: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ║       	                         ^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.3: 	let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
//│ ╙──     	                                    ^^
//│ ╔══[ERROR] Type `?a * ?a list` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `?a * ?a list`
//│ ║  l.8: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ╙──     	                          ^^^^^^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── this `else` branch has type `bool`
//│ ║  l.8: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ║       	                                                         ^^^^
//│ ╟── this if-then-else expression has type `bool` and it flows into `?a`
//│ ║  l.8: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?a`
//│ ║  l.6: 	  match digits n with
//│ ║       	  ^^^^^^^^^^^^^^^^^^^
//│ ║  l.7: 	  | [] -> 0 ...
//│ ║       	^^^^^^^^^^^
//│ ╟── this integer literal has type `int` and it flows into `?a`
//│ ║  l.7: 	  | [] -> 0
//│ ╙──     	          ^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list ---> ?c <--- ?b list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?c`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                 ^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?c` and it flows from `?b list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this `then` branch has type `?a list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                 ^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.4: 	let digits n = digitsOfInt (abs n);;
//│ ║       	               ^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.6: 	  match digits n with
//│ ║       	        ^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.7: 	  | [] -> 0
//│ ╙──     	    ^^
//│ ╔══[ERROR] Type `?b list` does not match `?a list`
//│ ║  
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ║           	                               ^^^^^^^
//│ ╟── this `else` branch has type `?b list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?b list`
//│ ║  l.4: 	let digits n = digitsOfInt (abs n);;
//│ ║       	               ^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?b list`
//│ ║  l.6: 	  match digits n with
//│ ║       	        ^^^^^^^^
//│ ╟── this pattern has type `?a list`
//│ ║  l.7: 	  | [] -> 0
//│ ╙──     	    ^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list ---> ?c <--- ?b list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?c`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                 ^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?c` and it flows from `?b list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                                                   ^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                    ^^^^^^^
//│ ╔══[ERROR] Type `?b * ?a list` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `?b * ?a list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ╙──     	                                                   ^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this `then` branch has type `?a list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                 ^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                         ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?b list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                         ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?b list`
//│ ║  l.2: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
//│ ║       	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ digitsOfInt: int -> list[int]
//│ addNumbs: list[int] -> int
//│ digits: int -> list[int]
//│ additivePersistence: int -> (bool | int)

// TODO: Create adts for built in types
// file 358 mod
// type expr used from previous
let buildCosine e = Cosine e;;
let buildSine e = Sine e;;
let buildX () = VarX;;
let buildY () = VarY;;
let rec build (rand,depth) =
  let r = rand 0.4 in
  match depth with
  | 0 -> if (r mod 2) = 0 then buildX else buildY
  | d ->
      if r = 0
      then buildSine build (rand, (d - 1))
      else buildCosine build (rand, (d - 1));;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: could not find type definition d

// TODO file 1337 in separate file to avoid collisions

// file 2752 mod
let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
let x l = List.map string_of_int;;
let y = [1, 2, 3];;
let rec mulByDigit i l =
  match List.rev l with
  | [] -> []
  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this function argument has type `?a list`
//│ ║  l.7: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ║       	                                            ^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let List.rev: 'a list -> 'a list
//│ ╙──         	              ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.7: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ║       	             ^^^^^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	         ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.3: 	let y = [1, 2, 3];;
//│ ║       	        ^^^^^^^^^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let ( * ): int -> int -> int
//│ ╙──         	                  ^^^
//│ ╔══[ERROR] Type `?a -> ?b` does not match `int`
//│ ║  
//│ ╟── this function has type `?a -> ?b`
//│ ║  l.2: 	let x l = List.map string_of_int;;
//│ ║       	      ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `?a -> ?b`
//│ ║  l.7: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ║       	                       ^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let ( * ): int -> int -> int
//│ ╙──         	           ^^^
//│ ╔══[ERROR] Type `?b * ?a list` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `?b * ?a list`
//│ ║  l.7: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ╙──     	             ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `int * int * int * ?a list` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `int * int * int * ?a list`
//│ ║  l.3: 	let y = [1, 2, 3];;
//│ ╙──     	         ^^^^^^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.UnificationSolver.makeMessagesUR$1(UnificationSolver.scala:229)
//│ 	at: mlscript.UnificationSolver.createErrorMessage(UnificationSolver.scala:275)
//│ 	at: mlscript.UnificationSolver.createErrorMessage$(UnificationSolver.scala:179)
//│ 	at: mlscript.TypeDefs.createErrorMessage(TypeDefs.scala:11)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:169)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:168)
//│ 	at: scala.collection.Iterator$$anon$7.hasNext(Iterator.scala:525)
//│ 	at: scala.collection.immutable.List.prependedAll(List.scala:152)
//│ 	at: scala.collection.IterableOnceOps.toList(IterableOnce.scala:1288)


// file 344 mod
let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
let padLength l1 l2 = abs ((List.length l1) - (List.length l2));;
let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then (clone 0 (padLength l1 l2)) :: l1
  else (clone 0 (padLength l1 l2)) l2;;
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?b`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ║       	                                  ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a0 list` and it flows into `?b`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ╙──     	                                                              ^^
//│ ╔══[ERROR] Type `?a list` does not match `?b -> ?c`
//│ ║  
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ║       	                                                              ^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.6: 	  else (clone 0 (padLength l1 l2)) l2;;
//│ ╙──     	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b -> ?c`
//│ ║  
//│ ╟── this `then` branch has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ║       	                                  ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.6: 	  else (clone 0 (padLength l1 l2)) l2;;
//│ ╙──     	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?b`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ║       	                                  ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a0 list` and it flows into `?b`
//│ ║  l.1: 	let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ ╙──     	                                                              ^^
//│ ╔══[ERROR] Type `?b * ?c` does not match `?a * ?a list`
//│ ║  
//│ ╟── this function argument has type `?b * ?c`
//│ ║  l.5: 	  then (clone 0 (padLength l1 l2)) :: l1
//│ ╙──     	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.UnificationSolver.makeMessagesUR$1(UnificationSolver.scala:229)
//│ 	at: mlscript.UnificationSolver.createErrorMessage(UnificationSolver.scala:275)
//│ 	at: mlscript.UnificationSolver.createErrorMessage$(UnificationSolver.scala:179)
//│ 	at: mlscript.TypeDefs.createErrorMessage(TypeDefs.scala:11)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:169)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:168)
//│ 	at: scala.collection.Iterator$$anon$7.hasNext(Iterator.scala:525)
//│ 	at: scala.collection.immutable.List.prependedAll(List.scala:152)
//│ 	at: scala.collection.IterableOnceOps.toList(IterableOnce.scala:1288)

// file 2736 [TODO different part of file has errors]
let rec addHelper (t,u) =
 match List.rev t with
 | [] -> []
 | h::t ->
    match List.rev u with
     | [] -> []
     | h'::t' ->
         if (h + h') > 10
         then (addHelper (t, t')) @ [(1 + h') + h]
         else (addHelper (t, t')) @ [h' + h];;
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ║           	                               ^^^^^^^
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	         ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	                                     ^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                    ^^^^^^^
//│ ╔══[ERROR] Type `?b * ?a list` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `?b * ?a list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ╙──      	                                     ^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.3: 	 | [] -> []
//│ ║       	         ^^
//│ ╟── this match expression has type `?b`
//│ ║  l.2: 	 match List.rev t with
//│ ║       	 ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3: 	 | [] -> [] ...
//│ ║       	^^^^^^^^^^^
//│ ╟── this match expression has type `?b` and it flows from `?a0 list`
//│ ║  l.5: 	    match List.rev u with
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.6: 	     | [] -> [] ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a0 list`
//│ ║  l.6: 	     | [] -> []
//│ ╙──     	             ^^
//│ ╔══[ERROR] Type `?a list * ?a0 list` does not match `?b * ?c`
//│ ║  
//│ ╟── this function argument has type `?a list * ?a0 list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	                         ^^^^^^^
//│ ╟── this tuple literal has type `?b * ?c`
//│ ║  l.1: 	let rec addHelper (t,u) =
//│ ╙──     	                  ^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.9: 	         then (addHelper (t, t')) @ [(1 + h') + h]
//│ ║       	                                     ^^^^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                    ^^^^^^^
//│ ╔══[ERROR] Type `?b * ?a list` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `?b * ?a list`
//│ ║  l.9: 	         then (addHelper (t, t')) @ [(1 + h') + h]
//│ ╙──     	                                     ^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?b list` does not match `?a list`
//│ ║  
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let List.rev: 'a list -> 'a list
//│ ║           	                         ^^^^^^^
//│ ╟── this application has type `?b list`
//│ ║  l.5: 	    match List.rev u with
//│ ║       	          ^^^^^^^^^^
//│ ╟── this pattern has type `?a list`
//│ ║  l.6: 	     | [] -> []
//│ ╙──     	       ^^
//│ ╔══[ERROR] Type `?b list` does not match `?a list`
//│ ║  
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let List.rev: 'a list -> 'a list
//│ ║           	                         ^^^^^^^
//│ ╟── this application has type `?b list`
//│ ║  l.2: 	 match List.rev t with
//│ ║       	       ^^^^^^^^^^
//│ ╟── this pattern has type `?a list`
//│ ║  l.3: 	 | [] -> []
//│ ╙──     	   ^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.6: 	     | [] -> []
//│ ║       	             ^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.5: 	    match List.rev u with
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.6: 	     | [] -> [] ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.2: 	 match List.rev t with
//│ ║       	 ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3: 	 | [] -> [] ...
//│ ║       	^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	              ^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?b list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	              ^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?b list`
//│ ║  l.2: 	 match List.rev t with
//│ ║       	 ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3: 	 | [] -> [] ...
//│ ║       	^^^^^^^^^^^
//│ ╟── this match expression has type `?b list`
//│ ║  l.5: 	    match List.rev u with
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.6: 	     | [] -> [] ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b list`
//│ ║  l.8: 	         if (h + h') > 10
//│ ║       	         ^^^^^^^^^^^^^^^^
//│ ║  l.9: 	         then (addHelper (t, t')) @ [(1 + h') + h] ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?b list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list ---> ?c <--- ?b list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?c`
//│ ║  l.6: 	     | [] -> []
//│ ║       	             ^^
//│ ╟── this match expression has type `?c`
//│ ║  l.5: 	    match List.rev u with
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.6: 	     | [] -> [] ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.8: 	         if (h + h') > 10
//│ ║       	         ^^^^^^^^^^^^^^^^
//│ ║  l.9: 	         then (addHelper (t, t')) @ [(1 + h') + h] ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?c` and it flows from `?b list`
//│ ║  l.9: 	         then (addHelper (t, t')) @ [(1 + h') + h]
//│ ║       	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                               ^^^^^^^
//│ ╔══[ERROR] Type `?b list` does not match `?a list`
//│ ║  
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ║           	                               ^^^^^^^
//│ ╟── this `else` branch has type `?b list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b list`
//│ ║  l.8: 	         if (h + h') > 10
//│ ║       	         ^^^^^^^^^^^^^^^^
//│ ║  l.9: 	         then (addHelper (t, t')) @ [(1 + h') + h] ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?b list`
//│ ║  l.5: 	    match List.rev u with
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.6: 	     | [] -> [] ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?b list`
//│ ║  l.2: 	 match List.rev t with
//│ ║       	 ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3: 	 | [] -> [] ...
//│ ║       	^^^^^^^^^^^
//│ ╟── this application has type `?b list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	              ^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	              ^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.2: 	 match List.rev t with
//│ ║       	 ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3: 	 | [] -> [] ...
//│ ║       	^^^^^^^^^^^
//│ ╟── this reference has type `?a list`
//│ ║  l.3: 	 | [] -> []
//│ ╙──     	         ^^
//│ ╔══[ERROR] Type `?b list` does not match `?a list`
//│ ║  
//│ ╟──        ?b list <--- ?c ---> ?d <--- ?a list 
//│ ║  
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ║           	         ^^^^^^^
//│ ╟── this application has type `?b list` and it flows from `?c`
//│ ║  l.9: 	         then (addHelper (t, t')) @ [(1 + h') + h]
//│ ║       	              ^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?c`
//│ ║  l.2: 	 match List.rev t with
//│ ║       	 ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3: 	 | [] -> [] ...
//│ ║       	^^^^^^^^^^^
//│ ╟── this application has type `?c` and it flows into `?d`
//│ ║  l.10: 	         else (addHelper (t, t')) @ [h' + h];;
//│ ║        	              ^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a list` and it flows into `?d`
//│ ║  l.3: 	 | [] -> []
//│ ╙──     	         ^^
//│ addHelper: (list[int], list[int],) -> list[int]

:e
// file 1948 // TODO disconnected provs
let rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
let bigMul l1 l2 =
  let f a x =
    let (x1,x2) = x in
    let (carry,res) = a in
    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
  let base = (0, []) in
  let args = l1 (tenEx 0 l2) in
  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ /!!!\ Uncaught error: java.lang.StackOverflowError
//│ 	at: mlscript.TypeSimplifier.$anonfun$simplifyType$54(TypeSimplifier.scala:598)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.TypeSimplifier.transform$1(TypeSimplifier.scala:679)
//│ 	at: mlscript.TypeSimplifier.$anonfun$simplifyType$54(TypeSimplifier.scala:664)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.TypeSimplifier.transform$1(TypeSimplifier.scala:679)
//│ 	at: mlscript.TypeSimplifier.mergeTransform$1(TypeSimplifier.scala:588)
//│ 	at: mlscript.TypeSimplifier.$anonfun$simplifyType$69(TypeSimplifier.scala:615)
//│ 	at: mlscript.TypeSimplifier.$anonfun$simplifyType$69$adapted(TypeSimplifier.scala:615)
//│ 	at: scala.Option.fold(Option.scala:263)

// file 335
let fixpointHelper f =
  match f with | (num,expr) -> if expr then (num, true) else (num, false);;
let rec wwhile (f,b) =
  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│ ╔══[ERROR] Type `?a * bool` does not match `?b -> ?c`
//│ ║  
//│ ╟── this tuple literal has type `?a * bool`
//│ ║  l.2: 	  match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│ ║       	                                                             ^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * bool`
//│ ║  l.2: 	  match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│ ║       	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a * bool`
//│ ║  l.2: 	  match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * bool`
//│ ║  l.5: 	let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│ ╙──     	                             ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.5: 	let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│ ║       	                            ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.3: 	let rec wwhile (f,b) =
//│ ╙──     	               ^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a * ?c`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.4: 	  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│ ║       	                                                     ^^^^^^^^
//│ ╟── this tuple literal has type `?a * ?c`
//│ ║  l.3: 	let rec wwhile (f,b) =
//│ ╙──     	               ^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a * ?c`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.4: 	  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│ ║       	                                                     ^^^^^^^^
//│ ╟── this tuple literal has type `?a * ?c`
//│ ║  l.3: 	let rec wwhile (f,b) =
//│ ╙──     	               ^^^^^
//│ fixpointHelper: ('a, bool,) -> ('a, bool,)
//│ wwhile: (('a | 'b) -> ('a & 'b & 'c & 'd, bool,), 'b,) -> 'c
//│   where
//│     'a <: 'c & 'd
//│     'c :> 'a | 'd
//│        <: 'a & 'd
//│     'd :> 'a | 'c
//│        <: 'a & 'c
//│ fixpoint: ((anything, bool,), anything,) -> nothing

// file 3 mod
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let numZeros = (List.length l1) - (List.length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (carry,currentSum) = a in
      if x = []
      then (0, (carry :: currentSum))
      else
        (let (toSum1,toSum2) = x in
         let intermediateValue = (toSum1 + toSum2) + carry in
         let valueToAddToArray = intermediateValue mod 10 in
         let carry = intermediateValue / 10 in
         (carry, (valueToAddToArray :: currentSum))) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                                               ^
//│ ╟── this variable has type `?a list`
//│ ║  l.10: 	let rec removeZero l =
//│ ║        	                   ^
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                                                           ^
//│ ╟── this match expression has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a0 list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ╙──      	                       ^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                       ^^
//│ ╟── this match expression has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                                                           ^
//│ ╟── this variable has type `?b`
//│ ║  l.10: 	let rec removeZero l =
//│ ║        	                   ^
//│ ╟── this application has type `?b`
//│ ║  l.27: 	  removeZero (add (padZero l1 l2));;
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b` and it flows from `?a0 list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                                ^^^
//│ ╟── this 1 element of this tuple has type `?a0 list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ╙──      	        ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                                               ^
//│ ╟── this variable has type `?b`
//│ ║  l.10: 	let rec removeZero l =
//│ ║        	                   ^
//│ ╟── this application has type `?b`
//│ ║  l.27: 	  removeZero (add (padZero l1 l2));;
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b` and it flows from `?a0 list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                                ^^^
//│ ╟── this 1 element of this tuple has type `?a0 list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ╙──      	        ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                       ^^
//│ ╟── this match expression has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                                                           ^
//│ ╟── this variable has type `?b`
//│ ║  l.10: 	let rec removeZero l =
//│ ║        	                   ^
//│ ╟── this application has type `?b`
//│ ║  l.27: 	  removeZero (add (padZero l1 l2));;
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                                ^^^
//│ ╟── this 1 element of this tuple has type `?b` and it flows from `?a0 list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this application has type `?a0 list`
//│ ║  l.23: 	         (carry, (valueToAddToArray :: currentSum))) in
//│ ╙──      	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this 1 element of this tuple has type `?a list` and it flows into `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this application has type `?a0 list` and it flows into `?b`
//│ ║  l.23: 	         (carry, (valueToAddToArray :: currentSum))) in
//│ ╙──      	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                                               ^
//│ ╟── this variable has type `?b`
//│ ║  l.10: 	let rec removeZero l =
//│ ║        	                   ^
//│ ╟── this application has type `?b`
//│ ║  l.27: 	  removeZero (add (padZero l1 l2));;
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                                ^^^
//│ ╟── this 1 element of this tuple has type `?b` and it flows from `?a0 list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this application has type `?a0 list`
//│ ║  l.23: 	         (carry, (valueToAddToArray :: currentSum))) in
//│ ╙──      	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this application has type `?a list` and it flows into `?b`
//│ ║  l.23: 	         (carry, (valueToAddToArray :: currentSum))) in
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this 1 element of this tuple has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this application has type `?a0 list` and it flows into `?b`
//│ ║  l.17: 	      then (0, (carry :: currentSum))
//│ ╙──      	               ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                       ^^
//│ ╟── this match expression has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                                                           ^
//│ ╟── this variable has type `?b`
//│ ║  l.10: 	let rec removeZero l =
//│ ║        	                   ^
//│ ╟── this application has type `?b`
//│ ║  l.27: 	  removeZero (add (padZero l1 l2));;
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                                ^^^
//│ ╟── this 1 element of this tuple has type `?b` and it flows from `?a0 list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this application has type `?a0 list`
//│ ║  l.17: 	      then (0, (carry :: currentSum))
//│ ╙──      	               ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this 1 element of this tuple has type `?a list` and it flows into `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this application has type `?a0 list` and it flows into `?b`
//│ ║  l.17: 	      then (0, (carry :: currentSum))
//│ ╙──      	               ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                                               ^
//│ ╟── this variable has type `?b`
//│ ║  l.10: 	let rec removeZero l =
//│ ║        	                   ^
//│ ╟── this application has type `?b`
//│ ║  l.27: 	  removeZero (add (padZero l1 l2));;
//│ ║        	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                                ^^^
//│ ╟── this 1 element of this tuple has type `?b` and it flows from `?a0 list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this application has type `?a0 list`
//│ ║  l.17: 	      then (0, (carry :: currentSum))
//│ ╙──      	               ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a * ?c`
//│ ║  
//│ ╟──        ?a * ?b ---> ?d <--- ?a * ?c 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b` and it flows into `?d`
//│ ║  l.6: 	  then (l1, l2)
//│ ║       	       ^^^^^^^^
//│ ╟── this if-then-else expression has type `?d`
//│ ║  l.5: 	  if numZeros = 0
//│ ║       	  ^^^^^^^^^^^^^^^
//│ ║  l.6: 	  then (l1, l2) ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?d` and it flows from `?a * ?c`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?a * ?c`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ╙──     	                          ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?b`
//│ ║  
//│ ╟──        ?a * ?b ---> ?d <--- ?c * ?b 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b` and it flows into `?d`
//│ ║  l.6: 	  then (l1, l2)
//│ ║       	       ^^^^^^^^
//│ ╟── this if-then-else expression has type `?d`
//│ ║  l.5: 	  if numZeros = 0
//│ ║       	  ^^^^^^^^^^^^^^^
//│ ║  l.6: 	  then (l1, l2) ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?d` and it flows from `?c * ?b`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?b`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ╙──     	                                                      ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟──        ?a * ?b ---> ?e <--- ?c * ?d 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b` and it flows into `?e`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                          ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?e`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d` and it flows into `?e`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ╙──     	                                                      ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.6: 	  then (l1, l2)
//│ ║       	       ^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.5: 	  if numZeros = 0
//│ ║       	  ^^^^^^^^^^^^^^^
//│ ║  l.6: 	  then (l1, l2) ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b`
//│ ║  l.27: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                  ^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ╙──      	          ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                                      ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.5: 	  if numZeros = 0
//│ ║       	  ^^^^^^^^^^^^^^^
//│ ║  l.6: 	  then (l1, l2) ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b`
//│ ║  l.27: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                  ^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ╙──      	          ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                          ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.5: 	  if numZeros = 0
//│ ║       	  ^^^^^^^^^^^^^^^
//│ ║  l.6: 	  then (l1, l2) ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b`
//│ ║  l.27: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                  ^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ╙──      	          ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list <--- ?c ---> ?b list 
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║           	                             ^^^^^^^
//│ ╟── this reference has type `?a list`
//│ ║  l.25: 	    let args = List.rev (List.combine l1 l2) in
//│ ║        	                                         ^^
//│ ╟── this variable has type `?a list`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ║        	              ^^
//│ ╟── this reference has type `?a list` and it flows from `?c`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                                                         ^^
//│ ╟── this variable has type `?c`
//│ ║  l.2: 	let padZero l1 l2 =
//│ ║       	               ^^
//│ ╟── this reference has type `?c` and it flows into `?b list`
//│ ║  l.3: 	  let numZeros = (List.length l1) - (List.length l2) in
//│ ║       	                                                 ^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let List.length: 'a list -> int
//│ ╙──         	                 ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list <--- ?c ---> ?b list 
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.length: 'a list -> int
//│ ║           	                 ^^^^^^^
//│ ╟── this reference has type `?a list` and it flows from `?c`
//│ ║  l.3: 	  let numZeros = (List.length l1) - (List.length l2) in
//│ ║       	                                                 ^^
//│ ╟── this variable has type `?c`
//│ ║  l.2: 	let padZero l1 l2 =
//│ ║       	               ^^
//│ ╟── this reference has type `?c` and it flows into `?b list`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                            ^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                    ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list <--- ?c ---> ?b list 
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║           	                             ^^^^^^^
//│ ╟── this reference has type `?a list`
//│ ║  l.25: 	    let args = List.rev (List.combine l1 l2) in
//│ ║        	                                         ^^
//│ ╟── this variable has type `?a list`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ║        	              ^^
//│ ╟── this reference has type `?a list` and it flows from `?c`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                                                         ^^
//│ ╟── this variable has type `?c`
//│ ║  l.2: 	let padZero l1 l2 =
//│ ║       	               ^^
//│ ╟── this reference has type `?c` and it flows into `?b list`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                            ^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                    ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list <--- ?c ---> ?b list 
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║           	                  ^^^^^^^
//│ ╟── this reference has type `?a list`
//│ ║  l.25: 	    let args = List.rev (List.combine l1 l2) in
//│ ║        	                                      ^^
//│ ╟── this variable has type `?a list`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ║        	           ^^
//│ ╟── this reference has type `?a list` and it flows from `?c`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                           ^^
//│ ╟── this variable has type `?c`
//│ ║  l.2: 	let padZero l1 l2 =
//│ ║       	            ^^
//│ ╟── this reference has type `?c` and it flows into `?b list`
//│ ║  l.3: 	  let numZeros = (List.length l1) - (List.length l2) in
//│ ║       	                              ^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let List.length: 'a list -> int
//│ ╙──         	                 ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list <--- ?c ---> ?b list 
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║           	                  ^^^^^^^
//│ ╟── this reference has type `?a list`
//│ ║  l.25: 	    let args = List.rev (List.combine l1 l2) in
//│ ║        	                                      ^^
//│ ╟── this variable has type `?a list`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ║        	           ^^
//│ ╟── this reference has type `?a list` and it flows from `?c`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                           ^^
//│ ╟── this variable has type `?c`
//│ ║  l.2: 	let padZero l1 l2 =
//│ ║       	            ^^
//│ ╟── this reference has type `?c` and it flows into `?b list`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                                                    ^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                    ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list <--- ?c ---> ?b list 
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.length: 'a list -> int
//│ ║           	                 ^^^^^^^
//│ ╟── this reference has type `?a list` and it flows from `?c`
//│ ║  l.3: 	  let numZeros = (List.length l1) - (List.length l2) in
//│ ║       	                              ^^
//│ ╟── this variable has type `?c`
//│ ║  l.2: 	let padZero l1 l2 =
//│ ║       	            ^^
//│ ╟── this reference has type `?c` and it flows into `?b list`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                                                    ^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                    ^^^^^^^
//│ ╔══[ERROR] Type `int * ?a` does not match `?b * ?c`
//│ ║  
//│ ╟──        int * ?a ---> ?d <--- ?b * ?c 
//│ ║  
//│ ╟── this tuple literal has type `int * ?a` and it flows into `?d`
//│ ║  l.17: 	      then (0, (carry :: currentSum))
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?d`
//│ ║  l.16: 	      if x = []
//│ ║        	      ^^^^^^^^^
//│ ║  l.17: 	      then (0, (carry :: currentSum)) ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?d` and it flows from `?b * ?c`
//│ ║  l.19: 	        (let (toSum1,toSum2) = x in
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.20: 	         let intermediateValue = (toSum1 + toSum2) + carry in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?b * ?c`
//│ ║  l.23: 	         (carry, (valueToAddToArray :: currentSum))) in
//│ ╙──      	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?b * ?c` does not match `int * ?a list`
//│ ║  
//│ ╟──        ?b * ?c ---> ?d <--- int * ?a list 
//│ ║  
//│ ╟── this tuple literal has type `?b * ?c`
//│ ║  l.23: 	         (carry, (valueToAddToArray :: currentSum))) in
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b * ?c`
//│ ║  l.19: 	        (let (toSum1,toSum2) = x in
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.20: 	         let intermediateValue = (toSum1 + toSum2) + carry in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b * ?c`
//│ ║  l.16: 	      if x = []
//│ ║        	      ^^^^^^^^^
//│ ║  l.17: 	      then (0, (carry :: currentSum)) ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b * ?c` and it flows into `?d`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.16: 	      if x = [] ...
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── this application has type `?d`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?d` and it flows from `int * ?a list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                   ^^^^
//│ ╟── this tuple literal has type `int * ?a list`
//│ ║  l.24: 	    let base = (0, []) in
//│ ╙──      	               ^^^^^^^
//│ ╔══[ERROR] Type `int * ?b` does not match `int * ?a list`
//│ ║  
//│ ╟──        int * ?b ---> ?c <--- int * ?a list 
//│ ║  
//│ ╟── this tuple literal has type `int * ?b`
//│ ║  l.17: 	      then (0, (carry :: currentSum))
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `int * ?b`
//│ ║  l.16: 	      if x = []
//│ ║        	      ^^^^^^^^^
//│ ║  l.17: 	      then (0, (carry :: currentSum)) ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `int * ?b` and it flows into `?c`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.16: 	      if x = [] ...
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── this application has type `?c`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?c` and it flows from `int * ?a list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                   ^^^^
//│ ╟── this tuple literal has type `int * ?a list`
//│ ║  l.24: 	    let base = (0, []) in
//│ ╙──      	               ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.23: 	         (carry, (valueToAddToArray :: currentSum))) in
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a * ?b`
//│ ║  l.19: 	        (let (toSum1,toSum2) = x in
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.20: 	         let intermediateValue = (toSum1 + toSum2) + carry in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.16: 	      if x = []
//│ ║        	      ^^^^^^^^^
//│ ║  l.17: 	      then (0, (carry :: currentSum)) ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a * ?b`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.16: 	      if x = [] ...
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?c * ?d`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ╙──      	        ^^^^^^^
//│ ╔══[ERROR] Type `int * ?a` does not match `?b * ?c`
//│ ║  
//│ ╟── this tuple literal has type `int * ?a`
//│ ║  l.17: 	      then (0, (carry :: currentSum))
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `int * ?a`
//│ ║  l.16: 	      if x = []
//│ ║        	      ^^^^^^^^^
//│ ║  l.17: 	      then (0, (carry :: currentSum)) ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `int * ?a`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.16: 	      if x = [] ...
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── this application has type `int * ?a`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?b * ?c`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ╙──      	        ^^^^^^^
//│ ╔══[ERROR] Type `int * ?a list` does not match `?b * ?c`
//│ ║  
//│ ╟── this tuple literal has type `int * ?a list`
//│ ║  l.24: 	    let base = (0, []) in
//│ ║        	               ^^^^^^^
//│ ╟── this function argument has type `int * ?a list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                   ^^^^
//│ ╟── this application has type `int * ?a list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?b * ?c`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ╙──      	        ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.rev: 'a list -> 'a list
//│ ║           	                         ^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.25: 	    let args = List.rev (List.combine l1 l2) in
//│ ║        	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `?a list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                        ^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│ ╙──         	                                               ^^^^^^^
//│ ╔══[ERROR] Type `int * ?a list` does not match `?b * ?c`
//│ ║  
//│ ╟── this tuple literal has type `int * ?a list`
//│ ║  l.24: 	    let base = (0, []) in
//│ ║        	               ^^^^^^^
//│ ╟── this function argument has type `int * ?a list`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                   ^^^^
//│ ╟── this pattern has type `?b * ?c`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ╙──      	          ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟──        ?a * ?b <--- ?e ---> ?c * ?d 
//│ ║  
//│ ╟── this pattern has type `?a * ?b` and it flows from `?e`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	        ^^^^^^^
//│ ╟── this application has type `?e`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `?f`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                   ^^^^
//│ ╟── this variable has type `?f`
//│ ║  l.14: 	    let f a x =
//│ ║        	          ^
//│ ╟── this reference has type `?f` and it flows into `?c * ?d`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ║        	                               ^
//│ ╟── this pattern has type `?c * ?d`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ╙──      	          ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟──        ?a * ?b ---> ?e <--- ?f ---> ?c * ?d 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.23: 	         (carry, (valueToAddToArray :: currentSum))) in
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a * ?b`
//│ ║  l.19: 	        (let (toSum1,toSum2) = x in
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.20: 	         let intermediateValue = (toSum1 + toSum2) + carry in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.16: 	      if x = []
//│ ║        	      ^^^^^^^^^
//│ ║  l.17: 	      then (0, (carry :: currentSum)) ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a * ?b` and it flows into `?e`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.16: 	      if x = [] ...
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── this application has type `?e`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `?f` and it flows into `?e`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                   ^^^^
//│ ╟── this variable has type `?f`
//│ ║  l.14: 	    let f a x =
//│ ║        	          ^
//│ ╟── this reference has type `?f` and it flows into `?c * ?d`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ║        	                               ^
//│ ╟── this pattern has type `?c * ?d`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ╙──      	          ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `int * ?a` does not match `?b * ?c`
//│ ║  
//│ ╟──        int * ?a ---> ?d <--- ?e ---> ?b * ?c 
//│ ║  
//│ ╟── this tuple literal has type `int * ?a`
//│ ║  l.17: 	      then (0, (carry :: currentSum))
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `int * ?a`
//│ ║  l.16: 	      if x = []
//│ ║        	      ^^^^^^^^^
//│ ║  l.17: 	      then (0, (carry :: currentSum)) ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `int * ?a` and it flows into `?d`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.16: 	      if x = [] ...
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── this application has type `?d`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `?e` and it flows into `?d`
//│ ║  l.26: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                                   ^^^^
//│ ╟── this variable has type `?e`
//│ ║  l.14: 	    let f a x =
//│ ║        	          ^
//│ ╟── this reference has type `?e` and it flows into `?b * ?c`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ║        	                               ^
//│ ╟── this pattern has type `?b * ?c`
//│ ║  l.15: 	      let (carry,currentSum) = a in
//│ ╙──      	          ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── `?a * ?b` comes from this type expression
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║           	                                         ^^^^^^^
//│ ╟── this pattern has type `?c * ?d`
//│ ║  l.19: 	        (let (toSum1,toSum2) = x in
//│ ╙──      	             ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b list` does not match `?c list`
//│ ║  
//│ ╟── `?a * ?b list` comes from this type expression
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║           	                                         ^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b list`
//│ ║  l.25: 	    let args = List.rev (List.combine l1 l2) in
//│ ║        	                        ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `?c list` comes from this type expression
//│ ║  builtin: 	let List.rev: 'a list -> 'a list
//│ ╙──         	              ^^^^^^^
//│ ╔══[ERROR] Type `?b * ?c` does not match `?a * ?a list`
//│ ║  
//│ ╟── this function argument has type `?b * ?c`
//│ ║  l.23: 	         (carry, (valueToAddToArray :: currentSum))) in
//│ ╙──      	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `int` does not match `?a -> ?b`
//│ ║  
//│ ╟──        int <--- ?c ---> ?a -> ?b 
//│ ║  
//│ ╟── `int` comes from this type expression and it flows from `?c`
//│ ║  builtin: 	let ( / ): int -> int -> int
//│ ║           	           ^^^
//│ ╟── this function argument has type `?c`
//│ ║  l.22: 	         let carry = intermediateValue / 10 in
//│ ║        	                     ^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?d` and it flows into `?a -> ?b`
//│ ║  l.20: 	         let intermediateValue = (toSum1 + toSum2) + carry in
//│ ║        	                                 ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a -> ?b`
//│ ║  l.21: 	         let valueToAddToArray = intermediateValue mod 10 in
//│ ╙──      	                                 ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?b * ?c` does not match `?a * ?a list`
//│ ║  
//│ ╟── this function argument has type `?b * ?c`
//│ ║  l.17: 	      then (0, (carry :: currentSum))
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                       ^^
//│ ╟── this match expression has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ║        	                                                           ^
//│ ╟── this variable has type `?b` and it flows from `?a0 list`
//│ ║  l.10: 	let rec removeZero l =
//│ ║        	                   ^
//│ ╟── this reference has type `?a0 list`
//│ ║  l.11: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ╙──      	                                               ^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this `then` branch has type `?a list` and it flows into `?b`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                                   ^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a0 list` and it flows into `?b`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ╙──     	                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.8: 	    (let listZeros = clone 0 absNumZeros in
//│ ║       	                     ^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `?a list`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                                        ^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	         ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this `then` branch has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                                   ^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.8: 	    (let listZeros = clone 0 absNumZeros in
//│ ║       	                     ^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `?a list`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                                        ^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	         ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this `else` branch has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.8: 	    (let listZeros = clone 0 absNumZeros in
//│ ║       	                     ^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `?a list`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                ^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	         ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this `then` branch has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                                   ^^
//│ ╟── this if-then-else expression has type `?a list`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.8: 	    (let listZeros = clone 0 absNumZeros in
//│ ║       	                     ^^^^^^^^^^^^^^^^^^^
//│ ╟── this function argument has type `?a list`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                ^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	         ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟──        ?a * ?b ---> ?e <--- ?c * ?d 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b` and it flows into `?e`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                                      ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?e`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d` and it flows into `?e`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ╙──     	                          ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a * ?c`
//│ ║  
//│ ╟──        ?a * ?b ---> ?d <--- ?a * ?c 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b` and it flows into `?d`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                          ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?d`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?e` and it flows from `?a * ?c`
//│ ║  l.5: 	  if numZeros = 0
//│ ║       	  ^^^^^^^^^^^^^^^
//│ ║  l.6: 	  then (l1, l2) ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?a * ?c`
//│ ║  l.6: 	  then (l1, l2)
//│ ╙──     	       ^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?b`
//│ ║  
//│ ╟──        ?a * ?b ---> ?d <--- ?c * ?b 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b` and it flows into `?d`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	                                                      ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?d`
//│ ║  l.9: 	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?e` and it flows from `?c * ?b`
//│ ║  l.5: 	  if numZeros = 0
//│ ║       	  ^^^^^^^^^^^^^^^
//│ ║  l.6: 	  then (l1, l2) ...
//│ ║       	^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?b`
//│ ║  l.6: 	  then (l1, l2)
//│ ╙──     	       ^^^^^^^^
//│ ╔══[ERROR] Type `?b * ?c` does not match `?a * ?a list`
//│ ║  
//│ ╟── this function argument has type `?b * ?c`
//│ ║  l.1: 	let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
//│ ╙──     	                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?b * ?c` does not match `?a list`
//│ ║  
//│ ╟──        ?b * ?c ---> ?d <--- ?a list 
//│ ║  
//│ ╟── `?b * ?c` comes from this type expression and it flows into `?d`
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║           	                                         ^^^^^^^
//│ ╟── this reference has type `?a list` and it flows into `?e`
//│ ║  l.16: 	      if x = []
//│ ╙──      	             ^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.UnificationSolver.makeMessagesUR$1(UnificationSolver.scala:229)
//│ 	at: mlscript.UnificationSolver.createErrorMessage(UnificationSolver.scala:275)
//│ 	at: mlscript.UnificationSolver.createErrorMessage$(UnificationSolver.scala:179)
//│ 	at: mlscript.TypeDefs.createErrorMessage(TypeDefs.scala:11)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:169)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:168)
//│ 	at: scala.collection.Iterator$$anon$7.hasNext(Iterator.scala:525)
//│ 	at: scala.collection.immutable.List.prependedAll(List.scala:152)
//│ 	at: scala.collection.IterableOnceOps.toList(IterableOnce.scala:1288)

// file 1935
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let addTuple (l1,l2) = l1 + l2;;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a + x) mod 10 in
    let base = 0 in
    let args = List.map addTuple (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this `else` branch has type `?a list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ ║        	                                                                    ^^^^^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.11: 	  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ ║        	                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a0 list` and it flows into `?b`
//│ ║  l.11: 	  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ ╙──      	                       ^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟──        ?a * ?b ---> ?e <--- ?c * ?d 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b` and it flows into `?e`
//│ ║  l.5: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?e`
//│ ║  l.4: 	  if (List.length l1) > (List.length l2)
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.5: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?e` and it flows from `?c * ?d`
//│ ║  l.7: 	    if (List.length l1) < (List.length l2)
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.8: 	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.8: 	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ╙──     	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?b`
//│ ║  
//│ ╟──        ?a * ?b ---> ?d <--- ?c * ?b 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b` and it flows into `?d`
//│ ║  l.8: 	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ║       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?d`
//│ ║  l.7: 	    if (List.length l1) < (List.length l2)
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.8: 	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?b` and it flows into `?d`
//│ ║  l.9: 	    else (l1, l2);;
//│ ╙──     	         ^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a * ?c`
//│ ║  
//│ ╟──        ?a * ?b ---> ?d <--- ?a * ?c 
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b` and it flows into `?d`
//│ ║  l.5: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?d`
//│ ║  l.4: 	  if (List.length l1) > (List.length l2)
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.5: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?d` and it flows from `?a * ?c`
//│ ║  l.7: 	    if (List.length l1) < (List.length l2)
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.8: 	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?a * ?c`
//│ ║  l.9: 	    else (l1, l2);;
//│ ╙──     	         ^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.8: 	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ║       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.7: 	    if (List.length l1) < (List.length l2)
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.8: 	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.4: 	  if (List.length l1) > (List.length l2)
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.5: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b`
//│ ║  l.18: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                  ^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ╙──      	          ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.9: 	    else (l1, l2);;
//│ ║       	         ^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.7: 	    if (List.length l1) < (List.length l2)
//│ ║       	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.8: 	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.4: 	  if (List.length l1) > (List.length l2)
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.5: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b`
//│ ║  l.18: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                  ^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ╙──      	          ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.5: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a * ?b`
//│ ║  l.4: 	  if (List.length l1) > (List.length l2)
//│ ║       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.5: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b`
//│ ║  l.18: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                  ^^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ╙──      	          ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟──        ?a list <--- ?c ---> ?b list 
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║           	                             ^^^^^^^
//│ ╟── this reference has type `?a list`
//│ ║  l.16: 	    let args = List.map addTuple (List.combine l1 l2) in
//│ ║        	                                                  ^^
//│ ╟── this variable has type `?a list`
//│ ║  l.13: 	  let add (l1,l2) =
//│ ║        	              ^^
//│ ╟── this reference has type `?a list` and it flows from `?c`
//│ ║  l.9: 	    else (l1, l2);;
//│ ║       	              ^^
//│ ╟── this variable has type `?c`
//│ ║  l.3: 	let padZero l1 l2 =
//│ ║       	               ^^
//│ ╟── this reference has type `?c` and it flows into `?b list`
//│ ║  l.4: 	  if (List.length l1) > (List.length l2)
//│ ║       	                                     ^^
//│ ╟── this applied type reference has type `?b list`
//│ ║  builtin: 	let List.length: 'a list -> int
//│ ╙──         	                 ^^^^^^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.UnificationSolver.makeMessagesUR$1(UnificationSolver.scala:229)
//│ 	at: mlscript.UnificationSolver.createErrorMessage(UnificationSolver.scala:275)
//│ 	at: mlscript.UnificationSolver.createErrorMessage$(UnificationSolver.scala:179)
//│ 	at: mlscript.TypeDefs.createErrorMessage(TypeDefs.scala:11)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:169)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:168)
//│ 	at: scala.collection.Iterator$$anon$7.hasNext(Iterator.scala:525)
//│ 	at: scala.collection.immutable.List.prependedAll(List.scala:152)
//│ 	at: scala.collection.IterableOnceOps.toList(IterableOnce.scala:1288)



// file 1907
let intboolf f x = ((f x), ((f x) < 1));;
let fixpoint (f,b) = wwhile (intboolf, b);;
let rec wwhile (f,b) =
  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a * ?c`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.4: 	  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;
//│ ║       	                                                ^^^^^^^
//│ ╟── this tuple literal has type `?a * ?c`
//│ ║  l.3: 	let rec wwhile (f,b) =
//│ ╙──     	               ^^^^^
//│ ╔══[ERROR] Type `?a -> ?b -> ?c * ?d * ?e` does not match `?f * ?g`
//│ ║  
//│ ╟── this function argument has type `?a -> ?b -> ?c * ?d * ?e`
//│ ║  l.2: 	let fixpoint (f,b) = wwhile (intboolf, b);;
//│ ║       	                            ^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?f * ?g`
//│ ║  l.-1193: 	let rec wwhile (f,b) =
//│ ╙──         	               ^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a * ?c`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.-1192: 	  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│ ║           	                                                     ^^^^^^^^
//│ ╟── this tuple literal has type `?a * ?c`
//│ ║  l.-1193: 	let rec wwhile (f,b) =
//│ ╙──         	               ^^^^^
//│ ╔══[ERROR] Type `?a -> ?b * ?c` does not match `?d * ?e`
//│ ║  
//│ ╟── this function has type `?a -> ?b * ?c`
//│ ║  l.1: 	let intboolf f x = ((f x), ((f x) < 1));;
//│ ║       	               ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a -> ?b * ?c`
//│ ║  l.-1192: 	  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│ ║           	        ^^^
//│ ╟── this pattern has type `?d * ?e`
//│ ║  l.-1192: 	  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│ ╙──         	                   ^^^^^^^^^^
//│ intboolf: ('a -> 'b) -> 'a -> ('b, bool,)
//│ fixpoint: (anything, nothing -> anything,) -> nothing
//│ wwhile: (('a | 'b) -> ('a & 'b & 'c & 'd, bool,), 'b,) -> 'c
//│   where
//│     'a <: 'c & 'd
//│     'c :> 'a | 'd
//│        <: 'a & 'd
//│     'd :> 'a | 'c
//│        <: 'a & 'c



// file 2047
let identity a = a;;
let pipe fs =
  let f a x = a x in let base = identity in List.fold_left f base fs;;
//│ identity: 'a -> 'a
//│ pipe: list['a & 'b & 'c & 'd & 'e] -> ('a | 'b | 'd | 'e)
//│   where
//│     'a :> ('a & 'b & 'c & 'e) -> ('b | 'd) | 'b | 'd | 'e
//│        <: 'c
//│     'c <: 'd -> 'e
//│     'e :> 'b | 'd
//│        <: 'a & 'c


// file 830
// TODO: fix how match case is done
let modulus ss = ss mod 10;;
let rec digitsOfInt n =
  if n <= 0
  then []
  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;
let lt10 q = q < 10;;
let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
let rec additivePersistence n =
  if lt10 n
  then n
  else
    (match n with
     | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: could not find type definition x


// FIXME investigate
// file 1770 (TODO fix nested flows)
let rec filter l a =
  match l with
  | [] -> []
  | h::t -> if a = h then filter t a else h :: (filter t a);;
let removeDuplicates l =
  let rec helper (seen,rest) =
    match rest with
    | [] -> seen
    | h::t ->
        let seen' = h in
        let rest' = h :: (filter (t h)) in helper (seen', rest') in
  List.rev (helper ([], l));;
//│ ╔══[ERROR] Type `?a list` does not match `?b list`
//│ ║  
//│ ╟── this variable has type `?a list`
//│ ║  l.6: 	  let rec helper (seen,rest) =
//│ ║       	                  ^^^^
//│ ╟── this reference has type `?a list`
//│ ║  l.8: 	    | [] -> seen
//│ ║       	            ^^^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.7: 	    match rest with
//│ ║       	    ^^^^^^^^^^^^^^^
//│ ║  l.8: 	    | [] -> seen ...
//│ ║       	^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.11: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ║        	                                           ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.7: 	    match rest with
//│ ║       	    ^^^^^^^^^^^^^^^
//│ ║  l.8: 	    | [] -> seen ...
//│ ║       	^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.12: 	  List.rev (helper ([], l));;
//│ ║        	           ^^^^^^^^^^^^^^^^
//│ ╟── `?b list` comes from this type expression
//│ ║  builtin: 	let List.rev: 'a list -> 'a list
//│ ╙──         	              ^^^^^^^
//│ ╔══[ERROR] Type `?a list * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this function argument has type `?a list * ?b`
//│ ║  l.12: 	  List.rev (helper ([], l));;
//│ ║        	                   ^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.6: 	  let rec helper (seen,rest) =
//│ ╙──     	                 ^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.11: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ║        	                                                  ^^^^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.6: 	  let rec helper (seen,rest) =
//│ ╙──     	                 ^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.11: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?a0 list`
//│ ║  l.8: 	    | [] -> seen
//│ ╙──     	      ^^
//│ ╔══[ERROR] Type `?b -> ?c` does not match `?a list`
//│ ║  
//│ ╟── this function has type `?b -> ?c`
//│ ║  l.1: 	let rec filter l a =
//│ ║       	                 ^^^
//│ ║  l.2: 	  match l with ...
//│ ║       	^^^^^^^^^^^^^^
//│ ╟── this application has type `?b -> ?c`
//│ ║  l.11: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ╙──      	                         ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?b`
//│ ║  l.3: 	  | [] -> []
//│ ║       	          ^^
//│ ╟── this match expression has type `?b`
//│ ║  l.2: 	  match l with
//│ ║       	  ^^^^^^^^^^^^
//│ ║  l.3: 	  | [] -> [] ...
//│ ║       	^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b` and it flows from `?a0 list`
//│ ║  l.4: 	  | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a0 list`
//│ ║  l.4: 	  | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ ╙──     	                                          ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.11: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ╙──      	                    ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a0 * ?a0 list`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.4: 	  | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ ╙──     	                                          ^^^^^^^^^^^^^^^^^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing


// file 0221
let fu x b = (x, (b < (x b)));;
let rec wwhile (f,b) =
  let temp = f b in
  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;
let fixpoint (f,b) = wwhile ((fu f), b);;
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.5: 	let fixpoint (f,b) = wwhile ((fu f), b);;
//│ ║       	                            ^^^^^^^^^^^
//│ ╟── this tuple literal has type `?c * ?d`
//│ ║  l.2: 	let rec wwhile (f,b) =
//│ ╙──     	               ^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a * ?c`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.4: 	  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;
//│ ║       	                                                          ^^^^^^
//│ ╟── this tuple literal has type `?a * ?c`
//│ ║  l.2: 	let rec wwhile (f,b) =
//│ ╙──     	               ^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.1: 	let fu x b = (x, (b < (x b)));;
//│ ║       	             ^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b`
//│ ║  l.3: 	  let temp = f b in
//│ ║       	             ^^^
//│ ╟── this pattern has type `?c * ?d`
//│ ║  l.4: 	  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;
//│ ╙──     	                    ^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?a * ?c`
//│ ║  
//│ ╟── this function argument has type `?a * ?b`
//│ ║  l.4: 	  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;
//│ ║       	                                                          ^^^^^^
//│ ╟── this tuple literal has type `?a * ?c`
//│ ║  l.2: 	let rec wwhile (f,b) =
//│ ╙──     	               ^^^^^
//│ fu: ('a -> anything & 'b) -> 'a -> ('b, bool,)
//│ wwhile: (('a | 'b) -> ('a & 'b & 'c & 'd, bool,), 'b,) -> 'c
//│   where
//│     'a <: 'c & 'd
//│     'c :> 'a | 'd
//│        <: 'a & 'd
//│     'd :> 'a | 'c
//│        <: 'a & 'c
//│ fixpoint: (('a | 'b) -> anything & 'a & 'b & 'c & 'd, 'a,) -> ('d | 'b)
//│   where
//│     'b <: 'c & 'd
//│     'c :> 'd | 'b
//│        <: 'b & 'd
//│     'd :> 'c | 'b
//│        <: 'b & 'c

// file 2338
:unify
let rec assoc (d,k,l) =
  match l with
  | [] -> d
  | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.UnificationSolver.makeMessagesUR$1(UnificationSolver.scala:244)
//│ 	at: mlscript.UnificationSolver.createErrorMessage(UnificationSolver.scala:275)
//│ 	at: mlscript.UnificationSolver.createErrorMessage$(UnificationSolver.scala:179)
//│ 	at: mlscript.TypeDefs.createErrorMessage(TypeDefs.scala:11)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:169)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:168)
//│ 	at: scala.collection.Iterator$$anon$7.hasNext(Iterator.scala:525)
//│ 	at: scala.collection.immutable.List.prependedAll(List.scala:155)
//│ 	at: scala.collection.IterableOnceOps.toList(IterableOnce.scala:1288)
