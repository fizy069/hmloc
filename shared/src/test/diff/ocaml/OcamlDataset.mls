:AllowTypeErrors

// file 246
let rec cloneHelper x n l =
  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;
let rec clone x n = if n < 1 then [] else cloneHelper x n [];;
let padZero l1 l2 =
  let diff = (List.length l1) - (List.length l2) in
  if diff < 0
  then (((clone 0 (-1 * diff)) @ l1), l2)
  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = padZero l1 l2 in
    let base = List.combine l1 l2 in
    let args = failwith "to be implemented" in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `(_ * _) list` does not match `_ * _`
//│ 
//│         ((_ * _) list) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ ((_ * _) list) is here
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ │  - l.16     let (_,res) = List.fold_left f base args in res in
//│ │                                            ^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.16     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ [ERROR] Type `(_ * _) list` does not match `_ list * _`
//│ 
//│         ((_ * _) list) ---> (?a) ~~~~ (?b) <--- (_ list * _)
//│ 
//│ ◉ ((_ * _) list) is here
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│     ◉ (?a -> _ -> ?a) is here
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.16     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) is here
//│        - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ ▲  - l.6    if diff < 0
//│ │           ^^^^^^^^^^^
//│ │           then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list * _) is here
//│    - l.7    then (((clone 0 (-1 * diff)) @ l1), l2)
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `(_ * _) list` does not match `_ * _ list`
//│ 
//│         ((_ * _) list) ---> (?a) ~~~~ (?b) <--- (?c) <--- (_ * _ list)
//│ 
//│ ◉ ((_ * _) list) is here
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│     ◉ (?a -> _ -> ?a) is here
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.16     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) is here
//│        - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ ▲  - l.6    if diff < 0
//│ │           ^^^^^^^^^^^
//│ │           then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed here
//│ ▲  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ * _ list) is here
//│    - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `(_ * _) list` does not match `_ * _`
//│ 
//│         ((_ * _) list) ---> (?a) ~~~~ (?b) <--- (?c) <--- (_ * _)
//│ 
//│ ◉ ((_ * _) list) is here
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│     ◉ (?a -> _ -> ?a) is here
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.16     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) is here
//│        - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ ▲  - l.6    if diff < 0
//│ │           ^^^^^^^^^^^
//│ │           then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed here
//│ ▲  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ * _) is here
//│    - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                    ^^^^^^^^
//│ cloneHelper: 'a -> int -> ('b & 'c & list['a]) -> 'b
//│   where
//│     'b :> list['a] | 'c
//│        <: 'c
//│     'c :> 'b | list['a]
//│        <: 'b
//│ clone: 'a -> int -> (list[nothing] | list['a])
//│ padZero: (list['a] & list[?]) -> (list['b] & list[?]) -> (? | list['a], ? | list['b],)
//│ removeZero: ('b & 'c & 'd & list['a]) -> 'c
//│   where
//│     'b :> 'c | 'd | list[nothing] | list['a]
//│        <: 'c & 'd
//│     'c :> list[nothing] | 'b | 'd | list['a]
//│        <: 'b & 'd
//│     'd :> 'c | list[nothing] | 'b | list['a]
//│        <: 'b & 'c
//│ bigAdd: list[?] -> (list['a] & 'b & 'c & 'd & list[?] & list['a & 'e] & list['a & 'e & 'f]) -> ('c | 'd | 'b | list[int | 'f] | list[int | 'f | 'e] | list[int | 'f | 'e | 'a] | list[nothing])
//│   where
//│     'b :> list[int | 'f] | list[int | 'f | 'e] | 'c | list[nothing] | 'd | list[int | 'f | 'e | 'a]
//│        <: 'd & 'c
//│     'c :> list[int | 'f] | list[int | 'f | 'e] | list[nothing] | 'd | 'b | list[int | 'f | 'e | 'a]
//│        <: 'd & 'b
//│     'd :> list[int | 'f] | list[int | 'f | 'e] | 'c | 'b | list[nothing] | list[int | 'f | 'e | 'a]
//│        <: 'c & 'b
//│ U max: 22, total: 246
//│ UERR 4 errors
//│ L: 2 [list[([α328''], [α329''],)] ~ ([[α273'']], [[list[α297'']]],), list[([α328''], [α329''],)] <: α336'', [α336'' - (α337'' -> α336'') ~ (α339'' -> [α320'']) - α320'', L: 1 [(α337'' -> α336'') ~ (α339'' -> [α320'']), [(α337'' -> α336'') - (α336'' -> (α337'' -> α336'')) ~ (α338'' -> (α339'' -> [α320''])) - (α339'' -> [α320'']), L: 0 [(α336'' -> (α337'' -> α336'')) ~ (α338'' -> (α339'' -> [α320''])), (α336'' -> (α337'' -> α336'')) :> (α338'' -> (α339'' -> [α320'']))]]]], α320'' :> α319'', α319'' :> ([[α273'']], [[list[α297'']]],)]
//│ L: 2 [list[([α328''], [α329''],)] ~ ([[α273'']], [[α296'']],), list[([α328''], [α329''],)] <: α336'', [α336'' - (α337'' -> α336'') ~ (α339'' -> [α320'']) - α320'', L: 1 [(α337'' -> α336'') ~ (α339'' -> [α320'']), [(α337'' -> α336'') - (α336'' -> (α337'' -> α336'')) ~ (α338'' -> (α339'' -> [α320''])) - (α339'' -> [α320'']), L: 0 [(α336'' -> (α337'' -> α336'')) ~ (α338'' -> (α339'' -> [α320''])), (α336'' -> (α337'' -> α336'')) :> (α338'' -> (α339'' -> [α320'']))]]]], α320'' :> α319'', α319'' :> ([[α273'']], [[α296'']],)]
//│ L: 2 [list[([α328''], [α329''],)] ~ ([[list[α274'']]], [[α296'']],), list[([α328''], [α329''],)] <: α336'', [α336'' - (α337'' -> α336'') ~ (α339'' -> [α320'']) - α320'', L: 1 [(α337'' -> α336'') ~ (α339'' -> [α320'']), [(α337'' -> α336'') - (α336'' -> (α337'' -> α336'')) ~ (α338'' -> (α339'' -> [α320''])) - (α339'' -> [α320'']), L: 0 [(α336'' -> (α337'' -> α336'')) ~ (α338'' -> (α339'' -> [α320''])), (α336'' -> (α337'' -> α336'')) :> (α338'' -> (α339'' -> [α320'']))]]]], α320'' :> ([[list[α274'']]], [[α296'']],)]
//│ L: 0 [list[([α328''], [α329''],)] ~ ([α345''], [α346''],), list[([α328''], [α329''],)] <: α336'', α336'' <: ([α345''], [α346''],)]

// file 67 mod
type expr =
    VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;
let pi = 4.0 *. (atan 1.0);;
let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y);;
//│ Defined type alias expr
//│ Defined class VarX
//│ Defined class VarY
//│ Defined class Sine
//│ Defined class Cosine
//│ Defined class Average
//│ Defined class Times
//│ Defined class Thresh
//│ [ERROR] Type `int` does not match `float`
//│ 
//│         (int) ---> (float)
//│ 
//│ ◉ (int) is here
//│ │  - l.16   | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
//│ │                                                                           ^
//│ ▼ 
//│ ◉ (float) is here
//│    - lib. let ( /. ): float -> float -> float
//│                                ^^^^^
//│ VarX: expr
//│ VarY: expr
//│ Sine: expr -> expr
//│ Cosine: expr -> expr
//│ Average: (expr, expr,) -> expr
//│ Times: (expr, expr,) -> expr
//│ Thresh: (expr, expr, expr, expr,) -> expr
//│ pi: float
//│ eval: (nothing, nothing, nothing,) -> 'a
//│   where
//│     'a :> float
//│ U max: 10, total: 144
//│ UERR 1 errors
//│ L: 0 [int ~ float, int <: float]

// FIXME file 1087 mod
let sqsum xs =
  let f a x = match x with | [] -> 0 | h::t -> 1 in
  let base = List.hd xs in List.fold_left f base xs;;
//│ [ERROR] Type `int` does not match `_ list`
//│ 
//│         (int) ---> (?a) ~~~~ (?b) <--- (?c) ~~~~ (?d) ~~~~ (?e) ---> (_ list)
//│ 
//│ ◉ (int) is here
//│ │  - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│ │                                            ^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│    - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b -> ?a) is here
//│     │  - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│     │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│     │                                                   ^
//│     ▼ 
//│     ◉ (?c -> ?d -> ?c) is here
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed here
//│ ▲  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│ │                                                     ^^^^
//│ │ 
//│ ◉ (?e) is assumed here
//│    - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│                        ^^^^^^^^^^
//│   ◉ (?e list) is here
//│   ▲  - lib. let List.hd: 'a list -> 'a
//│   │                      ^^^^^^^
//│   │  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│   │                              ^^
//│   │  - l.1  let sqsum xs =
//│   │                   ^^
//│   │ 
//│   ◉ (?f) is assumed here
//│   │  - l.1  let sqsum xs =
//│   │                   ^^
//│   │  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│   │                                                          ^^
//│   ▼ 
//│   ◉ (?d list) is here
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                                            ^^^^^^^
//│     ◉ (?c -> ?d -> ?c) is here
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│     │                                                   ^
//│     │ 
//│     ◉ (_ -> ?b -> ?a) is here
//│        - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ │  - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│ │                   ^
//│ │  - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│ │                             ^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│                                        ^^
//│ sqsum: (list[list[?]] & list['a]) -> (int | 'a)
//│ U max: 2, total: 17
//│ UERR 1 errors
//│ L: 2 [int ~ list['a623'], int <: α624', [α624' - (α622' -> α624') ~ (α620' -> α619') - α619', L: 1 [(α622' -> α624') ~ (α620' -> α619'), [(α622' -> α624') - (α621' -> (α622' -> α624')) ~ (α619' -> (α620' -> α619')) - (α620' -> α619'), L: 0 [(α621' -> (α622' -> α624')) ~ (α619' -> (α620' -> α619')), (α621' -> (α622' -> α624')) <: (α619' -> (α620' -> α619'))]]]], α619' :> α616', [α616' - list[α616'] ~ list[α620'] - α620', L: 0 [list[α616'] ~ list[α620'], list[α616'] :> α611', α611' <: list[α620']]], [α620' - (α620' -> α619') ~ (α622' -> α624') - α622', L: 1 [(α620' -> α619') ~ (α622' -> α624'), [(α620' -> α619') - (α619' -> (α620' -> α619')) ~ (α621' -> (α622' -> α624')) - (α622' -> α624'), L: 0 [(α619' -> (α620' -> α619')) ~ (α621' -> (α622' -> α624')), (α619' -> (α620' -> α619')) :> (α621' -> (α622' -> α624'))]]]], α622' <: list['a623']]


// file 26 mod
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;
let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ sepConcat: string -> list[string] -> string
//│ stringOfList: anything -> anything -> string

// FIXME string indexing - Array types not supported
// file 2376
let getHead h = match h with | [] -> [] | h::t -> h;;
let getTail t = match t with | [] -> [] | h::t -> t;;
let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
let rec matchHeads x y =
  match x with
  | [] -> true
  | h::t ->
      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
let explode s =
  let rec go i =
    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
  go 0;;
let palindrome w =
  match explode w with
  | [] -> true
  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ /!!!\ Uncaught error: scala.MatchError: undefined (of class mlscript.TyperDatatypes$TypeRef)


// file 1563
let rec sumListHelper total xs =
  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
let rec digitsOfIntHelper n =
  if n < 1
  then []
  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
let rec digitsOfInt n = digitsOfIntHelper n;;
let rec sumList xs = sumListHelper 0 xs;;
let rec additivePersistence n = sumList digitsOfInt n;;
//│ sumListHelper: ('a & 'b & int) -> list[int] -> 'a
//│   where
//│     'a :> int | 'b
//│        <: 'b
//│     'b :> 'a | int
//│        <: 'a
//│ digitsOfIntHelper: int -> (list[int] | list[nothing])
//│ digitsOfInt: int -> (list[int] | list[nothing])
//│ sumList: list[int] -> int
//│ additivePersistence: anything -> nothing

// file 8776
// TODO list indexing here. skip this example?
let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
let getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;
let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
let rec matchHeads x =
  match explode x with
  | h::t ->
      if (getHeads (explode x)) = []
      then true
      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ [ERROR] Type `error` does not match `_ -> _`
//│ 
//│         (error) ---> (_ -> _)
//│ 
//│ ◉ (error) is here
//│ │  - l.6    match explode x with
//│ │                 ^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) is here
//│    - l.6    match explode x with
//│                   ^^^^^^^
//│ [ERROR] Type `error` does not match `_ -> _`
//│ 
//│         (error) ---> (_ -> _)
//│ 
//│ ◉ (error) is here
//│ │  - l.8        if (getHeads (explode x)) = []
//│ │                             ^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) is here
//│    - l.8        if (getHeads (explode x)) = []
//│                               ^^^^^^^
//│ listReverse: list['a] -> (list['a] | list[nothing])
//│ getHeads: list['a] -> (list['a] | list[nothing])
//│ loseTail: list['a] -> (list['a] | list[nothing])
//│ ╔══[ERROR] identifier not found: explode
//│ ║  
//│ ║  l.365:	  match explode x with
//│ ╙──      	        ^^^^^^^
//│ ╔══[ERROR] identifier not found: explode
//│ ║  
//│ ║  l.367:	      if (getHeads (explode x)) = []
//│ ╙──      	                    ^^^^^^^
//│ matchHeads: error -> bool
//│ U max: 3, total: 94
//│ UERR 2 errors
//│ L: 0 [error<> ~ ([α1021'] -> α1044'), error<> <: ([α1021'] -> α1044')]
//│ L: 0 [error<> ~ ([α1021'] -> α1023'), error<> <: ([α1021'] -> α1023')]

// TODO: parse correctly
let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;
//│ /!!!\ Uncaught error: scala.MatchError: undefined (of class mlscript.TyperDatatypes$TypeRef)

// file 89
// TODO: parse properly
let rec digitsOfInt n =
  let return = [n mod 10] in
  if (n / 10) <> 0
  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)
  else return;;
let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t)
let rec digitalRoot n =
  let digits = digitsOfInt n in
  let s = sumList digits in
  if (n / 10) <> 0
  then (print_int n; print_endline " "; digitalRoot)
  else digits;;
//│ /!\ Parse error: Expected ")":4:29, found "; (digitsO" at l.421:29:   then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)

// file 2361
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
let digits n = digitsOfInt (abs n);;
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ [ERROR] Type `error` does not match `_ -> _`
//│ 
//│         (error) ---> (_ -> _)
//│ 
//│ ◉ (error) is here
//│ │  - l.-20    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ │                      ^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) is here
//│    - l.-20    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                        ^^^^^^^^^^^^^
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) ---> (?a) ---> (?b) <--- (int)
//│ 
//│ ◉ (bool) is here
//│ │  - l.8    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                                                       ^^^^^
//│ │  - l.8    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.8    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.6    match digits n with
//│ │           ^^^^^^^^^^^^^^^^^^^
//│ │           | [] -> 0 ...
//│ │           ^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ ▲  - l.6    match digits n with
//│ │           ^^^^^^^^^^^^^^^^^^^
//│ │           | [] -> 0 ...
//│ │           ^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) is here
//│    - l.7    | [] -> 0
//│                     ^
//│ digitsOfInt: int -> (list[int] | list[nothing])
//│ addNumbs: list[int] -> int
//│ digits: int -> (list[int] | list[nothing])
//│ additivePersistence: int -> (bool | int)
//│ U max: 2, total: 62
//│ UERR 2 errors
//│ L: 0 [bool ~ int, bool <: α1197', α1197' <: α1183', α1183' :> int]
//│ L: 0 [error<> ~ ([α1098'] -> α1104''), error<> <: ([α1098'] -> α1104'')]


// file 358 mod
// type expr used from previous
let buildCosine e = Cosine e;;
let buildSine e = Sine e;;
let buildX () = VarX;;
let buildY () = VarY;;
let rec build (rand,depth) =
  let r = rand 0.4 in
  match depth with
  | 0 -> if (r mod 2) = 0 then buildX else buildY
  | d ->
      if r = 0
      then buildSine build (rand, (d - 1))
      else buildCosine build (rand, (d - 1));;
//│ [ERROR] Type `expr` does not match `(_ * int) -> _`
//│ 
//│         (expr) ---> ((_ * int) -> _)
//│ 
//│ ◉ (expr) is here
//│ │  - l.-306  | Thresh of expr* expr* expr* expr;;
//│ │              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2  let buildSine e = Sine e;;
//│ │                           ^^^^^^
//│ ▼ 
//│ ◉ ((_ * int) -> _) is here
//│    - l.11       then buildSine build (rand, (d - 1))
//│                      ^^^^^^^^^^^^^^^
//│ [ERROR] Type `expr` does not match `(_ * int) -> _`
//│ 
//│         (expr) ---> ((_ * int) -> _)
//│ 
//│ ◉ (expr) is here
//│ │  - l.-306  | Thresh of expr* expr* expr* expr;;
//│ │              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let buildCosine e = Cosine e;;
//│ │                             ^^^^^^^^
//│ ▼ 
//│ ◉ ((_ * int) -> _) is here
//│    - l.12       else buildCosine build (rand, (d - 1));;
//│                      ^^^^^^^^^^^^^^^^^
//│ buildCosine: expr -> expr
//│ buildSine: expr -> expr
//│ buildX: () -> expr
//│ buildY: () -> expr
//│ build: (nothing, nothing,) -> () -> expr
//│ U max: 1, total: 23
//│ UERR 2 errors
//│ L: 0 [expr ~ (([[α1210']], [[int]],) -> α1231'), expr <: (([[α1210']], [[int]],) -> α1231')]
//│ L: 0 [expr ~ (([[α1210']], [[int]],) -> α1237'), expr <: (([[α1210']], [[int]],) -> α1237')]

// TODO file 1337 in separate file to avoid collisions

// file 2752 mod
let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
let x l = List.map string_of_int;;
let y = [1, 2, 3];;
let rec mulByDigit i l =
  match List.rev l with
  | [] -> []
  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ [ERROR] Type `_ -> _ list -> _ list` does not match `int`
//│ 
//│         (_ -> _ list -> _ list) ---> (?a) ---> (int)
//│ 
//│ ◉ (_ -> _ list -> _ list) is here
//│ │  - l.2  let x l = List.map string_of_int;;
//│ │               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7    | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ │                                ^
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                       ^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                       ^
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                                 ^
//│ ▼ 
//│ ◉ (int) is here
//│    - lib. let ( * ): int -> int -> int
//│                      ^^^
//│ [ERROR] Type `_ list` does not match `int`
//│ 
//│         (_ list) ---> (?a) ---> (int)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.3  let y = [1, 2, 3];;
//│ │                 ^^^^^^^^^
//│ │  - l.7    | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ │                                  ^
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                         ^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                         ^
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                                     ^
//│ ▼ 
//│ ◉ (int) is here
//│    - lib. let ( * ): int -> int -> int
//│                             ^^^
//│ remainder: int -> int -> int
//│ x: anything -> list[int] -> list[string]
//│ y: list[(int, int, int,)]
//│ mulByDigit: anything -> list[?] -> (list[int] | list[nothing])
//│ U max: 2, total: 36
//│ UERR 2 errors
//│ L: 0 [(α1288' -> [(list[α1289'] -> list[α1290'])]) ~ int, (α1288' -> [(list[α1289'] -> list[α1290'])]) <: α1285', α1285' <: int]
//│ L: 0 [list['a1292'] ~ int, list['a1292'] <: α1286', α1286' <: int]


// file 344 mod
let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
let padLength l1 l2 = abs ((List.length l1) - (List.length l2));;
let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then (clone 0 (padLength l1 l2)) :: l1
  else (clone 0 (padLength l1 l2)) l2;;
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ~~~~ (?a) ~~~~ (?b) ---> (_ -> _)
//│ 
//│   ◉ (_ * _ list) is here
//│   ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                           ^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ * ?a) is here
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                               ^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (int -> ?a) is here
//│   ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                                 ^^^^^^^
//│   │ 
//│   ◉ (?b) is assumed here
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                     ^^^^^^^
//│     ◉ (_ -> ?b) is here
//│     ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                                                 ^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (?clone) is assumed here
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (int -> ?c) is here
//│        - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                       ^^^^^
//│   ◉ (?c) is assumed here
//│   │  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (int -> ?d) is here
//│      - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                     ^^^^^^^
//│ ◉ (?d) is assumed here
//│ │  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) is here
//│    - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ clone: 'a -> int -> (list[nothing] | list['a])
//│ padLength: list[?] -> list[?] -> int
//│ padZero: (list[?] & list['a]) -> list[?] -> list[list[nothing] | list[int] | 'a]
//│ U max: 3, total: 81
//│ UERR 1 errors
//│ L: 2 [list['a1389'] ~ ([α1357'] -> α1407'), [list['a1389'] - ('a1389', list['a1389'],) ~ ([[α1388']], [α1392'],) - α1392', L: 0 [('a1389', list['a1389'],) ~ ([[α1388']], [α1392'],), ('a1389', list['a1389'],) :> ([[α1388']], [α1392'],)]], [α1392' - ([int] -> α1392') ~ ([[int]] -> α1405') - α1405', L: 1 [([int] -> α1392') ~ ([[int]] -> α1405'), ([int] -> α1392') :> α1395', [α1395' - ([α1388'] -> α1395') ~ (int -> α1397') - α1397', L: 0 [([α1388'] -> α1395') ~ (int -> α1397'), ([α1388'] -> α1395') :> clone1387', clone1387' <: (int -> α1397')]], α1397' <: ([[int]] -> α1405')]], α1405' <: ([α1357'] -> α1407')]

// file 2736 [TODO different part of file has errors]
let rec addHelper (t,u) =
 match List.rev t with
 | [] -> []
 | h::t ->
    match List.rev u with
     | [] -> []
     | h'::t' ->
         if (h + h') > 10
         then (addHelper (t, t')) @ [(1 + h') + h]
         else (addHelper (t, t')) @ [h' + h];;
//│ addHelper: (nothing, nothing,) -> (list[int] | list[nothing])



// file 1948
let rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
let bigMul l1 l2 =
  let f a x =
    let (x1,x2) = x in
    let (carry,res) = a in
    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
  let base = (0, []) in
  let args = l1 (tenEx 0 l2) in
  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) ---> (?a) <--- (_ list)
//│ 
//│ ◉ (_ -> _) is here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                        ^^^^
//│ │            let add (l1,l2) = ...
//│ │            ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list) is here
//│    - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                     ^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ │  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ │  - l.-665  then (((clone 0 (-1 * diff)) @ l1), l2)
//│ │                                           ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                               ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ │  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ │  - l.-667  let diff = (List.length l1) - (List.length l2) in
//│ │                                    ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                   ^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ list * _) is here
//│      - l.-665  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (?c) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _ list) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) is here
//│      - l.-660  let add (l1,l2) =
//│                        ^^^^^^^
//│ ◉ (?e) is assumed here
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │  - l.-658    let base = List.combine l1 l2 in
//│ │                                      ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                             ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (?c) ---> (?d) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _ list) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) is here
//│      - l.-660  let add (l1,l2) =
//│                        ^^^^^^^
//│ ◉ (?e) is assumed here
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ │  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?f) is assumed here
//│ │  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ │  - l.-667  let diff = (List.length l1) - (List.length l2) in
//│ │                                    ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (?c) ---> (?d) ~~~~ (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _ list) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) is here
//│      - l.-660  let add (l1,l2) =
//│                        ^^^^^^^
//│ ◉ (?e) is assumed here
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ ▼ 
//│ ◉ (?f) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?f * _) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                   ^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?g) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?h) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ list * _) is here
//│      - l.-665  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (?c) ~~~~ (?b) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _ list) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) is here
//│      - l.-660  let add (l1,l2) =
//│                        ^^^^^^^
//│   ◉ (?e * _) is here
//│   ▲  - l.-660  let add (l1,l2) =
//│   │                    ^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?c) is assumed here
//│   ▲  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?b * _ list) is here
//│      - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ │  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ │  - l.-667  let diff = (List.length l1) - (List.length l2) in
//│ │                                    ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `_ -> _`
//│ 
//│         (int * _ list) ---> (?a) ~~~~ (?b) <--- (?c) <--- (?d) <--- (_ -> _)
//│ 
//│ ◉ (int * _ list) is here
//│ │  - l.9    let base = (0, []) in
//│ │                      ^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│    - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                                ^^^^
//│     ◉ (?a -> _ -> ?a) is here
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) is here
//│        - l.5    let f a x =
//│                       ^^^^^
//│                   let (x1,x2) = x in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ ▲  - l.6      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed here
//│ ▲  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?d) is assumed here
//│ ▲  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ -> _) is here
//│    - l.-661let bigAdd l1 l2 =
//│                          ^^^^
//│              let add (l1,l2) = ...
//│              ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `_ list`
//│ 
//│         (int * _ list) ---> (?a) ~~~~ (?b) <--- (?c) <--- (?d) <--- (_ list)
//│ 
//│ ◉ (int * _ list) is here
//│ │  - l.9    let base = (0, []) in
//│ │                      ^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│    - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                                ^^^^
//│     ◉ (?a -> _ -> ?a) is here
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) is here
//│        - l.5    let f a x =
//│                       ^^^^^
//│                   let (x1,x2) = x in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ ▲  - l.6      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed here
//│ ▲  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?d) is assumed here
//│ ▲  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list) is here
//│    - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                     ^^
//│ [ERROR] Type `_ -> _` does not match `_ * _`
//│ 
//│         (_ -> _) ---> (?a) ---> (?b) ---> (?c) ~~~~ (?d) ---> (_ * _)
//│ 
//│ ◉ (_ -> _) is here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                        ^^^^
//│ │            let add (l1,l2) = ...
//│ │            ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?c) is here
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?d -> _ -> ?d) is here
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│ ◉ (?d) is assumed here
//│ │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                 ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ~~~~ (?a) ---> (_ -> _)
//│ 
//│   ◉ (_ list -> _) is here
//│   ▲  - l.-127  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│   │                                         ^^^^^^^^^^^^
//│   │ 
//│   ◉ (?a) is assumed here
//│      - l.-127  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│                                             ^^^^^^^^^^^^
//│     ◉ (_ -> ?a) is here
//│     ▲  - l.-127  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│     │                                         ^^^^^^^^^^
//│     │  - l.-130let rec mulByDigit i l =
//│     │                  ^^^^^^^^^^
//│     │ 
//│     ◉ (?mulByDigit) is assumed here
//│     │  - l.-130let rec mulByDigit i l =
//│     │                  ^^^^^^^^^^
//│     ▼ 
//│     ◉ (_ -> ?b) is here
//│        - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                               ^^^^^^^^^^
//│   ◉ (?b) is assumed here
//│   │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│   │                                                         ^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c -> _) is here
//│      - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                             ^^^^^^^^^^^^
//│ ◉ (?c) is assumed here
//│ │  - l.4  let bigMul l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (_ -> _) is here
//│    - l.10   let args = l1 (tenEx 0 l2) in
//│                        ^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) ---> (?b) ---> (?c) ~~~~ (?d) ---> (_ * _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?c) is here
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?d -> _ -> ?d) is here
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│ ◉ (?d) is assumed here
//│ │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                 ^^^^^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ * _`
//│ 
//│         (_ -> _) ---> (?a) ---> (?b) ---> (?c) ~~~~ (?d) ~~~~ (?e) ---> (_ * _)
//│ 
//│ ◉ (_ -> _) is here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                        ^^^^
//│ │            let add (l1,l2) = ...
//│ │            ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (?d -> _ -> ?c) is here
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?e -> _ -> ?e) is here
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (?e -> _ -> ?e) is here
//│   ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│   │                               ^^^^^^^^^^^^^^
//│   │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│   │                                            ^
//│   │ 
//│   ◉ (?d -> _ -> ?c) is here
//│      - l.5    let f a x =
//│                     ^^^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?d) is assumed here
//│ │  - l.5    let f a x =
//│ │                 ^
//│ │  - l.7      let (carry,res) = a in
//│ │                               ^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.7      let (carry,res) = a in
//│                   ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) ---> (?b) ---> (?c) ~~~~ (?d) ~~~~ (?e) ---> (_ * _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (?d -> _ -> ?c) is here
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?e -> _ -> ?e) is here
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (?e -> _ -> ?e) is here
//│   ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│   │                               ^^^^^^^^^^^^^^
//│   │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│   │                                            ^
//│   │ 
//│   ◉ (?d -> _ -> ?c) is here
//│      - l.5    let f a x =
//│                     ^^^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?d) is assumed here
//│ │  - l.5    let f a x =
//│ │                 ^
//│ │  - l.7      let (carry,res) = a in
//│ │                               ^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.7      let (carry,res) = a in
//│                   ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ---> (?a) ---> (?b) ---> (?c) ~~~~ (?d) ~~~~ (?c) <--- (?b) <--- (?a) <--- (_ -> _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?c) is here
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?d -> _ -> ?d) is here
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│     ◉ (?d -> _ -> ?d) is here
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     │ 
//│     ◉ (_ -> _ -> ?c) is here
//│        - l.5    let f a x =
//│                       ^^^^^
//│                   let (x1,x2) = x in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed here
//│ ▲  - l.6      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed here
//│ ▲  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ -> _) is here
//│    - l.-661let bigAdd l1 l2 =
//│                          ^^^^
//│              let add (l1,l2) = ...
//│              ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (?c) ---> (?d) ~~~~ (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _ list) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) is here
//│      - l.-660  let add (l1,l2) =
//│                        ^^^^^^^
//│ ◉ (?e) is assumed here
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ ▼ 
//│ ◉ (?f) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?f * _) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                   ^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?g) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?h) is assumed here
//│      - l.-666  if diff < 0
//│                ^^^^^^^^^^^
//│                then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?h) is here
//│       │  - l.-659    let f a x = padZero l1 l2 in
//│       │                    ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       ▼ 
//│       ◉ (?i -> _ -> ?i) is here
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│       ◉ (?i -> _ -> ?i) is here
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       │ 
//│       ◉ (_ -> _ -> ?h) is here
//│          - l.-659    let f a x = padZero l1 l2 in
//│                            ^^^^^^^^^^^^^^^^^^^
//│   ◉ (?h) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ list * _) is here
//│      - l.-665  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (?c) ---> (?d) ~~~~ (?e) ~~~~ (?d) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _ list) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) is here
//│      - l.-660  let add (l1,l2) =
//│                        ^^^^^^^
//│ ◉ (?e) is assumed here
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ ▼ 
//│ ◉ (?f) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?f * _) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                   ^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?g) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?h) is assumed here
//│      - l.-666  if diff < 0
//│                ^^^^^^^^^^^
//│                then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?h) is here
//│       │  - l.-659    let f a x = padZero l1 l2 in
//│       │                    ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       ▼ 
//│       ◉ (?i -> _ -> ?i) is here
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│   ◉ (?i) is assumed here
//│   │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│   │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?j * _) is here
//│      - l.-656    let (_,res) = List.fold_left f base args in res in
//│                      ^^^^^^^
//│   ◉ (?j * _) is here
//│   ▲  - l.-656    let (_,res) = List.fold_left f base args in res in
//│   │                  ^^^^^^^
//│   │ 
//│   ◉ (?i) is assumed here
//│      - l.-656    let (_,res) = List.fold_left f base args in res in
//│                                ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       ◉ (?i -> _ -> ?i) is here
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       │ 
//│       ◉ (_ -> _ -> ?h) is here
//│          - l.-659    let f a x = padZero l1 l2 in
//│                            ^^^^^^^^^^^^^^^^^^^
//│   ◉ (?h) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?g) is assumed here
//│   ▲  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?f * _) is here
//│      - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                       ^^^^^^^^
//│ ◉ (?f) is assumed here
//│ │  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ │  - l.-667  let diff = (List.length l1) - (List.length l2) in
//│ │                                    ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (?c) ---> (?d) ~~~~ (?e) ~~~~ (?d) <--- (?c) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _ list) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) is here
//│      - l.-660  let add (l1,l2) =
//│                        ^^^^^^^
//│ ◉ (?e) is assumed here
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ ▼ 
//│ ◉ (?f) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?f * _) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                   ^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?g) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?h) is assumed here
//│      - l.-666  if diff < 0
//│                ^^^^^^^^^^^
//│                then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?h) is here
//│       │  - l.-659    let f a x = padZero l1 l2 in
//│       │                    ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       ▼ 
//│       ◉ (?i -> _ -> ?i) is here
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│   ◉ (?i) is assumed here
//│   │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│   │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?j * _) is here
//│      - l.-656    let (_,res) = List.fold_left f base args in res in
//│                      ^^^^^^^
//│   ◉ (?j * _) is here
//│   ▲  - l.-656    let (_,res) = List.fold_left f base args in res in
//│   │                  ^^^^^^^
//│   │ 
//│   ◉ (?i) is assumed here
//│      - l.-656    let (_,res) = List.fold_left f base args in res in
//│                                ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       ◉ (?i -> _ -> ?i) is here
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       │ 
//│       ◉ (_ -> _ -> ?h) is here
//│          - l.-659    let f a x = padZero l1 l2 in
//│                            ^^^^^^^^^^^^^^^^^^^
//│   ◉ (?h) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?g) is assumed here
//│   ▲  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?f * _) is here
//│      - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                       ^^^^^^^^
//│ ◉ (?f) is assumed here
//│ ▲  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │ 
//│ ◉ (?e) is assumed here
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │  - l.-658    let base = List.combine l1 l2 in
//│ │                                      ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                             ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (?c) ---> (?d) ~~~~ (?e) ~~~~ (?d) <--- (?c) ~~~~ (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _ list) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) is here
//│      - l.-660  let add (l1,l2) =
//│                        ^^^^^^^
//│ ◉ (?e) is assumed here
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ ▼ 
//│ ◉ (?f) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?f * _) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                   ^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?g) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?h) is assumed here
//│      - l.-666  if diff < 0
//│                ^^^^^^^^^^^
//│                then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?h) is here
//│       │  - l.-659    let f a x = padZero l1 l2 in
//│       │                    ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       ▼ 
//│       ◉ (?i -> _ -> ?i) is here
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│   ◉ (?i) is assumed here
//│   │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│   │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?j * _) is here
//│      - l.-656    let (_,res) = List.fold_left f base args in res in
//│                      ^^^^^^^
//│   ◉ (?j * _) is here
//│   ▲  - l.-656    let (_,res) = List.fold_left f base args in res in
//│   │                  ^^^^^^^
//│   │ 
//│   ◉ (?i) is assumed here
//│      - l.-656    let (_,res) = List.fold_left f base args in res in
//│                                ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       ◉ (?i -> _ -> ?i) is here
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       │ 
//│       ◉ (_ -> _ -> ?h) is here
//│          - l.-659    let f a x = padZero l1 l2 in
//│                            ^^^^^^^^^^^^^^^^^^^
//│   ◉ (?h) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?g) is assumed here
//│   ▲  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?f * _) is here
//│      - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                       ^^^^^^^^
//│ ◉ (?f) is assumed here
//│ ▲  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ │ 
//│ ◉ (?e) is assumed here
//│    - l.-660  let add (l1,l2) =
//│                       ^^
//│   ◉ (?e * _) is here
//│   ▲  - l.-660  let add (l1,l2) =
//│   │                    ^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ list * _) is here
//│      - l.-665  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (?b) ~~~~ (?c) ---> (?d) ~~~~ (?e) ~~~~ (?d) <--- (?c) ~~~~ (?b) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-661let bigAdd l1 l2 =
//│ │                     ^^
//│ │  - l.-655  removeZero (add (padZero l1 l2));;
//│ │                                     ^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?b * _ list) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed here
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) is here
//│      - l.-660  let add (l1,l2) =
//│                        ^^^^^^^
//│ ◉ (?e) is assumed here
//│ │  - l.-660  let add (l1,l2) =
//│ │                     ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ ▼ 
//│ ◉ (?f) is assumed here
//│    - l.-668let padZero l1 l2 =
//│                        ^^
//│   ◉ (?f * _) is here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                   ^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?g) is assumed here
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?h) is assumed here
//│      - l.-666  if diff < 0
//│                ^^^^^^^^^^^
//│                then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?h) is here
//│       │  - l.-659    let f a x = padZero l1 l2 in
//│       │                    ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       ▼ 
//│       ◉ (?i -> _ -> ?i) is here
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│   ◉ (?i) is assumed here
//│   │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│   │                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?j * _) is here
//│      - l.-656    let (_,res) = List.fold_left f base args in res in
//│                      ^^^^^^^
//│   ◉ (?j * _) is here
//│   ▲  - l.-656    let (_,res) = List.fold_left f base args in res in
//│   │                  ^^^^^^^
//│   │ 
//│   ◉ (?i) is assumed here
//│      - l.-656    let (_,res) = List.fold_left f base args in res in
//│                                ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       ◉ (?i -> _ -> ?i) is here
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-656    let (_,res) = List.fold_left f base args in res in
//│       │                                           ^
//│       │ 
//│       ◉ (_ -> _ -> ?h) is here
//│          - l.-659    let f a x = padZero l1 l2 in
//│                            ^^^^^^^^^^^^^^^^^^^
//│   ◉ (?h) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?g) is assumed here
//│   ▲  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?f * _) is here
//│      - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                       ^^^^^^^^
//│ ◉ (?f) is assumed here
//│ ▲  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ │  - l.-659    let f a x = padZero l1 l2 in
//│ │                                  ^^
//│ │ 
//│ ◉ (?e) is assumed here
//│    - l.-660  let add (l1,l2) =
//│                       ^^
//│   ◉ (?e * _) is here
//│   ▲  - l.-660  let add (l1,l2) =
//│   │                    ^^^^^^^
//│   │  - l.-655  removeZero (add (padZero l1 l2));;
//│   │                            ^^^^^^^^^^^^^^^
//│   │  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed here
//│   ▲  - l.-666  if diff < 0
//│   │            ^^^^^^^^^^^
//│   │            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?c) is assumed here
//│   ▲  - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?b * _ list) is here
//│      - l.-664  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ │  - l.-668let padZero l1 l2 =
//│ │                      ^^
//│ │  - l.-667  let diff = (List.length l1) - (List.length l2) in
//│ │                                    ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ helper: int -> int
//│ tenEx: int -> list[int] -> (list[int] | list[nothing])
//│ bigMul: ((list[int] | list[nothing]) -> list[(nothing, nothing,)] & list[?]) -> list[int] -> list[int]
//│ U max: 7, total: 133
//│ UERR 21 errors
//│ L: 2 [(α1775' -> α1776') ~ ([α1908'], [α1909'],), (α1775' -> α1776') <: α1774', α1774' <: α1773', α1773' <: α1772', [α1772' - (α1754' -> α1772') ~ (α1750' -> α1749') - α1749', L: 1 [(α1754' -> α1772') ~ (α1750' -> α1749'), [(α1754' -> α1772') - (α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')) - (α1750' -> α1749'), L: 0 [(α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')), (α1751' -> (α1754' -> α1772')) <: (α1749' -> (α1750' -> α1749'))]]]], α1749' <: ([α1908'], [α1909'],)]
//│ L: 0 [(α1676'' -> α1677'') ~ list['a1569''], (α1676'' -> α1677'') <: α1567'', α1567'' :> list['a1569'']]
//│ L: 2 [(α1775' -> α1776') ~ ([α1752'], [α1753'],), (α1775' -> α1776') <: α1774', α1774' <: α1773', α1773' <: α1772', [α1772' - (α1754' -> α1772') ~ (α1750' -> α1749') - α1749', L: 1 [(α1754' -> α1772') ~ (α1750' -> α1749'), [(α1754' -> α1772') - (α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')) - (α1750' -> α1749'), L: 0 [(α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')), (α1751' -> (α1754' -> α1772')) <: (α1749' -> (α1750' -> α1749'))]]]], [α1749' - (α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')) - α1751', L: 0 [(α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')), (α1749' -> (α1750' -> α1749')) :> (α1751' -> (α1754' -> α1772'))]], α1751' <: ([α1752'], [α1753'],)]
//│ L: 2 [list['a1700'] ~ (α1738' -> α1741'), [list['a1700'] - ([list['a1700']] -> α1708'') ~ ([α1554'] -> α1713'') - α1554', L: 1 [([list['a1700']] -> α1708'') ~ ([α1554'] -> α1713''), ([list['a1700']] -> α1708'') :> α1709'', [α1709'' - ([α1698''] -> α1709'') ~ (['a1568''] -> α1711'') - α1711'', L: 0 [([α1698''] -> α1709'') ~ (['a1568''] -> α1711''), ([α1698''] -> α1709'') :> mulByDigit1697'', mulByDigit1697'' <: (['a1568''] -> α1711'')]], α1711'' <: ([α1554'] -> α1713'')]], α1554' <: (α1738' -> α1741')]
//│ L: 1 [([α1713''], [[[α1566'']]],) ~ list[α1597''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],) - α1598'', L: 0 [([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],), ([[α1599'']], [[list[α1625'']]],) <: α1690'', α1690'' <: α1689'', α1689'' <: ([α1598''], [α1681''],)]], α1598'' <: list[α1597'']]
//│ L: 3 [([α1713''], [[[α1566'']]],) ~ list[α1623''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],) - α1598'', L: 0 [([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],), ([[α1599'']], [[list[α1625'']]],) <: α1690'', α1690'' <: α1689'', α1689'' <: ([α1598''], [α1681''],)]], α1598'' <: α1622'', [α1622'' - ([[α1622'']], [[α1680'']],) ~ ([α1600''], [α1679''],) - α1600'', L: 2 [([[α1622'']], [[α1680'']],) ~ ([α1600''], [α1679''],), ([[α1622'']], [[α1680'']],) <: α1691'', α1691'' <: α1693'', [α1693'' - (α1695'' -> [α1693'']) ~ (α1696'' -> α1694'') - α1694'', L: 1 [(α1695'' -> [α1693'']) ~ (α1696'' -> α1694''), [(α1695'' -> [α1693'']) - (α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')) - (α1696'' -> α1694''), L: 0 [(α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')), (α1692'' -> (α1695'' -> [α1693''])) <: (α1694'' -> (α1696'' -> α1694''))]]]], α1694'' <: ([α1600''], [α1679''],)]], [α1600'' - ([α1600''], [α1679''],) ~ ([[α1622'']], [[α1680'']],) - α1622'', L: 2 [([α1600''], [α1679''],) ~ ([[α1622'']], [[α1680'']],), ([α1600''], [α1679''],) :> α1694'', [α1694'' - (α1696'' -> α1694'') ~ (α1695'' -> [α1693'']) - α1693'', L: 1 [(α1696'' -> α1694'') ~ (α1695'' -> [α1693'']), [(α1696'' -> α1694'') - (α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])) - (α1695'' -> [α1693'']), L: 0 [(α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])), (α1694'' -> (α1696'' -> α1694'')) :> (α1692'' -> (α1695'' -> [α1693'']))]]]], α1693'' :> α1691'', α1691'' :> ([[α1622'']], [[α1680'']],)]], α1622'' :> α1598'', [α1598'' - ([α1598''], [α1681''],) ~ ([[α1599'']], [[list[α1625'']]],) - α1599'', L: 0 [([α1598''], [α1681''],) ~ ([[α1599'']], [[list[α1625'']]],), ([α1598''], [α1681''],) :> α1689'', α1689'' :> α1690'', α1690'' :> ([[α1599'']], [[list[α1625'']]],)]], α1599'' <: list[α1623'']]
//│ L: 2 [list['a1902'] ~ ([α1908'], [α1909'],), list['a1902'] <: α1774', α1774' <: α1773', α1773' <: α1772', [α1772' - (α1754' -> α1772') ~ (α1750' -> α1749') - α1749', L: 1 [(α1754' -> α1772') ~ (α1750' -> α1749'), [(α1754' -> α1772') - (α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')) - (α1750' -> α1749'), L: 0 [(α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')), (α1751' -> (α1754' -> α1772')) <: (α1749' -> (α1750' -> α1749'))]]]], α1749' <: ([α1908'], [α1909'],)]
//│ L: 2 [list['a1902'] ~ ([α1752'], [α1753'],), list['a1902'] <: α1774', α1774' <: α1773', α1773' <: α1772', [α1772' - (α1754' -> α1772') ~ (α1750' -> α1749') - α1749', L: 1 [(α1754' -> α1772') ~ (α1750' -> α1749'), [(α1754' -> α1772') - (α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')) - (α1750' -> α1749'), L: 0 [(α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')), (α1751' -> (α1754' -> α1772')) <: (α1749' -> (α1750' -> α1749'))]]]], [α1749' - (α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')) - α1751', L: 0 [(α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')), (α1749' -> (α1750' -> α1749')) :> (α1751' -> (α1754' -> α1772'))]], α1751' <: ([α1752'], [α1753'],)]
//│ L: 0 [([α1713''], [[[α1566'']]],) ~ list[α1623''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', α1599'' <: list[α1623'']]
//│ L: 2 [([int], [[list['a1904']]],) ~ (α1775' -> α1776'), ([int], [[list['a1904']]],) <: α1749', [α1749' - (α1750' -> α1749') ~ (α1754' -> α1772') - α1772', L: 1 [(α1750' -> α1749') ~ (α1754' -> α1772'), [(α1750' -> α1749') - (α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')) - (α1754' -> α1772'), L: 0 [(α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')), (α1749' -> (α1750' -> α1749')) :> (α1751' -> (α1754' -> α1772'))]]]], α1772' :> α1773', α1773' :> α1774', α1774' :> (α1775' -> α1776')]
//│ L: 3 [([α1713''], [[[α1566'']]],) ~ list[α1572''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],) - α1598'', L: 0 [([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],), ([[α1599'']], [[list[α1625'']]],) <: α1690'', α1690'' <: α1689'', α1689'' <: ([α1598''], [α1681''],)]], α1598'' <: α1622'', [α1622'' - ([[α1622'']], [[α1680'']],) ~ ([α1600''], [α1679''],) - α1600'', L: 2 [([[α1622'']], [[α1680'']],) ~ ([α1600''], [α1679''],), ([[α1622'']], [[α1680'']],) <: α1691'', α1691'' <: α1693'', [α1693'' - (α1695'' -> [α1693'']) ~ (α1696'' -> α1694'') - α1694'', L: 1 [(α1695'' -> [α1693'']) ~ (α1696'' -> α1694''), [(α1695'' -> [α1693'']) - (α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')) - (α1696'' -> α1694''), L: 0 [(α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')), (α1692'' -> (α1695'' -> [α1693''])) <: (α1694'' -> (α1696'' -> α1694''))]]]], α1694'' <: ([α1600''], [α1679''],)]], [α1600'' - ([α1600''], [α1679''],) ~ ([[α1622'']], [[α1680'']],) - α1622'', L: 2 [([α1600''], [α1679''],) ~ ([[α1622'']], [[α1680'']],), ([α1600''], [α1679''],) :> α1694'', [α1694'' - (α1696'' -> α1694'') ~ (α1695'' -> [α1693'']) - α1693'', L: 1 [(α1696'' -> α1694'') ~ (α1695'' -> [α1693'']), [(α1696'' -> α1694'') - (α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])) - (α1695'' -> [α1693'']), L: 0 [(α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])), (α1694'' -> (α1696'' -> α1694'')) :> (α1692'' -> (α1695'' -> [α1693'']))]]]], α1693'' :> α1691'', α1691'' :> ([[α1622'']], [[α1680'']],)]], α1622'' :> α1598'', [α1598'' - ([α1598''], [α1681''],) ~ ([[list[α1572'']]], [[α1675'']],) - list[α1572''], L: 0 [([α1598''], [α1681''],) ~ ([[list[α1572'']]], [[α1675'']],), ([α1598''], [α1681''],) :> α1689'', α1689'' :> ([[list[α1572'']]], [[α1675'']],)]]]
//│ L: 1 [([α1713''], [[[α1566'']]],) ~ list[α1623''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],) - α1598'', L: 0 [([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],), ([[α1599'']], [[list[α1625'']]],) <: α1690'', α1690'' <: α1689'', α1689'' <: ([α1598''], [α1681''],)]], [α1598'' - ([α1598''], [α1681''],) ~ ([[α1599'']], [[list[α1625'']]],) - α1599'', L: 0 [([α1598''], [α1681''],) ~ ([[α1599'']], [[list[α1625'']]],), ([α1598''], [α1681''],) :> α1689'', α1689'' :> α1690'', α1690'' :> ([[α1599'']], [[list[α1625'']]],)]], α1599'' <: list[α1623'']]
//│ L: 2 [list['a1902'] ~ (α1775' -> α1776'), list['a1902'] <: α1774', α1774' <: α1773', α1773' <: α1772', [α1772' - (α1754' -> α1772') ~ (α1750' -> α1749') - α1749', L: 1 [(α1754' -> α1772') ~ (α1750' -> α1749'), [(α1754' -> α1772') - (α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')) - (α1750' -> α1749'), L: 0 [(α1751' -> (α1754' -> α1772')) ~ (α1749' -> (α1750' -> α1749')), (α1751' -> (α1754' -> α1772')) <: (α1749' -> (α1750' -> α1749'))]]]], [α1749' - (α1750' -> α1749') ~ (α1754' -> α1772') - α1772', L: 1 [(α1750' -> α1749') ~ (α1754' -> α1772'), [(α1750' -> α1749') - (α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')) - (α1754' -> α1772'), L: 0 [(α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')), (α1749' -> (α1750' -> α1749')) :> (α1751' -> (α1754' -> α1772'))]]]], α1772' :> α1773', α1773' :> α1774', α1774' :> (α1775' -> α1776')]
//│ L: 1 [([α1713''], [[[α1566'']]],) ~ list[α1572''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[α1675'']],) ~ ([[list[α1572'']]], [[α1675'']],) - list[α1572''], L: 0 [([[α1599'']], [[α1675'']],) ~ ([[list[α1572'']]], [[α1675'']],), ([[α1599'']], [[α1675'']],) <: α1690'', α1690'' <: α1689'', α1689'' :> ([[list[α1572'']]], [[α1675'']],)]]]
//│ L: 1 [([α1713''], [[[α1566'']]],) ~ list[α1601''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],) - α1598'', L: 0 [([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],), ([[α1599'']], [[list[α1625'']]],) <: α1690'', α1690'' <: α1689'', α1689'' <: ([α1598''], [α1681''],)]], α1598'' <: α1622'', [α1622'' - ([[α1622'']], [[α1680'']],) ~ ([[list[α1601'']]], [[α1680'']],) - list[α1601''], L: 0 [([[α1622'']], [[α1680'']],) ~ ([[list[α1601'']]], [[α1680'']],), ([[α1622'']], [[α1680'']],) <: α1691'', α1691'' <: α1693'', α1693'' :> ([[list[α1601'']]], [[α1680'']],)]]]
//│ L: 3 [([α1713''], [[[α1566'']]],) ~ list[α1597''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],) - α1598'', L: 0 [([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],), ([[α1599'']], [[list[α1625'']]],) <: α1690'', α1690'' <: α1689'', α1689'' <: ([α1598''], [α1681''],)]], α1598'' <: α1622'', [α1622'' - ([[α1622'']], [[α1680'']],) ~ ([α1600''], [α1679''],) - α1600'', L: 2 [([[α1622'']], [[α1680'']],) ~ ([α1600''], [α1679''],), ([[α1622'']], [[α1680'']],) <: α1691'', α1691'' <: α1693'', [α1693'' - (α1695'' -> [α1693'']) ~ (α1696'' -> α1694'') - α1694'', L: 1 [(α1695'' -> [α1693'']) ~ (α1696'' -> α1694''), [(α1695'' -> [α1693'']) - (α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')) - (α1696'' -> α1694''), L: 0 [(α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')), (α1692'' -> (α1695'' -> [α1693''])) <: (α1694'' -> (α1696'' -> α1694''))]]]], α1694'' <: ([α1600''], [α1679''],)]], [α1600'' - ([α1600''], [α1679''],) ~ ([[α1622'']], [[α1680'']],) - α1622'', L: 2 [([α1600''], [α1679''],) ~ ([[α1622'']], [[α1680'']],), ([α1600''], [α1679''],) :> α1694'', [α1694'' - (α1696'' -> α1694'') ~ (α1695'' -> [α1693'']) - α1693'', L: 1 [(α1696'' -> α1694'') ~ (α1695'' -> [α1693'']), [(α1696'' -> α1694'') - (α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])) - (α1695'' -> [α1693'']), L: 0 [(α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])), (α1694'' -> (α1696'' -> α1694'')) :> (α1692'' -> (α1695'' -> [α1693'']))]]]], α1693'' :> α1691'', α1691'' :> ([[α1622'']], [[α1680'']],)]], α1622'' :> α1598'', α1598'' <: list[α1597'']]
//│ L: 3 [([α1713''], [[[α1566'']]],) ~ list[α1595''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],) - α1598'', L: 0 [([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],), ([[α1599'']], [[list[α1625'']]],) <: α1690'', α1690'' <: α1689'', α1689'' <: ([α1598''], [α1681''],)]], α1598'' <: α1622'', [α1622'' - ([[α1622'']], [[α1680'']],) ~ ([α1600''], [α1679''],) - α1600'', L: 2 [([[α1622'']], [[α1680'']],) ~ ([α1600''], [α1679''],), ([[α1622'']], [[α1680'']],) <: α1691'', α1691'' <: α1693'', [α1693'' - (α1695'' -> [α1693'']) ~ (α1696'' -> α1694'') - α1694'', L: 1 [(α1695'' -> [α1693'']) ~ (α1696'' -> α1694''), [(α1695'' -> [α1693'']) - (α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')) - (α1696'' -> α1694''), L: 0 [(α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')), (α1692'' -> (α1695'' -> [α1693''])) <: (α1694'' -> (α1696'' -> α1694''))]]]], α1694'' <: ([α1600''], [α1679''],)]], [α1600'' - ([α1600''], [α1679''],) ~ ([[α1622'']], [[α1680'']],) - α1622'', L: 2 [([α1600''], [α1679''],) ~ ([[α1622'']], [[α1680'']],), ([α1600''], [α1679''],) :> α1694'', [α1694'' - (α1696'' -> α1694'') ~ (α1695'' -> [α1693'']) - α1693'', L: 1 [(α1696'' -> α1694'') ~ (α1695'' -> [α1693'']), [(α1696'' -> α1694'') - (α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])) - (α1695'' -> [α1693'']), L: 0 [(α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])), (α1694'' -> (α1696'' -> α1694'')) :> (α1692'' -> (α1695'' -> [α1693'']))]]]], α1693'' :> α1691'', α1691'' :> ([[α1622'']], [[α1680'']],)]], α1622'' <: list[α1595'']]
//│ L: 2 [([int], [[list['a1904']]],) ~ list['a1902'], ([int], [[list['a1904']]],) <: α1749', [α1749' - (α1750' -> α1749') ~ (α1754' -> α1772') - α1772', L: 1 [(α1750' -> α1749') ~ (α1754' -> α1772'), [(α1750' -> α1749') - (α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')) - (α1754' -> α1772'), L: 0 [(α1749' -> (α1750' -> α1749')) ~ (α1751' -> (α1754' -> α1772')), (α1749' -> (α1750' -> α1749')) :> (α1751' -> (α1754' -> α1772'))]]]], α1772' :> α1773', α1773' :> α1774', α1774' :> list['a1902']]
//│ L: 3 [([α1713''], [[[α1566'']]],) ~ list[α1601''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],) - α1598'', L: 0 [([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],), ([[α1599'']], [[list[α1625'']]],) <: α1690'', α1690'' <: α1689'', α1689'' <: ([α1598''], [α1681''],)]], α1598'' <: α1622'', [α1622'' - ([[α1622'']], [[α1680'']],) ~ ([[list[α1601'']]], [[α1680'']],) - list[α1601''], L: 2 [([[α1622'']], [[α1680'']],) ~ ([[list[α1601'']]], [[α1680'']],), ([[α1622'']], [[α1680'']],) <: α1691'', α1691'' <: α1693'', [α1693'' - (α1695'' -> [α1693'']) ~ (α1696'' -> α1694'') - α1694'', L: 1 [(α1695'' -> [α1693'']) ~ (α1696'' -> α1694''), [(α1695'' -> [α1693'']) - (α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')) - (α1696'' -> α1694''), L: 0 [(α1692'' -> (α1695'' -> [α1693''])) ~ (α1694'' -> (α1696'' -> α1694'')), (α1692'' -> (α1695'' -> [α1693''])) <: (α1694'' -> (α1696'' -> α1694''))]]]], [α1694'' - (α1696'' -> α1694'') ~ (α1695'' -> [α1693'']) - α1693'', L: 1 [(α1696'' -> α1694'') ~ (α1695'' -> [α1693'']), [(α1696'' -> α1694'') - (α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])) - (α1695'' -> [α1693'']), L: 0 [(α1694'' -> (α1696'' -> α1694'')) ~ (α1692'' -> (α1695'' -> [α1693''])), (α1694'' -> (α1696'' -> α1694'')) :> (α1692'' -> (α1695'' -> [α1693'']))]]]], α1693'' :> ([[list[α1601'']]], [[α1680'']],)]]]
//│ L: 0 [([α1713''], [[[α1566'']]],) ~ list[α1572''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', α1599'' <: list[α1572'']]
//│ L: 1 [([α1713''], [[[α1566'']]],) ~ list[α1595''], ([α1713''], [[[α1566'']]],) <: α1570'', α1570'' <: α1599'', [α1599'' - ([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],) - α1598'', L: 0 [([[α1599'']], [[list[α1625'']]],) ~ ([α1598''], [α1681''],), ([[α1599'']], [[list[α1625'']]],) <: α1690'', α1690'' <: α1689'', α1689'' <: ([α1598''], [α1681''],)]], α1598'' <: α1622'', α1622'' <: list[α1595'']]

// file 335
let fixpointHelper f =
  match f with | (num,expr) -> if expr then (num, true) else (num, false);;
let rec wwhile (f,b) =
  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│ [ERROR] Type `_ -> _` does not match `_ * bool`
//│ 
//│         (_ -> _) <--- (?a) ~~~~ (?b) <--- (?c) <--- (_ * bool)
//│ 
//│ ◉ (_ -> _) is here
//│ ▲  - l.4    match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│ │                 ^
//│ │ 
//│ ◉ (?a) is assumed here
//│    - l.3  let rec wwhile (f,b) =
//│                           ^
//│     ◉ ((?a * _) -> _) is here
//│     ▲  - l.4    match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│     │                                                       ^^^^^^
//│     │  - l.3  let rec wwhile (f,b) =
//│     │                 ^^^^^^
//│     │ 
//│     ◉ (?wwhile) is assumed here
//│     │  - l.3  let rec wwhile (f,b) =
//│     │                 ^^^^^^
//│     ▼ 
//│     ◉ ((?b * _) -> _) is here
//│        - l.5  let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│                                    ^^^^^^
//│ ◉ (?b) is assumed here
//│ ▲  - l.2    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│ │                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed here
//│ ▲  - l.2    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│ │                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ * bool) is here
//│    - l.2    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│                                                       ^^^^^^^^^^^
//│ fixpointHelper: ('a, nothing,) -> ('a, bool,)
//│ wwhile: (nothing, ?,) -> 'a
//│ fixpoint: (nothing, nothing,) -> nothing
//│ U max: 4, total: 26
//│ UERR 1 errors
//│ L: 2 [([α1983'] -> α1988') ~ ([[[α1991']]], [[bool]],), ([α1983'] -> α1988') :> α1982', [α1982' - ([[α1982']], [[[α1984']]],) ~ ([[α1993']], [[α1980']],) - α1993', L: 1 [([[α1982']], [[[α1984']]],) ~ ([[α1993']], [[α1980']],), [([[α1982']], [[[α1984']]],) - (([[α1982']], [[[α1984']]],) -> α1987') ~ (([[α1993']], [[α1980']],) -> α1997') - ([[α1993']], [[α1980']],), L: 0 [(([[α1982']], [[[α1984']]],) -> α1987') ~ (([[α1993']], [[α1980']],) -> α1997'), (([[α1982']], [[[α1984']]],) -> α1987') :> wwhile1981', wwhile1981' <: (([[α1993']], [[α1980']],) -> α1997')]]]], α1993' :> α1994', α1994' :> ([[[α1991']]], [[bool]],)]

// FIXME: no common provs
// file 3 mod
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let numZeros = (List.length l1) - (List.length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (carry,currentSum) = a in
      if x = []
      then (0, (carry :: currentSum))
      else
        (let (toSum1,toSum2) = x in
         let intermediateValue = (toSum1 + toSum2) + carry in
         let valueToAddToArray = intermediateValue mod 10 in
         let carry = intermediateValue / 10 in
         (carry, (valueToAddToArray :: currentSum))) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) <--- (?b) ---> (_ * _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.16       if x = []
//│ │                      ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.16       if x = []
//│ │                  ^
//│ │  - l.14     let f a x =
//│ │                     ^
//│ │ 
//│ ◉ (?b) is assumed here
//│ │  - l.14     let f a x =
//│ │                     ^
//│ │  - l.19         (let (toSum1,toSum2) = x in
//│ │                                        ^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.19         (let (toSum1,toSum2) = x in
//│                        ^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ~~~~ (?a) ~~~~ (?b) ~~~~ (?c) ---> (?d) <--- (_ list)
//│ 
//│   ◉ ((_ * _) list) is here
//│   │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│   │                                                  ^^^^^^^^^^^^^
//│   │  - l.25     let args = List.rev (List.combine l1 l2) in
//│   │                                 ^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a list) is here
//│      - lib. let List.rev: 'a list -> 'a list
//│                           ^^^^^^^
//│   ◉ (?a list) is here
//│   │  - lib. let List.rev: 'a list -> 'a list
//│   │                                  ^^^^^^^
//│   │  - l.25     let args = List.rev (List.combine l1 l2) in
//│   │                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.26     let (_,res) = List.fold_left f base args in res in
//│   │                                                 ^^^^
//│   ▼ 
//│   ◉ (?b list) is here
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                                            ^^^^^^^
//│     ◉ (_ -> ?b -> _) is here
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.26     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> ?c -> _) is here
//│        - l.14     let f a x =
//│                         ^^^^^
//│                     let (carry,currentSum) = a in ...
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed here
//│ │  - l.14     let f a x =
//│ │                     ^
//│ │  - l.16       if x = []
//│ │                  ^
//│ ▼ 
//│ ◉ (?d) is assumed here
//│ ▲  - l.16       if x = []
//│ │                      ^^
//│ │ 
//│ ◉ (_ list) is here
//│    - l.16       if x = []
//│                        ^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) <--- (?b) ~~~~ (?c) ~~~~ (?b) ---> (_ * _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.16       if x = []
//│ │                      ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.16       if x = []
//│ │                  ^
//│ │ 
//│ ◉ (?b) is assumed here
//│    - l.14     let f a x =
//│                       ^
//│     ◉ (_ -> ?b -> _) is here
//│     │  - l.14     let f a x =
//│     │                   ^^^^^
//│     │               let (carry,currentSum) = a in ...
//│     │               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.26     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     ▼ 
//│     ◉ (_ -> ?c -> _) is here
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│     ◉ (_ -> ?c -> _) is here
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.26     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> ?b -> _) is here
//│        - l.14     let f a x =
//│                         ^^^^^
//│                     let (carry,currentSum) = a in ...
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ │  - l.14     let f a x =
//│ │                     ^
//│ │  - l.19         (let (toSum1,toSum2) = x in
//│ │                                        ^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.19         (let (toSum1,toSum2) = x in
//│                        ^^^^^^^^^^^^^^^
//│ clone: 'a -> int -> (list['a] | list[nothing])
//│ padZero: (list['a] & list[?]) -> (list['b] & list[?]) -> (list['a] | ?, ? | list['b],)
//│ removeZero: ('b & 'c & list[int & 'a]) -> 'b
//│   where
//│     'b :> list[nothing] | list['a] | 'c
//│        <: 'c
//│     'c :> 'b | list[nothing] | list['a]
//│        <: 'b
//│ bigAdd: (list[int] & list[?]) -> (list[int] & list[?]) -> (list[int] | list[nothing])
//│ U max: 14, total: 256
//│ UERR 3 errors
//│ L: 2 [list['a2189''] ~ ([α2186''], [α2187''],), list['a2189''] <: α2188'', α2188'' :> α2185'', [α2185'' - (α2185'' -> α2190'') ~ (α2179'' -> α2178'') - α2179'', L: 1 [(α2185'' -> α2190'') ~ (α2179'' -> α2178''), [(α2185'' -> α2190'') - (α2180'' -> (α2185'' -> α2190'')) ~ (α2178'' -> (α2179'' -> α2178'')) - (α2179'' -> α2178''), L: 0 [(α2180'' -> (α2185'' -> α2190'')) ~ (α2178'' -> (α2179'' -> α2178'')), (α2180'' -> (α2185'' -> α2190'')) <: (α2178'' -> (α2179'' -> α2178''))]]]], [α2179'' - (α2179'' -> α2178'') ~ (α2185'' -> α2190'') - α2185'', L: 1 [(α2179'' -> α2178'') ~ (α2185'' -> α2190''), [(α2179'' -> α2178'') - (α2178'' -> (α2179'' -> α2178'')) ~ (α2180'' -> (α2185'' -> α2190'')) - (α2185'' -> α2190''), L: 0 [(α2178'' -> (α2179'' -> α2178'')) ~ (α2180'' -> (α2185'' -> α2190'')), (α2178'' -> (α2179'' -> α2178'')) :> (α2180'' -> (α2185'' -> α2190''))]]]], α2185'' <: ([α2186''], [α2187''],)]
//│ L: 2 [([α2171''], [α2172''],) ~ list['a2189''], [([α2171''], [α2172''],) - list[([α2171''], [α2172''],)] ~ list[α2196''] - α2196'', L: 0 [list[([α2171''], [α2172''],)] ~ list[α2196''], list[([α2171''], [α2172''],)] <: list[α2196'']]], [α2196'' - list[α2196''] ~ list[α2179''] - α2179'', L: 0 [list[α2196''] ~ list[α2179''], list[α2196''] <: list[α2179'']]], [α2179'' - (α2179'' -> α2178'') ~ (α2185'' -> α2190'') - α2185'', L: 1 [(α2179'' -> α2178'') ~ (α2185'' -> α2190''), [(α2179'' -> α2178'') - (α2178'' -> (α2179'' -> α2178'')) ~ (α2180'' -> (α2185'' -> α2190'')) - (α2185'' -> α2190''), L: 0 [(α2178'' -> (α2179'' -> α2178'')) ~ (α2180'' -> (α2185'' -> α2190'')), (α2178'' -> (α2179'' -> α2178'')) :> (α2180'' -> (α2185'' -> α2190''))]]]], α2185'' <: α2188'', α2188'' :> list['a2189'']]
//│ L: 0 [list['a2151'''] ~ ([α2157'''], [α2158'''],), list['a2151'''] <: α2149''', α2149''' :> α2145''', α2145''' <: ([α2157'''], [α2158'''],)]

// file 1935
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let addTuple (l1,l2) = l1 + l2;;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a + x) mod 10 in
    let base = 0 in
    let args = List.map addTuple (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ (int) is here
//│ │  - l.15     let base = 0 in
//│ │                        ^
//│ │  - l.17     let (_,res) = List.fold_left f base args in res in
//│ │                                            ^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.17     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.17     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) <--- (?a) ~~~~ (?b) ---> (_ * _)
//│ 
//│ ◉ (int) is here
//│ ▲  - lib. let (+): int -> int -> int
//│ │                  ^^^
//│ │  - l.14     let f a x = (a + x) mod 10 in
//│ │                          ^
//│ │ 
//│ ◉ (?a) is assumed here
//│    - l.14     let f a x = (a + x) mod 10 in
//│                     ^
//│   ◉ (?a -> _ -> int) is here
//│   │  - l.14     let f a x = (a + x) mod 10 in
//│   │                   ^^^^^^^^^^^^^^^^^^^^
//│   │  - l.17     let (_,res) = List.fold_left f base args in res in
//│   │                                          ^
//│   ▼ 
//│   ◉ (?b -> _ -> ?b) is here
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                   ^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed here
//│ │  - l.17     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.17     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) ~~~~ (?a) ---> (_ * _)
//│ 
//│     ◉ (_ -> _ -> int) is here
//│     │  - l.14     let f a x = (a + x) mod 10 in
//│     │                   ^^^^^^^^^^^^^^^^^^^^
//│     │  - l.17     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     ▼ 
//│     ◉ (?a -> _ -> ?a) is here
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed here
//│ │  - l.17     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.17     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ clone: 'a -> int -> (list['a] | list[nothing])
//│ addTuple: (nothing, nothing,) -> int
//│ padZero: (list['a] & list[?]) -> (list[?] & list['b]) -> (? | list['a], ? | list['b],)
//│ removeZero: list['a] -> (list[nothing] | list['a])
//│ bigAdd: (list[int] & list[?]) -> (list[int] & list[?]) -> list[nothing]
//│ U max: 31, total: 293
//│ UERR 3 errors
//│ L: 1 [int ~ ([α2480''], [α2481''],), int :> α2472'', [α2472'' - (α2472'' -> (α2473'' -> [int])) ~ (α2470'' -> (α2471'' -> α2470'')) - α2470'', L: 0 [(α2472'' -> (α2473'' -> [int])) ~ (α2470'' -> (α2471'' -> α2470'')), (α2472'' -> (α2473'' -> [int])) <: (α2470'' -> (α2471'' -> α2470''))]], α2470'' <: ([α2480''], [α2481''],)]
//│ L: 2 [int ~ ([α2480''], [α2481''],), [int - (α2473'' -> [int]) ~ (α2471'' -> α2470'') - α2470'', L: 1 [(α2473'' -> [int]) ~ (α2471'' -> α2470''), [(α2473'' -> [int]) - (α2472'' -> (α2473'' -> [int])) ~ (α2470'' -> (α2471'' -> α2470'')) - (α2471'' -> α2470''), L: 0 [(α2472'' -> (α2473'' -> [int])) ~ (α2470'' -> (α2471'' -> α2470'')), (α2472'' -> (α2473'' -> [int])) <: (α2470'' -> (α2471'' -> α2470''))]]]], α2470'' <: ([α2480''], [α2481''],)]
//│ L: 0 [int ~ ([α2480''], [α2481''],), int <: α2470'', α2470'' <: ([α2480''], [α2481''],)]



// file 1907
let intboolf f x = ((f x), ((f x) < 1));;
let fixpoint (f,b) = wwhile (intboolf, b);;
let rec wwhile (f,b) =
  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;
//│ [ERROR] Type `_ * _` does not match `_ -> (_ * bool)`
//│ 
//│         (_ * _) <--- (?a) ~~~~ (_ -> (_ * bool))
//│ 
//│ ◉ (_ * _) is here
//│ ▲  - l.-305  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│ │                             ^^^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed here
//│    - l.-305  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│                    ^^^
//│   ◉ (_ -> ?a) is here
//│   ▲  - l.-305  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│   │                  ^
//│   │ 
//│   ◉ (?b) is assumed here
//│      - l.-306let rec wwhile (f,b) =
//│                              ^
//│       ◉ ((?b * _) -> _) is here
//│       ▲  - l.-305  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│       │                                                        ^^^^^^
//│       │  - l.-306let rec wwhile (f,b) =
//│       │                  ^^^^^^
//│       │ 
//│       ◉ (?wwhile) is assumed here
//│       │  - l.-306let rec wwhile (f,b) =
//│       │                  ^^^^^^
//│       ▼ 
//│       ◉ ((_ -> _ -> (_ * bool) * _) -> _) is here
//│          - l.2  let fixpoint (f,b) = wwhile (intboolf, b);;
//│                                      ^^^^^^
//│ intboolf: ('a -> 'b) -> 'a -> ('b, bool,)
//│ fixpoint: (nothing, nothing,) -> nothing
//│ wwhile: (nothing, ?,) -> 'a
//│ U max: 5, total: 29
//│ UERR 1 errors
//│ L: 3 [([α2596'], [α2601'],) ~ (α2603' -> ([α2606'], [[bool]],)), ([α2596'], [α2601'],) :> α2600', [α2600' - ([α2595'] -> α2600') ~ (α2602' -> (α2603' -> ([α2606'], [[bool]],))) - (α2603' -> ([α2606'], [[bool]],)), L: 2 [([α2595'] -> α2600') ~ (α2602' -> (α2603' -> ([α2606'], [[bool]],))), ([α2595'] -> α2600') :> α2594', [α2594' - ([[α2594']], [[[α2596']]],) ~ ([[(α2602' -> (α2603' -> ([α2606'], [[bool]],)))]], [[α2592']],) - (α2602' -> (α2603' -> ([α2606'], [[bool]],))), L: 1 [([[α2594']], [[[α2596']]],) ~ ([[(α2602' -> (α2603' -> ([α2606'], [[bool]],)))]], [[α2592']],), [([[α2594']], [[[α2596']]],) - (([[α2594']], [[[α2596']]],) -> α2599') ~ (([[(α2602' -> (α2603' -> ([α2606'], [[bool]],)))]], [[α2592']],) -> α2608') - ([[(α2602' -> (α2603' -> ([α2606'], [[bool]],)))]], [[α2592']],), L: 0 [(([[α2594']], [[[α2596']]],) -> α2599') ~ (([[(α2602' -> (α2603' -> ([α2606'], [[bool]],)))]], [[α2592']],) -> α2608'), (([[α2594']], [[[α2596']]],) -> α2599') :> wwhile2593', wwhile2593' <: (([[(α2602' -> (α2603' -> ([α2606'], [[bool]],)))]], [[α2592']],) -> α2608')]]]]]]]



// file 2047
let identity a = a;;
let pipe fs =
  let f a x = a x in let base = identity in List.fold_left f base fs;;
//│ identity: 'a -> 'a
//│ pipe: list['a & 'b & 'c & 'd & 'e] -> 'a
//│   where
//│     'a :> 'e | 'd | ('a & 'b & 'c & 'd) -> ('e | 'd) | 'c
//│        <: 'b
//│     'b <: 'e -> 'c
//│     'c :> 'e | 'd
//│        <: 'b & 'a



// file 830
let modulus ss = ss mod 10;;
let rec digitsOfInt n =
  if n <= 0
  then []
  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;
let lt10 q = q < 10;;
let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
let rec additivePersistence n =
  if lt10 n
  then n
  else
    (match n with
     | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│ [ERROR] Type `int` does not match `_ -> _`
//│ 
//│         (int) <--- (?a) ~~~~ (?b) ---> (_ -> _)
//│ 
//│ ◉ (int) is here
//│ ▲  - lib. let (+): int -> int -> int
//│ │                         ^^^
//│ │ 
//│ ◉ (?a) is assumed here
//│    - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│                                                                      ^^^^^^^^^^^
//│   ◉ (_ list -> ?a) is here
//│   ▲  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                                                                     ^^^^^^^
//│   │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                 ^^^^^^^
//│   │ 
//│   ◉ (?sumList) is assumed here
//│   │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (_ -> ?b) is here
//│      - l.13      | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│                                                   ^^^^^^^
//│ ◉ (?b) is assumed here
//│ │  - l.13      | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│ │                                               ^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) is here
//│    - l.13      | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│                                                 ^^^^^^^^^^
//│ modulus: int -> int
//│ digitsOfInt: int -> (list[int] | list[nothing])
//│ lt10: anything -> bool
//│ sumList: list[int] -> int
//│ additivePersistence: (int & 'a) -> 'a
//│ U max: 3, total: 61
//│ UERR 1 errors
//│ L: 1 [int ~ ([additivePersistence2740'] -> α2780'), int :> α2764', [α2764' - ([list['a2762']] -> α2764') ~ ([α2765'] -> α2778') - α2778', L: 0 [([list['a2762']] -> α2764') ~ ([α2765'] -> α2778'), ([list['a2762']] -> α2764') :> sumList2760', sumList2760' <: ([α2765'] -> α2778')]], α2778' <: ([additivePersistence2740'] -> α2780')]


// FIXME investigate
// file 1770 (TODO fix nested flows)
let rec filter l a =
  match l with
  | [] -> []
  | h::t -> if a = h then filter t a else h :: (filter t a);;
let removeDuplicates l =
  let rec helper (seen,rest) =
    match rest with
    | [] -> seen
    | h::t ->
        let seen' = h in
        let rest' = h :: (filter (t h)) in helper (seen', rest') in
  List.rev (helper ([], l));;
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ---> (_ -> _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ │                                           ^
//│ ▼ 
//│ ◉ (_ -> _) is here
//│    - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                             ^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) <--- (?a) ~~~~ (?b) ~~~~ (_ list)
//│ 
//│ ◉ (_ -> _) is here
//│ ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ │                                                         ^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed here
//│    - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                                           ^^^^^^^^
//│   ◉ (_ list -> ?a) is here
//│   ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│   │                                                         ^^^^^^
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   │ 
//│   ◉ (?filter) is assumed here
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (_ -> ?b) is here
//│      - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                       ^^^^^^
//│   ◉ (_ * ?b) is here
//│   │  - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│   │                             ^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (_ * _ list) is here
//│      - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                 ^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) <--- (?a) ~~~~ (?b) ~~~~ (?c) ~~~~ (_ list)
//│ 
//│ ◉ (_ -> _) is here
//│ ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ │                                   ^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed here
//│    - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                     ^^^^^^^^
//│   ◉ (_ list -> ?a) is here
//│   ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│   │                                   ^^^^^^
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   │ 
//│   ◉ (?filter) is assumed here
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (_ list -> ?b) is here
//│      - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                                             ^^^^^^
//│   ◉ (_ list -> ?b) is here
//│   ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│   │                                                         ^^^^^^
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   │ 
//│   ◉ (?filter) is assumed here
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (_ -> ?c) is here
//│      - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                       ^^^^^^
//│   ◉ (_ * ?c) is here
//│   │  - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│   │                             ^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (_ * _ list) is here
//│      - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                 ^^^^^^^^^^^^^^^^^^^
//│ filter: list['a] -> anything -> (list[nothing] | list['a])
//│ removeDuplicates: list[list['a]] -> list['a]
//│ U max: 4, total: 79
//│ UERR 3 errors
//│ L: 1 [([α2841'''] -> α2839''') ~ list['a2831''], ([α2841'''] -> α2839''') :> α2844''', [α2844''' - ([list['a2834''']] -> α2844''') ~ ([list['a2834''']] -> α2843''') - α2843''', L: 0 [([list['a2834''']] -> α2844''') ~ ([list['a2834''']] -> α2843'''), ([list['a2834''']] -> α2844''') :> filter2832''', filter2832''' <: ([list['a2834''']] -> α2843''')]], [α2843''' - ([list['a2834''']] -> α2843''') ~ (α2846''' -> α2848''') - α2848''', L: 0 [([list['a2834''']] -> α2843''') ~ (α2846''' -> α2848'''), ([list['a2834''']] -> α2843''') :> filter2832''', filter2832''' <: (α2846''' -> α2848''')]], [α2848''' - ([['a2830'']], [α2848'''],) ~ ('a2831'', list['a2831''],) - list['a2831''], L: 0 [([['a2830'']], [α2848'''],) ~ ('a2831'', list['a2831''],), ([['a2830'']], [α2848'''],) <: ('a2831'', list['a2831''],)]]]
//│ L: 0 [list['a2830''] ~ (['a2830''] -> α2846'''), list['a2830''] <: (['a2830''] -> α2846''')]
//│ L: 1 [([α2841'''] -> α2840''') ~ list['a2831''], ([α2841'''] -> α2840''') :> α2843''', [α2843''' - ([list['a2834''']] -> α2843''') ~ (α2846''' -> α2848''') - α2848''', L: 0 [([list['a2834''']] -> α2843''') ~ (α2846''' -> α2848'''), ([list['a2834''']] -> α2843''') :> filter2832''', filter2832''' <: (α2846''' -> α2848''')]], [α2848''' - ([['a2830'']], [α2848'''],) ~ ('a2831'', list['a2831''],) - list['a2831''], L: 0 [([['a2830'']], [α2848'''],) ~ ('a2831'', list['a2831''],), ([['a2830'']], [α2848'''],) <: ('a2831'', list['a2831''],)]]]


// file 0221
let fu x b = (x, (b < (x b)));;
let rec wwhile (f,b) =
  let temp = f b in
  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;
let fixpoint (f,b) = wwhile ((fu f), b);;
//│ fu: ('a -> anything & 'b) -> 'a -> ('b, bool,)
//│ wwhile: (nothing, ?,) -> 'a
//│ fixpoint: (nothing, nothing,) -> 'a

// file 2338
:unify
let rec assoc (d,k,l) =
  match l with
  | [] -> d
  | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│ assoc: ('a, 'b, nothing,) -> 'c
//│   where
//│     'a <: 'd & ('a, 'b, nothing,) & 'c
//│     'd <: 'b -> list[nothing] -> 'e
//│     'e <: 'd & 'c & 'f & 'g
//│     'c :> 'f | 'g | 'e | 'a
//│        <: 'd
//│     'f :> 'g | 'e
//│        <: 'd & 'c
//│     'g :> 'e
//│        <: 'd & 'c & 'f
