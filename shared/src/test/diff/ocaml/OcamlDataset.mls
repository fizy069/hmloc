:OcamlParser
:OcamlLoadLibrary

// file 246
let rec cloneHelper x n l =
  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;
let rec clone x n = if n < 1 then [] else cloneHelper x n [];;
let padZero l1 l2 =
  let diff = (List_length l1) - (List_length l2) in
  if diff < 0
  then (((clone 0 (-1 * diff)) @ l1), l2)
  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = padZero l1 l2 in
    let base = List_combine l1 l2 in
    let args = failwith "to be implemented" in
    let (_,res) = List_fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: match case without any arms
//│ 	at: mlscript.utils.package$.lastWords(package.scala:185)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:740)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:789)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:689)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:789)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:689)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:789)

// file 67 mod
type expr =
    VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;
let pi = 4.0 *. (atan 1.0);;
let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y);;
//│ Defined type alias expr
//│ Defined class VarX
//│ Defined class VarY
//│ Defined class Sine
//│ Defined class Cosine
//│ Defined class Average
//│ Defined class Times
//│ Defined class Thresh
//│ VarX: expr
//│ VarY: expr
//│ Sine: expr -> expr
//│ Cosine: expr -> expr
//│ Average: (expr, expr,) -> expr
//│ Times: (expr, expr,) -> expr
//│ Thresh: (expr, expr, expr, expr,) -> expr
//│ pi: float
//│ ╔══[ERROR] identifier not found: e'
//│ ║  l.48: 	  | Sine e' -> sin (pi *. (eval (e', x, y)))
//│ ╙──      	                                 ^^
//│ ╔══[ERROR] identifier not found: e'
//│ ║  l.49: 	  | Cosine e' -> cos (pi *. (eval (e', x, y)))
//│ ╙──      	                                   ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.50: 	  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
//│ ╙──      	                                                   ^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.50: 	  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
//│ ║        	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `float`
//│ ║  l.50: 	  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
//│ ║        	                                                                  ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.47: 	let ( /. ): float -> float -> float
//│ ╙──      	                     ^^^^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.51: 	  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
//│ ╙──      	                            ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.51: 	  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
//│ ╙──      	                                                 ^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.53: 	      if (eval (e1, x, y)) < (eval (e2, x, y))
//│ ╙──      	                ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.53: 	      if (eval (e1, x, y)) < (eval (e2, x, y))
//│ ╙──      	                                    ^^
//│ ╔══[ERROR] identifier not found: e3
//│ ║  l.54: 	      then eval (e3, x, y)
//│ ╙──      	                 ^^
//│ ╔══[ERROR] identifier not found: e4
//│ ║  l.55: 	      else eval (e4, x, y);;
//│ ╙──      	                 ^^
//│ eval: (expr, float, float,) -> float

// file 1087 mod
let sqsum xs =
  let f a x = match x with | [] -> 0 | h::t -> 1 in
  let base = List_hd xs in List_fold_left f base xs;;
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.112: 	  let f a x = match x with | [] -> 0 | h::t -> 1 in
//│ ╙──       	                                       ^
//│ sqsum: list[list[error] | 'a] -> (int | 'a)


// file 26 mod
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List_fold_left f base l;;
let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.124: 	  | h::t ->
//│ ╙──       	    ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.126: 	      let base = h in let l = t in List_fold_left f base l;;
//│ ╙──       	                 ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.126: 	      let base = h in let l = t in List_fold_left f base l;;
//│ ╙──       	                              ^
//│ sepConcat: string -> list[error] -> (error | string)
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.127: 	let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ ╙──       	                                              ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.127: 	let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ ║         	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not a function
//│ ║  l.13: 	let (^): string -> string -> string
//│ ║        	                             ^^^^^^
//│ ╟── but it flows into application with expected type `(?a, ?b,) -> ?c`
//│ ║  l.127: 	let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ ╙──       	                               ^^^^^^^^^^^^^^^^^^^^^^^
//│ stringOfList: anything -> anything -> string

// file 2376
let getHead h = match h with | [] -> [] | h::t -> h;;
let getTail t = match t with | [] -> [] | h::t -> t;;
let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
let rec matchHeads x y =
  match x with
  | [] -> true
  | h::t ->
      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
let palindrome w =
  match explode w with
  | [] -> true
  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ getHead: 'a -> (list[nothing] | 'a)
//│   where
//│     'a <: list[error & 'a]
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.154: 	let getTail t = match t with | [] -> [] | h::t -> t;;
//│ ╙──       	                                          ^
//│ getTail: (list['a] & 'b) -> (list[nothing] | 'b)
//│   where
//│     'a <: list['a] & error
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.156: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ╙──       	                            ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.156: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ╙──       	                                                 ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.156: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ╙──       	                                                       ^
//│ listReverse: 'a -> list[error]
//│   where
//│     'a <: list[error & 'a]
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.160: 	  | h::t ->
//│ ╙──       	    ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.161: 	      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
//│ ╙──       	                                                   ^
//│ matchHeads: (list['a] & 'b) -> (list['a] & 'b) -> bool
//│   where
//│     'b <: list[error & 'b]
//│     'a <: list['a] & error
//│ ╔══[ERROR] identifier not found: explode
//│ ║  l.163: 	  match explode w with
//│ ╙──       	        ^^^^^^^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.165: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ╙──       	    ^
//│ ╔══[ERROR] identifier not found: explode
//│ ║  l.165: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ╙──       	                        ^^^^^^^
//│ ╔══[ERROR] identifier not found: explode
//│ ║  l.165: 	  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ ╙──       	                                                 ^^^^^^^
//│ palindrome: anything -> bool

// TODO: parse properly
// let explode s =
//   let rec go i =
//     if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//   go 0;;

// file 1563
let rec sumListHelper total xs =
  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
let rec digitsOfIntHelper n =
  if n < 1
  then []
  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [n];;
let rec digitsOfInt n = digitsOfIntHelper n;;
let rec sumList xs = sumListHelper 0 xs;;
let rec additivePersistence n = sumList digitsOfInt n;;
//│ ╔══[ERROR] identifier not found: hd
//│ ║  l.219: 	  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ ╙──       	                                ^^
//│ ╔══[ERROR] identifier not found: hd
//│ ║  l.219: 	  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ ╙──       	                                                                   ^^
//│ ╔══[ERROR] identifier not found: tail
//│ ║  l.219: 	  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ ╙──       	                                                                       ^^^^
//│ sumListHelper: int -> 'a -> int
//│   where
//│     'a <: list[error & 'a]
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.220: 	let rec digitsOfIntHelper n =
//│ ║         	                          ^^^
//│ ║  l.221: 	  if n < 1
//│ ║         	^^^^^^^^^^
//│ ║  l.222: 	  then []
//│ ║         	^^^^^^^^^
//│ ║  l.223: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [n];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.223: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [n];;
//│ ║         	                                           ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.223: 	  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [n];;
//│ ╙──       	                                                       ^
//│ digitsOfIntHelper: nothing -> list[int]
//│ digitsOfInt: nothing -> list[int]
//│ sumList: 'a -> int
//│   where
//│     'a <: list[error & 'a]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.226: 	let rec additivePersistence n = sumList digitsOfInt n;;
//│ ║         	                                ^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?b -> ?c` does not match type `Cons[?a] | Nil`
//│ ║  l.224: 	let rec digitsOfInt n = digitsOfIntHelper n;;
//│ ║         	                    ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Cons[?a0] | Nil`
//│ ║  l.226: 	let rec additivePersistence n = sumList digitsOfInt n;;
//│ ║         	                                        ^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.225: 	let rec sumList xs = sumListHelper 0 xs;;
//│ ║         	                                     ^^
//│ ╟── from union type:
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──     	                       ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.226: 	let rec additivePersistence n = sumList digitsOfInt n;;
//│ ║         	                                ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not a function
//│ ║  l.225: 	let rec sumList xs = sumListHelper 0 xs;;
//│ ║         	                                   ^
//│ ╟── but it flows into application with expected type `?a -> ?b`
//│ ║  l.226: 	let rec additivePersistence n = sumList digitsOfInt n;;
//│ ╙──       	                                ^^^^^^^^^^^^^^^^^^^
//│ additivePersistence: anything -> nothing

// file 8776
let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
let getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;
let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
let rec matchHeads x =
  match explode x with
  | h::t ->
      if (getHeads (explode x)) = []
      then true
      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.290: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ╙──       	                            ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.290: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ╙──       	                                                 ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.290: 	  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│ ╙──       	                                                       ^
//│ listReverse: 'a -> list[error]
//│   where
//│     'a <: list[error & 'a]
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.291: 	let getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;
//│ ╙──       	                                                       ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.291: 	let getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;
//│ ╙──       	                                                                ^
//│ getHeads: 'a -> list[error]
//│   where
//│     'a <: list[error & 'a]
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.292: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ╙──       	                                                       ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.292: 	let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│ ╙──       	                                                               ^
//│ loseTail: 'a -> (error | list[nothing])
//│   where
//│     'a <: list[error & 'a]
//│ ╔══[ERROR] identifier not found: explode
//│ ║  l.294: 	  match explode x with
//│ ╙──       	        ^^^^^^^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.295: 	  | h::t ->
//│ ╙──       	    ^
//│ ╔══[ERROR] identifier not found: explode
//│ ║  l.296: 	      if (getHeads (explode x)) = []
//│ ╙──       	                    ^^^^^^^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.298: 	      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ ╙──       	               ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.298: 	      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ ╙──       	                              ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.298: 	      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ ╙──       	                                                           ^
//│ matchHeads: anything -> bool

// TODO: parse correctly
// let explode s =
//   let rec go i =
//     if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//   go 0;;

// file 89
// TODO: parse properly
// let rec digitsOfInt n =
//   let return = [n mod 10] in
//   if (n / 10) <> 0
//   then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)
//   else return;;
// let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
// let rec digitalRoot n =
//   let digits = digitsOfInt n in
//   let s = sumList digits in
//   if (n / 10) <> 0
//   then (print_int n; print_endline " "; digitalRoot)
//   else digits;;

// file 2361
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
let digits n = digitsOfInt (abs n);;
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.371: 	let rec digitsOfInt n =
//│ ║         	                    ^^^
//│ ║  l.372: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.19: 	let ( / ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.372: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;
//│ ║         	                                       ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.372: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;
//│ ╙──       	                                                   ^
//│ digitsOfInt: nothing -> list[nothing]
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.373: 	let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
//│ ╙──       	                                              ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.373: 	let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
//│ ╙──       	                                                      ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.373: 	let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
//│ ╙──       	                                                                    ^
//│ addNumbs: 'a -> int
//│   where
//│     'a <: list[error & 'a]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.374: 	let digits n = digitsOfInt (abs n);;
//│ ║         	               ^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.21: 	let abs: int -> int
//│ ║        	                ^^^
//│ ╟── but it flows into application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.374: 	let digits n = digitsOfInt (abs n);;
//│ ║         	                            ^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.372: 	  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;
//│ ╙──       	                                                   ^
//│ digits: int -> list[nothing]
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.378: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ╙──       	    ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.378: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ╙──       	                          ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.378: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ╙──       	                               ^
//│ additivePersistence: int -> (false | int | true)


// file 358 mod
// type expr used from previous
let buildCosine e = Cosine e;;
let buildSine e = Sine e;;
let buildX () = VarX;;
let buildY () = VarY;;
let rec build (rand,depth) =
  let r = rand 0.4 in
  match depth with
  | 0 -> if (r mod 2) = 0 then buildX else buildY
  | d ->
      if r = 0
      then buildSine build (rand, (d - 1))
      else buildCosine build (rand, (d - 1));;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: could not find type defintion d
//│ 	at: mlscript.utils.package$.lastWords(package.scala:185)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$22(Typer.scala:735)
//│ 	at: scala.collection.immutable.BitmapIndexedMapNode.getOrElse(HashMap.scala:683)
//│ 	at: scala.collection.immutable.HashMap.getOrElse(HashMap.scala:681)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$21(Typer.scala:735)
//│ 	at: scala.collection.immutable.List.map(List.scala:246)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:734)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:789)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:689)

// TODO file 1337 in separate file to avoid collisions

// file 2752
let remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;
let x l = List_map string_of_int;;
let y = [1, 2, 3];;
let rec mulByDigit i l =
  match List_rev l with
  | [] -> []
  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.460: 	let remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;
//│ ║         	                                         ^^^^^^^^^^^
//│ ╟── type `int` is not a function
//│ ║  l.18: 	let ( * ): int -> int -> int
//│ ║        	                         ^^^
//│ ╟── but it flows into operator application with expected type `(int -> int -> int) -> ?a`
//│ ║  l.460: 	let remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;
//│ ╙──       	                                          ^^^^^
//│ remainder: int -> int -> int
//│ x: anything -> list[int] -> list[string]
//│ y: list[(int, int, int,)]
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.466: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ╙──       	    ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.466: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ║         	             ^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.461: 	let x l = List_map string_of_int;;
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.466: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ║         	                       ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.460: 	let remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;
//│ ║         	                                          ^
//│ ╟── from type reference:
//│ ║  l.18: 	let ( * ): int -> int -> int
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.466: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ║         	             ^^^^^^^^^^^^^
//│ ╟── type `Nil` is not an instance of type `int`
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.466: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ║         	                         ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.460: 	let remainder x y = if (x * y) > 10 then (x * y) mod 10 else 0;;
//│ ║         	                                              ^
//│ ╟── from type reference:
//│ ║  l.18: 	let ( * ): int -> int -> int
//│ ╙──      	                  ^^^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.466: 	  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ ╙──       	                                            ^
//│ mulByDigit: anything -> list['a] -> list[int]
//│   where
//│     'a <: list['a] & error


// file 344 mod
let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
let padLength l1 l2 = abs ((List_length l1) - (List_length l2));;
let padZero l1 l2 =
  if (List_length l1) < (List_length l2)
  then (clone 0 (padLength l1 l2)) :: l1
  else (clone 0 (padLength l1 l2)) l2;;
//│ clone: 'a -> int -> list['a]
//│ padLength: list[?] -> list[?] -> int
//│ ╔══[ERROR] Type mismatch in if-then-else false condition:
//│ ║  l.526: 	  else (clone 0 (padLength l1 l2)) l2;;
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not a function
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into application with expected type `?a -> ?b`
//│ ║  l.526: 	  else (clone 0 (padLength l1 l2)) l2;;
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ padZero: list[?] -> list[?] -> list[list[int]]

// file 2736
// TODO parse properly
// let rec addHelper (t,u) =
// match List_rev t with
//  | [] -> []
//  | h::t ->
//     match List_rev u with
//      | [] -> []
//      | h'::t' ->
//          if (h + h') > 10
//          then (addHelper (t, t')) @ [(1 + h') + h]
//          else (addHelper (t, t')) @ [h' + h];;

// file 1948
// TODO parse properly
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
// let bigMul l1 l2 =
//   let f a x =
//     let (x1,x2) = x in
//     let (carry,res) = a in
//     match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//   let base = (0, []) in
//   let args = l1 (tenEx 0 l2) in
//   let (carry,res) = List_fold_left f base args in [carry] @ res;;
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.556: 	  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
//│ ╙──       	                            ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.556: 	  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
//│ ╙──       	                                                   ^
//│ ╔══[ERROR] identifier not found: helper
//│ ║  l.556: 	  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
//│ ╙──       	                                                          ^^^^^^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.556: 	  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
//│ ╙──       	                                                                      ^
//│ tenEx: int -> 'a -> list[int]
//│   where
//│     'a <: list[error & 'a]

// file 335
// TODO fix type system
let fixpointHelper f =
  match f with | (num,expr) -> if expr then (num, true) else (num, false);;
let rec wwhile (f,b) =
  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: match case without any arms

// file 3 mod
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let numZeros = (List_length l1) - (List_length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ clone: 'a -> int -> list['a]
//│ padZero: list[?] -> list[?] -> (list[int], list[int],)
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.601: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ╙──       	                                               ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.601: 	  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ╙──       	                                                   ^
//│ removeZero: (list[nothing] & 'a) -> (error | list[nothing] | 'a)

// TODO: parse let (a, b) = ... correctly
// let bigAdd l1 l2 =
//   let add (l1,l2) =
//     let f a x =
//       let (carry,currentSum) = a in
//       if x = []
//       then (0, (carry :: currentSum))
//       else
//         (let (toSum1,toSum2) = x in
//          let intermediateValue = (toSum1 + toSum2) + carry in
//          let valueToAddToArray = intermediateValue mod 10 in
//          let carry = intermediateValue / 10 in
//          (carry, (valueToAddToArray :: currentSum))) in
//     let base = (0, []) in
//     let args = List.rev (List.combine l1 l2) in
//     let (_,res) = List.fold_left f base args in res in
//   removeZero (add (padZero l1 l2));;

// file 1935
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let addTuple (l1,l2) = l1 + l2;;
let padZero l1 l2 =
  if (List_length l1) > (List_length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List_length l1) < (List_length l2)
    then (((clone 0 ((List_length l2) - (List_length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ clone: 'a -> int -> list['a]
//│ addTuple: (int, int,) -> int
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.635: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ╙──       	                        ^^^^
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.635: 	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ╙──       	                                           ^^^^
//│ padZero: list[?] -> list[?] -> (list[int], list[int],)
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.641: 	  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ ╙──       	                            ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.641: 	  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ ╙──       	                                       ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.641: 	  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ ╙──       	                                                             ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.641: 	  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ ╙──       	                                                                    ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.641: 	  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ ╙──       	                                                                         ^
//│ removeZero: list[nothing] -> list[error]

// TODO: parse let (a, b) = .. 
// let bigAdd l1 l2 =
//   let add (l1,l2) =
//     let f a x = (a + x) mod 10 in
//     let base = 0 in
//     let args = List_map addTuple (List_combine l1 l2) in
//     let (_,res) = List_fold_left f base args in res in
//   removeZero (add (padZero l1 l2));;


// file 1907
let intboolf f x = ((f x), ((f x) < 1));;
let fixpoint (f,b) = wwhile (intboolf, b);;
//│ intboolf: ('a -> 'b) -> 'a -> ('b, bool,)
//│ ╔══[ERROR] identifier not found: wwhile
//│ ║  l.680: 	let fixpoint (f,b) = wwhile (intboolf, b);;
//│ ╙──       	                     ^^^^^^
//│ fixpoint: (anything, anything,) -> error

// TODO: fix loc error
// let rec wwhile (f,b) =
//   match f b with | (b',c') -> if c' then wwhile (f, b') else b';;


// file 2047
let identity a = a;;
let pipe fs =
  let f a x = a x in let base = identity in List_fold_left f base fs;;
//│ identity: 'a -> 'a
//│ pipe: list['a & 'b & 'c] -> (('b & 'c) -> 'b | 'c)
//│   where
//│     'c <: 'a -> 'c


// file 830
// TODO: fix how match case is done
let modulus ss = ss mod 10;;
let rec digitsOfInt n =
  if n <= 0
  then []
  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;
let lt10 q = q < 10;;
let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
let rec additivePersistence n =
  if lt10 n
  then n
  else
    (match n with
     | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: could not find type defintion x


// file 1770
let rec filter l a =
  match l with
  | [] -> []
  | h::t -> if a = h then filter t a else h :: (filter t a);;
let removeDuplicates l =
  let rec helper (seen,rest) =
    match rest with
    | [] -> seen
    | h::t ->
        let seen' = h in
        let rest' = h :: (filter (t h)) in helper (seen', rest') in
  List_rev (helper ([], l));;
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.724: 	  | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ ╙──       	    ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.724: 	  | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ ╙──       	                   ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.724: 	  | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ ╙──       	                                 ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.724: 	  | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ ╙──       	                                          ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.724: 	  | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ ╙──       	                                                       ^
//│ filter: list[nothing] -> anything -> list[error]
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.729: 	    | h::t ->
//│ ╙──       	      ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.730: 	        let seen' = h in
//│ ╙──       	                    ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.731: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ╙──       	                    ^
//│ ╔══[ERROR] identifier not found: t
//│ ║  l.731: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ╙──       	                                  ^
//│ ╔══[ERROR] identifier not found: h
//│ ║  l.731: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ╙──       	                                    ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.731: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ║         	                    ^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` does not match type `Cons[?c] | Nil`
//│ ║  l.721: 	let rec filter l a =
//│ ║         	                 ^^^
//│ ║  l.722: 	  match l with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.723: 	  | [] -> []
//│ ║         	^^^^^^^^^^^^
//│ ║  l.724: 	  | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `Cons[?d] | Nil`
//│ ║  l.731: 	        let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ ║         	                          ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                            ^^
//│ ╟── from union type:
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ╙──     	                       ^^^^^^^^^^^^^^^^^^
//│ removeDuplicates: list[nothing] -> list[nothing]


// file 0221
// TODO fix Tuple2 in type system
let fu x b = (x, (b < (x b)));;
let rec wwhile (f,b) =
  let temp = f b in
  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;
let fixpoint (f,b) = wwhile ((fu f), b);;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: match case without any arms

// file 2338
let rec assoc (d,k,l) =
  match l with
  | [] -> d
  | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: match case without any arms
//│ 	at: mlscript.utils.package$.lastWords(package.scala:185)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:740)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:789)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$26(Typer.scala:778)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:756)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:789)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:651)
