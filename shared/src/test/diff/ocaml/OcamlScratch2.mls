let confluence z = if true then z else 5
//│ confluence: 'a -> (int | 'a)

:d
let mkpair x y = (x, confluence y)
//│ 1. Typing term x => y => x, confluence y,
//│ | 1. Typing pattern x
//│ | 1. : α58'
//│ | 1. Typing term y => x, confluence y,
//│ | | 1. Typing pattern y
//│ | | 1. : α59'
//│ | | 1. Typing term x, confluence y,
//│ | | | 1. Typing term x
//│ | | | 1. : [α58']
//│ | | | 1. Typing term confluence y
//│ | | | | 1. Typing term confluence
//│ | | | | 1. : [(α60' -> α61')]
//│ | | | | 1. Typing term y
//│ | | | | 1. : [α59']
//│ | | | | CONSTRAIN [(α60' -> α61')] <! ([α59'] -> α63')
//│ | | | |   where 
//│ 		α60' <: [[[α61']]]
//│ 		α61' :> [[int]] | [[[α60']]]
//│ | | | | C [(α60' -> α61')] <! ([α59'] -> α63')    (0) where ProvType <: FunctionType}
//│ | | | | | C (α60' -> α61') <! ([α59'] -> α63')    (0) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[α59']]
//│ | | | | | | C [α59'] <! α60'    (1) where ProvType <: TypeVariable}
//│ | | | | | | | C α59' <! α60'    (1) where TypeVariable <: TypeVariable}
//│ | | | | | | | | symmetric
//│ | | | | | | | | C α59' <! [[[α61']]]    (2) where TypeVariable <: ProvType}
//│ | | | | | | | | | C α59' <! [[α61']]    (2) where TypeVariable <: ProvType}
//│ | | | | | | | | | | C α59' <! [α61']    (2) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | C α59' <! α61'    (2) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | symmetric
//│ | | | | | | [nested] [α61']
//│ | | | | | | C α61' <! α63'    (3) where TypeVariable <: TypeVariable}
//│ | | | | | | | symmetric
//│ | | | | | | | C [[[[[[α59']]]]]] <! α63'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | C [[[[[α59']]]]] <! α63'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | C [[[[α59']]]] <! α63'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | C [[[α59']]] <! α63'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | C [[α59']] <! α63'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | C [α59'] <! α63'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | C α59' <! α63'    (4) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | symmetric
//│ | | | | | | | C [[int]] <! α63'    (5) where ProvType <: TypeVariable}
//│ | | | | | | | | C [int] <! α63'    (5) where ProvType <: TypeVariable}
//│ | | | | | | | | | C int <! α63'    (5) where TypeRef <: TypeVariable}
//│ | | | | | | | C [[[α60']]] <! α63'    (6) where ProvType <: TypeVariable}
//│ | | | | | | | | C [[α60']] <! α63'    (6) where ProvType <: TypeVariable}
//│ | | | | | | | | | C [α60'] <! α63'    (6) where ProvType <: TypeVariable}
//│ | | | | | | | | | | C α60' <! α63'    (6) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | symmetric
//│ | | | | | | | | | | | C [[[[α59']]]] <! α63'    (7) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | C [[[α59']]] <! α63'    (7) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | C [[α59']] <! α63'    (7) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | | C [α59'] <! α63'    (7) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | | | C α59' <! α63'    (7) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | Cached!
//│ | | | 1. : α63'
//│ | | 1. : ([α58'], α63',)
//│ | 1. : (α59' -> ([α58'], α63',))
//│ 1. : (α58' -> (α59' -> ([α58'], α63',)))
//│ ⬤ Typed as: (α58' -> (α59' -> ([α58'], α63',)))
//│  where: 
//│ 		α59' <: [[[[[[[[α63']]]]]]]] & [[[[[[α61']]]]]] & [[[[α60']]]]
//│ 		α60' :> [[[[α59']]]] <: [[[[[α63']]]]] & [[[α61']]]
//│ 		α61' :> [[[[[[α59']]]]]] | [[int]] | [[[α60']]] <: [[[α63']]]
//│ 		α63' :> [[[α61']]] | [[[[[α60']]]]] | [[[[int]]]] | [[[[[[[[α59']]]]]]]]
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)

:d
// mkpair 1 "2"

:unifyDbg
:d
let conflict x = mkpair (not x) x
//│ 1. Typing term x => mkpair (not x) x
//│ | 1. Typing pattern x
//│ | 1. : α73'
//│ | 1. Typing term mkpair (not x) x
//│ | | 1. Typing term mkpair (not x)
//│ | | | 1. Typing term mkpair
//│ | | | 1. : [(α74' -> (α75' -> ([α74'], α76',)))]
//│ | | | 1. Typing term not x
//│ | | | | 1. Typing term not
//│ | | | | 1. : [(bool -> bool)]
//│ | | | | 1. Typing term x
//│ | | | | 1. : [α73']
//│ | | | | CONSTRAIN [(bool -> bool)] <! ([α73'] -> α80')
//│ | | | |   where 
//│ | | | | C [(bool -> bool)] <! ([α73'] -> α80')    (0) where ProvType <: FunctionType}
//│ | | | | | C (bool -> bool) <! ([α73'] -> α80')    (0) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[α73']]
//│ | | | | | | C [α73'] <! bool    (1) where ProvType <: TypeRef}
//│ | | | | | | | C α73' <! bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | | [nested] [bool]
//│ | | | | | | C bool <! α80'    (2) where TypeRef <: TypeVariable}
//│ | | | 1. : α80'
//│ | | | CONSTRAIN [(α74' -> (α75' -> ([α74'], α76',)))] <! (α80' -> α82')
//│ | | |   where 
//│ 		α75' <: [[[[[[[[α76']]]]]]]] & [[[[[[α77']]]]]] & [[[[α78']]]]
//│ 		α76' :> [[[α77']]] | [[[[[α78']]]]] | [[[[int]]]] | [[[[[[[[α75']]]]]]]]
//│ 		α77' :> [[[[[[α75']]]]]] | [[int]] | [[[α78']]] <: [[[α76']]]
//│ 		α78' :> [[[[α75']]]] <: [[[[[α76']]]]] & [[[α77']]]
//│ 		α80' :> [[[bool]]]
//│ | | | C [(α74' -> (α75' -> ([α74'], α76',)))] <! (α80' -> α82')    (0) where ProvType <: FunctionType}
//│ | | | | C (α74' -> (α75' -> ([α74'], α76',))) <! (α80' -> α82')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [α80']
//│ | | | | | C α80' <! α74'    (1) where TypeVariable <: TypeVariable}
//│ | | | | | | symmetric
//│ | | | | | | C [[[bool]]] <! α74'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | C [[bool]] <! α74'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | C [bool] <! α74'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | | C bool <! α74'    (2) where TypeRef <: TypeVariable}
//│ | | | | | [nested] [(α75' -> ([α74'], α76',))]
//│ | | | | | C (α75' -> ([α74'], α76',)) <! α82'    (3) where FunctionType <: TypeVariable}
//│ | | 1. : α82'
//│ | | 1. Typing term x
//│ | | 1. : [α73']
//│ | | CONSTRAIN α82' <! ([α73'] -> α84')
//│ | |   where 
//│ 		α73' <: [[[[bool]]]]
//│ 		α74' :> [[[α80']]] | [[[[[bool]]]]]
//│ 		α75' <: [[[[[[[[α76']]]]]]]] & [[[[[[α77']]]]]] & [[[[α78']]]]
//│ 		α76' :> [[[α77']]] | [[[[[α78']]]]] | [[[[int]]]] | [[[[[[[[α75']]]]]]]]
//│ 		α77' :> [[[[[[α75']]]]]] | [[int]] | [[[α78']]] <: [[[α76']]]
//│ 		α78' :> [[[[α75']]]] <: [[[[[α76']]]]] & [[[α77']]]
//│ 		α80' :> [[[bool]]] <: [[[α74']]]
//│ 		α82' :> [[[(α75' -> ([α74'], α76',))]]]
//│ | | C α82' <! ([α73'] -> α84')    (0) where TypeVariable <: FunctionType}
//│ | | | C [[[(α75' -> ([α74'], α76',))]]] <! ([α73'] -> α84')    (1) where ProvType <: FunctionType}
//│ | | | | C [[(α75' -> ([α74'], α76',))]] <! ([α73'] -> α84')    (1) where ProvType <: FunctionType}
//│ | | | | | C [(α75' -> ([α74'], α76',))] <! ([α73'] -> α84')    (1) where ProvType <: FunctionType}
//│ | | | | | | C (α75' -> ([α74'], α76',)) <! ([α73'] -> α84')    (1) where FunctionType <: FunctionType}
//│ | | | | | | | [nested] [[α73']]
//│ | | | | | | | C [α73'] <! α75'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | C α73' <! α75'    (2) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | symmetric
//│ | | | | | | | | | C α73' <! [[[[[[[[α76']]]]]]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | C α73' <! [[[[[[[α76']]]]]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | C α73' <! [[[[[[α76']]]]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | C α73' <! [[[[[α76']]]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | C α73' <! [[[[α76']]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | C α73' <! [[[α76']]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | C α73' <! [[α76']]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | C α73' <! [α76']    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | C α73' <! α76'    (3) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | | | symmetric
//│ | | | | | | | | | C α73' <! [[[[[[α77']]]]]]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | C α73' <! [[[[[α77']]]]]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | C α73' <! [[[[α77']]]]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | C α73' <! [[[α77']]]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | C α73' <! [[α77']]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | C α73' <! [α77']    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | C α73' <! α77'    (4) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | symmetric
//│ | | | | | | | | | | | | | | | | C α73' <! [[[α76']]]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | C α73' <! [[α76']]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | | C α73' <! [α76']    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | | | C α73' <! α76'    (5) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | | | | | Cached!
//│ | | | | | | | | | C α73' <! [[[[α78']]]]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | C α73' <! [[[α78']]]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | C α73' <! [[α78']]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | C α73' <! [α78']    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | C α73' <! α78'    (5) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | symmetric
//│ | | | | | | | | | | | | | | C α73' <! [[[[[α76']]]]]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | C α73' <! [[[[α76']]]]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | C α73' <! [[[α76']]]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | C α73' <! [[α76']]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | | C α73' <! [α76']    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | | | C α73' <! α76'    (6) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | | | | | Cached!
//│ | | | | | | | | | | | | | | C α73' <! [[[α77']]]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | C α73' <! [[α77']]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | C α73' <! [α77']    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | C α73' <! α77'    (6) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | | | Cached!
//│ | | | | | | | [nested] [([α74'], α76',)]
//│ | | | | | | | C ([α74'], α76',) <! α84'    (6) where TupleType <: TypeVariable}
//│ | 1. : α84'
//│ 1. : (α73' -> α84')
//│ ⬤ Typed as: (α73' -> α84')
//│  where: 
//│ 		α73' <: [[[[[[[α78']]]]]]] & [[[[[[[[[α77']]]]]]]]] & [[[[[[[[[[[α76']]]]]]]]]]] & [[[[α75']]]] & [[[[bool]]]]
//│ 		α74' :> [[[α80']]] | [[[[[bool]]]]]
//│ 		α75' :> [[[[α73']]]] <: [[[[[[[[α76']]]]]]]] & [[[[[[α77']]]]]] & [[[[α78']]]]
//│ 		α76' :> [[[[[[[[[[[α73']]]]]]]]]]] | [[[α77']]] | [[[[[α78']]]]] | [[[[int]]]] | [[[[[[[[α75']]]]]]]]
//│ 		α77' :> [[[[[[[[[α73']]]]]]]]] | [[[[[[α75']]]]]] | [[int]] | [[[α78']]] <: [[[α76']]]
//│ 		α78' :> [[[[[[[α73']]]]]]] | [[[[α75']]]] <: [[[[[α76']]]]] & [[[α77']]]
//│ 		α80' :> [[[bool]]] <: [[[α74']]]
//│ 		α84' :> [[[([α74'], α76',)]]]
//│ unified α84' with:
//│ unified α83' with:
//│ unified α82' with:
//│ unified α81' with:
//│ unified α80' with:
//│ unified α79' with:
//│ unified α78' with:
//│ unified α77' with:
//│ unified α76' with:
//│ unified α75' with:
//│ unified α74' with:
//│ unified α73' with:
//│ α84' bounds
//│  α84' <: [[[([α74'], α76',)]]] with lb([[[([α74'], α76',)]]] <: α84') length: 3
//│ UT α84' <: [[[([α74'], α76',)]]] len: 4 
//│ | UT  ([α74'], α76',) with
//│ | UT  [[[([α74'], α76',)]]] <: α84' <: ([α74'], α76',)
//│ | UT [[[([α74'], α76',)]]] <: [[[([α74'], α76',)]]] len: 7 
//│ | | U [[[([α74'], α76',)]]] = [[[([α74'], α76',)]]] because lb([[[([α74'], α76',)]]] <: [[[([α74'], α76',)]]]) skipCache
//│ | | | UT [α74'] <: [α74'] len: 4 nested: [[[([α74'], α76',)]]] = [[[([α74'], α76',)]]] because lb([[[([α74'], α76',)]]] <: [[[([α74'], α76',)]]])
//│ | | | UT α76' <: α76' len: 2 nested: [[[([α74'], α76',)]]] = [[[([α74'], α76',)]]] because lb([[[([α74'], α76',)]]] <: [[[([α74'], α76',)]]])
//│ | UT  α84' += ([[[([α74'], α76',)]]],List(ub(α84' <: [[[([α74'], α76',)]]])))
//│ α83' bounds
//│ α82' bounds
//│  α82' <: [[[(α75' -> ([α74'], α76',))]]] with lb([[[(α75' -> ([α74'], α76',))]]] <: α82') length: 3
//│ UT α82' <: [[[(α75' -> ([α74'], α76',))]]] len: 4 
//│ | UT  (α75' -> ([α74'], α76',)) with
//│ | UT  [[[(α75' -> ([α74'], α76',))]]] <: α82' <: (α75' -> ([α74'], α76',))
//│ | UT [[[(α75' -> ([α74'], α76',))]]] <: [[[(α75' -> ([α74'], α76',))]]] len: 7 
//│ | | U [[[(α75' -> ([α74'], α76',))]]] = [[[(α75' -> ([α74'], α76',))]]] because lb([[[(α75' -> ([α74'], α76',))]]] <: [[[(α75' -> ([α74'], α76',))]]]) skipCache
//│ | UT  (α75' -> ([α74'], α76',)) with
//│ | UT  α82' += ([[[(α75' -> ([α74'], α76',))]]],List(ub(α82' <: [[[(α75' -> ([α74'], α76',))]]])))
//│  α82' :> [[([α73'] -> α84')]] with ub(α82' <: [[([α73'] -> α84')]]) length: 3
//│ UT α82' <: [[([α73'] -> α84')]] len: 4 
//│ | UT  ([α73'] -> α84') with
//│ | UT  [[[(α75' -> ([α74'], α76',))]]] <: α82' <: ([α73'] -> α84')
//│ | UT [[[(α75' -> ([α74'], α76',))]]] <: [[([α73'] -> α84')]] len: 7 
//│ | | U [[[(α75' -> ([α74'], α76',))]]] = [[([α73'] -> α84')]] because lb([[[(α75' -> ([α74'], α76',))]]] <: [[([α73'] -> α84')]]) skipCache
//│ | UT  ([α73'] -> α84') with
//│ | UT  α82' += ([[([α73'] -> α84')]],List(ub(α82' <: [[([α73'] -> α84')]])))
//│ α81' bounds
//│ α80' bounds
//│  α80' <: [[[bool]]] with lb([[[bool]]] <: α80') length: 3
//│ UT α80' <: [[[bool]]] len: 4 
//│ | UT  bool with
//│ | UT  [[[bool]]] <: α80' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 7 
//│ | | U [[[bool]]] = [[[bool]]] because lb([[[bool]]] <: [[[bool]]]) skipCache
//│ | UT  bool with
//│ | UT  α80' += ([[[bool]]],List(ub(α80' <: [[[bool]]])))
//│  α80' :> [[[α74']]] with ub(α80' <: [[[α74']]]) length: 3
//│ UT α80' <: [[[α74']]] len: 4 
//│ | UT  α74' with
//│ | UT  [[[bool]]] <: α80' <: α74'
//│ | UT [[[bool]]] <: [[[α74']]] len: 7 
//│ | | UT  [[[bool]]] with
//│ | | UT  α74' += ([[[bool]]],List(lb([[[bool]]] <: α74')))
//│ | UT  α74' with
//│ | UT  α80' += ([[[α74']]],List(ub(α80' <: [[[α74']]])))
//│ α79' bounds
//│ α78' bounds
//│  α78' <: [[[[[[[α73']]]]]]] with lb([[[[[[[α73']]]]]]] <: α78') length: 6
//│ UT α78' <: [[[[[[[α73']]]]]]] len: 7 
//│ | UT  α73' with
//│ | UT  [[[[[[[α73']]]]]]] <: α78' <: α73'
//│ | UT [[[[[[[α73']]]]]]] <: [[[[[[[α73']]]]]]] len: 13 
//│ | UT  [[[[α75']]]] <: α78' <: α73'
//│ | UT [[[[α75']]]] <: [[[[[[[α73']]]]]]] len: 11 
//│ | | UT  α73' with
//│ | | UT  [[[[α73']]]] <: α75' <: α73'
//│ | | UT [[[[α73']]]] <: [[[[[[[α73']]]]]]] len: 15 
//│ | | UT  α73' with
//│ | | UT  α75' += ([[[[[[[α73']]]]]]],List(ub(α75' <: [[[[[[[α73']]]]]]])))
//│ | UT  α73' with
//│ | UT  α78' += ([[[[[[[α73']]]]]]],List(ub(α78' <: [[[[[[[α73']]]]]]])))
//│  α78' <: [[[[α75']]]] with lb([[[[α75']]]] <: α78') length: 4
//│ UT α78' <: [[[[α75']]]] len: 5 
//│ | UT  α75' with
//│ | UT  [[[[[[[α73']]]]]]] <: α78' <: α75'
//│ | UT [[[[[[[α73']]]]]]] <: [[[[α75']]]] len: 11 
//│ | UT  [[[[α75']]]] <: α78' <: α75'
//│ | UT [[[[α75']]]] <: [[[[α75']]]] len: 9 
//│ | UT  α75' with
//│ | UT  α78' += ([[[[α75']]]],List(ub(α78' <: [[[[α75']]]])))
//│  α78' :> [[[[[α76']]]]] with ub(α78' <: [[[[[α76']]]]]) length: 5
//│ UT α78' <: [[[[[α76']]]]] len: 6 
//│ | UT  α76' with
//│ | UT  [[[[[[[α73']]]]]]] <: α78' <: α76'
//│ | UT [[[[[[[α73']]]]]]] <: [[[[[α76']]]]] len: 12 
//│ | | UT  α76' with
//│ | | UT  α73' += ([[[[[α76']]]]],List(ub(α73' <: [[[[[α76']]]]])))
//│ | UT  [[[[α75']]]] <: α78' <: α76'
//│ | UT [[[[α75']]]] <: [[[[[α76']]]]] len: 10 
//│ | | UT  α76' with
//│ | | UT  [[[[α73']]]] <: α75' <: α76'
//│ | | UT [[[[α73']]]] <: [[[[[α76']]]]] len: 14 
//│ | | UT  α76' with
//│ | | UT  α75' += ([[[[[α76']]]]],List(ub(α75' <: [[[[[α76']]]]])))
//│ | UT  α76' with
//│ | UT  α78' += ([[[[[α76']]]]],List(ub(α78' <: [[[[[α76']]]]])))
//│  α78' :> [[[α77']]] with ub(α78' <: [[[α77']]]) length: 4
//│ UT α78' <: [[[α77']]] len: 5 
//│ | UT  α77' with
//│ | UT  [[[[[[[α73']]]]]]] <: α78' <: α77'
//│ | UT [[[[[[[α73']]]]]]] <: [[[α77']]] len: 11 
//│ | | UT  α77' with
//│ | | UT  α73' <: [[[[[[[[[[[α76']]]]]]]]]]]  for ub(α73' <: [[[[[α76']]]]])
//│ | | U [[[[[[[[[[[α76']]]]]]]]]]] = [[[α77']]] because ub(α73' <: [[[[[α76']]]]]), ub(α73' <: [[[α77']]]) ()
//│ | | UT  α73' += ([[[α77']]],List(ub(α73' <: [[[α77']]])))
//│ | UT  [[[[α75']]]] <: α78' <: α77'
//│ | UT [[[[α75']]]] <: [[[α77']]] len: 9 
//│ | | UT  α77' with
//│ | | UT  [[[[α73']]]] <: α75' <: α77'
//│ | | UT [[[[α73']]]] <: [[[α77']]] len: 13 
//│ | | UT  α77' with
//│ | | UT  α75' <: [[[[[[[[α76']]]]]]]]  for ub(α75' <: [[[[[α76']]]]])
//│ | | U [[[[[[[[α76']]]]]]]] = [[[α77']]] because ub(α75' <: [[[[[α76']]]]]), ub(α75' <: [[[α77']]]) ()
//│ | | UT  α75' += ([[[α77']]],List(ub(α75' <: [[[α77']]])))
//│ | UT  α77' with
//│ | UT  α78' <: [[[[[α76']]]]]  for ub(α78' <: [[[[[α76']]]]])
//│ | U [[[[[α76']]]]] = [[[α77']]] because ub(α78' <: [[[[[α76']]]]]), ub(α78' <: [[[α77']]]) ()
//│ | UT  α78' += ([[[α77']]],List(ub(α78' <: [[[α77']]])))
//│ α77' bounds
//│  α77' <: [[[[[[[[[α73']]]]]]]]] with lb([[[[[[[[[α73']]]]]]]]] <: α77') length: 8
//│ UT α77' <: [[[[[[[[[α73']]]]]]]]] len: 9 
//│  α77' <: [[[[[[α75']]]]]] with lb([[[[[[α75']]]]]] <: α77') length: 6
//│ UT α77' <: [[[[[[α75']]]]]] len: 7 
//│  α77' <: [[int]] with lb([[int]] <: α77') length: 3
//│ UT α77' <: [[int]] len: 4 
//│ | UT  int with
//│ | UT  [[[[[[[[[α73']]]]]]]]] <: α77' <: int
//│ | UT [[[[[[[[[α73']]]]]]]]] <: [[int]] len: 12 
//│ | | UT  int with
//│ | | UT  α73' <: [[[[[[[[[α77']]]]]]]]]  for ub(α73' <: [[[α77']]])
//│ | | U [[[[[[[[[α77']]]]]]]]] = [[int]] because ub(α73' <: [[[α77']]]), ub(α73' <: [[int]]) ()
//│ | | UT  α73' <: [[[[[[[[[[[α76']]]]]]]]]]]  for ub(α73' <: [[[[[α76']]]]])
//│ | | U [[[[[[[[[[[α76']]]]]]]]]]] = [[int]] because ub(α73' <: [[[[[α76']]]]]), ub(α73' <: [[int]]) ()
//│ | | UT  α73' += ([[int]],List(ub(α73' <: [[int]])))
//│ | UT  [[[[[[α75']]]]]] <: α77' <: int
//│ | UT [[[[[[α75']]]]]] <: [[int]] len: 10 
//│ | | UT  int with
//│ | | UT  [[[[α73']]]] <: α75' <: int
//│ | | UT [[[[α73']]]] <: [[int]] len: 14 
//│ | | UT  int with
//│ | | UT  α75' <: [[[[[[[[α76']]]]]]]]  for ub(α75' <: [[[[[α76']]]]])
//│ | | U [[[[[[[[α76']]]]]]]] = [[int]] because ub(α75' <: [[[[[α76']]]]]), ub(α75' <: [[int]]) ()
//│ | | UT  α75' <: [[[[[[α77']]]]]]  for ub(α75' <: [[[α77']]])
//│ | | U [[[[[[α77']]]]]] = [[int]] because ub(α75' <: [[[α77']]]), ub(α75' <: [[int]]) ()
//│ | | UT  α75' += ([[int]],List(ub(α75' <: [[int]])))
//│ | UT  [[int]] <: α77' <: int
//│ | UT [[int]] <: [[int]] len: 7 
//│ | | U [[int]] = [[int]] because lb([[int]] <: [[int]]) skipCache
//│ | UT  [[[α78']]] <: α77' <: int
//│ | UT [[[α78']]] <: [[int]] len: 8 
//│ | | UT  int with
//│ | | UT  [[[[[[[α73']]]]]]] <: α78' <: int
//│ | | UT [[[[[[[α73']]]]]]] <: [[int]] len: 14 
//│ | | UT  [[[[α75']]]] <: α78' <: int
//│ | | UT [[[[α75']]]] <: [[int]] len: 12 
//│ | | UT  int with
//│ | | UT  α78' <: [[[[[α76']]]]]  for ub(α78' <: [[[[[α76']]]]])
//│ | | U [[[[[α76']]]]] = [[int]] because ub(α78' <: [[[[[α76']]]]]), ub(α78' <: [[int]]) ()
//│ | | UT  α78' <: [[[α77']]]  for ub(α78' <: [[[α77']]])
//│ | | U [[[α77']]] = [[int]] because ub(α78' <: [[[α77']]]), ub(α78' <: [[int]]) ()
//│ | | UT  α78' += ([[int]],List(ub(α78' <: [[int]])))
//│ | UT  int with
//│ | UT  α77' += ([[int]],List(ub(α77' <: [[int]])))
//│  α77' <: [[[α78']]] with lb([[[α78']]] <: α77') length: 4
//│ UT α77' <: [[[α78']]] len: 5 
//│  α77' :> [[[α76']]] with ub(α77' <: [[[α76']]]) length: 3
//│ UT α77' <: [[[α76']]] len: 4 
//│ α76' bounds
//│  α76' <: [[[[[[[[[[[α73']]]]]]]]]]] with lb([[[[[[[[[[[α73']]]]]]]]]]] <: α76') length: 9
//│ UT α76' <: [[[[[[[[[[[α73']]]]]]]]]]] len: 10 
//│  α76' <: [[[α77']]] with lb([[[α77']]] <: α76') length: 3
//│ UT α76' <: [[[α77']]] len: 4 
//│  α76' <: [[[[[α78']]]]] with lb([[[[[α78']]]]] <: α76') length: 5
//│ UT α76' <: [[[[[α78']]]]] len: 6 
//│  α76' <: [[[[int]]]] with lb([[[[int]]]] <: α76') length: 4
//│ UT α76' <: [[[[int]]]] len: 5 
//│  α76' <: [[[[[[[[α75']]]]]]]] with lb([[[[[[[[α75']]]]]]]] <: α76') length: 7
//│ UT α76' <: [[[[[[[[α75']]]]]]]] len: 8 
//│ α75' bounds
//│  α75' <: [[[[α73']]]] with lb([[[[α73']]]] <: α75') length: 4
//│ UT α75' <: [[[[α73']]]] len: 5 
//│  α75' :> [[[[[[[[α76']]]]]]]] with ub(α75' <: [[[[[[[[α76']]]]]]]]) length: 7
//│ UT α75' <: [[[[[[[[α76']]]]]]]] len: 8 
//│  α75' :> [[[[[[α77']]]]]] with ub(α75' <: [[[[[[α77']]]]]]) length: 6
//│ UT α75' <: [[[[[[α77']]]]]] len: 7 
//│  α75' :> [[[[α78']]]] with ub(α75' <: [[[[α78']]]]) length: 4
//│ UT α75' <: [[[[α78']]]] len: 5 
//│ α74' bounds
//│  α74' <: [[[α80']]] with lb([[[α80']]] <: α74') length: 3
//│ UT α74' <: [[[α80']]] len: 4 
//│  α74' <: [[[[[bool]]]]] with lb([[[[[bool]]]]] <: α74') length: 4
//│ UT α74' <: [[[[[bool]]]]] len: 5 
//│ α73' bounds
//│  α73' :> [[[[[[[α78']]]]]]] with ub(α73' <: [[[[[[[α78']]]]]]]) length: 6
//│ UT α73' <: [[[[[[[α78']]]]]]] len: 7 
//│  α73' :> [[[[[[[[[α77']]]]]]]]] with ub(α73' <: [[[[[[[[[α77']]]]]]]]]) length: 8
//│ UT α73' <: [[[[[[[[[α77']]]]]]]]] len: 9 
//│  α73' :> [[[[[[[[[[[α76']]]]]]]]]]] with ub(α73' <: [[[[[[[[[[[α76']]]]]]]]]]]) length: 9
//│ UT α73' <: [[[[[[[[[[[α76']]]]]]]]]]] len: 10 
//│  α73' :> [[[[α75']]]] with ub(α73' <: [[[[α75']]]]) length: 4
//│ UT α73' <: [[[[α75']]]] len: 5 
//│  α73' :> [[[[bool]]]] with ub(α73' <: [[[[bool]]]]) length: 4
//│ UT α73' <: [[[[bool]]]] len: 5 
//│ | UT  bool with
//│ | UT  α73' <: [[[[[[[α78']]]]]]]  for ub(α73' <: [[[[[[[α78']]]]]]])
//│ | U [[[[[[[α78']]]]]]] = [[[[bool]]]] because ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | U   bool with
//│ | |     α78' = [[[α77']]] for ub(α78' <: [[[α77']]])
//│ | | U [[[α77']]] = bool because ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | U   bool with
//│ | | |     α77' = [[[α78']]] for lb([[[α78']]] <: α77')
//│ | | | U [[[α78']]] = bool because lb([[[α78']]] <: α77'), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | |     α77' = [[[[[[[[[α73']]]]]]]]] for lb([[[[[[[[[α73']]]]]]]]] <: α77')
//│ | | | U [[[[[[[[[α73']]]]]]]]] = bool because lb([[[[[[[[[α73']]]]]]]]] <: α77'), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | |     α77' = [[int]] for lb([[int]] <: α77')
//│ | | | U [[int]] = bool because lb([[int]] <: α77'), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | | UERR  [[int]] = bool because lb([[int]] <: α77'),ub(α78' <: [[[α77']]]),ub(α73' <: [[[[[[[α78']]]]]]]),ub(α73' <: [[[[bool]]]])
//│ | | | | (lb([[int]] <: α77'),true) -> (ub(α78' <: [[[α77']]]),false) showFirst: true leftSame: false
//│ | | | | show 2 locations for (lb([[int]] <: α77'),true)
//│ | | | | (lb([[int]] <: α77'),true) -> (ub(α78' <: [[[α77']]]),false) showFirst: false leftSame: false
//│ | | | | show 2 locations for (ub(α78' <: [[[α77']]]),false)
//│ | | | | (ub(α78' <: [[[α77']]]),false) -> (ub(α73' <: [[[[bool]]]]),true) showFirst: false leftSame: false
//│ | | | | show 3 locations for (ub(α73' <: [[[[bool]]]]),true)
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a` and it flows from `?b`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── this variable has type `?b`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── this variable has type `?c`
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── this reference has type `?c` and it flows into `bool`
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                             ^
//│ ╟── this type reference has type `bool`
//│ ║  builtin: 	let not: bool -> bool
//│ ╙──         	         ^^^^
//│ | | |     α77' = [[[α76']]] for ub(α77' <: [[[α76']]])
//│ | | | U [[[α76']]] = bool because ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | | U   bool with
//│ | | | |     α76' = [[[[[α78']]]]] for lb([[[[[α78']]]]] <: α76')
//│ | | | | U [[[[[α78']]]]] = bool because lb([[[[[α78']]]]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | |     α76' = [[[α77']]] for lb([[[α77']]] <: α76')
//│ | | | | U [[[α77']]] = bool because lb([[[α77']]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | |     α76' = [[[[[[[[[[[α73']]]]]]]]]]] for lb([[[[[[[[[[[α73']]]]]]]]]]] <: α76')
//│ | | | | U [[[[[[[[[[[α73']]]]]]]]]]] = bool because lb([[[[[[[[[[[α73']]]]]]]]]]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | |     α76' = [[[[int]]]] for lb([[[[int]]]] <: α76')
//│ | | | | U [[[[int]]]] = bool because lb([[[[int]]]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | |     α76' = [[[[[[[[α75']]]]]]]] for lb([[[[[[[[α75']]]]]]]] <: α76')
//│ | | | | U [[[[[[[[α75']]]]]]]] = bool because lb([[[[[[[[α75']]]]]]]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | | | U   bool with
//│ | | | | |     α75' = [[[[α78']]]] for ub(α75' <: [[[[α78']]]])
//│ | | | | | U [[[[α78']]]] = bool because ub(α75' <: [[[[α78']]]]), lb([[[[[[[[α75']]]]]]]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | | |     α75' = [[[α77']]] for ub(α75' <: [[[[[[α77']]]]]])
//│ | | | | | U [[[α77']]] = bool because ub(α75' <: [[[[[[α77']]]]]]), lb([[[[[[[[α75']]]]]]]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | | |     α75' = [[[[[[[α73']]]]]]] for lb([[[[α73']]]] <: α75')
//│ | | | | | U [[[[[[[α73']]]]]]] = bool because lb([[[[α73']]]] <: α75'), lb([[[[[[[[α75']]]]]]]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | | |     α75' = [[int]] for ub(α75' <: [[int]])
//│ | | | | | U [[int]] = bool because ub(α75' <: [[int]]), lb([[[[[[[[α75']]]]]]]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | | | |     α75' = [[[[[α76']]]]] for ub(α75' <: [[[[[[[[α76']]]]]]]])
//│ | | | | | U [[[[[α76']]]]] = bool because ub(α75' <: [[[[[[[[α76']]]]]]]]), lb([[[[[[[[α75']]]]]]]] <: α76'), ub(α77' <: [[[α76']]]), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | | |     α77' = [[[[[[α75']]]]]] for lb([[[[[[α75']]]]]] <: α77')
//│ | | | U [[[[[[α75']]]]]] = bool because lb([[[[[[α75']]]]]] <: α77'), ub(α78' <: [[[α77']]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | |     α78' = [[[[[[[α73']]]]]]] for lb([[[[[[[α73']]]]]]] <: α78')
//│ | | U [[[[[[[α73']]]]]]] = bool because lb([[[[[[[α73']]]]]]] <: α78'), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | |     α78' = [[int]] for ub(α78' <: [[int]])
//│ | | U [[int]] = bool because ub(α78' <: [[int]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | |     α78' = [[[[[α76']]]]] for ub(α78' <: [[[[[α76']]]]])
//│ | | U [[[[[α76']]]]] = bool because ub(α78' <: [[[[[α76']]]]]), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | |     α78' = [[[[α75']]]] for lb([[[[α75']]]] <: α78')
//│ | | U [[[[α75']]]] = bool because lb([[[[α75']]]] <: α78'), ub(α73' <: [[[[[[[α78']]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | UT  α73' <: [[[[[[[[[α77']]]]]]]]]  for ub(α73' <: [[[[[[[[[α77']]]]]]]]])
//│ | U [[[[[[[[[α77']]]]]]]]] = [[[[bool]]]] because ub(α73' <: [[[[[[[[[α77']]]]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | UT  α73' <: [[[[[[[[[[[α76']]]]]]]]]]]  for ub(α73' <: [[[[[[[[[[[α76']]]]]]]]]]])
//│ | U [[[[[[[[[[[α76']]]]]]]]]]] = [[[[bool]]]] because ub(α73' <: [[[[[[[[[[[α76']]]]]]]]]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | UT  α73' <: [[[[α75']]]]  for ub(α73' <: [[[[α75']]]])
//│ | U [[[[α75']]]] = [[[[bool]]]] because ub(α73' <: [[[[α75']]]]), ub(α73' <: [[[[bool]]]]) ()
//│ | UT  α73' += ([[[[bool]]]],List(ub(α73' <: [[[[bool]]]])))
//│ ╔══[WARNING] ?a is unified with ?b * ?c because lb([[[([α74'], α76',)]]] <: α84'))
//│ ║  
//│ ╟── tuple literal
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                 ^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                 ^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ╙──      	                 ^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b -> ?c * ?d because lb([[[(α75' -> ([α74'], α76',))]]] <: α82'))
//│ ║  
//│ ╟── function
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ╙──      	                 ^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b -> ?c because ub(α82' <: [[([α73'] -> α84')]]))
//│ ║  
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                 ^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                 ^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ╙──      	                 ^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because lb([[[bool]]] <: α80'))
//│ ║  
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ║           	                 ^^^^
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ║           	                 ^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ╙──      	                        ^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α80' <: [[[α74']]]))
//│ ║  
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	           ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	           ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α78' <: [[[α77']]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[[α73']]]]]]] <: α78'))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	               ^
//│ ╔══[WARNING] ?a is unified with int because ub(α78' <: [[int]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α78' <: [[[[[α76']]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[α75']]]] <: α78'))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	               ^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[α78']]] <: α77'))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[[[[α73']]]]]]]]] <: α77'))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with int because lb([[int]] <: α77'))
//│ ║  
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α77' <: [[[α76']]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[α75']]]]]] <: α77'))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[α78']]]]] <: α76'))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[α77']]] <: α76'))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[[[[[[α73']]]]]]]]]]] <: α76'))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with int because lb([[[[int]]]] <: α76'))
//│ ║  
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[[[α75']]]]]]]] <: α76'))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α75' <: [[[[α78']]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	               ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α75' <: [[[[[[α77']]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[α73']]]] <: α75'))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	             ^
//│ ╔══[WARNING] ?a is unified with int because ub(α75' <: [[int]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α75' <: [[[[[[[[α76']]]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because lb([[[[[bool]]]]] <: α74'))
//│ ║  
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ║           	                 ^^^^
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ║           	                 ^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	           ^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[α80']]] <: α74'))
//│ ║  
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	           ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α73' <: [[[[[[[[[α77']]]]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α73' <: [[int]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α73' <: [[[[[[[[[[[α76']]]]]]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α73' <: [[[[α75']]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	             ^
//│ ╔══[WARNING] ?a is unified with bool because ub(α73' <: [[[[bool]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                             ^
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ║           	         ^^^^
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ╙──         	         ^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α73' <: [[[[[[[α78']]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	               ^
//│ conflict: (bool & 'a) -> (bool, int | 'a,)

:d
:unifyDbg
let g x = (not x, (if true then x else 5))
//│ 1. Typing term x => not x, if true(true) then x then (false) then 5,
//│ | 1. Typing pattern x
//│ | 1. : α95'
//│ | 1. Typing term not x, if true(true) then x then (false) then 5,
//│ | | 1. Typing term not x
//│ | | | 1. Typing term not
//│ | | | 1. : [(bool -> bool)]
//│ | | | 1. Typing term x
//│ | | | 1. : [α95']
//│ | | | CONSTRAIN [(bool -> bool)] <! ([α95'] -> α97')
//│ | | |   where 
//│ | | | C [(bool -> bool)] <! ([α95'] -> α97')    (0) where ProvType <: FunctionType}
//│ | | | | C (bool -> bool) <! ([α95'] -> α97')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[α95']]
//│ | | | | | C [α95'] <! bool    (1) where ProvType <: TypeRef}
//│ | | | | | | C α95' <! bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | [nested] [bool]
//│ | | | | | C bool <! α97'    (2) where TypeRef <: TypeVariable}
//│ | | 1. : α97'
//│ | | 1. Typing term if true(true) then x then (false) then 5
//│ | | | If(Var(true), List(IfThen(Var(true), Var(x), IfThen(Var(false), IntLit(5)))
//│ | | | 1. Typing term true
//│ | | | 1. : [bool]
//│ | | | CONSTRAIN [bool] <! bool
//│ | | |   where 
//│ | | | C [bool] <! bool    (0) where ProvType <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α95']
//│ | | | CONSTRAIN [α95'] <! α98'
//│ | | |   where 
//│ 		α95' <: [[[[bool]]]]
//│ | | | C [α95'] <! α98'    (0) where ProvType <: TypeVariable}
//│ | | | | C α95' <! α98'    (0) where TypeVariable <: TypeVariable}
//│ | | | | | symmetric
//│ | | | 1. Typing term 5
//│ | | | 1. : int
//│ | | | CONSTRAIN int <! α98'
//│ | | |   where 
//│ 		α95' <: [[[α98']]] & [[[[bool]]]]
//│ 		α98' :> [[[α95']]]
//│ | | | C int <! α98'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α98'
//│ | 1. : (α97', α98',)
//│ 1. : (α95' -> (α97', α98',))
//│ ⬤ Typed as: (α95' -> (α97', α98',))
//│  where: 
//│ 		α95' <: [[[α98']]] & [[[[bool]]]]
//│ 		α97' :> [[[bool]]]
//│ 		α98' :> [[int]] | [[[α95']]]
//│ unified α98' with:
//│ unified α97' with:
//│ unified α96' with:
//│ unified α95' with:
//│ α98' bounds
//│  α98' <: [[int]] with lb([[int]] <: α98') length: 3
//│ UT α98' <: [[int]] len: 4 
//│ | UT  int with
//│ | UT  [[int]] <: α98' <: int
//│ | UT [[int]] <: [[int]] len: 7 
//│ | | U [[int]] = [[int]] because lb([[int]] <: [[int]]) skipCache
//│ | UT  [[[α95']]] <: α98' <: int
//│ | UT [[[α95']]] <: [[int]] len: 8 
//│ | | UT  int with
//│ | | UT  α95' += ([[int]],List(ub(α95' <: [[int]])))
//│ | UT  α98' += ([[int]],List(ub(α98' <: [[int]])))
//│  α98' <: [[[α95']]] with lb([[[α95']]] <: α98') length: 4
//│ UT α98' <: [[[α95']]] len: 5 
//│ | UT  α95' with
//│ | UT  [[int]] <: α98' <: α95'
//│ | UT [[int]] <: [[[α95']]] len: 8 
//│ | UT  [[[α95']]] <: α98' <: α95'
//│ | UT [[[α95']]] <: [[[α95']]] len: 9 
//│ | UT  α98' += ([[[α95']]],List(ub(α98' <: [[[α95']]])))
//│ α97' bounds
//│  α97' <: [[[bool]]] with lb([[[bool]]] <: α97') length: 3
//│ UT α97' <: [[[bool]]] len: 4 
//│ | UT  bool with
//│ | UT  [[[bool]]] <: α97' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 7 
//│ | | U [[[bool]]] = [[[bool]]] because lb([[[bool]]] <: [[[bool]]]) skipCache
//│ | UT  α97' += ([[[bool]]],List(ub(α97' <: [[[bool]]])))
//│ α96' bounds
//│ α95' bounds
//│  α95' :> [[[α98']]] with ub(α95' <: [[[α98']]]) length: 4
//│ UT α95' <: [[[α98']]] len: 5 
//│  α95' :> [[[[bool]]]] with ub(α95' <: [[[[bool]]]]) length: 4
//│ UT α95' <: [[[[bool]]]] len: 5 
//│ | UT  bool with
//│ | UT  α95' <: [[[α98']]]  for ub(α95' <: [[[α98']]])
//│ | U [[[α98']]] = [[[[bool]]]] because ub(α95' <: [[[α98']]]), ub(α95' <: [[[[bool]]]]) ()
//│ | | U   bool with
//│ | |     α98' = [[int]] for lb([[int]] <: α98')
//│ | | U [[int]] = bool because lb([[int]] <: α98'), ub(α95' <: [[[α98']]]), ub(α95' <: [[[[bool]]]]) ()
//│ | | | UERR  [[int]] = bool because lb([[int]] <: α98'),ub(α95' <: [[[α98']]]),ub(α95' <: [[[[bool]]]])
//│ | | | (lb([[int]] <: α98'),true) -> (ub(α95' <: [[[α98']]]),false) showFirst: true leftSame: false
//│ | | | show 2 locations for (lb([[int]] <: α98'),true)
//│ | | | (lb([[int]] <: α98'),true) -> (ub(α95' <: [[[α98']]]),false) showFirst: false leftSame: false
//│ | | | show 2 locations for (ub(α95' <: [[[α98']]]),false)
//│ | | | (ub(α95' <: [[[α98']]]),false) -> (ub(α95' <: [[[[bool]]]]),true) showFirst: false leftSame: true
//│ | | | show 2 locations for (ub(α95' <: [[[[bool]]]]),true)
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a` and it flows from `?b`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── this variable has type `?b`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── this reference has type `?b` and it flows into `bool`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	               ^
//│ ╟── this type reference has type `bool`
//│ ║  builtin: 	let not: bool -> bool
//│ ╙──         	         ^^^^
//│ | |     α98' = [[[α95']]] for lb([[[α95']]] <: α98')
//│ | | U [[[α95']]] = bool because lb([[[α95']]] <: α98'), ub(α95' <: [[[α98']]]), ub(α95' <: [[[[bool]]]]) ()
//│ | UT  α95' += ([[[[bool]]]],List(ub(α95' <: [[[[bool]]]])))
//│ ╔══[WARNING] ?a is unified with int because lb([[int]] <: α98'))
//│ ║  
//│ ╟── `else` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── `else` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[α95']]] <: α98'))
//│ ║  
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── `then` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because lb([[[bool]]] <: α97'))
//│ ║  
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ║           	                 ^^^^
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ║           	                 ^^^^
//│ ╟── application
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	           ^^^^^
//│ ╔══[WARNING] ?a is unified with bool because ub(α95' <: [[[[bool]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── reference
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	               ^
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ║           	         ^^^^
//│ ╟── type reference
//│ ║  builtin: 	let not: bool -> bool
//│ ╙──         	         ^^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α95' <: [[int]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── `then` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── `else` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	                                       ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α95' <: [[[α98']]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── `then` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ g: (bool & 'a) -> (bool, int | 'a,)

:d
let g x = (not x, (if true then x else 5))
//│ 1. Typing term x => not x, if true(true) then x then (false) then 5,
//│ | 1. Typing pattern x
//│ | 1. : α104'
//│ | 1. Typing term not x, if true(true) then x then (false) then 5,
//│ | | 1. Typing term not x
//│ | | | 1. Typing term not
//│ | | | 1. : [(bool -> bool)]
//│ | | | 1. Typing term x
//│ | | | 1. : [α104']
//│ | | | CONSTRAIN [(bool -> bool)] <! ([α104'] -> α106')
//│ | | |   where 
//│ | | | C [(bool -> bool)] <! ([α104'] -> α106')    (0) where ProvType <: FunctionType}
//│ | | | | C (bool -> bool) <! ([α104'] -> α106')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[α104']]
//│ | | | | | C [α104'] <! bool    (1) where ProvType <: TypeRef}
//│ | | | | | | C α104' <! bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | [nested] [bool]
//│ | | | | | C bool <! α106'    (2) where TypeRef <: TypeVariable}
//│ | | 1. : α106'
//│ | | 1. Typing term if true(true) then x then (false) then 5
//│ | | | If(Var(true), List(IfThen(Var(true), Var(x), IfThen(Var(false), IntLit(5)))
//│ | | | 1. Typing term true
//│ | | | 1. : [bool]
//│ | | | CONSTRAIN [bool] <! bool
//│ | | |   where 
//│ | | | C [bool] <! bool    (0) where ProvType <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α104']
//│ | | | CONSTRAIN [α104'] <! α107'
//│ | | |   where 
//│ 		α104' <: [[[[bool]]]]
//│ | | | C [α104'] <! α107'    (0) where ProvType <: TypeVariable}
//│ | | | | C α104' <! α107'    (0) where TypeVariable <: TypeVariable}
//│ | | | | | symmetric
//│ | | | 1. Typing term 5
//│ | | | 1. : int
//│ | | | CONSTRAIN int <! α107'
//│ | | |   where 
//│ 		α104' <: [[[α107']]] & [[[[bool]]]]
//│ 		α107' :> [[[α104']]]
//│ | | | C int <! α107'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α107'
//│ | 1. : (α106', α107',)
//│ 1. : (α104' -> (α106', α107',))
//│ ⬤ Typed as: (α104' -> (α106', α107',))
//│  where: 
//│ 		α104' <: [[[α107']]] & [[[[bool]]]]
//│ 		α106' :> [[[bool]]]
//│ 		α107' :> [[int]] | [[[α104']]]
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a` and it flows from `?b`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── this variable has type `?b`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── this reference has type `?b` and it flows into `bool`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	               ^
//│ ╟── this type reference has type `bool`
//│ ║  builtin: 	let not: bool -> bool
//│ ╙──         	         ^^^^
//│ g: (bool & 'a) -> (bool, int | 'a,)
