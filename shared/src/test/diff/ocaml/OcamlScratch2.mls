let confluence z = if true then z else 5
//│ confluence: 'a -> (int | 'a)

:d
let mkpair x y = (x, confluence y)
//│ 1. Typing term x => y => x, confluence y,
//│ | 1. Typing pattern x
//│ | 1. : α65'
//│ | 1. Typing term y => x, confluence y,
//│ | | 1. Typing pattern y
//│ | | 1. : α66'
//│ | | 1. Typing term x, confluence y,
//│ | | | 1. Typing term x
//│ | | | 1. : [α65']
//│ | | | 1. Typing term confluence y
//│ | | | | 1. Typing term confluence
//│ | | | | 1. : [(α67' -> α68')]
//│ | | | | 1. Typing term y
//│ | | | | 1. : [α66']
//│ | | | | CONSTRAIN [(α67' -> α68')] <! ([α66'] -> α70')
//│ | | | |   where 
//│ 		α67' <: [[[α68']]]
//│ 		α68' :> [[int]] | [[[α67']]]
//│ | | | | C [(α67' -> α68')] <! ([α66'] -> α70')    (0) where ProvType <: FunctionType}
//│ | | | | | C (α67' -> α68') <! ([α66'] -> α70')    (0) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[α66']]
//│ | | | | | | C [α66'] <! α67'    (1) where ProvType <: TypeVariable}
//│ | | | | | | | C α66' <! α67'    (1) where TypeVariable <: TypeVariable}
//│ | | | | | | | | symmetric
//│ | | | | | | | | C α66' <! [[[α68']]]    (2) where TypeVariable <: ProvType}
//│ | | | | | | | | | C α66' <! [[α68']]    (2) where TypeVariable <: ProvType}
//│ | | | | | | | | | | C α66' <! [α68']    (2) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | C α66' <! α68'    (2) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | symmetric
//│ | | | | | | [nested] [α68']
//│ | | | | | | C α68' <! α70'    (3) where TypeVariable <: TypeVariable}
//│ | | | | | | | symmetric
//│ | | | | | | | C [[[[[[α66']]]]]] <! α70'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | C [[[[[α66']]]]] <! α70'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | C [[[[α66']]]] <! α70'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | C [[[α66']]] <! α70'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | C [[α66']] <! α70'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | C [α66'] <! α70'    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | C α66' <! α70'    (4) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | symmetric
//│ | | | | | | | C [[int]] <! α70'    (5) where ProvType <: TypeVariable}
//│ | | | | | | | | C [int] <! α70'    (5) where ProvType <: TypeVariable}
//│ | | | | | | | | | C int <! α70'    (5) where TypeRef <: TypeVariable}
//│ | | | | | | | C [[[α67']]] <! α70'    (6) where ProvType <: TypeVariable}
//│ | | | | | | | | C [[α67']] <! α70'    (6) where ProvType <: TypeVariable}
//│ | | | | | | | | | C [α67'] <! α70'    (6) where ProvType <: TypeVariable}
//│ | | | | | | | | | | C α67' <! α70'    (6) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | symmetric
//│ | | | | | | | | | | | C [[[[α66']]]] <! α70'    (7) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | C [[[α66']]] <! α70'    (7) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | C [[α66']] <! α70'    (7) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | | C [α66'] <! α70'    (7) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | | | C α66' <! α70'    (7) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | Cached!
//│ | | | 1. : α70'
//│ | | 1. : ([α65'], α70',)
//│ | 1. : (α66' -> ([α65'], α70',))
//│ 1. : (α65' -> (α66' -> ([α65'], α70',)))
//│ ⬤ Typed as: (α65' -> (α66' -> ([α65'], α70',)))
//│  where: 
//│ 		α66' <: [[[[[[[[α70']]]]]]]] & [[[[[[α68']]]]]] & [[[[α67']]]]
//│ 		α67' :> [[[[α66']]]] <: [[[[[α70']]]]] & [[[α68']]]
//│ 		α68' :> [[[[[[α66']]]]]] | [[int]] | [[[α67']]] <: [[[α70']]]
//│ 		α70' :> [[[α68']]] | [[[[[α67']]]]] | [[[[int]]]] | [[[[[[[[α66']]]]]]]]
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)

:d
// mkpair 1 "2"

:unifyDbg
:d
let conflict x = mkpair (not x) x
//│ 1. Typing term x => mkpair (not x) x
//│ | 1. Typing pattern x
//│ | 1. : α80'
//│ | 1. Typing term mkpair (not x) x
//│ | | 1. Typing term mkpair (not x)
//│ | | | 1. Typing term mkpair
//│ | | | 1. : [(α81' -> (α82' -> ([α81'], α83',)))]
//│ | | | 1. Typing term not x
//│ | | | | 1. Typing term not
//│ | | | | 1. : [(bool -> bool)]
//│ | | | | 1. Typing term x
//│ | | | | 1. : [α80']
//│ | | | | CONSTRAIN [(bool -> bool)] <! ([α80'] -> α87')
//│ | | | |   where 
//│ | | | | C [(bool -> bool)] <! ([α80'] -> α87')    (0) where ProvType <: FunctionType}
//│ | | | | | C (bool -> bool) <! ([α80'] -> α87')    (0) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[α80']]
//│ | | | | | | C [α80'] <! bool    (1) where ProvType <: TypeRef}
//│ | | | | | | | C α80' <! bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | | [nested] [bool]
//│ | | | | | | C bool <! α87'    (2) where TypeRef <: TypeVariable}
//│ | | | 1. : α87'
//│ | | | CONSTRAIN [(α81' -> (α82' -> ([α81'], α83',)))] <! (α87' -> α89')
//│ | | |   where 
//│ 		α82' <: [[[[[[[[α83']]]]]]]] & [[[[[[α84']]]]]] & [[[[α85']]]]
//│ 		α83' :> [[[α84']]] | [[[[[α85']]]]] | [[[[int]]]] | [[[[[[[[α82']]]]]]]]
//│ 		α84' :> [[[[[[α82']]]]]] | [[int]] | [[[α85']]] <: [[[α83']]]
//│ 		α85' :> [[[[α82']]]] <: [[[[[α83']]]]] & [[[α84']]]
//│ 		α87' :> [[[bool]]]
//│ | | | C [(α81' -> (α82' -> ([α81'], α83',)))] <! (α87' -> α89')    (0) where ProvType <: FunctionType}
//│ | | | | C (α81' -> (α82' -> ([α81'], α83',))) <! (α87' -> α89')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [α87']
//│ | | | | | C α87' <! α81'    (1) where TypeVariable <: TypeVariable}
//│ | | | | | | symmetric
//│ | | | | | | C [[[bool]]] <! α81'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | C [[bool]] <! α81'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | C [bool] <! α81'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | | C bool <! α81'    (2) where TypeRef <: TypeVariable}
//│ | | | | | [nested] [(α82' -> ([α81'], α83',))]
//│ | | | | | C (α82' -> ([α81'], α83',)) <! α89'    (3) where FunctionType <: TypeVariable}
//│ | | 1. : α89'
//│ | | 1. Typing term x
//│ | | 1. : [α80']
//│ | | CONSTRAIN α89' <! ([α80'] -> α91')
//│ | |   where 
//│ 		α80' <: [[[[bool]]]]
//│ 		α81' :> [[[α87']]] | [[[[[bool]]]]]
//│ 		α82' <: [[[[[[[[α83']]]]]]]] & [[[[[[α84']]]]]] & [[[[α85']]]]
//│ 		α83' :> [[[α84']]] | [[[[[α85']]]]] | [[[[int]]]] | [[[[[[[[α82']]]]]]]]
//│ 		α84' :> [[[[[[α82']]]]]] | [[int]] | [[[α85']]] <: [[[α83']]]
//│ 		α85' :> [[[[α82']]]] <: [[[[[α83']]]]] & [[[α84']]]
//│ 		α87' :> [[[bool]]] <: [[[α81']]]
//│ 		α89' :> [[[(α82' -> ([α81'], α83',))]]]
//│ | | C α89' <! ([α80'] -> α91')    (0) where TypeVariable <: FunctionType}
//│ | | | C [[[(α82' -> ([α81'], α83',))]]] <! ([α80'] -> α91')    (1) where ProvType <: FunctionType}
//│ | | | | C [[(α82' -> ([α81'], α83',))]] <! ([α80'] -> α91')    (1) where ProvType <: FunctionType}
//│ | | | | | C [(α82' -> ([α81'], α83',))] <! ([α80'] -> α91')    (1) where ProvType <: FunctionType}
//│ | | | | | | C (α82' -> ([α81'], α83',)) <! ([α80'] -> α91')    (1) where FunctionType <: FunctionType}
//│ | | | | | | | [nested] [[α80']]
//│ | | | | | | | C [α80'] <! α82'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | C α80' <! α82'    (2) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | symmetric
//│ | | | | | | | | | C α80' <! [[[[[[[[α83']]]]]]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | C α80' <! [[[[[[[α83']]]]]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | C α80' <! [[[[[[α83']]]]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | C α80' <! [[[[[α83']]]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | C α80' <! [[[[α83']]]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | C α80' <! [[[α83']]]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | C α80' <! [[α83']]    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | C α80' <! [α83']    (3) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | C α80' <! α83'    (3) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | | | symmetric
//│ | | | | | | | | | C α80' <! [[[[[[α84']]]]]]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | C α80' <! [[[[[α84']]]]]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | C α80' <! [[[[α84']]]]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | C α80' <! [[[α84']]]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | C α80' <! [[α84']]    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | C α80' <! [α84']    (4) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | C α80' <! α84'    (4) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | symmetric
//│ | | | | | | | | | | | | | | | | C α80' <! [[[α83']]]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | C α80' <! [[α83']]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | | C α80' <! [α83']    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | | | C α80' <! α83'    (5) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | | | | | Cached!
//│ | | | | | | | | | C α80' <! [[[[α85']]]]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | C α80' <! [[[α85']]]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | C α80' <! [[α85']]    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | C α80' <! [α85']    (5) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | C α80' <! α85'    (5) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | symmetric
//│ | | | | | | | | | | | | | | C α80' <! [[[[[α83']]]]]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | C α80' <! [[[[α83']]]]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | C α80' <! [[[α83']]]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | C α80' <! [[α83']]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | | C α80' <! [α83']    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | | | C α80' <! α83'    (6) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | | | | | Cached!
//│ | | | | | | | | | | | | | | C α80' <! [[[α84']]]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | C α80' <! [[α84']]    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | C α80' <! [α84']    (6) where TypeVariable <: ProvType}
//│ | | | | | | | | | | | | | | | | | C α80' <! α84'    (6) where TypeVariable <: TypeVariable}
//│ | | | | | | | | | | | | | | | | | | Cached!
//│ | | | | | | | [nested] [([α81'], α83',)]
//│ | | | | | | | C ([α81'], α83',) <! α91'    (6) where TupleType <: TypeVariable}
//│ | 1. : α91'
//│ 1. : (α80' -> α91')
//│ ⬤ Typed as: (α80' -> α91')
//│  where: 
//│ 		α80' <: [[[[[[[α85']]]]]]] & [[[[[[[[[α84']]]]]]]]] & [[[[[[[[[[[α83']]]]]]]]]]] & [[[[α82']]]] & [[[[bool]]]]
//│ 		α81' :> [[[α87']]] | [[[[[bool]]]]]
//│ 		α82' :> [[[[α80']]]] <: [[[[[[[[α83']]]]]]]] & [[[[[[α84']]]]]] & [[[[α85']]]]
//│ 		α83' :> [[[[[[[[[[[α80']]]]]]]]]]] | [[[α84']]] | [[[[[α85']]]]] | [[[[int]]]] | [[[[[[[[α82']]]]]]]]
//│ 		α84' :> [[[[[[[[[α80']]]]]]]]] | [[[[[[α82']]]]]] | [[int]] | [[[α85']]] <: [[[α83']]]
//│ 		α85' :> [[[[[[[α80']]]]]]] | [[[[α82']]]] <: [[[[[α83']]]]] & [[[α84']]]
//│ 		α87' :> [[[bool]]] <: [[[α81']]]
//│ 		α91' :> [[[([α81'], α83',)]]]
//│ unified α91' with:
//│ unified α90' with:
//│ unified α89' with:
//│ unified α88' with:
//│ unified α87' with:
//│ unified α86' with:
//│ unified α85' with:
//│ unified α84' with:
//│ unified α83' with:
//│ unified α82' with:
//│ unified α81' with:
//│ unified α80' with:
//│ α91' bounds
//│  α91' <: [[[([α81'], α83',)]]] with lb([[[([α81'], α83',)]]] <: α91') length: 3
//│ UT α91' <: [[[([α81'], α83',)]]] len: 4 
//│ | UT  ([α81'], α83',) with
//│ | UT  [[[([α81'], α83',)]]] <: α91' <: ([α81'], α83',)
//│ | UT [[[([α81'], α83',)]]] <: [[[([α81'], α83',)]]] len: 7 
//│ | | U [[[([α81'], α83',)]]] = [[[([α81'], α83',)]]] because lb([[[([α81'], α83',)]]] <: [[[([α81'], α83',)]]]) skipCache
//│ | | | UT [α81'] <: [α81'] len: 4 nested: [[[([α81'], α83',)]]] = [[[([α81'], α83',)]]] because lb([[[([α81'], α83',)]]] <: [[[([α81'], α83',)]]])
//│ | | | UT α83' <: α83' len: 2 nested: [[[([α81'], α83',)]]] = [[[([α81'], α83',)]]] because lb([[[([α81'], α83',)]]] <: [[[([α81'], α83',)]]])
//│ | UT  α91' += ([[[([α81'], α83',)]]],List(ub(α91' <: [[[([α81'], α83',)]]])))
//│ α90' bounds
//│ α89' bounds
//│  α89' <: [[[(α82' -> ([α81'], α83',))]]] with lb([[[(α82' -> ([α81'], α83',))]]] <: α89') length: 3
//│ UT α89' <: [[[(α82' -> ([α81'], α83',))]]] len: 4 
//│ | UT  (α82' -> ([α81'], α83',)) with
//│ | UT  [[[(α82' -> ([α81'], α83',))]]] <: α89' <: (α82' -> ([α81'], α83',))
//│ | UT [[[(α82' -> ([α81'], α83',))]]] <: [[[(α82' -> ([α81'], α83',))]]] len: 7 
//│ | | U [[[(α82' -> ([α81'], α83',))]]] = [[[(α82' -> ([α81'], α83',))]]] because lb([[[(α82' -> ([α81'], α83',))]]] <: [[[(α82' -> ([α81'], α83',))]]]) skipCache
//│ | UT  (α82' -> ([α81'], α83',)) with
//│ | UT  α89' += ([[[(α82' -> ([α81'], α83',))]]],List(ub(α89' <: [[[(α82' -> ([α81'], α83',))]]])))
//│  α89' :> [[([α80'] -> α91')]] with ub(α89' <: [[([α80'] -> α91')]]) length: 3
//│ UT α89' <: [[([α80'] -> α91')]] len: 4 
//│ | UT  ([α80'] -> α91') with
//│ | UT  [[[(α82' -> ([α81'], α83',))]]] <: α89' <: ([α80'] -> α91')
//│ | UT [[[(α82' -> ([α81'], α83',))]]] <: [[([α80'] -> α91')]] len: 7 
//│ | | U [[[(α82' -> ([α81'], α83',))]]] = [[([α80'] -> α91')]] because lb([[[(α82' -> ([α81'], α83',))]]] <: [[([α80'] -> α91')]]) skipCache
//│ | UT  ([α80'] -> α91') with
//│ | UT  α89' += ([[([α80'] -> α91')]],List(ub(α89' <: [[([α80'] -> α91')]])))
//│ α88' bounds
//│ α87' bounds
//│  α87' <: [[[bool]]] with lb([[[bool]]] <: α87') length: 3
//│ UT α87' <: [[[bool]]] len: 4 
//│ | UT  bool with
//│ | UT  [[[bool]]] <: α87' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 7 
//│ | | U [[[bool]]] = [[[bool]]] because lb([[[bool]]] <: [[[bool]]]) skipCache
//│ | UT  bool with
//│ | UT  α87' += ([[[bool]]],List(ub(α87' <: [[[bool]]])))
//│  α87' :> [[[α81']]] with ub(α87' <: [[[α81']]]) length: 3
//│ UT α87' <: [[[α81']]] len: 4 
//│ | UT  α81' with
//│ | UT  [[[bool]]] <: α87' <: α81'
//│ | UT [[[bool]]] <: [[[α81']]] len: 7 
//│ | | UT  [[[bool]]] with
//│ | | UT  α81' += ([[[bool]]],List(lb([[[bool]]] <: α81')))
//│ | UT  α81' with
//│ | UT  α87' += ([[[α81']]],List(ub(α87' <: [[[α81']]])))
//│ α86' bounds
//│ α85' bounds
//│  α85' <: [[[[[[[α80']]]]]]] with lb([[[[[[[α80']]]]]]] <: α85') length: 6
//│ UT α85' <: [[[[[[[α80']]]]]]] len: 7 
//│ | UT  α80' with
//│ | UT  [[[[[[[α80']]]]]]] <: α85' <: α80'
//│ | UT [[[[[[[α80']]]]]]] <: [[[[[[[α80']]]]]]] len: 13 
//│ | UT  [[[[α82']]]] <: α85' <: α80'
//│ | UT [[[[α82']]]] <: [[[[[[[α80']]]]]]] len: 11 
//│ | | UT  α80' with
//│ | | UT  [[[[α80']]]] <: α82' <: α80'
//│ | | UT [[[[α80']]]] <: [[[[[[[α80']]]]]]] len: 15 
//│ | | UT  α80' with
//│ | | UT  α82' += ([[[[[[[α80']]]]]]],List(ub(α82' <: [[[[[[[α80']]]]]]])))
//│ | UT  α80' with
//│ | UT  α85' += ([[[[[[[α80']]]]]]],List(ub(α85' <: [[[[[[[α80']]]]]]])))
//│  α85' <: [[[[α82']]]] with lb([[[[α82']]]] <: α85') length: 4
//│ UT α85' <: [[[[α82']]]] len: 5 
//│ | UT  α82' with
//│ | UT  [[[[[[[α80']]]]]]] <: α85' <: α82'
//│ | UT [[[[[[[α80']]]]]]] <: [[[[α82']]]] len: 11 
//│ | UT  [[[[α82']]]] <: α85' <: α82'
//│ | UT [[[[α82']]]] <: [[[[α82']]]] len: 9 
//│ | UT  α82' with
//│ | UT  α85' += ([[[[α82']]]],List(ub(α85' <: [[[[α82']]]])))
//│  α85' :> [[[[[α83']]]]] with ub(α85' <: [[[[[α83']]]]]) length: 5
//│ UT α85' <: [[[[[α83']]]]] len: 6 
//│ | UT  α83' with
//│ | UT  [[[[[[[α80']]]]]]] <: α85' <: α83'
//│ | UT [[[[[[[α80']]]]]]] <: [[[[[α83']]]]] len: 12 
//│ | | UT  α83' with
//│ | | UT  α80' += ([[[[[α83']]]]],List(ub(α80' <: [[[[[α83']]]]])))
//│ | UT  [[[[α82']]]] <: α85' <: α83'
//│ | UT [[[[α82']]]] <: [[[[[α83']]]]] len: 10 
//│ | | UT  α83' with
//│ | | UT  [[[[α80']]]] <: α82' <: α83'
//│ | | UT [[[[α80']]]] <: [[[[[α83']]]]] len: 14 
//│ | | UT  α83' with
//│ | | UT  α82' += ([[[[[α83']]]]],List(ub(α82' <: [[[[[α83']]]]])))
//│ | UT  α83' with
//│ | UT  α85' += ([[[[[α83']]]]],List(ub(α85' <: [[[[[α83']]]]])))
//│  α85' :> [[[α84']]] with ub(α85' <: [[[α84']]]) length: 4
//│ UT α85' <: [[[α84']]] len: 5 
//│ | UT  α84' with
//│ | UT  [[[[[[[α80']]]]]]] <: α85' <: α84'
//│ | UT [[[[[[[α80']]]]]]] <: [[[α84']]] len: 11 
//│ | | UT  α84' with
//│ | | UT  α80' <: [[[[[[[[[[[α83']]]]]]]]]]]  for ub(α80' <: [[[[[α83']]]]])
//│ | | U [[[[[[[[[[[α83']]]]]]]]]]] = [[[α84']]] because ub(α80' <: [[[[[α83']]]]]), ub(α80' <: [[[α84']]]) ()
//│ | | UT  α80' += ([[[α84']]],List(ub(α80' <: [[[α84']]])))
//│ | UT  [[[[α82']]]] <: α85' <: α84'
//│ | UT [[[[α82']]]] <: [[[α84']]] len: 9 
//│ | | UT  α84' with
//│ | | UT  [[[[α80']]]] <: α82' <: α84'
//│ | | UT [[[[α80']]]] <: [[[α84']]] len: 13 
//│ | | UT  α84' with
//│ | | UT  α82' <: [[[[[[[[α83']]]]]]]]  for ub(α82' <: [[[[[α83']]]]])
//│ | | U [[[[[[[[α83']]]]]]]] = [[[α84']]] because ub(α82' <: [[[[[α83']]]]]), ub(α82' <: [[[α84']]]) ()
//│ | | UT  α82' += ([[[α84']]],List(ub(α82' <: [[[α84']]])))
//│ | UT  α84' with
//│ | UT  α85' <: [[[[[α83']]]]]  for ub(α85' <: [[[[[α83']]]]])
//│ | U [[[[[α83']]]]] = [[[α84']]] because ub(α85' <: [[[[[α83']]]]]), ub(α85' <: [[[α84']]]) ()
//│ | UT  α85' += ([[[α84']]],List(ub(α85' <: [[[α84']]])))
//│ α84' bounds
//│  α84' <: [[[[[[[[[α80']]]]]]]]] with lb([[[[[[[[[α80']]]]]]]]] <: α84') length: 8
//│ UT α84' <: [[[[[[[[[α80']]]]]]]]] len: 9 
//│  α84' <: [[[[[[α82']]]]]] with lb([[[[[[α82']]]]]] <: α84') length: 6
//│ UT α84' <: [[[[[[α82']]]]]] len: 7 
//│  α84' <: [[int]] with lb([[int]] <: α84') length: 3
//│ UT α84' <: [[int]] len: 4 
//│ | UT  int with
//│ | UT  [[[[[[[[[α80']]]]]]]]] <: α84' <: int
//│ | UT [[[[[[[[[α80']]]]]]]]] <: [[int]] len: 12 
//│ | | UT  int with
//│ | | UT  α80' <: [[[[[[[[[α84']]]]]]]]]  for ub(α80' <: [[[α84']]])
//│ | | U [[[[[[[[[α84']]]]]]]]] = [[int]] because ub(α80' <: [[[α84']]]), ub(α80' <: [[int]]) ()
//│ | | UT  α80' <: [[[[[[[[[[[α83']]]]]]]]]]]  for ub(α80' <: [[[[[α83']]]]])
//│ | | U [[[[[[[[[[[α83']]]]]]]]]]] = [[int]] because ub(α80' <: [[[[[α83']]]]]), ub(α80' <: [[int]]) ()
//│ | | UT  α80' += ([[int]],List(ub(α80' <: [[int]])))
//│ | UT  [[[[[[α82']]]]]] <: α84' <: int
//│ | UT [[[[[[α82']]]]]] <: [[int]] len: 10 
//│ | | UT  int with
//│ | | UT  [[[[α80']]]] <: α82' <: int
//│ | | UT [[[[α80']]]] <: [[int]] len: 14 
//│ | | UT  int with
//│ | | UT  α82' <: [[[[[[[[α83']]]]]]]]  for ub(α82' <: [[[[[α83']]]]])
//│ | | U [[[[[[[[α83']]]]]]]] = [[int]] because ub(α82' <: [[[[[α83']]]]]), ub(α82' <: [[int]]) ()
//│ | | UT  α82' <: [[[[[[α84']]]]]]  for ub(α82' <: [[[α84']]])
//│ | | U [[[[[[α84']]]]]] = [[int]] because ub(α82' <: [[[α84']]]), ub(α82' <: [[int]]) ()
//│ | | UT  α82' += ([[int]],List(ub(α82' <: [[int]])))
//│ | UT  [[int]] <: α84' <: int
//│ | UT [[int]] <: [[int]] len: 7 
//│ | | U [[int]] = [[int]] because lb([[int]] <: [[int]]) skipCache
//│ | UT  [[[α85']]] <: α84' <: int
//│ | UT [[[α85']]] <: [[int]] len: 8 
//│ | | UT  int with
//│ | | UT  [[[[[[[α80']]]]]]] <: α85' <: int
//│ | | UT [[[[[[[α80']]]]]]] <: [[int]] len: 14 
//│ | | UT  [[[[α82']]]] <: α85' <: int
//│ | | UT [[[[α82']]]] <: [[int]] len: 12 
//│ | | UT  int with
//│ | | UT  α85' <: [[[[[α83']]]]]  for ub(α85' <: [[[[[α83']]]]])
//│ | | U [[[[[α83']]]]] = [[int]] because ub(α85' <: [[[[[α83']]]]]), ub(α85' <: [[int]]) ()
//│ | | UT  α85' <: [[[α84']]]  for ub(α85' <: [[[α84']]])
//│ | | U [[[α84']]] = [[int]] because ub(α85' <: [[[α84']]]), ub(α85' <: [[int]]) ()
//│ | | UT  α85' += ([[int]],List(ub(α85' <: [[int]])))
//│ | UT  int with
//│ | UT  α84' += ([[int]],List(ub(α84' <: [[int]])))
//│  α84' <: [[[α85']]] with lb([[[α85']]] <: α84') length: 4
//│ UT α84' <: [[[α85']]] len: 5 
//│  α84' :> [[[α83']]] with ub(α84' <: [[[α83']]]) length: 3
//│ UT α84' <: [[[α83']]] len: 4 
//│ α83' bounds
//│  α83' <: [[[[[[[[[[[α80']]]]]]]]]]] with lb([[[[[[[[[[[α80']]]]]]]]]]] <: α83') length: 9
//│ UT α83' <: [[[[[[[[[[[α80']]]]]]]]]]] len: 10 
//│  α83' <: [[[α84']]] with lb([[[α84']]] <: α83') length: 3
//│ UT α83' <: [[[α84']]] len: 4 
//│  α83' <: [[[[[α85']]]]] with lb([[[[[α85']]]]] <: α83') length: 5
//│ UT α83' <: [[[[[α85']]]]] len: 6 
//│  α83' <: [[[[int]]]] with lb([[[[int]]]] <: α83') length: 4
//│ UT α83' <: [[[[int]]]] len: 5 
//│  α83' <: [[[[[[[[α82']]]]]]]] with lb([[[[[[[[α82']]]]]]]] <: α83') length: 7
//│ UT α83' <: [[[[[[[[α82']]]]]]]] len: 8 
//│ α82' bounds
//│  α82' <: [[[[α80']]]] with lb([[[[α80']]]] <: α82') length: 4
//│ UT α82' <: [[[[α80']]]] len: 5 
//│  α82' :> [[[[[[[[α83']]]]]]]] with ub(α82' <: [[[[[[[[α83']]]]]]]]) length: 7
//│ UT α82' <: [[[[[[[[α83']]]]]]]] len: 8 
//│  α82' :> [[[[[[α84']]]]]] with ub(α82' <: [[[[[[α84']]]]]]) length: 6
//│ UT α82' <: [[[[[[α84']]]]]] len: 7 
//│  α82' :> [[[[α85']]]] with ub(α82' <: [[[[α85']]]]) length: 4
//│ UT α82' <: [[[[α85']]]] len: 5 
//│ α81' bounds
//│  α81' <: [[[α87']]] with lb([[[α87']]] <: α81') length: 3
//│ UT α81' <: [[[α87']]] len: 4 
//│  α81' <: [[[[[bool]]]]] with lb([[[[[bool]]]]] <: α81') length: 4
//│ UT α81' <: [[[[[bool]]]]] len: 5 
//│ α80' bounds
//│  α80' :> [[[[[[[α85']]]]]]] with ub(α80' <: [[[[[[[α85']]]]]]]) length: 6
//│ UT α80' <: [[[[[[[α85']]]]]]] len: 7 
//│  α80' :> [[[[[[[[[α84']]]]]]]]] with ub(α80' <: [[[[[[[[[α84']]]]]]]]]) length: 8
//│ UT α80' <: [[[[[[[[[α84']]]]]]]]] len: 9 
//│  α80' :> [[[[[[[[[[[α83']]]]]]]]]]] with ub(α80' <: [[[[[[[[[[[α83']]]]]]]]]]]) length: 9
//│ UT α80' <: [[[[[[[[[[[α83']]]]]]]]]]] len: 10 
//│  α80' :> [[[[α82']]]] with ub(α80' <: [[[[α82']]]]) length: 4
//│ UT α80' <: [[[[α82']]]] len: 5 
//│  α80' :> [[[[bool]]]] with ub(α80' <: [[[[bool]]]]) length: 4
//│ UT α80' <: [[[[bool]]]] len: 5 
//│ | UT  bool with
//│ | UT  α80' <: [[[[[[[α85']]]]]]]  for ub(α80' <: [[[[[[[α85']]]]]]])
//│ | U [[[[[[[α85']]]]]]] = [[[[bool]]]] because ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | U   bool with
//│ | |     α85' = [[[α84']]] for ub(α85' <: [[[α84']]])
//│ | | U [[[α84']]] = bool because ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | U   bool with
//│ | | |     α84' = [[[α85']]] for lb([[[α85']]] <: α84')
//│ | | | U [[[α85']]] = bool because lb([[[α85']]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | |     α84' = [[int]] for lb([[int]] <: α84')
//│ | | | U [[int]] = bool because lb([[int]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | | UERR  [[int]] = bool because lb([[int]] <: α84'),ub(α85' <: [[[α84']]]),ub(α80' <: [[[[[[[α85']]]]]]]),ub(α80' <: [[[[bool]]]])
//│ | | | | (lb([[int]] <: α84'),true) -> (ub(α85' <: [[[α84']]]),false) showFirst: true leftSame: false
//│ | | | | show 2 locations for (lb([[int]] <: α84'),true)
//│ | | | | (lb([[int]] <: α84'),true) -> (ub(α85' <: [[[α84']]]),false) showFirst: false leftSame: false
//│ | | | | show 2 locations for (ub(α85' <: [[[α84']]]),false)
//│ | | | | (ub(α85' <: [[[α84']]]),false) -> (ub(α80' <: [[[[bool]]]]),true) showFirst: false leftSame: false
//│ | | | | show 3 locations for (ub(α80' <: [[[[bool]]]]),true)
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a` and it flows from `?b`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── this variable has type `?b`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── this variable has type `?c`
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── this reference has type `?c` and it flows into `bool`
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                             ^
//│ ╟── this type reference has type `bool`
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	         ^^^^
//│ | | |     α84' = [[[[[[[[[α80']]]]]]]]] for lb([[[[[[[[[α80']]]]]]]]] <: α84')
//│ | | | U [[[[[[[[[α80']]]]]]]]] = bool because lb([[[[[[[[[α80']]]]]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | |     α84' = [[[[[[α82']]]]]] for lb([[[[[[α82']]]]]] <: α84')
//│ | | | U [[[[[[α82']]]]]] = bool because lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | | U   bool with
//│ | | | |     α82' = [[[α84']]] for ub(α82' <: [[[[[[α84']]]]]])
//│ | | | | U [[[α84']]] = bool because ub(α82' <: [[[[[[α84']]]]]]), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | |     α82' = [[[[α85']]]] for ub(α82' <: [[[[α85']]]])
//│ | | | | U [[[[α85']]]] = bool because ub(α82' <: [[[[α85']]]]), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | |     α82' = [[int]] for ub(α82' <: [[int]])
//│ | | | | U [[int]] = bool because ub(α82' <: [[int]]), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | |     α82' = [[[[[[[α80']]]]]]] for lb([[[[α80']]]] <: α82')
//│ | | | | U [[[[[[[α80']]]]]]] = bool because lb([[[[α80']]]] <: α82'), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | |     α82' = [[[[[α83']]]]] for ub(α82' <: [[[[[[[[α83']]]]]]]])
//│ | | | | U [[[[[α83']]]]] = bool because ub(α82' <: [[[[[[[[α83']]]]]]]]), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | | | U   bool with
//│ | | | | |     α83' = [[[α84']]] for lb([[[α84']]] <: α83')
//│ | | | | | U [[[α84']]] = bool because lb([[[α84']]] <: α83'), ub(α82' <: [[[[[[[[α83']]]]]]]]), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | | |     α83' = [[[[[α85']]]]] for lb([[[[[α85']]]]] <: α83')
//│ | | | | | U [[[[[α85']]]]] = bool because lb([[[[[α85']]]]] <: α83'), ub(α82' <: [[[[[[[[α83']]]]]]]]), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | | |     α83' = [[[[int]]]] for lb([[[[int]]]] <: α83')
//│ | | | | | U [[[[int]]]] = bool because lb([[[[int]]]] <: α83'), ub(α82' <: [[[[[[[[α83']]]]]]]]), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | | |     α83' = [[[[[[[[[[[α80']]]]]]]]]]] for lb([[[[[[[[[[[α80']]]]]]]]]]] <: α83')
//│ | | | | | U [[[[[[[[[[[α80']]]]]]]]]]] = bool because lb([[[[[[[[[[[α80']]]]]]]]]]] <: α83'), ub(α82' <: [[[[[[[[α83']]]]]]]]), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | | | |     α83' = [[[[[[[[α82']]]]]]]] for lb([[[[[[[[α82']]]]]]]] <: α83')
//│ | | | | | U [[[[[[[[α82']]]]]]]] = bool because lb([[[[[[[[α82']]]]]]]] <: α83'), ub(α82' <: [[[[[[[[α83']]]]]]]]), lb([[[[[[α82']]]]]] <: α84'), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | | |     α84' = [[[α83']]] for ub(α84' <: [[[α83']]])
//│ | | | U [[[α83']]] = bool because ub(α84' <: [[[α83']]]), ub(α85' <: [[[α84']]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | |     α85' = [[int]] for ub(α85' <: [[int]])
//│ | | U [[int]] = bool because ub(α85' <: [[int]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | |     α85' = [[[[[[[α80']]]]]]] for lb([[[[[[[α80']]]]]]] <: α85')
//│ | | U [[[[[[[α80']]]]]]] = bool because lb([[[[[[[α80']]]]]]] <: α85'), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | |     α85' = [[[[α82']]]] for lb([[[[α82']]]] <: α85')
//│ | | U [[[[α82']]]] = bool because lb([[[[α82']]]] <: α85'), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | |     α85' = [[[[[α83']]]]] for ub(α85' <: [[[[[α83']]]]])
//│ | | U [[[[[α83']]]]] = bool because ub(α85' <: [[[[[α83']]]]]), ub(α80' <: [[[[[[[α85']]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | UT  α80' <: [[[[[[[[[α84']]]]]]]]]  for ub(α80' <: [[[[[[[[[α84']]]]]]]]])
//│ | U [[[[[[[[[α84']]]]]]]]] = [[[[bool]]]] because ub(α80' <: [[[[[[[[[α84']]]]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | UT  α80' <: [[[[[[[[[[[α83']]]]]]]]]]]  for ub(α80' <: [[[[[[[[[[[α83']]]]]]]]]]])
//│ | U [[[[[[[[[[[α83']]]]]]]]]]] = [[[[bool]]]] because ub(α80' <: [[[[[[[[[[[α83']]]]]]]]]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | UT  α80' <: [[[[α82']]]]  for ub(α80' <: [[[[α82']]]])
//│ | U [[[[α82']]]] = [[[[bool]]]] because ub(α80' <: [[[[α82']]]]), ub(α80' <: [[[[bool]]]]) ()
//│ | UT  α80' += ([[[[bool]]]],List(ub(α80' <: [[[[bool]]]])))
//│ ╔══[WARNING] ?a is unified with ?b * ?c because lb([[[([α81'], α83',)]]] <: α91'))
//│ ║  
//│ ╟── tuple literal
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                 ^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                 ^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ╙──      	                 ^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b -> ?c * ?d because lb([[[(α82' -> ([α81'], α83',))]]] <: α89'))
//│ ║  
//│ ╟── function
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ╙──      	                 ^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b -> ?c because ub(α89' <: [[([α80'] -> α91')]]))
//│ ║  
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                 ^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                 ^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ╙──      	                 ^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because lb([[[bool]]] <: α87'))
//│ ║  
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ╙──      	                        ^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α87' <: [[[α81']]]))
//│ ║  
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	           ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	           ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α85' <: [[[α84']]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α85' <: [[int]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[[α80']]]]]]] <: α85'))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	               ^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[α82']]]] <: α85'))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	               ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α85' <: [[[[[α83']]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[α85']]] <: α84'))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with int because lb([[int]] <: α84'))
//│ ║  
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[[[[α80']]]]]]]]] <: α84'))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[α82']]]]]] <: α84'))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α84' <: [[[α83']]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[α84']]] <: α83'))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[α85']]]]] <: α83'))
//│ ║  
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with int because lb([[[[int]]]] <: α83'))
//│ ║  
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[[[[[[α80']]]]]]]]]]] <: α83'))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[[[[[α82']]]]]]]] <: α83'))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α82' <: [[[[[[α84']]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α82' <: [[[[α85']]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	               ^
//│ ╔══[WARNING] ?a is unified with int because ub(α82' <: [[int]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[[α80']]]] <: α82'))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	             ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α82' <: [[[[[[[[α83']]]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because lb([[[[[bool]]]]] <: α81'))
//│ ║  
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	           ^
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[α87']]] <: α81'))
//│ ║  
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── application
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	           ^
//│ ╔══[WARNING] ?a is unified with bool because ub(α80' <: [[[[bool]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                             ^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	         ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	         ^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α80' <: [[[[[[[[[α84']]]]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α80' <: [[[[[[[α85']]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	               ^
//│ ╔══[WARNING] ?a is unified with int because ub(α80' <: [[int]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α80' <: [[[[α82']]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	             ^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α80' <: [[[[[[[[[[[α83']]]]]]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	             ^
//│ ╟── reference
//│ ║  l.77: 	let conflict x = mkpair (not x) x
//│ ║        	                                ^
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── reference
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── `then` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                     ^^^^^^^^^^^^
//│ conflict: (bool & 'a) -> (bool, int | 'a,)

:d
:unifyDbg
let g x = (not x, (if true then x else 5))
//│ 1. Typing term x => not x, if true(true) then x then (false) then 5,
//│ | 1. Typing pattern x
//│ | 1. : α102'
//│ | 1. Typing term not x, if true(true) then x then (false) then 5,
//│ | | 1. Typing term not x
//│ | | | 1. Typing term not
//│ | | | 1. : [(bool -> bool)]
//│ | | | 1. Typing term x
//│ | | | 1. : [α102']
//│ | | | CONSTRAIN [(bool -> bool)] <! ([α102'] -> α104')
//│ | | |   where 
//│ | | | C [(bool -> bool)] <! ([α102'] -> α104')    (0) where ProvType <: FunctionType}
//│ | | | | C (bool -> bool) <! ([α102'] -> α104')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[α102']]
//│ | | | | | C [α102'] <! bool    (1) where ProvType <: TypeRef}
//│ | | | | | | C α102' <! bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | [nested] [bool]
//│ | | | | | C bool <! α104'    (2) where TypeRef <: TypeVariable}
//│ | | 1. : α104'
//│ | | 1. Typing term if true(true) then x then (false) then 5
//│ | | | If(Var(true), List(IfThen(Var(true), Var(x), IfThen(Var(false), IntLit(5)))
//│ | | | 1. Typing term true
//│ | | | 1. : [bool]
//│ | | | CONSTRAIN [bool] <! bool
//│ | | |   where 
//│ | | | C [bool] <! bool    (0) where ProvType <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α102']
//│ | | | CONSTRAIN [α102'] <! α105'
//│ | | |   where 
//│ 		α102' <: [[[[bool]]]]
//│ | | | C [α102'] <! α105'    (0) where ProvType <: TypeVariable}
//│ | | | | C α102' <! α105'    (0) where TypeVariable <: TypeVariable}
//│ | | | | | symmetric
//│ | | | 1. Typing term 5
//│ | | | 1. : int
//│ | | | CONSTRAIN int <! α105'
//│ | | |   where 
//│ 		α102' <: [[[α105']]] & [[[[bool]]]]
//│ 		α105' :> [[[α102']]]
//│ | | | C int <! α105'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α105'
//│ | 1. : (α104', α105',)
//│ 1. : (α102' -> (α104', α105',))
//│ ⬤ Typed as: (α102' -> (α104', α105',))
//│  where: 
//│ 		α102' <: [[[α105']]] & [[[[bool]]]]
//│ 		α104' :> [[[bool]]]
//│ 		α105' :> [[int]] | [[[α102']]]
//│ unified α105' with:
//│ unified α104' with:
//│ unified α103' with:
//│ unified α102' with:
//│ α105' bounds
//│  α105' <: [[int]] with lb([[int]] <: α105') length: 3
//│ UT α105' <: [[int]] len: 4 
//│ | UT  int with
//│ | UT  [[int]] <: α105' <: int
//│ | UT [[int]] <: [[int]] len: 7 
//│ | | U [[int]] = [[int]] because lb([[int]] <: [[int]]) skipCache
//│ | UT  [[[α102']]] <: α105' <: int
//│ | UT [[[α102']]] <: [[int]] len: 8 
//│ | | UT  int with
//│ | | UT  α102' += ([[int]],List(ub(α102' <: [[int]])))
//│ | UT  α105' += ([[int]],List(ub(α105' <: [[int]])))
//│  α105' <: [[[α102']]] with lb([[[α102']]] <: α105') length: 4
//│ UT α105' <: [[[α102']]] len: 5 
//│ | UT  α102' with
//│ | UT  [[int]] <: α105' <: α102'
//│ | UT [[int]] <: [[[α102']]] len: 8 
//│ | UT  [[[α102']]] <: α105' <: α102'
//│ | UT [[[α102']]] <: [[[α102']]] len: 9 
//│ | UT  α105' += ([[[α102']]],List(ub(α105' <: [[[α102']]])))
//│ α104' bounds
//│  α104' <: [[[bool]]] with lb([[[bool]]] <: α104') length: 3
//│ UT α104' <: [[[bool]]] len: 4 
//│ | UT  bool with
//│ | UT  [[[bool]]] <: α104' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 7 
//│ | | U [[[bool]]] = [[[bool]]] because lb([[[bool]]] <: [[[bool]]]) skipCache
//│ | UT  α104' += ([[[bool]]],List(ub(α104' <: [[[bool]]])))
//│ α103' bounds
//│ α102' bounds
//│  α102' :> [[[α105']]] with ub(α102' <: [[[α105']]]) length: 4
//│ UT α102' <: [[[α105']]] len: 5 
//│  α102' :> [[[[bool]]]] with ub(α102' <: [[[[bool]]]]) length: 4
//│ UT α102' <: [[[[bool]]]] len: 5 
//│ | UT  bool with
//│ | UT  α102' <: [[[α105']]]  for ub(α102' <: [[[α105']]])
//│ | U [[[α105']]] = [[[[bool]]]] because ub(α102' <: [[[α105']]]), ub(α102' <: [[[[bool]]]]) ()
//│ | | U   bool with
//│ | |     α105' = [[[α102']]] for lb([[[α102']]] <: α105')
//│ | | U [[[α102']]] = bool because lb([[[α102']]] <: α105'), ub(α102' <: [[[α105']]]), ub(α102' <: [[[[bool]]]]) ()
//│ | |     α105' = [[int]] for lb([[int]] <: α105')
//│ | | U [[int]] = bool because lb([[int]] <: α105'), ub(α102' <: [[[α105']]]), ub(α102' <: [[[[bool]]]]) ()
//│ | | | UERR  [[int]] = bool because lb([[int]] <: α105'),ub(α102' <: [[[α105']]]),ub(α102' <: [[[[bool]]]])
//│ | | | (lb([[int]] <: α105'),true) -> (ub(α102' <: [[[α105']]]),false) showFirst: true leftSame: false
//│ | | | show 2 locations for (lb([[int]] <: α105'),true)
//│ | | | (lb([[int]] <: α105'),true) -> (ub(α102' <: [[[α105']]]),false) showFirst: false leftSame: false
//│ | | | show 2 locations for (ub(α102' <: [[[α105']]]),false)
//│ | | | (ub(α102' <: [[[α105']]]),false) -> (ub(α102' <: [[[[bool]]]]),true) showFirst: false leftSame: true
//│ | | | show 2 locations for (ub(α102' <: [[[[bool]]]]),true)
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a` and it flows from `?b`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── this variable has type `?b`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── this reference has type `?b` and it flows into `bool`
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	               ^
//│ ╟── this type reference has type `bool`
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	         ^^^^
//│ | UT  α102' += ([[[[bool]]]],List(ub(α102' <: [[[[bool]]]])))
//│ ╔══[WARNING] ?a is unified with ?b because lb([[[α102']]] <: α105'))
//│ ║  
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── `then` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with int because lb([[int]] <: α105'))
//│ ║  
//│ ╟── `else` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── `else` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because lb([[[bool]]] <: α104'))
//│ ║  
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── application
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	           ^^^^^
//│ ╔══[WARNING] ?a is unified with bool because ub(α102' <: [[[[bool]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── reference
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	               ^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	         ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	         ^^^^
//│ ╔══[WARNING] ?a is unified with ?b because ub(α102' <: [[[α105']]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── `then` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α102' <: [[int]]))
//│ ║  
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── variable
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── `then` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── `else` branch
//│ ║  l.1083: 	let g x = (not x, (if true then x else 5))
//│ ╙──        	                                       ^
//│ g: (bool & 'a) -> (bool, int | 'a,)

:d
let g x = (not x, (if true then x else 5))
//│ 1. Typing term x => not x, if true(true) then x then (false) then 5,
//│ | 1. Typing pattern x
//│ | 1. : α111'
//│ | 1. Typing term not x, if true(true) then x then (false) then 5,
//│ | | 1. Typing term not x
//│ | | | 1. Typing term not
//│ | | | 1. : [(bool -> bool)]
//│ | | | 1. Typing term x
//│ | | | 1. : [α111']
//│ | | | CONSTRAIN [(bool -> bool)] <! ([α111'] -> α113')
//│ | | |   where 
//│ | | | C [(bool -> bool)] <! ([α111'] -> α113')    (0) where ProvType <: FunctionType}
//│ | | | | C (bool -> bool) <! ([α111'] -> α113')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[α111']]
//│ | | | | | C [α111'] <! bool    (1) where ProvType <: TypeRef}
//│ | | | | | | C α111' <! bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | [nested] [bool]
//│ | | | | | C bool <! α113'    (2) where TypeRef <: TypeVariable}
//│ | | 1. : α113'
//│ | | 1. Typing term if true(true) then x then (false) then 5
//│ | | | If(Var(true), List(IfThen(Var(true), Var(x), IfThen(Var(false), IntLit(5)))
//│ | | | 1. Typing term true
//│ | | | 1. : [bool]
//│ | | | CONSTRAIN [bool] <! bool
//│ | | |   where 
//│ | | | C [bool] <! bool    (0) where ProvType <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α111']
//│ | | | CONSTRAIN [α111'] <! α114'
//│ | | |   where 
//│ 		α111' <: [[[[bool]]]]
//│ | | | C [α111'] <! α114'    (0) where ProvType <: TypeVariable}
//│ | | | | C α111' <! α114'    (0) where TypeVariable <: TypeVariable}
//│ | | | | | symmetric
//│ | | | 1. Typing term 5
//│ | | | 1. : int
//│ | | | CONSTRAIN int <! α114'
//│ | | |   where 
//│ 		α111' <: [[[α114']]] & [[[[bool]]]]
//│ 		α114' :> [[[α111']]]
//│ | | | C int <! α114'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α114'
//│ | 1. : (α113', α114',)
//│ 1. : (α111' -> (α113', α114',))
//│ ⬤ Typed as: (α111' -> (α113', α114',))
//│  where: 
//│ 		α111' <: [[[α114']]] & [[[[bool]]]]
//│ 		α113' :> [[[bool]]]
//│ 		α114' :> [[int]] | [[[α111']]]
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                       ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a` and it flows from `?b`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	                                ^
//│ ╟── this variable has type `?b`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	      ^
//│ ╟── this reference has type `?b` and it flows into `bool`
//│ ║  l.1302: 	let g x = (not x, (if true then x else 5))
//│ ║          	               ^
//│ ╟── this type reference has type `bool`
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	         ^^^^
//│ g: (bool & 'a) -> (bool, int | 'a,)
