let confluence z = if true then z else 5
//│ confluence: 'a -> (int | 'a)

:d
let mkpair x y = (x, confluence y)
//│ 1. Typing term x => y => x, confluence y,
//│ | 1. Typing pattern x
//│ | 1. : α65'
//│ | 1. Typing term y => x, confluence y,
//│ | | 1. Typing pattern y
//│ | | 1. : α66'
//│ | | 1. Typing term x, confluence y,
//│ | | | 1. Typing term x
//│ | | | 1. : [α65']
//│ | | | 1. Typing term confluence y
//│ | | | | 1. Typing term confluence
//│ | | | | 1. : [(α67' -> α68')]
//│ | | | | 1. Typing term y
//│ | | | | 1. : [α66']
//│ | | | | CONSTRAIN [(α67' -> α68')] <! ([α66'] -> α70')
//│ | | | |   where 
//│ 		α67' <: [[[α68']]]
//│ 		α68' :> [[Int]]
//│ | | | | C [(α67' -> α68')] <! ([α66'] -> α70')    (0) where ProvType <: FunctionType}
//│ | | | | | C (α67' -> α68') <! ([α66'] -> α70')    (0) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[α66']]
//│ | | | | | | C [α66'] <! α67'    (1) where ProvType <: TypeVariable}
//│ | | | | | | | C α66' <! α67'    (1) where TypeVariable <: TypeVariable}
//│ | | | | | | [nested] [α68']
//│ | | | | | | C α68' <! α70'    (2) where TypeVariable <: TypeVariable}
//│ | | | | | | | C [[Int]] <! α70'    (3) where ProvType <: TypeVariable}
//│ | | | | | | | | C [Int] <! α70'    (3) where ProvType <: TypeVariable}
//│ | | | | | | | | | C Int <! α70'    (3) where TypeRef <: TypeVariable}
//│ | | | 1. : α70'
//│ | | 1. : ([α65'], α70',)
//│ | 1. : (α66' -> ([α65'], α70',))
//│ 1. : (α65' -> (α66' -> ([α65'], α70',)))
//│ ⬤ Typed as: (α65' -> (α66' -> ([α65'], α70',)))
//│  where: 
//│ 		α66' <: [[[[α67']]]]
//│ 		α67' <: [[[α68']]]
//│ 		α68' :> [[Int]] <: [[[α70']]]
//│ 		α70' :> [[[[Int]]]]
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)

:d
// mkpair 1 "2"

:unifyDbg
:d
let conflict x = mkpair (not x) x
//│ 1. Typing term x => mkpair (not x) x
//│ | 1. Typing pattern x
//│ | 1. : α80'
//│ | 1. Typing term mkpair (not x) x
//│ | | 1. Typing term mkpair (not x)
//│ | | | 1. Typing term mkpair
//│ | | | 1. : [(α81' -> (α82' -> ([α81'], α85',)))]
//│ | | | 1. Typing term not x
//│ | | | | 1. Typing term not
//│ | | | | 1. : [(Bool -> Bool)]
//│ | | | | 1. Typing term x
//│ | | | | 1. : [α80']
//│ | | | | CONSTRAIN [(Bool -> Bool)] <! ([α80'] -> α87')
//│ | | | |   where 
//│ | | | | C [(Bool -> Bool)] <! ([α80'] -> α87')    (0) where ProvType <: FunctionType}
//│ | | | | | C (Bool -> Bool) <! ([α80'] -> α87')    (0) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[α80']]
//│ | | | | | | C [α80'] <! Bool    (1) where ProvType <: TypeRef}
//│ | | | | | | | C α80' <! Bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | | [nested] [Bool]
//│ | | | | | | C Bool <! α87'    (2) where TypeRef <: TypeVariable}
//│ | | | 1. : α87'
//│ | | | CONSTRAIN [(α81' -> (α82' -> ([α81'], α85',)))] <! (α87' -> α89')
//│ | | |   where 
//│ 		α82' <: [[[[α83']]]]
//│ 		α83' <: [[[α84']]]
//│ 		α84' :> [[Int]] <: [[[α85']]]
//│ 		α85' :> [[[[Int]]]]
//│ 		α87' :> [[[Bool]]]
//│ | | | C [(α81' -> (α82' -> ([α81'], α85',)))] <! (α87' -> α89')    (0) where ProvType <: FunctionType}
//│ | | | | C (α81' -> (α82' -> ([α81'], α85',))) <! (α87' -> α89')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [α87']
//│ | | | | | C α87' <! α81'    (1) where TypeVariable <: TypeVariable}
//│ | | | | | | C [[[Bool]]] <! α81'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | C [[Bool]] <! α81'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | C [Bool] <! α81'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | | C Bool <! α81'    (2) where TypeRef <: TypeVariable}
//│ | | | | | [nested] [(α82' -> ([α81'], α85',))]
//│ | | | | | C (α82' -> ([α81'], α85',)) <! α89'    (3) where FunctionType <: TypeVariable}
//│ | | 1. : α89'
//│ | | 1. Typing term x
//│ | | 1. : [α80']
//│ | | CONSTRAIN α89' <! ([α80'] -> α91')
//│ | |   where 
//│ 		α80' <: [[[[Bool]]]]
//│ 		α81' :> [[[[[Bool]]]]]
//│ 		α82' <: [[[[α83']]]]
//│ 		α83' <: [[[α84']]]
//│ 		α84' :> [[Int]] <: [[[α85']]]
//│ 		α85' :> [[[[Int]]]]
//│ 		α89' :> [[[(α82' -> ([α81'], α85',))]]]
//│ | | C α89' <! ([α80'] -> α91')    (0) where TypeVariable <: FunctionType}
//│ | | | C [[[(α82' -> ([α81'], α85',))]]] <! ([α80'] -> α91')    (1) where ProvType <: FunctionType}
//│ | | | | C [[(α82' -> ([α81'], α85',))]] <! ([α80'] -> α91')    (1) where ProvType <: FunctionType}
//│ | | | | | C [(α82' -> ([α81'], α85',))] <! ([α80'] -> α91')    (1) where ProvType <: FunctionType}
//│ | | | | | | C (α82' -> ([α81'], α85',)) <! ([α80'] -> α91')    (1) where FunctionType <: FunctionType}
//│ | | | | | | | [nested] [[α80']]
//│ | | | | | | | C [α80'] <! α82'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | C α80' <! α82'    (2) where TypeVariable <: TypeVariable}
//│ | | | | | | | [nested] [([α81'], α85',)]
//│ | | | | | | | C ([α81'], α85',) <! α91'    (3) where TupleType <: TypeVariable}
//│ | 1. : α91'
//│ 1. : (α80' -> α91')
//│ ⬤ Typed as: (α80' -> α91')
//│  where: 
//│ 		α80' <: [[[[α82']]]] & [[[[Bool]]]]
//│ 		α81' :> [[[[[Bool]]]]]
//│ 		α82' <: [[[[α83']]]]
//│ 		α83' <: [[[α84']]]
//│ 		α84' :> [[Int]] <: [[[α85']]]
//│ 		α85' :> [[[[Int]]]]
//│ 		α91' :> [[[([α81'], α85',)]]]
//│ unified α91' with:
//│ unified α90' with:
//│ unified α89' with:
//│ unified α88' with:
//│ unified α87' with:
//│ unified α86' with:
//│ unified α85' with:
//│ unified α84' with:
//│ unified α83' with:
//│ unified α82' with:
//│ unified α81' with:
//│ unified α80' with:
//│ α91' bounds
//│  α91' <: [[[([α81'], α85',)]]] with lb([[[([α81'], α85',)]]] <: α91') length: 4
//│ UT α91' <: [[[([α81'], α85',)]]] len: 5 
//│ | UT  ([α81'], α85',) with
//│ | UT  [[[([α81'], α85',)]]] <: α91' <: ([α81'], α85',)
//│ | UT [[[([α81'], α85',)]]] <: [[[([α81'], α85',)]]] len: 9 
//│ | | U [[[([α81'], α85',)]]] = [[[([α81'], α85',)]]] because lb([[[([α81'], α85',)]]] <: [[[([α81'], α85',)]]]) skipCache
//│ | | | UT [α81'] <: [α81'] len: 4 nested: [[[([α81'], α85',)]]] = [[[([α81'], α85',)]]] because lb([[[([α81'], α85',)]]] <: [[[([α81'], α85',)]]])
//│ | | | UT α85' <: α85' len: 2 nested: [[[([α81'], α85',)]]] = [[[([α81'], α85',)]]] because lb([[[([α81'], α85',)]]] <: [[[([α81'], α85',)]]])
//│ | UT  α91' += ([[[([α81'], α85',)]]],List(ub(α91' <: [[[([α81'], α85',)]]])))
//│  α91' :> [[[([α81'], α85',)]]] with ub(α91' <: [[[([α81'], α85',)]]]) length: 4
//│ UT α91' <: [[[([α81'], α85',)]]] len: 5 
//│ α90' bounds
//│ α89' bounds
//│  α89' <: [[[(α82' -> ([α81'], α85',))]]] with lb([[[(α82' -> ([α81'], α85',))]]] <: α89') length: 4
//│ UT α89' <: [[[(α82' -> ([α81'], α85',))]]] len: 5 
//│ | UT  (α82' -> ([α81'], α85',)) with
//│ | UT  [[[(α82' -> ([α81'], α85',))]]] <: α89' <: (α82' -> ([α81'], α85',))
//│ | UT [[[(α82' -> ([α81'], α85',))]]] <: [[[(α82' -> ([α81'], α85',))]]] len: 9 
//│ | | U [[[(α82' -> ([α81'], α85',))]]] = [[[(α82' -> ([α81'], α85',))]]] because lb([[[(α82' -> ([α81'], α85',))]]] <: [[[(α82' -> ([α81'], α85',))]]]) skipCache
//│ | UT  (α82' -> ([α81'], α85',)) with
//│ | UT  α89' += ([[[(α82' -> ([α81'], α85',))]]],List(ub(α89' <: [[[(α82' -> ([α81'], α85',))]]])))
//│  α89' :> [[[(α82' -> ([α81'], α85',))]]] with ub(α89' <: [[[(α82' -> ([α81'], α85',))]]]) length: 4
//│ UT α89' <: [[[(α82' -> ([α81'], α85',))]]] len: 5 
//│ α88' bounds
//│ α87' bounds
//│  α87' <: [[[Bool]]] with lb([[[Bool]]] <: α87') length: 4
//│ UT α87' <: [[[Bool]]] len: 5 
//│ | UT  Bool with
//│ | UT  [[[Bool]]] <: α87' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | | U [[[Bool]]] = [[[Bool]]] because lb([[[Bool]]] <: [[[Bool]]]) skipCache
//│ | UT  Bool with
//│ | UT  α87' += ([[[Bool]]],List(ub(α87' <: [[[Bool]]])))
//│  α87' :> [[[Bool]]] with ub(α87' <: [[[Bool]]]) length: 4
//│ UT α87' <: [[[Bool]]] len: 5 
//│ α86' bounds
//│ α85' bounds
//│  α85' <: [[[[Int]]]] with lb([[[[Int]]]] <: α85') length: 5
//│ UT α85' <: [[[[Int]]]] len: 6 
//│ | UT  Int with
//│ | UT  [[[[Int]]]] <: α85' <: Int
//│ | UT [[[[Int]]]] <: [[[[Int]]]] len: 11 
//│ | UT  α85' += ([[[[Int]]]],List(ub(α85' <: [[[[Int]]]])))
//│  α85' :> [[[[Int]]]] with ub(α85' <: [[[[Int]]]]) length: 5
//│ UT α85' <: [[[[Int]]]] len: 6 
//│ α84' bounds
//│  α84' <: [[Int]] with lb([[Int]] <: α84') length: 3
//│ UT α84' <: [[Int]] len: 4 
//│ | UT  Int with
//│ | UT  [[Int]] <: α84' <: Int
//│ | UT [[Int]] <: [[Int]] len: 7 
//│ | UT  Int with
//│ | UT  α84' += ([[Int]],List(ub(α84' <: [[Int]])))
//│  α84' :> [[Int]] with ub(α84' <: [[Int]]) length: 3
//│ UT α84' <: [[Int]] len: 4 
//│ α83' bounds
//│ α82' bounds
//│ α81' bounds
//│  α81' <: [[[[[Bool]]]]] with lb([[[[[Bool]]]]] <: α81') length: 6
//│ UT α81' <: [[[[[Bool]]]]] len: 7 
//│ | UT  Bool with
//│ | UT  [[[[[Bool]]]]] <: α81' <: Bool
//│ | UT [[[[[Bool]]]]] <: [[[[[Bool]]]]] len: 13 
//│ | UT  α81' += ([[[[[Bool]]]]],List(ub(α81' <: [[[[[Bool]]]]])))
//│  α81' :> [[[[[Bool]]]]] with ub(α81' <: [[[[[Bool]]]]]) length: 6
//│ UT α81' <: [[[[[Bool]]]]] len: 7 
//│ α80' bounds
//│ ╔══[WARNING] ?a is unified with ?b * ?c because ub(α91' <: [[[([α81'], α85',)]]]))
//│ ║  
//│ ╟── application
//│ ║  l.51: 	let conflict x = mkpair (not x) x
//│ ║        	                 ^^^^^^^^^^^^^^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── tuple literal
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                 ^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                 ^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b -> ?c * ?d because ub(α89' <: [[[(α82' -> ([α81'], α85',))]]]))
//│ ║  
//│ ╟── application
//│ ║  l.51: 	let conflict x = mkpair (not x) x
//│ ║        	                 ^^^^^^^^^^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── function
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because ub(α87' <: [[[Bool]]]))
//│ ║  
//│ ╟── application
//│ ║  l.51: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	                 ^^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α85' <: [[[[Int]]]]))
//│ ║  
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with int because ub(α84' <: [[Int]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with bool because ub(α81' <: [[[[[Bool]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	           ^
//│ ╟── <nested> function lhs len: 3
//│ ╟── application
//│ ║  l.51: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	                 ^^^^
//│ conflict: (bool & 'a) -> (bool, int | 'a,)

:d
:unifyDbg
let g x = (not x, (if true then x else 5))
//│ 1. Typing term x => not x, if true(true) then x then (false) then 5,
//│ | 1. Typing pattern x
//│ | 1. : α101'
//│ | 1. Typing term not x, if true(true) then x then (false) then 5,
//│ | | 1. Typing term not x
//│ | | | 1. Typing term not
//│ | | | 1. : [(Bool -> Bool)]
//│ | | | 1. Typing term x
//│ | | | 1. : [α101']
//│ | | | CONSTRAIN [(Bool -> Bool)] <! ([α101'] -> α103')
//│ | | |   where 
//│ | | | C [(Bool -> Bool)] <! ([α101'] -> α103')    (0) where ProvType <: FunctionType}
//│ | | | | C (Bool -> Bool) <! ([α101'] -> α103')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[α101']]
//│ | | | | | C [α101'] <! Bool    (1) where ProvType <: TypeRef}
//│ | | | | | | C α101' <! Bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | [nested] [Bool]
//│ | | | | | C Bool <! α103'    (2) where TypeRef <: TypeVariable}
//│ | | 1. : α103'
//│ | | 1. Typing term if true(true) then x then (false) then 5
//│ | | | If(Var(true), List(IfThen(Var(true), Var(x), IfThen(Var(false), IntLit(5)))
//│ | | | 1. Typing term true
//│ | | | 1. : [Bool]
//│ | | | CONSTRAIN [Bool] <! Bool
//│ | | |   where 
//│ | | | C [Bool] <! Bool    (0) where ProvType <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α101']
//│ | | | CONSTRAIN [α101'] <! α104'
//│ | | |   where 
//│ 		α101' <: [[[[Bool]]]]
//│ | | | C [α101'] <! α104'    (0) where ProvType <: TypeVariable}
//│ | | | | C α101' <! α104'    (0) where TypeVariable <: TypeVariable}
//│ | | | 1. Typing term 5
//│ | | | 1. : Int
//│ | | | CONSTRAIN Int <! α104'
//│ | | |   where 
//│ | | | C Int <! α104'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α104'
//│ | 1. : (α103', α104',)
//│ 1. : (α101' -> (α103', α104',))
//│ ⬤ Typed as: (α101' -> (α103', α104',))
//│  where: 
//│ 		α101' <: [[[α104']]] & [[[[Bool]]]]
//│ 		α103' :> [[[Bool]]]
//│ 		α104' :> [[Int]]
//│ unified α104' with:
//│ unified α103' with:
//│ unified α102' with:
//│ unified α101' with:
//│ α104' bounds
//│  α104' <: [[Int]] with lb([[Int]] <: α104') length: 3
//│ UT α104' <: [[Int]] len: 4 
//│ | UT  Int with
//│ | UT  [[Int]] <: α104' <: Int
//│ | UT [[Int]] <: [[Int]] len: 7 
//│ | UT  α104' += ([[Int]],List(ub(α104' <: [[Int]])))
//│  α104' :> [[Int]] with ub(α104' <: [[Int]]) length: 3
//│ UT α104' <: [[Int]] len: 4 
//│ α103' bounds
//│  α103' <: [[[Bool]]] with lb([[[Bool]]] <: α103') length: 4
//│ UT α103' <: [[[Bool]]] len: 5 
//│ | UT  Bool with
//│ | UT  [[[Bool]]] <: α103' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  α103' += ([[[Bool]]],List(ub(α103' <: [[[Bool]]])))
//│  α103' :> [[[Bool]]] with ub(α103' <: [[[Bool]]]) length: 4
//│ UT α103' <: [[[Bool]]] len: 5 
//│ α102' bounds
//│ α101' bounds
//│ ╔══[WARNING] ?a is unified with int because ub(α104' <: [[Int]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.286: 	let g x = (not x, (if true then x else 5))
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.286: 	let g x = (not x, (if true then x else 5))
//│ ║         	                                       ^
//│ ╟── `else` branch
//│ ║  l.286: 	let g x = (not x, (if true then x else 5))
//│ ╙──       	                                       ^
//│ ╔══[WARNING] ?a is unified with bool because ub(α103' <: [[[Bool]]]))
//│ ║  
//│ ╟── application
//│ ║  l.286: 	let g x = (not x, (if true then x else 5))
//│ ║         	           ^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	                 ^^^^
//│ g: (bool & 'a) -> (bool, int | 'a,)

:d
let g x = (not x, (if true then x else 5))
//│ 1. Typing term x => not x, if true(true) then x then (false) then 5,
//│ | 1. Typing pattern x
//│ | 1. : α110'
//│ | 1. Typing term not x, if true(true) then x then (false) then 5,
//│ | | 1. Typing term not x
//│ | | | 1. Typing term not
//│ | | | 1. : [(Bool -> Bool)]
//│ | | | 1. Typing term x
//│ | | | 1. : [α110']
//│ | | | CONSTRAIN [(Bool -> Bool)] <! ([α110'] -> α112')
//│ | | |   where 
//│ | | | C [(Bool -> Bool)] <! ([α110'] -> α112')    (0) where ProvType <: FunctionType}
//│ | | | | C (Bool -> Bool) <! ([α110'] -> α112')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[α110']]
//│ | | | | | C [α110'] <! Bool    (1) where ProvType <: TypeRef}
//│ | | | | | | C α110' <! Bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | [nested] [Bool]
//│ | | | | | C Bool <! α112'    (2) where TypeRef <: TypeVariable}
//│ | | 1. : α112'
//│ | | 1. Typing term if true(true) then x then (false) then 5
//│ | | | If(Var(true), List(IfThen(Var(true), Var(x), IfThen(Var(false), IntLit(5)))
//│ | | | 1. Typing term true
//│ | | | 1. : [Bool]
//│ | | | CONSTRAIN [Bool] <! Bool
//│ | | |   where 
//│ | | | C [Bool] <! Bool    (0) where ProvType <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α110']
//│ | | | CONSTRAIN [α110'] <! α113'
//│ | | |   where 
//│ 		α110' <: [[[[Bool]]]]
//│ | | | C [α110'] <! α113'    (0) where ProvType <: TypeVariable}
//│ | | | | C α110' <! α113'    (0) where TypeVariable <: TypeVariable}
//│ | | | 1. Typing term 5
//│ | | | 1. : Int
//│ | | | CONSTRAIN Int <! α113'
//│ | | |   where 
//│ | | | C Int <! α113'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α113'
//│ | 1. : (α112', α113',)
//│ 1. : (α110' -> (α112', α113',))
//│ ⬤ Typed as: (α110' -> (α112', α113',))
//│  where: 
//│ 		α110' <: [[[α113']]] & [[[[Bool]]]]
//│ 		α112' :> [[[Bool]]]
//│ 		α113' :> [[Int]]
//│ g: (bool & 'a) -> (bool, int | 'a,)
