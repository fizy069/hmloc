let confluence z = if true then z else 5
//│ confluence: 'a -> (int | 'a)

:d
let mkpair x y = (x, confluence y)
//│ 1. Typing term x => y => x, confluence y,
//│ | 1. Typing pattern x
//│ | 1. : α65'
//│ | 1. Typing term y => x, confluence y,
//│ | | 1. Typing pattern y
//│ | | 1. : α66'
//│ | | 1. Typing term x, confluence y,
//│ | | | 1. Typing term x
//│ | | | 1. : [α65']
//│ | | | 1. Typing term confluence y
//│ | | | | 1. Typing term confluence
//│ | | | | 1. : [(α67' -> α68')]
//│ | | | | 1. Typing term y
//│ | | | | 1. : [α66']
//│ | | | | CONSTRAIN [(α67' -> α68')] <! ([α66'] -> α70')
//│ | | | |   where 
//│ 		α67' <: [[[α68']]]
//│ 		α68' :> [[int]]
//│ | | | | C [(α67' -> α68')] <! ([α66'] -> α70')    (0) where ProvType <: FunctionType}
//│ | | | | | C (α67' -> α68') <! ([α66'] -> α70')    (0) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[α66']]
//│ | | | | | | C [α66'] <! α67'    (1) where ProvType <: TypeVariable}
//│ | | | | | | | C α66' <! α67'    (1) where TypeVariable <: TypeVariable}
//│ | | | | | | [nested] [α68']
//│ | | | | | | C α68' <! α70'    (2) where TypeVariable <: TypeVariable}
//│ | | | | | | | C [[int]] <! α70'    (3) where ProvType <: TypeVariable}
//│ | | | | | | | | C [int] <! α70'    (3) where ProvType <: TypeVariable}
//│ | | | | | | | | | C int <! α70'    (3) where TypeRef <: TypeVariable}
//│ | | | 1. : α70'
//│ | | 1. : ([α65'], α70',)
//│ | 1. : (α66' -> ([α65'], α70',))
//│ 1. : (α65' -> (α66' -> ([α65'], α70',)))
//│ ⬤ Typed as: (α65' -> (α66' -> ([α65'], α70',)))
//│  where: 
//│ 		α66' <: [[[[α67']]]]
//│ 		α67' <: [[[α68']]]
//│ 		α68' :> [[int]] <: [[[α70']]]
//│ 		α70' :> [[[[int]]]]
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)

:d
// mkpair 1 "2"

:unifyDbg
:d
let conflict x = mkpair (not x) x
//│ 1. Typing term x => mkpair (not x) x
//│ | 1. Typing pattern x
//│ | 1. : α80'
//│ | 1. Typing term mkpair (not x) x
//│ | | 1. Typing term mkpair (not x)
//│ | | | 1. Typing term mkpair
//│ | | | 1. : [(α81' -> (α82' -> ([α81'], α85',)))]
//│ | | | 1. Typing term not x
//│ | | | | 1. Typing term not
//│ | | | | 1. : [(bool -> bool)]
//│ | | | | 1. Typing term x
//│ | | | | 1. : [α80']
//│ | | | | CONSTRAIN [(bool -> bool)] <! ([α80'] -> α87')
//│ | | | |   where 
//│ | | | | C [(bool -> bool)] <! ([α80'] -> α87')    (0) where ProvType <: FunctionType}
//│ | | | | | C (bool -> bool) <! ([α80'] -> α87')    (0) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[α80']]
//│ | | | | | | C [α80'] <! bool    (1) where ProvType <: TypeRef}
//│ | | | | | | | C α80' <! bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | | [nested] [bool]
//│ | | | | | | C bool <! α87'    (2) where TypeRef <: TypeVariable}
//│ | | | 1. : α87'
//│ | | | CONSTRAIN [(α81' -> (α82' -> ([α81'], α85',)))] <! (α87' -> α89')
//│ | | |   where 
//│ 		α82' <: [[[[α83']]]]
//│ 		α83' <: [[[α84']]]
//│ 		α84' :> [[int]] <: [[[α85']]]
//│ 		α85' :> [[[[int]]]]
//│ 		α87' :> [[[bool]]]
//│ | | | C [(α81' -> (α82' -> ([α81'], α85',)))] <! (α87' -> α89')    (0) where ProvType <: FunctionType}
//│ | | | | C (α81' -> (α82' -> ([α81'], α85',))) <! (α87' -> α89')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [α87']
//│ | | | | | C α87' <! α81'    (1) where TypeVariable <: TypeVariable}
//│ | | | | | | C [[[bool]]] <! α81'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | C [[bool]] <! α81'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | C [bool] <! α81'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | | C bool <! α81'    (2) where TypeRef <: TypeVariable}
//│ | | | | | [nested] [(α82' -> ([α81'], α85',))]
//│ | | | | | C (α82' -> ([α81'], α85',)) <! α89'    (3) where FunctionType <: TypeVariable}
//│ | | 1. : α89'
//│ | | 1. Typing term x
//│ | | 1. : [α80']
//│ | | CONSTRAIN α89' <! ([α80'] -> α91')
//│ | |   where 
//│ 		α80' <: [[[[bool]]]]
//│ 		α81' :> [[[[[bool]]]]]
//│ 		α82' <: [[[[α83']]]]
//│ 		α83' <: [[[α84']]]
//│ 		α84' :> [[int]] <: [[[α85']]]
//│ 		α85' :> [[[[int]]]]
//│ 		α89' :> [[[(α82' -> ([α81'], α85',))]]]
//│ | | C α89' <! ([α80'] -> α91')    (0) where TypeVariable <: FunctionType}
//│ | | | C [[[(α82' -> ([α81'], α85',))]]] <! ([α80'] -> α91')    (1) where ProvType <: FunctionType}
//│ | | | | C [[(α82' -> ([α81'], α85',))]] <! ([α80'] -> α91')    (1) where ProvType <: FunctionType}
//│ | | | | | C [(α82' -> ([α81'], α85',))] <! ([α80'] -> α91')    (1) where ProvType <: FunctionType}
//│ | | | | | | C (α82' -> ([α81'], α85',)) <! ([α80'] -> α91')    (1) where FunctionType <: FunctionType}
//│ | | | | | | | [nested] [[α80']]
//│ | | | | | | | C [α80'] <! α82'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | | C α80' <! α82'    (2) where TypeVariable <: TypeVariable}
//│ | | | | | | | [nested] [([α81'], α85',)]
//│ | | | | | | | C ([α81'], α85',) <! α91'    (3) where TupleType <: TypeVariable}
//│ | 1. : α91'
//│ 1. : (α80' -> α91')
//│ ⬤ Typed as: (α80' -> α91')
//│  where: 
//│ 		α80' <: [[[[α82']]]] & [[[[bool]]]]
//│ 		α81' :> [[[[[bool]]]]]
//│ 		α82' <: [[[[α83']]]]
//│ 		α83' <: [[[α84']]]
//│ 		α84' :> [[int]] <: [[[α85']]]
//│ 		α85' :> [[[[int]]]]
//│ 		α91' :> [[[([α81'], α85',)]]]
//│ unified α91' with:
//│ unified α90' with:
//│ unified α89' with:
//│ unified α88' with:
//│ unified α87' with:
//│ unified α86' with:
//│ unified α85' with:
//│ unified α84' with:
//│ unified α83' with:
//│ unified α82' with:
//│ unified α81' with:
//│ unified α80' with:
//│ α91' bounds
//│  α91' <: [[[([α81'], α85',)]]] with lb([[[([α81'], α85',)]]] <: α91') length: 4
//│ UT α91' <: [[[([α81'], α85',)]]] len: 5 
//│ | UT  ([α81'], α85',) with
//│ | UT  [[[([α81'], α85',)]]] <: α91' <: ([α81'], α85',)
//│ | UT [[[([α81'], α85',)]]] <: [[[([α81'], α85',)]]] len: 9 
//│ | | U [[[([α81'], α85',)]]] = [[[([α81'], α85',)]]] because lb([[[([α81'], α85',)]]] <: [[[([α81'], α85',)]]]) skipCache
//│ | | | UT [α81'] <: [α81'] len: 4 nested: [[[([α81'], α85',)]]] = [[[([α81'], α85',)]]] because lb([[[([α81'], α85',)]]] <: [[[([α81'], α85',)]]])
//│ | | | UT α85' <: α85' len: 2 nested: [[[([α81'], α85',)]]] = [[[([α81'], α85',)]]] because lb([[[([α81'], α85',)]]] <: [[[([α81'], α85',)]]])
//│ | UT  α91' += ([[[([α81'], α85',)]]],List(ub(α91' <: [[[([α81'], α85',)]]])))
//│  α91' :> [[[([α81'], α85',)]]] with ub(α91' <: [[[([α81'], α85',)]]]) length: 4
//│ UT α91' <: [[[([α81'], α85',)]]] len: 5 
//│ α90' bounds
//│ α89' bounds
//│  α89' <: [[[(α82' -> ([α81'], α85',))]]] with lb([[[(α82' -> ([α81'], α85',))]]] <: α89') length: 4
//│ UT α89' <: [[[(α82' -> ([α81'], α85',))]]] len: 5 
//│ | UT  (α82' -> ([α81'], α85',)) with
//│ | UT  [[[(α82' -> ([α81'], α85',))]]] <: α89' <: (α82' -> ([α81'], α85',))
//│ | UT [[[(α82' -> ([α81'], α85',))]]] <: [[[(α82' -> ([α81'], α85',))]]] len: 9 
//│ | | U [[[(α82' -> ([α81'], α85',))]]] = [[[(α82' -> ([α81'], α85',))]]] because lb([[[(α82' -> ([α81'], α85',))]]] <: [[[(α82' -> ([α81'], α85',))]]]) skipCache
//│ | UT  (α82' -> ([α81'], α85',)) with
//│ | UT  α89' += ([[[(α82' -> ([α81'], α85',))]]],List(ub(α89' <: [[[(α82' -> ([α81'], α85',))]]])))
//│  α89' :> [[[(α82' -> ([α81'], α85',))]]] with ub(α89' <: [[[(α82' -> ([α81'], α85',))]]]) length: 4
//│ UT α89' <: [[[(α82' -> ([α81'], α85',))]]] len: 5 
//│ α88' bounds
//│ α87' bounds
//│  α87' <: [[[bool]]] with lb([[[bool]]] <: α87') length: 4
//│ UT α87' <: [[[bool]]] len: 5 
//│ | UT  bool with
//│ | UT  [[[bool]]] <: α87' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 9 
//│ | | U [[[bool]]] = [[[bool]]] because lb([[[bool]]] <: [[[bool]]]) skipCache
//│ | UT  bool with
//│ | UT  α87' += ([[[bool]]],List(ub(α87' <: [[[bool]]])))
//│  α87' :> [[[bool]]] with ub(α87' <: [[[bool]]]) length: 4
//│ UT α87' <: [[[bool]]] len: 5 
//│ α86' bounds
//│ α85' bounds
//│  α85' <: [[[[int]]]] with lb([[[[int]]]] <: α85') length: 5
//│ UT α85' <: [[[[int]]]] len: 6 
//│ | UT  int with
//│ | UT  [[[[int]]]] <: α85' <: int
//│ | UT [[[[int]]]] <: [[[[int]]]] len: 11 
//│ | UT  α85' += ([[[[int]]]],List(ub(α85' <: [[[[int]]]])))
//│  α85' :> [[[[int]]]] with ub(α85' <: [[[[int]]]]) length: 5
//│ UT α85' <: [[[[int]]]] len: 6 
//│ α84' bounds
//│  α84' <: [[int]] with lb([[int]] <: α84') length: 3
//│ UT α84' <: [[int]] len: 4 
//│ | UT  int with
//│ | UT  [[int]] <: α84' <: int
//│ | UT [[int]] <: [[int]] len: 7 
//│ | UT  int with
//│ | UT  α84' += ([[int]],List(ub(α84' <: [[int]])))
//│  α84' :> [[int]] with ub(α84' <: [[int]]) length: 3
//│ UT α84' <: [[int]] len: 4 
//│ α83' bounds
//│ α82' bounds
//│ α81' bounds
//│  α81' <: [[[[[bool]]]]] with lb([[[[[bool]]]]] <: α81') length: 6
//│ UT α81' <: [[[[[bool]]]]] len: 7 
//│ | UT  bool with
//│ | UT  [[[[[bool]]]]] <: α81' <: bool
//│ | UT [[[[[bool]]]]] <: [[[[[bool]]]]] len: 13 
//│ | UT  α81' += ([[[[[bool]]]]],List(ub(α81' <: [[[[[bool]]]]])))
//│  α81' :> [[[[[bool]]]]] with ub(α81' <: [[[[[bool]]]]]) length: 6
//│ UT α81' <: [[[[[bool]]]]] len: 7 
//│ α80' bounds
//│ ╔══[WARNING] ?a is unified with ?b * ?c because ub(α91' <: [[[([α81'], α85',)]]]))
//│ ║  
//│ ╟── application
//│ ║  l.51: 	let conflict x = mkpair (not x) x
//│ ║        	                 ^^^^^^^^^^^^^^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── tuple literal
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                 ^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	                 ^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with ?b -> ?c * ?d because ub(α89' <: [[[(α82' -> ([α81'], α85',))]]]))
//│ ║  
//│ ╟── application
//│ ║  l.51: 	let conflict x = mkpair (not x) x
//│ ║        	                 ^^^^^^^^^^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── function
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ╙──     	             ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because ub(α87' <: [[[bool]]]))
//│ ║  
//│ ╟── application
//│ ║  l.51: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	                 ^^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α85' <: [[[[int]]]]))
//│ ║  
//│ ╟── application
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	                     ^^^^^^^^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with int because ub(α84' <: [[int]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── `else` branch
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ ╔══[WARNING] ?a is unified with bool because ub(α81' <: [[[[[bool]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let mkpair x y = (x, confluence y)
//│ ║       	           ^
//│ ╟── <nested> function lhs len: 3
//│ ╟── application
//│ ║  l.51: 	let conflict x = mkpair (not x) x
//│ ║        	                        ^^^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	                 ^^^^
//│ conflict: (bool & 'a) -> (bool, int | 'a,)

:d
:unifyDbg
let g x = (not x, (if true then x else 5))
//│ 1. Typing term x => not x, if true(true) then x then (false) then 5,
//│ | 1. Typing pattern x
//│ | 1. : α101'
//│ | 1. Typing term not x, if true(true) then x then (false) then 5,
//│ | | 1. Typing term not x
//│ | | | 1. Typing term not
//│ | | | 1. : [(bool -> bool)]
//│ | | | 1. Typing term x
//│ | | | 1. : [α101']
//│ | | | CONSTRAIN [(bool -> bool)] <! ([α101'] -> α103')
//│ | | |   where 
//│ | | | C [(bool -> bool)] <! ([α101'] -> α103')    (0) where ProvType <: FunctionType}
//│ | | | | C (bool -> bool) <! ([α101'] -> α103')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[α101']]
//│ | | | | | C [α101'] <! bool    (1) where ProvType <: TypeRef}
//│ | | | | | | C α101' <! bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | [nested] [bool]
//│ | | | | | C bool <! α103'    (2) where TypeRef <: TypeVariable}
//│ | | 1. : α103'
//│ | | 1. Typing term if true(true) then x then (false) then 5
//│ | | | If(Var(true), List(IfThen(Var(true), Var(x), IfThen(Var(false), IntLit(5)))
//│ | | | 1. Typing term true
//│ | | | 1. : [bool]
//│ | | | CONSTRAIN [bool] <! bool
//│ | | |   where 
//│ | | | C [bool] <! bool    (0) where ProvType <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α101']
//│ | | | CONSTRAIN [α101'] <! α104'
//│ | | |   where 
//│ 		α101' <: [[[[bool]]]]
//│ | | | C [α101'] <! α104'    (0) where ProvType <: TypeVariable}
//│ | | | | C α101' <! α104'    (0) where TypeVariable <: TypeVariable}
//│ | | | 1. Typing term 5
//│ | | | 1. : int
//│ | | | CONSTRAIN int <! α104'
//│ | | |   where 
//│ | | | C int <! α104'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α104'
//│ | 1. : (α103', α104',)
//│ 1. : (α101' -> (α103', α104',))
//│ ⬤ Typed as: (α101' -> (α103', α104',))
//│  where: 
//│ 		α101' <: [[[α104']]] & [[[[bool]]]]
//│ 		α103' :> [[[bool]]]
//│ 		α104' :> [[int]]
//│ unified α104' with:
//│ unified α103' with:
//│ unified α102' with:
//│ unified α101' with:
//│ α104' bounds
//│  α104' <: [[int]] with lb([[int]] <: α104') length: 3
//│ UT α104' <: [[int]] len: 4 
//│ | UT  int with
//│ | UT  [[int]] <: α104' <: int
//│ | UT [[int]] <: [[int]] len: 7 
//│ | UT  α104' += ([[int]],List(ub(α104' <: [[int]])))
//│  α104' :> [[int]] with ub(α104' <: [[int]]) length: 3
//│ UT α104' <: [[int]] len: 4 
//│ α103' bounds
//│  α103' <: [[[bool]]] with lb([[[bool]]] <: α103') length: 4
//│ UT α103' <: [[[bool]]] len: 5 
//│ | UT  bool with
//│ | UT  [[[bool]]] <: α103' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 9 
//│ | UT  α103' += ([[[bool]]],List(ub(α103' <: [[[bool]]])))
//│  α103' :> [[[bool]]] with ub(α103' <: [[[bool]]]) length: 4
//│ UT α103' <: [[[bool]]] len: 5 
//│ α102' bounds
//│ α101' bounds
//│ ╔══[WARNING] ?a is unified with int because ub(α104' <: [[int]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.286: 	let g x = (not x, (if true then x else 5))
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.286: 	let g x = (not x, (if true then x else 5))
//│ ║         	                                       ^
//│ ╟── `else` branch
//│ ║  l.286: 	let g x = (not x, (if true then x else 5))
//│ ╙──       	                                       ^
//│ ╔══[WARNING] ?a is unified with bool because ub(α103' <: [[[bool]]]))
//│ ║  
//│ ╟── application
//│ ║  l.286: 	let g x = (not x, (if true then x else 5))
//│ ║         	           ^^^^^
//│ ╟── <nested> function rhs len: 3
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ║              	                 ^^^^
//│ ╟── type reference
//│ ║  builtin:56: 	let not: bool -> bool
//│ ╙──            	                 ^^^^
//│ g: (bool & 'a) -> (bool, int | 'a,)

:d
let g x = (not x, (if true then x else 5))
//│ 1. Typing term x => not x, if true(true) then x then (false) then 5,
//│ | 1. Typing pattern x
//│ | 1. : α110'
//│ | 1. Typing term not x, if true(true) then x then (false) then 5,
//│ | | 1. Typing term not x
//│ | | | 1. Typing term not
//│ | | | 1. : [(bool -> bool)]
//│ | | | 1. Typing term x
//│ | | | 1. : [α110']
//│ | | | CONSTRAIN [(bool -> bool)] <! ([α110'] -> α112')
//│ | | |   where 
//│ | | | C [(bool -> bool)] <! ([α110'] -> α112')    (0) where ProvType <: FunctionType}
//│ | | | | C (bool -> bool) <! ([α110'] -> α112')    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[α110']]
//│ | | | | | C [α110'] <! bool    (1) where ProvType <: TypeRef}
//│ | | | | | | C α110' <! bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | [nested] [bool]
//│ | | | | | C bool <! α112'    (2) where TypeRef <: TypeVariable}
//│ | | 1. : α112'
//│ | | 1. Typing term if true(true) then x then (false) then 5
//│ | | | If(Var(true), List(IfThen(Var(true), Var(x), IfThen(Var(false), IntLit(5)))
//│ | | | 1. Typing term true
//│ | | | 1. : [bool]
//│ | | | CONSTRAIN [bool] <! bool
//│ | | |   where 
//│ | | | C [bool] <! bool    (0) where ProvType <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α110']
//│ | | | CONSTRAIN [α110'] <! α113'
//│ | | |   where 
//│ 		α110' <: [[[[bool]]]]
//│ | | | C [α110'] <! α113'    (0) where ProvType <: TypeVariable}
//│ | | | | C α110' <! α113'    (0) where TypeVariable <: TypeVariable}
//│ | | | 1. Typing term 5
//│ | | | 1. : int
//│ | | | CONSTRAIN int <! α113'
//│ | | |   where 
//│ | | | C int <! α113'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α113'
//│ | 1. : (α112', α113',)
//│ 1. : (α110' -> (α112', α113',))
//│ ⬤ Typed as: (α110' -> (α112', α113',))
//│  where: 
//│ 		α110' <: [[[α113']]] & [[[[bool]]]]
//│ 		α112' :> [[[bool]]]
//│ 		α113' :> [[int]]
//│ g: (bool & 'a) -> (bool, int | 'a,)
