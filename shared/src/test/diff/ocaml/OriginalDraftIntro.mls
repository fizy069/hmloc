val parse_version: string -> string
val show_major: string -> string
//│ parse_version: string -> string
//│ show_major: string -> string

let appInfo = ("My Application", 1.5)
//│ appInfo: (string, float,)

let process (name, vers) =
  name ^ show_major (parse_version vers)
//│ process: (string, string,) -> string

let test = process appInfo
//│ test: string

// * GOAL for concise error:

// ╔══[ERROR] Type `float` does not match `string`
// ╟── this float literal has type `float` but it flows into `string`
// ║  l.20: 	let appInfo = ("My Application", 1.5)
// ║        	                                 ^^^
// ╟── this variable has type `string`
// ║  l.48: 	let process (name, vers) =
// ║        	                   ^^^^
// ╟── this reference has type `string`
// ║  l.49: 	  name ^ show_major (parse_version vers)
// ║        	                                   ^^^^
// ╟── `string` comes from this type expression
// ║  l.15: 	val parse_version: string -> string
// ╙──      	                   ^^^^^^
// test: string


// 1
let x = 2;
let y x = if x then true else false
y x
//│ x: int
//│ y: bool -> bool
//│ res: bool

// 2a
let x = 2
let y = if true then x else "x"
//│ [ERROR] Type `string` does not match `int`
//│ 
//│         (string) ---> (?a) <--- (int)
//│ 
//│ ◉ (string) is here
//│ │  - l.2  let y = if true then x else "x"
//│ │                                     ^^^
//│ │  - l.2  let y = if true then x else "x"
//│ │                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.2  let y = if true then x else "x"
//│ │                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2  let y = if true then x else "x"
//│ │                              ^
//│ │ 
//│ ◉ (int) is here
//│    - l.1  let x = 2
//│                   ^
//│ x: int
//│ y: int | string
//│ U max: 3, total: 4
//│ UERR 1 errors
//│ L: 0 [string ~ int, string <: α86', α86' :> int]

// 2b
let f x = (not x , x + 1)
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) <--- (?a) ---> (int)
//│ 
//│ ◉ (bool) is here
//│ ▲  - lib. let not: bool -> bool
//│ │                  ^^^^
//│ │  - l.1  let f x = (not x , x + 1)
//│ │                        ^
//│ │  - l.1  let f x = (not x , x + 1)
//│ │               ^
//│ │ 
//│ ◉ (?a) is assumed here
//│ │  - l.1  let f x = (not x , x + 1)
//│ │               ^
//│ │  - l.1  let f x = (not x , x + 1)
//│ │                            ^
//│ ▼ 
//│ ◉ (int) is here
//│    - lib. let (+): int -> int -> int
//│                    ^^^
//│ f: nothing -> (bool, int,)
//│ U max: 3, total: 4
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool :> α88', α88' <: int]

// 3
let g x = ( not x
          , if true then x else 5)
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) <--- (?a) ---> (?b) <--- (int)
//│ 
//│ ◉ (bool) is here
//│ ▲  - lib. let not: bool -> bool
//│ │                  ^^^^
//│ │  - l.1  let g x = ( not x
//│ │                         ^
//│ │  - l.1  let g x = ( not x
//│ │               ^
//│ │ 
//│ ◉ (?a) is assumed here
//│ │  - l.1  let g x = ( not x
//│ │               ^
//│ │  - l.2            , if true then x else 5)
//│ │                                  ^
//│ │  - l.2            , if true then x else 5)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ ▲  - l.2            , if true then x else 5)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) is here
//│    - l.2            , if true then x else 5)
//│                                           ^
//│ g: (bool & 'a) -> (bool, int | 'a,)
//│ U max: 4, total: 6
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool :> α93', α93' <: α95', α95' :> int]
