val parse_version: string -> string
val show_major: string -> string
//│ parse_version: string -> string
//│ show_major: string -> string

let appInfo = ("My Application", 1.5)
//│ appInfo: (string, float,)

let process (name, vers) =
  name ^ show_major (parse_version vers)
//│ process: (string, string,) -> string

let test = process appInfo
//│ [ERROR] Type `float` does not match `string`
//│ 
//│         (float) ---> (?a) ---> (string)
//│ 
//│ ◉ (float) is here
//│ │  - l.-6 let appInfo = ("My Application", 1.5)
//│ │                                          ^^^
//│ │  - l.-3 let process (name, vers) =
//│ │                            ^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-3 let process (name, vers) =
//│ │                            ^^^^
//│ │  - l.-2   name ^ show_major (parse_version vers)
//│ │                                            ^^^^
//│ ▼ 
//│ ◉ (string) is here
//│    - l.-11val parse_version: string -> string
//│                              ^^^^^^
//│ test: string
//│ U max: 4, total: 6
//│ UERR 1 errors
//│ L: 0 [float ~ string, float <: α76', α76' <: string]

// * GOAL for concise error:

// ╔══[ERROR] Type `float` does not match `string`
// ╟── this float literal has type `float` but it flows into `string`
// ║  l.20: 	let appInfo = ("My Application", 1.5)
// ║        	                                 ^^^
// ╟── this variable has type `string`
// ║  l.48: 	let process (name, vers) =
// ║        	                   ^^^^
// ╟── this reference has type `string`
// ║  l.49: 	  name ^ show_major (parse_version vers)
// ║        	                                   ^^^^
// ╟── `string` comes from this type expression
// ║  l.15: 	val parse_version: string -> string
// ╙──      	                   ^^^^^^
// test: string


// 1
let x = 2;
let y x = if x then true else false
y x
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) ---> (?a) ---> (bool)
//│ 
//│ ◉ (int) is here
//│ │  - l.1  let x = 2;
//│ │                 ^
//│ │  - l.3  y x
//│ │           ^
//│ │  - l.2  let y x = if x then true else false
//│ │               ^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.2  let y x = if x then true else false
//│ │               ^
//│ ▼ 
//│ ◉ (bool) is here
//│    - l.2  let y x = if x then true else false
//│                        ^
//│ x: int
//│ y: bool -> bool
//│ res: bool
//│ U max: 6, total: 8
//│ UERR 1 errors
//│ L: 0 [int ~ bool, int <: α82, α82 <: bool]

// 2a
let x = 2
let y = if true then x else "x"
//│ [ERROR] Type `int` does not match `string`
//│ 
//│         (int) ---> (?a) <--- (string)
//│ 
//│ ◉ (int) is here
//│ │  - l.1  let x = 2
//│ │                 ^
//│ │  - l.2  let y = if true then x else "x"
//│ │                              ^
//│ │  - l.2  let y = if true then x else "x"
//│ │                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.2  let y = if true then x else "x"
//│ │                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (string) is here
//│    - l.2  let y = if true then x else "x"
//│                                       ^^^
//│ x: int
//│ y: int | string
//│ U max: 3, total: 5
//│ UERR 1 errors
//│ L: 0 [int ~ string, int <: α86', α86' :> string]

// 2b
let f x = (not x , x + 1)
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) <--- (?a) ---> (bool)
//│ 
//│ ◉ (int) is here
//│ ▲  - lib. let (+): int -> int -> int
//│ │                  ^^^
//│ │  - l.1  let f x = (not x , x + 1)
//│ │                            ^
//│ │  - l.1  let f x = (not x , x + 1)
//│ │               ^
//│ │ 
//│ ◉ (?a) is assumed here
//│ │  - l.1  let f x = (not x , x + 1)
//│ │               ^
//│ │  - l.1  let f x = (not x , x + 1)
//│ │                        ^
//│ ▼ 
//│ ◉ (bool) is here
//│    - lib. let not: bool -> bool
//│                    ^^^^
//│ f: nothing -> (bool, int,)
//│ U max: 3, total: 5
//│ UERR 1 errors
//│ L: 0 [int ~ bool, int :> α88', α88' <: bool]

// 3
let g x = ( not x
          , if true then x else 5)
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) <--- (?a) ---> (?b) <--- (int)
//│ 
//│ ◉ (bool) is here
//│ ▲  - lib. let not: bool -> bool
//│ │                  ^^^^
//│ │  - l.1  let g x = ( not x
//│ │                         ^
//│ │  - l.1  let g x = ( not x
//│ │               ^
//│ │ 
//│ ◉ (?a) is assumed here
//│ │  - l.1  let g x = ( not x
//│ │               ^
//│ │  - l.2            , if true then x else 5)
//│ │                                  ^
//│ │  - l.2            , if true then x else 5)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ ▲  - l.2            , if true then x else 5)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) is here
//│    - l.2            , if true then x else 5)
//│                                           ^
//│ g: (bool & 'a) -> (bool, int | 'a,)
//│ U max: 5, total: 9
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool :> α93', α93' <: α95', α95' :> int]
