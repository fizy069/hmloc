////////// file 1935

////////// ocamlc error
//
// File "1935.ml", line 22, characters 18-44:
// 22 |     let (_,res) = List.fold_left f base args in res in
//                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
// Error: This expression has type int but an expression was expected of type
//          'a * 'b

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let addTuple (l1,l2) = l1 + l2;;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ clone: 'a -> int -> list['a]
//│ addTuple: (int, int,) -> int
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: list['a] -> list['a]


let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a + x) mod 10 in
    let base = 0 in
    let args = List.map addTuple (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ (int) is here
//│ │  - lib. let mod: int -> int -> int
//│ │                                ^^^
//│ │  - l.3      let f a x = (a + x) mod 10 in
//│ │                         ^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.6      let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.6      let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ bigAdd: list[int] -> list[int] -> list[nothing]
//│ U max: 136, total: 563
//│ UERR 1 errors
//│ L: 0 [int ~ [[[([α239'], [α240'],)]]], [[[int]]] <: α233', α233' <: [[[([α239'], [α240'],)]]]]

////////// file 0003

////////// ocamlc error
//
// File "0003.ml", line 23, characters 31-32:
// 23 |         (let (toSum1,toSum2) = x in
//                                     ^
// Error: This expression has type 'a list
//        but an expression was expected of type 'b * 'c

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let numZeros = (List.length l1) - (List.length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ clone: 'a -> int -> list['a]
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: (list[int] & 'a & 'b) -> 'a
//│   where
//│     'a := 'b
//│     'b := 'a

:unify
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (carry,currentSum) = a in
      if x = []
      then (0, (carry :: currentSum))
      else
        (let (toSum1,toSum2) = x in
         let intermediateValue = (toSum1 + toSum2) + carry in
         let valueToAddToArray = intermediateValue mod 10 in
         let carry = intermediateValue / 10 in
         (carry, (valueToAddToArray :: currentSum))) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) <--- (_ * _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.5        if x = []
//│ │                      ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.5        if x = []
//│ │                  ^
//│ │  - l.3      let f a x =
//│ │                     ^
//│ │ 
//│ ◉ (_ * _) is here
//│    - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                                    ^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) <--- (?b) ---> (_ * _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.5        if x = []
//│ │                      ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.5        if x = []
//│ │                  ^
//│ │  - l.3      let f a x =
//│ │                     ^
//│ │ 
//│ ◉ (?b) is assumed here
//│ │  - l.3      let f a x =
//│ │                     ^
//│ │  - l.8          (let (toSum1,toSum2) = x in
//│ │                                        ^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.8          (let (toSum1,toSum2) = x in
//│                        ^^^^^^^^^^^^^^^
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ U max: 198, total: 561
//│ UERR 2 errors
//│ L: 0 [[[list['a412']]] ~ ([α418'], [α419'],), [[list['a412']]] <: α410', [[[α410']]] :> α438', α438' <: [[[[[([α418'], [α419'],)]]]]]]
//│ L: 0 [list['a412'] ~ [[[[[[(α432', α433',)]]]]]], [[list['a412']]] <: α410', α410' :> [[[[[[(α432', α433',)]]]]]]]

////////// file 1948

////////// ocamlc error
//
// File "1948.ml", line 43, characters 46-70:
// 43 |     match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//                                                    ^^^^^^^^^^^^^^^^^^^^^^^^
// Error: This expression has type 'a * 'b
//        but an expression was expected of type int list

let rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (x1,x2) = x in
      let (carry,res) = a in
      ((((x1 + x2) + carry) / 10), ((mod ((x1 + x2) + carry) 10) :: res)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (carry,res) = List.fold_left f base args in [carry] @ res in
  removeZero (add (padZero l1 l2));;
let rec mulByDigit i l =
  let f a x =
    let carry = i * x in
    match a with
    | h::t -> ((h + carry) / 10) :: (mod (h + carry) 10) :: t
    | _ -> [carry / 10; mod carry 10] in
  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ helper: int -> int
//│ clone: 'a -> int -> list['a]
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: list['a] -> list['a]
//│ tenEx: int -> list[int] -> list[int]
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ mulByDigit: int -> list[int] -> list[int]

// FIXME: no common provs
:unify
let bigMul l1 l2 =
  let f a x =
    let (x1,x2) = x in
    let (carry,res) = a in
    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
  let base = (0, []) in
  let args = l1 (tenEx 0 l2) in
  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) <--- (?a) ---> (_ -> _)
//│ 
//│ ◉ (_ list) is here
//│ ▲  - lib. let List.rev: 'a list -> 'a list
//│ │                       ^^^^^^^
//│ │  - l.-10  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ │                                                                        ^
//│ │ 
//│ ◉ (?a) is assumed here
//│    - l.-16let rec mulByDigit i l =
//│                                ^
//│   ◉ (_ -> _) is here
//│   │  - l.-16let rec mulByDigit i l =
//│   │                              ^^^
//│   │           let f a x = ...
//│   │           ^^^^^^^^^^^^^^^
//│   │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│   │                                                         ^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed here
//│   │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│   │                                                         ^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (_ -> _) is here
//│      - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                             ^^^^^^^^^^^^
//│ ◉ (?c) is assumed here
//│ │  - l.1  let bigMul l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (_ -> _) is here
//│    - l.7    let args = l1 (tenEx 0 l2) in
//│                        ^^
//│ [ERROR] Type `_ -> _` does not match `_ * _`
//│ 
//│         (_ -> _) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ (_ -> _) is here
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                       ^^^^
//│ │           let add (l1,l2) = ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                 ^^^^^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) ---> (?a) <--- (_ list)
//│ 
//│ ◉ (_ -> _) is here
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                       ^^^^
//│ │           let add (l1,l2) = ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list) is here
//│    - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                     ^^
//│ [ERROR] Type `_ list` does not match `int * _ list`
//│ 
//│         (_ list) ---> (?a) <--- (int * _ list)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                                              ^^^^
//│ │ 
//│ ◉ (int * _ list) is here
//│    - l.6    let base = (0, []) in
//│                        ^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) <--- (?a) ---> (_ list)
//│ 
//│ ◉ (_ -> _) is here
//│ ▲  - l.7    let args = l1 (tenEx 0 l2) in
//│ │                      ^^
//│ │  - l.1  let bigMul l1 l2 =
//│ │                    ^^
//│ │ 
//│ ◉ (?a) is assumed here
//│ │  - l.1  let bigMul l1 l2 =
//│ │                    ^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                                      ^^
//│ │  - l.-16let rec mulByDigit i l =
//│ │                              ^
//│ │  - l.-10  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ │                                                                        ^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.rev: 'a list -> 'a list
//│                         ^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.2    let f a x =
//│ │                 ^
//│ │  - l.4      let (carry,res) = a in
//│ │                               ^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.4      let (carry,res) = a in
//│                   ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) <--- (?a) ---> (_ -> _)
//│ 
//│ ◉ (_ list) is here
//│ ▲  - lib. let List.rev: 'a list -> 'a list
//│ │                       ^^^^^^^
//│ │  - l.-10  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ │                                                                        ^
//│ │ 
//│ ◉ (?a) is assumed here
//│    - l.-16let rec mulByDigit i l =
//│                                ^
//│     ◉ (_ -> _ -> _) is here
//│     │  - l.-16let rec mulByDigit i l =
//│     │                            ^^^^^
//│     │           let f a x = ...
//│     │           ^^^^^^^^^^^^^^^
//│     │  - l.-16let rec mulByDigit i l =
//│     │                 ^^^^^^^^^^
//│     ▼ 
//│     ◉ (?mulByDigit) is assumed here
//│     │  - l.-16let rec mulByDigit i l =
//│     │                 ^^^^^^^^^^
//│     ▼ 
//│     ◉ (_ -> _) is here
//│        - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                               ^^^^^^^^^^
//│   ◉ (?b) is assumed here
//│   │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│   │                                                         ^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (_ -> _) is here
//│      - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                             ^^^^^^^^^^^^
//│ ◉ (?c) is assumed here
//│ │  - l.1  let bigMul l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (_ -> _) is here
//│    - l.7    let args = l1 (tenEx 0 l2) in
//│                        ^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-35  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ │                                             ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                 ^^^^^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ * _`
//│ 
//│         (_ -> _) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ (_ -> _) is here
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                       ^^^^
//│ │           let add (l1,l2) = ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.2    let f a x =
//│ │                 ^
//│ │  - l.4      let (carry,res) = a in
//│ │                               ^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.4      let (carry,res) = a in
//│                   ^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-32    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ │                                                                      ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                               ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-31    else (l1, l2);;
//│ │                   ^^
//│ │  - l.-25  let add (l1,l2) =
//│ │                    ^^
//│ │  - l.-19    let args = List.rev (List.combine l1 l2) in
//│ │                                               ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                             ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-32    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ │                                                              ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-36  if (List.length l1) > (List.length l2)
//│ │                           ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) is here
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-33    if (List.length l1) < (List.length l2)
//│ │                             ^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `int * _ list`
//│ 
//│         (_ -> _) ---> (?a) <--- (int * _ list)
//│ 
//│ ◉ (_ -> _) is here
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                       ^^^^
//│ │           let add (l1,l2) = ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                                              ^^^^
//│ │ 
//│ ◉ (int * _ list) is here
//│    - l.6    let base = (0, []) in
//│                        ^^^^^^^
//│ bigMul: nothing -> list[int] -> list[int]
//│ U max: 306, total: 765
//│ UERR 16 errors
//│ L: 0 [(α952', [[α884']],) ~ [[[[[[list[α889']]]]]]], [[[[(α952', [[α884']],)]]]] <: α896', α896' <: [[[[[[list[α889']]]]]]]]
//│ L: 0 [(α901' -> α914') ~ [[[[[[list['a887']]]]]]], [[[[[[(α901' -> α914')]]]]]] <: α974', α974' :> [[[[[[list['a887']]]]]]]]
//│ L: 0 [list['a887'] ~ [[[([α980'], [α981'],)]]], [[[[[[list['a887']]]]]]] <: α974', α974' <: [[[([α980'], [α981'],)]]]]
//│ L: 0 [(α952', [[α884']],) ~ [[[list[α897']]]], [[[[(α952', [[α884']],)]]]] <: α896', α896' <: [[[list[α897']]]]]
//│ L: 0 [list['a887'] ~ [[[[[([α883'], [α884'],)]]]]], [[[[[[list['a887']]]]]]] <: α974', α974' <: [[[[[([α883'], [α884'],)]]]]]]
//│ L: 0 [(α901' -> α914') ~ [[(int, [list['a954']],)]], [[[[[[(α901' -> α914')]]]]]] <: α974', α974' :> [[(int, [list['a954']],)]]]
//│ L: 2 [list[α931'] ~ [[[(α971' -> α973')]]], [[[list[α931']]]] :> α930', [α930' - (α930' -> α934') ~ ([α875'] -> α952') - [α875'], [(α930' -> α934') - (α929' -> (α930' -> α934')) ~ (['a886'] -> α950') - α950', [[(α929' -> (α930' -> α934'))]] <: mulByDigit928', mulByDigit928' <: [[[(['a886'] -> α950')]]]], α950' <: [[([α875'] -> α952')]]], α875' <: [[[(α971' -> α973')]]]]
//│ L: 0 [(α952', [[α884']],) ~ [[[list[α899']]]], [[[[(α952', [[α884']],)]]]] <: α896', α896' <: [[[list[α899']]]]]
//│ L: 1 [list[α931'] ~ [[[(α971' -> α973')]]], [[[list[α931']]]] :> α930', [α930' - (α930' -> α934') ~ ([α875'] -> α952') - [α875'], [[[(α930' -> α934')]]] <: α950', α950' <: [[([α875'] -> α952')]]], α875' <: [[[(α971' -> α973')]]]]
//│ L: 0 [(α952', [[α884']],) ~ [[[list[α890']]]], [[[[(α952', [[α884']],)]]]] <: α896', α896' <: [[[list[α890']]]]]
//│ L: 0 [list['a887'] ~ [[(int, [list['a954']],)]], [[[[[[list['a887']]]]]]] <: α974', α974' :> [[(int, [list['a954']],)]]]
//│ L: 0 [(α952', [[α884']],) ~ [[[list[α898']]]], [[[[(α952', [[α884']],)]]]] <: α896', α896' <: [[[list[α898']]]]]
//│ L: 0 [[[[(α971' -> α973')]]] ~ list[α931'], [[[(α971' -> α973')]]] :> α875', α875' <: [[[[[[list[α931']]]]]]]]
//│ L: 0 [(α901' -> α914') ~ [[[([α980'], [α981'],)]]], [[[[[[(α901' -> α914')]]]]]] <: α974', α974' <: [[[([α980'], [α981'],)]]]]
//│ L: 0 [(α952', [[α884']],) ~ [[[list[α900']]]], [[[[(α952', [[α884']],)]]]] <: α896', α896' <: [[[list[α900']]]]]
//│ L: 0 [(α901' -> α914') ~ [[[[[([α883'], [α884'],)]]]]], [[[[[[(α901' -> α914')]]]]]] <: α974', α974' <: [[[[[([α883'], [α884'],)]]]]]]

////////// file 2361

////////// ocamlc error
// 
// File "2361.ml", line 12, characters 46-51:
// 12 |   | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//                                                    ^^^^^
// Error: This expression has type bool but an expression was expected of type
//          int

let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
let digits n = digitsOfInt (abs n);;
//│ digitsOfInt: int -> list[int]
//│ addNumbs: list[int] -> int
//│ digits: int -> list[int]

:unify
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) ---> (?a) <--- (bool)
//│ 
//│ ◉ (int) is here
//│ │  - l.3    | [] -> 0
//│ │                   ^
//│ │  - l.2    match digits n with
//│ │           ^^^^^^^^^^^^^^^^^^^
//│ │           | [] -> 0 ...
//│ │           ^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.2    match digits n with
//│ │           ^^^^^^^^^^^^^^^^^^^
//│ │           | [] -> 0 ...
//│ │           ^^^^^^^^^^^^^
//│ │  - l.4    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (bool) is here
//│    - l.4    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│                                                                    ^^^^
//│ additivePersistence: int -> (bool | int)
//│ U max: 58, total: 157
//│ UERR 1 errors
//│ L: 0 [int ~ [[[[bool]]]], [[int]] <: α1085', α1085' :> [[[[bool]]]]]
