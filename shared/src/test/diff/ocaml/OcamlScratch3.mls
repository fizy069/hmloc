:unifyDbg
// nested prov not shown in collision error
let a = 1
let b = a
let f x = if x then true else false
let g = f
g b
//│ unified α70 with:
//│ unified α69 with:
//│ unified α68 with:
//│ unified α67 with:
//│ unified α64' with:
//│ unified α63' with:
//│ unified α60' with:
//│ unified α59' with:
//│ α70 bounds
//│  α70 <: [[[[[Bool]]]]] with lb([[[[[Bool]]]]] <: α70) length: 6
//│ UT α70 <: [[[[[Bool]]]]] len: 7 
//│ | UT  Bool with
//│ | UT  [[[[[Bool]]]]] <: α70 <: Bool
//│ | UT [[[[[Bool]]]]] <: [[[[[Bool]]]]] len: 13 
//│ | | U [[[[[Bool]]]]] = [[[[[Bool]]]]] because lb([[[[[Bool]]]]] <: [[[[[Bool]]]]]) skipCache
//│ | UT  α70 += ([[[[[Bool]]]]],List(ub(α70 <: [[[[[Bool]]]]])))
//│  α70 :> [[[[[Bool]]]]] with ub(α70 <: [[[[[Bool]]]]]) length: 6
//│ UT α70 <: [[[[[Bool]]]]] len: 7 
//│ α69 bounds
//│ α68 bounds
//│  α68 <: [[[Bool]]] with lb([[[Bool]]] <: α68) length: 4
//│ UT α68 <: [[[Bool]]] len: 5 
//│ | UT  Bool with
//│ | UT  [[[Bool]]] <: α68 <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  [[[Bool]]] <: α68 <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  Bool with
//│ | UT  α68 += ([[[Bool]]],List(ub(α68 <: [[[Bool]]])))
//│  α68 <: [[[Bool]]] with lb([[[Bool]]] <: α68) length: 4
//│ UT α68 <: [[[Bool]]] len: 5 
//│  α68 :> [[[Bool]]] with ub(α68 <: [[[Bool]]]) length: 4
//│ UT α68 <: [[[Bool]]] len: 5 
//│  α68 :> [[[Bool]]] with ub(α68 <: [[[Bool]]]) length: 4
//│ UT α68 <: [[[Bool]]] len: 5 
//│ α67 bounds
//│  α67 <: [[[[[Int]]]]] with lb([[[[[Int]]]]] <: α67) length: 6
//│ UT α67 <: [[[[[Int]]]]] len: 7 
//│ | UT  Int with
//│ | UT  [[[[[Int]]]]] <: α67 <: Int
//│ | UT [[[[[Int]]]]] <: [[[[[Int]]]]] len: 13 
//│ | | U [[[[[Int]]]]] = [[[[[Int]]]]] because lb([[[[[Int]]]]] <: [[[[[Int]]]]]) skipCache
//│ | UT  Int with
//│ | UT  α67 += ([[[[[Int]]]]],List(ub(α67 <: [[[[[Int]]]]])))
//│  α67 :> [[[[[Int]]]]] with ub(α67 <: [[[[[Int]]]]]) length: 6
//│ UT α67 <: [[[[[Int]]]]] len: 7 
//│ α64' bounds
//│  α64' <: [[[Bool]]] with lb([[[Bool]]] <: α64') length: 4
//│ UT α64' <: [[[Bool]]] len: 5 
//│ | UT  Bool with
//│ | UT  [[[Bool]]] <: α64' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  [[[Bool]]] <: α64' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  α64' += ([[[Bool]]],List(ub(α64' <: [[[Bool]]])))
//│  α64' <: [[[Bool]]] with lb([[[Bool]]] <: α64') length: 4
//│ UT α64' <: [[[Bool]]] len: 5 
//│  α64' :> [[[Bool]]] with ub(α64' <: [[[Bool]]]) length: 4
//│ UT α64' <: [[[Bool]]] len: 5 
//│  α64' :> [[[Bool]]] with ub(α64' <: [[[Bool]]]) length: 4
//│ UT α64' <: [[[Bool]]] len: 5 
//│ α63' bounds
//│ α60' bounds
//│  α60' <: [[[Bool]]] with lb([[[Bool]]] <: α60') length: 4
//│ UT α60' <: [[[Bool]]] len: 5 
//│ | UT  Bool with
//│ | UT  [[[Bool]]] <: α60' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  [[[Bool]]] <: α60' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  α60' += ([[[Bool]]],List(ub(α60' <: [[[Bool]]])))
//│  α60' <: [[[Bool]]] with lb([[[Bool]]] <: α60') length: 4
//│ UT α60' <: [[[Bool]]] len: 5 
//│  α60' :> [[[Bool]]] with ub(α60' <: [[[Bool]]]) length: 4
//│ UT α60' <: [[[Bool]]] len: 5 
//│  α60' :> [[[Bool]]] with ub(α60' <: [[[Bool]]]) length: 4
//│ UT α60' <: [[[Bool]]] len: 5 
//│ α59' bounds
//│ ╔══[WARNING] ?a is unified with bool because ub(α70 <: [[[[[Bool]]]]]))
//│ ║  
//│ ╟── application
//│ ║  l.7: 	g b
//│ ║       	^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                              ^^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with bool because ub(α68 <: [[[Bool]]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `then` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with int because ub(α67 <: [[[[[Int]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	      ^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.7: 	g b
//│ ║       	  ^
//│ ╟── reference
//│ ║  l.4: 	let b = a
//│ ║       	        ^
//│ ╟── integer literal
//│ ║  l.3: 	let a = 1
//│ ║       	        ^
//│ ╟── integer literal
//│ ║  l.3: 	let a = 1
//│ ╙──     	        ^
//│ ╔══[WARNING] ?a is unified with bool because ub(α64' <: [[[Bool]]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `then` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with bool because ub(α60' <: [[[Bool]]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `then` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                    ^^^^
//│ ╟── type
//│ ╙── type
//│ a: int
//│ b: int
//│ f: bool -> bool
//│ g: bool -> bool
//│ res: bool

:d
:unifyDbg
let a = 1
let b = a
let f x y = if y then x else "x"
let g = f
g b true
//│ 1. Typing term 1
//│ 1. : Int
//│ ⬤ Typed as: Int
//│  where: 
//│ 1. Typing term a
//│ 1. : [Int]
//│ ⬤ Typed as: [Int]
//│  where: 
//│ 1. Typing term x => y => if y(true) then x then (false) then "x"
//│ | 1. Typing pattern x
//│ | 1. : α72'
//│ | 1. Typing term y => if y(true) then x then (false) then "x"
//│ | | 1. Typing pattern y
//│ | | 1. : α73'
//│ | | 1. Typing term if y(true) then x then (false) then "x"
//│ | | | If(Var(y), List(IfThen(Var(true), Var(x), IfThen(Var(false), StrLit(x)))
//│ | | | 1. Typing term y
//│ | | | 1. : [α73']
//│ | | | CONSTRAIN [α73'] <! Bool
//│ | | |   where 
//│ | | | C [α73'] <! Bool    (0) where ProvType <: TypeRef}
//│ | | | | C α73' <! Bool    (0) where TypeVariable <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α72']
//│ | | | CONSTRAIN [α72'] <! α74'
//│ | | |   where 
//│ | | | C [α72'] <! α74'    (0) where ProvType <: TypeVariable}
//│ | | | | C α72' <! α74'    (0) where TypeVariable <: TypeVariable}
//│ | | | 1. Typing term "x"
//│ | | | 1. : String
//│ | | | CONSTRAIN String <! α74'
//│ | | |   where 
//│ | | | C String <! α74'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α74'
//│ | 1. : (α73' -> α74')
//│ 1. : (α72' -> (α73' -> α74'))
//│ ⬤ Typed as: (α72' -> (α73' -> α74'))
//│  where: 
//│ 		α72' <: [[[α74']]]
//│ 		α73' <: [[[Bool]]]
//│ 		α74' :> [[String]]
//│ 1. Typing term f
//│ 1. : [(α80' -> (α82' -> α81'))]
//│ ⬤ Typed as: [(α80' -> (α82' -> α81'))]
//│  where: 
//│ 		α80' <: [[[α81']]]
//│ 		α81' :> [[String]]
//│ 		α82' <: [[[Bool]]]
//│ 0. Typing term g b true
//│ | 0. Typing term g b
//│ | | 0. Typing term g
//│ | | 0. : [[(α88 -> (α90 -> α89))]]
//│ | | 0. Typing term b
//│ | | 0. : [[Int]]
//│ | | CONSTRAIN [[(α88 -> (α90 -> α89))]] <! ([[Int]] -> α92)
//│ | |   where 
//│ 		α88 <: [[[α89]]]
//│ 		α89 :> [[String]]
//│ 		α90 <: [[[Bool]]]
//│ | | C [[(α88 -> (α90 -> α89))]] <! ([[Int]] -> α92)    (0) where ProvType <: FunctionType}
//│ | | | C [(α88 -> (α90 -> α89))] <! ([[Int]] -> α92)    (0) where ProvType <: FunctionType}
//│ | | | | C (α88 -> (α90 -> α89)) <! ([[Int]] -> α92)    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[[Int]]]
//│ | | | | | C [[Int]] <! α88    (1) where ProvType <: TypeVariable}
//│ | | | | | | C [Int] <! α88    (1) where ProvType <: TypeVariable}
//│ | | | | | | | C Int <! α88    (1) where TypeRef <: TypeVariable}
//│ | | | | | | | | C Int <! [[[α89]]]    (2) where TypeRef <: ProvType}
//│ | | | | | | | | | C Int <! [[α89]]    (2) where TypeRef <: ProvType}
//│ | | | | | | | | | | C Int <! [α89]    (2) where TypeRef <: ProvType}
//│ | | | | | | | | | | | C Int <! α89    (2) where TypeRef <: TypeVariable}
//│ | | | | | [nested] [(α90 -> α89)]
//│ | | | | | C (α90 -> α89) <! α92    (3) where FunctionType <: TypeVariable}
//│ | 0. : α92
//│ | 0. Typing term true
//│ | 0. : [Bool]
//│ | CONSTRAIN α92 <! ([Bool] -> α94)
//│ |   where 
//│ 		α89 :> [[[[[[[[Int]]]]]]]] | [[String]]
//│ 		α90 <: [[[Bool]]]
//│ 		α92 :> [[[(α90 -> α89)]]]
//│ | C α92 <! ([Bool] -> α94)    (0) where TypeVariable <: FunctionType}
//│ | | C [[[(α90 -> α89)]]] <! ([Bool] -> α94)    (1) where ProvType <: FunctionType}
//│ | | | C [[(α90 -> α89)]] <! ([Bool] -> α94)    (1) where ProvType <: FunctionType}
//│ | | | | C [(α90 -> α89)] <! ([Bool] -> α94)    (1) where ProvType <: FunctionType}
//│ | | | | | C (α90 -> α89) <! ([Bool] -> α94)    (1) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[Bool]]
//│ | | | | | | C [Bool] <! α90    (2) where ProvType <: TypeVariable}
//│ | | | | | | | C Bool <! α90    (2) where TypeRef <: TypeVariable}
//│ | | | | | | | | C Bool <! [[[Bool]]]    (3) where TypeRef <: ProvType}
//│ | | | | | | [nested] [α89]
//│ | | | | | | C α89 <! α94    (3) where TypeVariable <: TypeVariable}
//│ | | | | | | | C [[[[[[[[Int]]]]]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | C [[[[[[[Int]]]]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | C [[[[[[Int]]]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | C [[[[[Int]]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | C [[[[Int]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | C [[[Int]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | C [[Int]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | | C [Int] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | | | C Int <! α94    (4) where TypeRef <: TypeVariable}
//│ | | | | | | | C [[String]] <! α94    (5) where ProvType <: TypeVariable}
//│ | | | | | | | | C [String] <! α94    (5) where ProvType <: TypeVariable}
//│ | | | | | | | | | C String <! α94    (5) where TypeRef <: TypeVariable}
//│ 0. : α94
//│ ⬤ Typed as: α94
//│  where: 
//│ 		α94 :> [[[[String]]]] | [[[[[[[[[[Int]]]]]]]]]]
//│ unified α94 with:
//│ unified α93 with:
//│ unified α92 with:
//│ unified α91 with:
//│ unified α90 with:
//│ unified α89 with:
//│ unified α88 with:
//│ unified α82' with:
//│ unified α81' with:
//│ unified α80' with:
//│ unified α74' with:
//│ unified α73' with:
//│ unified α72' with:
//│ α94 bounds
//│  α94 <: [[[[String]]]] with lb([[[[String]]]] <: α94) length: 5
//│ UT α94 <: [[[[String]]]] len: 6 
//│ | UT  String with
//│ | UT  [[[[String]]]] <: α94 <: String
//│ | UT [[[[String]]]] <: [[[[String]]]] len: 11 
//│ | | U [[[[String]]]] = [[[[String]]]] because lb([[[[String]]]] <: [[[[String]]]]) skipCache
//│ | UT  [[[[[[[[[[Int]]]]]]]]]] <: α94 <: String
//│ | UT [[[[[[[[[[Int]]]]]]]]]] <: [[[[String]]]] len: 17 
//│ | | U [[[[[[[[[[Int]]]]]]]]]] = [[[[String]]]] because lb([[[[[[[[[[Int]]]]]]]]]] <: [[[[String]]]]) skipCache
//│ | | | UERR  [[[[[[[[[[Int]]]]]]]]]] = [[[[String]]]] because lb([[[[[[[[[[Int]]]]]]]]]] <: [[[[String]]]])
//│ ╔══[ERROR] Type `int` does not match `string`
//│ ║  
//│ ╟── this integer literal has type `int`
//│ ║  l.156: 	let a = 1
//│ ║         	        ^
//│ ╟── this reference has type `int`
//│ ║  l.157: 	let b = a
//│ ║         	        ^
//│ ╟── this reference has type `int`
//│ ║  l.160: 	g b true
//│ ║         	  ^
//│ ╟── this <nested> has type `int`
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `int`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                      ^
//│ ╟── this variable has type `int`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this <nested> has type `int`
//│ ╟── this application has type `int`
//│ ║  l.160: 	g b true
//│ ║         	^^^^^^^^
//│ ╟── this application has type `string`
//│ ║  l.160: 	g b true
//│ ║         	^^^^^^^^
//│ ╟── this <nested> has type `string`
//│ ╟── this if-then-else expression has type `string`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `string`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ | UT  α94 += ([[[[String]]]],List(ub(α94 <: [[[[String]]]])))
//│  α94 <: [[[[[[[[[[Int]]]]]]]]]] with lb([[[[[[[[[[Int]]]]]]]]]] <: α94) length: 11
//│ UT α94 <: [[[[[[[[[[Int]]]]]]]]]] len: 12 
//│ | UT  Int with
//│ | UT  [[[[String]]]] <: α94 <: Int
//│ | UT [[[[String]]]] <: [[[[[[[[[[Int]]]]]]]]]] len: 17 
//│ | UT  [[[[[[[[[[Int]]]]]]]]]] <: α94 <: Int
//│ | UT [[[[[[[[[[Int]]]]]]]]]] <: [[[[[[[[[[Int]]]]]]]]]] len: 23 
//│ | UT  α94 += ([[[[[[[[[[Int]]]]]]]]]],List(ub(α94 <: [[[[[[[[[[Int]]]]]]]]]])))
//│  α94 :> [[[[String]]]] with ub(α94 <: [[[[String]]]]) length: 5
//│ UT α94 <: [[[[String]]]] len: 6 
//│  α94 :> [[[[[[[[[[Int]]]]]]]]]] with ub(α94 <: [[[[[[[[[[Int]]]]]]]]]]) length: 11
//│ UT α94 <: [[[[[[[[[[Int]]]]]]]]]] len: 12 
//│ α93 bounds
//│ α92 bounds
//│  α92 <: [[[(α90 -> α89)]]] with lb([[[(α90 -> α89)]]] <: α92) length: 4
//│ UT α92 <: [[[(α90 -> α89)]]] len: 5 
//│ | UT  (α90 -> α89) with
//│ | UT  [[[(α90 -> α89)]]] <: α92 <: (α90 -> α89)
//│ | UT [[[(α90 -> α89)]]] <: [[[(α90 -> α89)]]] len: 9 
//│ | | U [[[(α90 -> α89)]]] = [[[(α90 -> α89)]]] because lb([[[(α90 -> α89)]]] <: [[[(α90 -> α89)]]]) skipCache
//│ | UT  (α90 -> α89) with
//│ | UT  α92 += ([[[(α90 -> α89)]]],List(ub(α92 <: [[[(α90 -> α89)]]])))
//│  α92 :> [[[(α90 -> α89)]]] with ub(α92 <: [[[(α90 -> α89)]]]) length: 4
//│ UT α92 <: [[[(α90 -> α89)]]] len: 5 
//│ α91 bounds
//│ α90 bounds
//│  α90 <: [[[[Bool]]]] with lb([[[[Bool]]]] <: α90) length: 5
//│ UT α90 <: [[[[Bool]]]] len: 6 
//│ | UT  Bool with
//│ | UT  [[[[Bool]]]] <: α90 <: Bool
//│ | UT [[[[Bool]]]] <: [[[[Bool]]]] len: 11 
//│ | UT  Bool with
//│ | UT  α90 += ([[[[Bool]]]],List(ub(α90 <: [[[[Bool]]]])))
//│  α90 :> [[[[Bool]]]] with ub(α90 <: [[[[Bool]]]]) length: 5
//│ UT α90 <: [[[[Bool]]]] len: 6 
//│ α89 bounds
//│  α89 <: [[[[[[[[Int]]]]]]]] with lb([[[[[[[[Int]]]]]]]] <: α89) length: 9
//│ UT α89 <: [[[[[[[[Int]]]]]]]] len: 10 
//│ | UT  Int with
//│ | UT  [[[[[[[[Int]]]]]]]] <: α89 <: Int
//│ | UT [[[[[[[[Int]]]]]]]] <: [[[[[[[[Int]]]]]]]] len: 19 
//│ | UT  [[String]] <: α89 <: Int
//│ | UT [[String]] <: [[[[[[[[Int]]]]]]]] len: 13 
//│ | UT  Int with
//│ | UT  α89 += ([[[[[[[[Int]]]]]]]],List(ub(α89 <: [[[[[[[[Int]]]]]]]])))
//│  α89 <: [[String]] with lb([[String]] <: α89) length: 3
//│ UT α89 <: [[String]] len: 4 
//│ | UT  String with
//│ | UT  [[[[[[[[Int]]]]]]]] <: α89 <: String
//│ | UT [[[[[[[[Int]]]]]]]] <: [[String]] len: 13 
//│ | UT  [[String]] <: α89 <: String
//│ | UT [[String]] <: [[String]] len: 7 
//│ | UT  String with
//│ | UT  α89 += ([[String]],List(ub(α89 <: [[String]])))
//│  α89 :> [[[[[[[[Int]]]]]]]] with ub(α89 <: [[[[[[[[Int]]]]]]]]) length: 9
//│ UT α89 <: [[[[[[[[Int]]]]]]]] len: 10 
//│  α89 :> [[String]] with ub(α89 <: [[String]]) length: 3
//│ UT α89 <: [[String]] len: 4 
//│ α88 bounds
//│  α88 <: [[[[[Int]]]]] with lb([[[[[Int]]]]] <: α88) length: 6
//│ UT α88 <: [[[[[Int]]]]] len: 7 
//│ | UT  Int with
//│ | UT  [[[[[Int]]]]] <: α88 <: Int
//│ | UT [[[[[Int]]]]] <: [[[[[Int]]]]] len: 13 
//│ | UT  Int with
//│ | UT  α88 += ([[[[[Int]]]]],List(ub(α88 <: [[[[[Int]]]]])))
//│  α88 :> [[[[[Int]]]]] with ub(α88 <: [[[[[Int]]]]]) length: 6
//│ UT α88 <: [[[[[Int]]]]] len: 7 
//│ α82' bounds
//│ α81' bounds
//│  α81' <: [[String]] with lb([[String]] <: α81') length: 3
//│ UT α81' <: [[String]] len: 4 
//│ | UT  String with
//│ | UT  [[String]] <: α81' <: String
//│ | UT [[String]] <: [[String]] len: 7 
//│ | UT  α81' += ([[String]],List(ub(α81' <: [[String]])))
//│  α81' :> [[String]] with ub(α81' <: [[String]]) length: 3
//│ UT α81' <: [[String]] len: 4 
//│ α80' bounds
//│ α74' bounds
//│  α74' <: [[String]] with lb([[String]] <: α74') length: 3
//│ UT α74' <: [[String]] len: 4 
//│ | UT  String with
//│ | UT  [[String]] <: α74' <: String
//│ | UT [[String]] <: [[String]] len: 7 
//│ | UT  α74' += ([[String]],List(ub(α74' <: [[String]])))
//│  α74' :> [[String]] with ub(α74' <: [[String]]) length: 3
//│ UT α74' <: [[String]] len: 4 
//│ α73' bounds
//│ α72' bounds
//│ ╔══[WARNING] ?a is unified with string because ub(α94 <: [[[[String]]]]))
//│ ║  
//│ ╟── application
//│ ║  l.160: 	g b true
//│ ║         	^^^^^^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α94 <: [[[[[[[[[[Int]]]]]]]]]]))
//│ ║  
//│ ╟── application
//│ ║  l.160: 	g b true
//│ ║         	^^^^^^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── variable
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── `then` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                      ^
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.160: 	g b true
//│ ║         	  ^
//│ ╟── reference
//│ ║  l.157: 	let b = a
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ╙──       	        ^
//│ ╔══[WARNING] ?a is unified with ?b -> ?c because ub(α92 <: [[[(α90 -> α89)]]]))
//│ ║  
//│ ╟── application
//│ ║  l.160: 	g b true
//│ ║         	^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── function
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because ub(α90 <: [[[[Bool]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	        ^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.160: 	g b true
//│ ║         	    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with string because ub(α89 <: [[String]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α89 <: [[[[[[[[Int]]]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── `then` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                      ^
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.160: 	g b true
//│ ║         	  ^
//│ ╟── reference
//│ ║  l.157: 	let b = a
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ╙──       	        ^
//│ ╔══[WARNING] ?a is unified with int because ub(α88 <: [[[[[Int]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.160: 	g b true
//│ ║         	  ^
//│ ╟── reference
//│ ║  l.157: 	let b = a
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ╙──       	        ^
//│ ╔══[WARNING] ?a is unified with string because ub(α81' <: [[String]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ ╔══[WARNING] ?a is unified with string because ub(α74' <: [[String]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ a: int
//│ b: int
//│ f: 'a -> bool -> (string | 'a)
//│ g: 'a -> bool -> (string | 'a)
//│ res: int | string
