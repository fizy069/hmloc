:unifyDbg
// nested prov not shown in collision error
let a = 1
let b = a
let f x = if x then true else false
let g = f
g b
//│ unified α70 with:
//│ unified α69 with:
//│ unified α68 with:
//│ unified α67 with:
//│ unified α64' with:
//│ unified α63' with:
//│ unified α60' with:
//│ unified α59' with:
//│ α70 bounds
//│  α70 <: [[[[[bool]]]]] with lb([[[[[bool]]]]] <: α70) length: 6
//│ UT α70 <: [[[[[bool]]]]] len: 7 
//│ | UT  bool with
//│ | UT  [[[[[bool]]]]] <: α70 <: bool
//│ | UT [[[[[bool]]]]] <: [[[[[bool]]]]] len: 13 
//│ | | U [[[[[bool]]]]] = [[[[[bool]]]]] because lb([[[[[bool]]]]] <: [[[[[bool]]]]]) skipCache
//│ | UT  α70 += ([[[[[bool]]]]],List(ub(α70 <: [[[[[bool]]]]])))
//│  α70 :> [[[[[bool]]]]] with ub(α70 <: [[[[[bool]]]]]) length: 6
//│ UT α70 <: [[[[[bool]]]]] len: 7 
//│ α69 bounds
//│ α68 bounds
//│  α68 <: [[[bool]]] with lb([[[bool]]] <: α68) length: 4
//│ UT α68 <: [[[bool]]] len: 5 
//│ | UT  bool with
//│ | UT  [[[bool]]] <: α68 <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 9 
//│ | UT  [[[bool]]] <: α68 <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 9 
//│ | UT  bool with
//│ | UT  α68 += ([[[bool]]],List(ub(α68 <: [[[bool]]])))
//│  α68 <: [[[bool]]] with lb([[[bool]]] <: α68) length: 4
//│ UT α68 <: [[[bool]]] len: 5 
//│  α68 :> [[[bool]]] with ub(α68 <: [[[bool]]]) length: 4
//│ UT α68 <: [[[bool]]] len: 5 
//│  α68 :> [[[bool]]] with ub(α68 <: [[[bool]]]) length: 4
//│ UT α68 <: [[[bool]]] len: 5 
//│ α67 bounds
//│  α67 <: [[[[[int]]]]] with lb([[[[[int]]]]] <: α67) length: 6
//│ UT α67 <: [[[[[int]]]]] len: 7 
//│ | UT  int with
//│ | UT  [[[[[int]]]]] <: α67 <: int
//│ | UT [[[[[int]]]]] <: [[[[[int]]]]] len: 13 
//│ | | U [[[[[int]]]]] = [[[[[int]]]]] because lb([[[[[int]]]]] <: [[[[[int]]]]]) skipCache
//│ | UT  int with
//│ | UT  α67 += ([[[[[int]]]]],List(ub(α67 <: [[[[[int]]]]])))
//│  α67 :> [[[[[int]]]]] with ub(α67 <: [[[[[int]]]]]) length: 6
//│ UT α67 <: [[[[[int]]]]] len: 7 
//│ α64' bounds
//│  α64' <: [[[bool]]] with lb([[[bool]]] <: α64') length: 4
//│ UT α64' <: [[[bool]]] len: 5 
//│ | UT  bool with
//│ | UT  [[[bool]]] <: α64' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 9 
//│ | UT  [[[bool]]] <: α64' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 9 
//│ | UT  α64' += ([[[bool]]],List(ub(α64' <: [[[bool]]])))
//│  α64' <: [[[bool]]] with lb([[[bool]]] <: α64') length: 4
//│ UT α64' <: [[[bool]]] len: 5 
//│  α64' :> [[[bool]]] with ub(α64' <: [[[bool]]]) length: 4
//│ UT α64' <: [[[bool]]] len: 5 
//│  α64' :> [[[bool]]] with ub(α64' <: [[[bool]]]) length: 4
//│ UT α64' <: [[[bool]]] len: 5 
//│ α63' bounds
//│ α60' bounds
//│  α60' <: [[[bool]]] with lb([[[bool]]] <: α60') length: 4
//│ UT α60' <: [[[bool]]] len: 5 
//│ | UT  bool with
//│ | UT  [[[bool]]] <: α60' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 9 
//│ | UT  [[[bool]]] <: α60' <: bool
//│ | UT [[[bool]]] <: [[[bool]]] len: 9 
//│ | UT  α60' += ([[[bool]]],List(ub(α60' <: [[[bool]]])))
//│  α60' <: [[[bool]]] with lb([[[bool]]] <: α60') length: 4
//│ UT α60' <: [[[bool]]] len: 5 
//│  α60' :> [[[bool]]] with ub(α60' <: [[[bool]]]) length: 4
//│ UT α60' <: [[[bool]]] len: 5 
//│  α60' :> [[[bool]]] with ub(α60' <: [[[bool]]]) length: 4
//│ UT α60' <: [[[bool]]] len: 5 
//│ α59' bounds
//│ ╔══[WARNING] ?a is unified with bool because ub(α70 <: [[[[[bool]]]]]))
//│ ║  
//│ ╟── application
//│ ║  l.7: 	g b
//│ ║       	^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                              ^^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with bool because ub(α68 <: [[[bool]]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `then` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with int because ub(α67 <: [[[[[int]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	      ^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.7: 	g b
//│ ║       	  ^
//│ ╟── reference
//│ ║  l.4: 	let b = a
//│ ║       	        ^
//│ ╟── integer literal
//│ ║  l.3: 	let a = 1
//│ ║       	        ^
//│ ╟── integer literal
//│ ║  l.3: 	let a = 1
//│ ╙──     	        ^
//│ ╔══[WARNING] ?a is unified with bool because ub(α64' <: [[[bool]]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `then` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with bool because ub(α60' <: [[[bool]]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `then` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                    ^^^^
//│ ╟── type
//│ ╙── type
//│ a: int
//│ b: int
//│ f: bool -> bool
//│ g: bool -> bool
//│ res: bool

:d
:unifyDbg
let a = 1
let b = a
let f x y = if y then x else "x"
let g = f
g b true
//│ 1. Typing term 1
//│ 1. : int
//│ ⬤ Typed as: int
//│  where: 
//│ 1. Typing term a
//│ 1. : [int]
//│ ⬤ Typed as: [int]
//│  where: 
//│ 1. Typing term x => y => if y(true) then x then (false) then "x"
//│ | 1. Typing pattern x
//│ | 1. : α72'
//│ | 1. Typing term y => if y(true) then x then (false) then "x"
//│ | | 1. Typing pattern y
//│ | | 1. : α73'
//│ | | 1. Typing term if y(true) then x then (false) then "x"
//│ | | | If(Var(y), List(IfThen(Var(true), Var(x), IfThen(Var(false), StrLit(x)))
//│ | | | 1. Typing term y
//│ | | | 1. : [α73']
//│ | | | CONSTRAIN [α73'] <! bool
//│ | | |   where 
//│ | | | C [α73'] <! bool    (0) where ProvType <: TypeRef}
//│ | | | | C α73' <! bool    (0) where TypeVariable <: TypeRef}
//│ | | | 1. Typing term x
//│ | | | 1. : [α72']
//│ | | | CONSTRAIN [α72'] <! α74'
//│ | | |   where 
//│ | | | C [α72'] <! α74'    (0) where ProvType <: TypeVariable}
//│ | | | | C α72' <! α74'    (0) where TypeVariable <: TypeVariable}
//│ | | | 1. Typing term "x"
//│ | | | 1. : string
//│ | | | CONSTRAIN string <! α74'
//│ | | |   where 
//│ | | | C string <! α74'    (0) where TypeRef <: TypeVariable}
//│ | | 1. : α74'
//│ | 1. : (α73' -> α74')
//│ 1. : (α72' -> (α73' -> α74'))
//│ ⬤ Typed as: (α72' -> (α73' -> α74'))
//│  where: 
//│ 		α72' <: [[[α74']]]
//│ 		α73' <: [[[bool]]]
//│ 		α74' :> [[string]]
//│ 1. Typing term f
//│ 1. : [(α80' -> (α82' -> α81'))]
//│ ⬤ Typed as: [(α80' -> (α82' -> α81'))]
//│  where: 
//│ 		α80' <: [[[α81']]]
//│ 		α81' :> [[string]]
//│ 		α82' <: [[[bool]]]
//│ 0. Typing term g b true
//│ | 0. Typing term g b
//│ | | 0. Typing term g
//│ | | 0. : [[(α88 -> (α90 -> α89))]]
//│ | | 0. Typing term b
//│ | | 0. : [[int]]
//│ | | CONSTRAIN [[(α88 -> (α90 -> α89))]] <! ([[int]] -> α92)
//│ | |   where 
//│ 		α88 <: [[[α89]]]
//│ 		α89 :> [[string]]
//│ 		α90 <: [[[bool]]]
//│ | | C [[(α88 -> (α90 -> α89))]] <! ([[int]] -> α92)    (0) where ProvType <: FunctionType}
//│ | | | C [(α88 -> (α90 -> α89))] <! ([[int]] -> α92)    (0) where ProvType <: FunctionType}
//│ | | | | C (α88 -> (α90 -> α89)) <! ([[int]] -> α92)    (0) where FunctionType <: FunctionType}
//│ | | | | | [nested] [[[int]]]
//│ | | | | | C [[int]] <! α88    (1) where ProvType <: TypeVariable}
//│ | | | | | | C [int] <! α88    (1) where ProvType <: TypeVariable}
//│ | | | | | | | C int <! α88    (1) where TypeRef <: TypeVariable}
//│ | | | | | | | | C int <! [[[α89]]]    (2) where TypeRef <: ProvType}
//│ | | | | | | | | | C int <! [[α89]]    (2) where TypeRef <: ProvType}
//│ | | | | | | | | | | C int <! [α89]    (2) where TypeRef <: ProvType}
//│ | | | | | | | | | | | C int <! α89    (2) where TypeRef <: TypeVariable}
//│ | | | | | [nested] [(α90 -> α89)]
//│ | | | | | C (α90 -> α89) <! α92    (3) where FunctionType <: TypeVariable}
//│ | 0. : α92
//│ | 0. Typing term true
//│ | 0. : [bool]
//│ | CONSTRAIN α92 <! ([bool] -> α94)
//│ |   where 
//│ 		α89 :> [[[[[[[[int]]]]]]]] | [[string]]
//│ 		α90 <: [[[bool]]]
//│ 		α92 :> [[[(α90 -> α89)]]]
//│ | C α92 <! ([bool] -> α94)    (0) where TypeVariable <: FunctionType}
//│ | | C [[[(α90 -> α89)]]] <! ([bool] -> α94)    (1) where ProvType <: FunctionType}
//│ | | | C [[(α90 -> α89)]] <! ([bool] -> α94)    (1) where ProvType <: FunctionType}
//│ | | | | C [(α90 -> α89)] <! ([bool] -> α94)    (1) where ProvType <: FunctionType}
//│ | | | | | C (α90 -> α89) <! ([bool] -> α94)    (1) where FunctionType <: FunctionType}
//│ | | | | | | [nested] [[bool]]
//│ | | | | | | C [bool] <! α90    (2) where ProvType <: TypeVariable}
//│ | | | | | | | C bool <! α90    (2) where TypeRef <: TypeVariable}
//│ | | | | | | | | C bool <! [[[bool]]]    (3) where TypeRef <: ProvType}
//│ | | | | | | [nested] [α89]
//│ | | | | | | C α89 <! α94    (3) where TypeVariable <: TypeVariable}
//│ | | | | | | | C [[[[[[[[int]]]]]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | C [[[[[[[int]]]]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | C [[[[[[int]]]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | C [[[[[int]]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | C [[[[int]]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | C [[[int]]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | C [[int]] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | | C [int] <! α94    (4) where ProvType <: TypeVariable}
//│ | | | | | | | | | | | | | | | C int <! α94    (4) where TypeRef <: TypeVariable}
//│ | | | | | | | C [[string]] <! α94    (5) where ProvType <: TypeVariable}
//│ | | | | | | | | C [string] <! α94    (5) where ProvType <: TypeVariable}
//│ | | | | | | | | | C string <! α94    (5) where TypeRef <: TypeVariable}
//│ 0. : α94
//│ ⬤ Typed as: α94
//│  where: 
//│ 		α94 :> [[[[string]]]] | [[[[[[[[[[int]]]]]]]]]]
//│ unified α94 with:
//│ unified α93 with:
//│ unified α92 with:
//│ unified α91 with:
//│ unified α90 with:
//│ unified α89 with:
//│ unified α88 with:
//│ unified α82' with:
//│ unified α81' with:
//│ unified α80' with:
//│ unified α74' with:
//│ unified α73' with:
//│ unified α72' with:
//│ α94 bounds
//│  α94 <: [[[[string]]]] with lb([[[[string]]]] <: α94) length: 5
//│ UT α94 <: [[[[string]]]] len: 6 
//│ | UT  string with
//│ | UT  [[[[string]]]] <: α94 <: string
//│ | UT [[[[string]]]] <: [[[[string]]]] len: 11 
//│ | | U [[[[string]]]] = [[[[string]]]] because lb([[[[string]]]] <: [[[[string]]]]) skipCache
//│ | UT  [[[[[[[[[[int]]]]]]]]]] <: α94 <: string
//│ | UT [[[[[[[[[[int]]]]]]]]]] <: [[[[string]]]] len: 17 
//│ | | U [[[[[[[[[[int]]]]]]]]]] = [[[[string]]]] because lb([[[[[[[[[[int]]]]]]]]]] <: [[[[string]]]]) skipCache
//│ | | | UERR  [[[[[[[[[[int]]]]]]]]]] = [[[[string]]]] because lb([[[[[[[[[[int]]]]]]]]]] <: [[[[string]]]])
//│ ╔══[ERROR] Type `int` does not match `string`
//│ ║  
//│ ╟── this integer literal has type `int`
//│ ║  l.156: 	let a = 1
//│ ║         	        ^
//│ ╟── this reference has type `int`
//│ ║  l.157: 	let b = a
//│ ║         	        ^
//│ ╟── this reference has type `int`
//│ ║  l.160: 	g b true
//│ ║         	  ^
//│ ╟── this <nested> has type `int`
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `int`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                      ^
//│ ╟── this variable has type `int`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this <nested> has type `int`
//│ ╟── this application has type `int`
//│ ║  l.160: 	g b true
//│ ║         	^^^^^^^^
//│ ╟── this application has type `string`
//│ ║  l.160: 	g b true
//│ ║         	^^^^^^^^
//│ ╟── this <nested> has type `string`
//│ ╟── this if-then-else expression has type `string`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `string`
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ | UT  α94 += ([[[[string]]]],List(ub(α94 <: [[[[string]]]])))
//│  α94 <: [[[[[[[[[[int]]]]]]]]]] with lb([[[[[[[[[[int]]]]]]]]]] <: α94) length: 11
//│ UT α94 <: [[[[[[[[[[int]]]]]]]]]] len: 12 
//│ | UT  int with
//│ | UT  [[[[string]]]] <: α94 <: int
//│ | UT [[[[string]]]] <: [[[[[[[[[[int]]]]]]]]]] len: 17 
//│ | UT  [[[[[[[[[[int]]]]]]]]]] <: α94 <: int
//│ | UT [[[[[[[[[[int]]]]]]]]]] <: [[[[[[[[[[int]]]]]]]]]] len: 23 
//│ | UT  α94 += ([[[[[[[[[[int]]]]]]]]]],List(ub(α94 <: [[[[[[[[[[int]]]]]]]]]])))
//│  α94 :> [[[[string]]]] with ub(α94 <: [[[[string]]]]) length: 5
//│ UT α94 <: [[[[string]]]] len: 6 
//│  α94 :> [[[[[[[[[[int]]]]]]]]]] with ub(α94 <: [[[[[[[[[[int]]]]]]]]]]) length: 11
//│ UT α94 <: [[[[[[[[[[int]]]]]]]]]] len: 12 
//│ α93 bounds
//│ α92 bounds
//│  α92 <: [[[(α90 -> α89)]]] with lb([[[(α90 -> α89)]]] <: α92) length: 4
//│ UT α92 <: [[[(α90 -> α89)]]] len: 5 
//│ | UT  (α90 -> α89) with
//│ | UT  [[[(α90 -> α89)]]] <: α92 <: (α90 -> α89)
//│ | UT [[[(α90 -> α89)]]] <: [[[(α90 -> α89)]]] len: 9 
//│ | | U [[[(α90 -> α89)]]] = [[[(α90 -> α89)]]] because lb([[[(α90 -> α89)]]] <: [[[(α90 -> α89)]]]) skipCache
//│ | UT  (α90 -> α89) with
//│ | UT  α92 += ([[[(α90 -> α89)]]],List(ub(α92 <: [[[(α90 -> α89)]]])))
//│  α92 :> [[[(α90 -> α89)]]] with ub(α92 <: [[[(α90 -> α89)]]]) length: 4
//│ UT α92 <: [[[(α90 -> α89)]]] len: 5 
//│ α91 bounds
//│ α90 bounds
//│  α90 <: [[[[bool]]]] with lb([[[[bool]]]] <: α90) length: 5
//│ UT α90 <: [[[[bool]]]] len: 6 
//│ | UT  bool with
//│ | UT  [[[[bool]]]] <: α90 <: bool
//│ | UT [[[[bool]]]] <: [[[[bool]]]] len: 11 
//│ | UT  bool with
//│ | UT  α90 += ([[[[bool]]]],List(ub(α90 <: [[[[bool]]]])))
//│  α90 :> [[[[bool]]]] with ub(α90 <: [[[[bool]]]]) length: 5
//│ UT α90 <: [[[[bool]]]] len: 6 
//│ α89 bounds
//│  α89 <: [[[[[[[[int]]]]]]]] with lb([[[[[[[[int]]]]]]]] <: α89) length: 9
//│ UT α89 <: [[[[[[[[int]]]]]]]] len: 10 
//│ | UT  int with
//│ | UT  [[[[[[[[int]]]]]]]] <: α89 <: int
//│ | UT [[[[[[[[int]]]]]]]] <: [[[[[[[[int]]]]]]]] len: 19 
//│ | UT  [[string]] <: α89 <: int
//│ | UT [[string]] <: [[[[[[[[int]]]]]]]] len: 13 
//│ | UT  int with
//│ | UT  α89 += ([[[[[[[[int]]]]]]]],List(ub(α89 <: [[[[[[[[int]]]]]]]])))
//│  α89 <: [[string]] with lb([[string]] <: α89) length: 3
//│ UT α89 <: [[string]] len: 4 
//│ | UT  string with
//│ | UT  [[[[[[[[int]]]]]]]] <: α89 <: string
//│ | UT [[[[[[[[int]]]]]]]] <: [[string]] len: 13 
//│ | UT  [[string]] <: α89 <: string
//│ | UT [[string]] <: [[string]] len: 7 
//│ | UT  string with
//│ | UT  α89 += ([[string]],List(ub(α89 <: [[string]])))
//│  α89 :> [[[[[[[[int]]]]]]]] with ub(α89 <: [[[[[[[[int]]]]]]]]) length: 9
//│ UT α89 <: [[[[[[[[int]]]]]]]] len: 10 
//│  α89 :> [[string]] with ub(α89 <: [[string]]) length: 3
//│ UT α89 <: [[string]] len: 4 
//│ α88 bounds
//│  α88 <: [[[[[int]]]]] with lb([[[[[int]]]]] <: α88) length: 6
//│ UT α88 <: [[[[[int]]]]] len: 7 
//│ | UT  int with
//│ | UT  [[[[[int]]]]] <: α88 <: int
//│ | UT [[[[[int]]]]] <: [[[[[int]]]]] len: 13 
//│ | UT  int with
//│ | UT  α88 += ([[[[[int]]]]],List(ub(α88 <: [[[[[int]]]]])))
//│  α88 :> [[[[[int]]]]] with ub(α88 <: [[[[[int]]]]]) length: 6
//│ UT α88 <: [[[[[int]]]]] len: 7 
//│ α82' bounds
//│ α81' bounds
//│  α81' <: [[string]] with lb([[string]] <: α81') length: 3
//│ UT α81' <: [[string]] len: 4 
//│ | UT  string with
//│ | UT  [[string]] <: α81' <: string
//│ | UT [[string]] <: [[string]] len: 7 
//│ | UT  α81' += ([[string]],List(ub(α81' <: [[string]])))
//│  α81' :> [[string]] with ub(α81' <: [[string]]) length: 3
//│ UT α81' <: [[string]] len: 4 
//│ α80' bounds
//│ α74' bounds
//│  α74' <: [[string]] with lb([[string]] <: α74') length: 3
//│ UT α74' <: [[string]] len: 4 
//│ | UT  string with
//│ | UT  [[string]] <: α74' <: string
//│ | UT [[string]] <: [[string]] len: 7 
//│ | UT  α74' += ([[string]],List(ub(α74' <: [[string]])))
//│  α74' :> [[string]] with ub(α74' <: [[string]]) length: 3
//│ UT α74' <: [[string]] len: 4 
//│ α73' bounds
//│ α72' bounds
//│ ╔══[WARNING] ?a is unified with string because ub(α94 <: [[[[string]]]]))
//│ ║  
//│ ╟── application
//│ ║  l.160: 	g b true
//│ ║         	^^^^^^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α94 <: [[[[[[[[[[int]]]]]]]]]]))
//│ ║  
//│ ╟── application
//│ ║  l.160: 	g b true
//│ ║         	^^^^^^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── variable
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── `then` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                      ^
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.160: 	g b true
//│ ║         	  ^
//│ ╟── reference
//│ ║  l.157: 	let b = a
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ╙──       	        ^
//│ ╔══[WARNING] ?a is unified with ?b -> ?c because ub(α92 <: [[[(α90 -> α89)]]]))
//│ ║  
//│ ╟── application
//│ ║  l.160: 	g b true
//│ ║         	^^^
//│ ╟── <nested> function rhs len: 4
//│ ╟── function
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] ?a is unified with bool because ub(α90 <: [[[[bool]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	        ^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.160: 	g b true
//│ ║         	    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with string because ub(α89 <: [[string]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α89 <: [[[[[[[[int]]]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── `then` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                      ^
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.160: 	g b true
//│ ║         	  ^
//│ ╟── reference
//│ ║  l.157: 	let b = a
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ╙──       	        ^
//│ ╔══[WARNING] ?a is unified with int because ub(α88 <: [[[[[int]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── <nested> function lhs len: 4
//│ ╟── reference
//│ ║  l.160: 	g b true
//│ ║         	  ^
//│ ╟── reference
//│ ║  l.157: 	let b = a
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.156: 	let a = 1
//│ ╙──       	        ^
//│ ╔══[WARNING] ?a is unified with string because ub(α81' <: [[string]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ ╔══[WARNING] ?a is unified with string because ub(α74' <: [[string]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.158: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ a: int
//│ b: int
//│ f: 'a -> bool -> (string | 'a)
//│ g: 'a -> bool -> (string | 'a)
//│ res: int | string
