:OcamlParser
:OcamlLoadLibrary

:unifyDbg
let boolToInt x = if x then "0" else 1
//│ unified α57' with:
//│   String: lb(String <: α57')
//│   Int: lb(Int <: α57')
//│ unified α56' with:
//│   Bool: ub(α56' <: Bool)
//│ ╔══[ERROR] [level 1] Cannot unify string and int because lb(String <: α57'),lb(Int <: α57')
//│ ╟── (lb(String <: α57'),true), (lb(Int <: α57'),false)   string ---> ?a <--- int 
//│ ╟── string is the type of `then` branch
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                            ^^^
//│ ╟── ?a is the type of if-then-else `expression`; string flows here
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── int is the type of `else` branch; ?a flows here
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ╙──     	                                     ^
//│ boolToInt: bool -> (int | string)

type ('a, 'b) either = Left of 'a | Right of 'b
//│ Defined type alias either[+'a, +'b]
//│ Defined class Left[+'a]
//│ Defined class Right[+'b]
//│ Left: 'a -> either['a, nothing]
//│ Right: 'a -> either[nothing, 'a]

:unifyDbg
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ unified α88' with:
//│   Bool: lb(Bool <: α88')
//│   α84': ub(α88' <: α84')
//│ unified α87' with:
//│   (Bool -> Bool): lb((Bool -> Bool) <: α87')
//│   ([Bool] -> α88'): ub(α87' <: ([Bool] -> α88'))
//│ unified α86' with:
//│   α84': ub(α86' <: α84')
//│   Int: lb(Int <: α86')
//│ unified α85' with:
//│   (Int -> Int): lb((Int -> Int) <: α85')
//│   (Int -> α86'): ub(α85' <: (Int -> α86'))
//│ unified α84' with:
//│   Bool: lb([[[Bool]]] <: α84')
//│   Int: lb([[[Int]]] <: α84')
//│ unified 'b83' with:
//│   Bool: ub('b83' <: Bool)
//│ unified 'a82' with:
//│   Int: ub('a82' <: Int)
//│ unified α81' with:
//│   either['a82','b83']: ub(α81' <: either['a82','b83'])
//│ ╔══[ERROR] [level 1] Cannot unify int and bool because lb([[[Int]]] <: α84'),lb([[[Bool]]] <: α84')
//│ ╟── (lb([[[Int]]] <: α84'),true), (lb([[[Bool]]] <: α84'),false)   int ---> ?a <--- bool 
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is the type of operator application
//│ ║  l.33: 	 | Left l -> l + 1
//│ ║        	             ^^^^^
//│ ╟── ?a is the type of match expression; int flows here
//│ ║  l.32: 	let destructEither x = match x with
//│ ║        	                       ^^^^^^^^^^^^
//│ ║  l.33: 	 | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.34: 	 | Right r -> r && true
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── bool is the type of operator application; ?a flows here
//│ ║  l.34: 	 | Right r -> r && true
//│ ║        	              ^^^^^^^^^^
//│ ╟── bool is here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ╙──      	                          ^^^^
//│ destructEither: either[int, bool] -> (bool | int)

:unifyDbg
let text x = if x then x + 1 else 1
//│ unified α96' with:
//│   Int: lb(Int <: α96')
//│   α94': ub(α96' <: α94')
//│ unified α95' with:
//│   (Int -> Int): lb((Int -> Int) <: α95')
//│   (Int -> α96'): ub(α95' <: (Int -> α96'))
//│ unified α94' with:
//│   Int: lb(Int <: α94')
//│ unified α93' with:
//│   Bool: ub(α93' <: Bool)
//│   Int: ub(α93' <: Int)
//│ ╔══[ERROR] [level 1] Cannot unify int and bool because ub(α93' <: Int),ub(α93' <: Bool)
//│ ╟── (ub(α93' <: Int),false), (ub(α93' <: Bool),true)   int <--- ?a ---> bool 
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	         ^^^
//│ ╟── ?a is the type of reference; int flows from here
//│ ║  l.80: 	let text x = if x then x + 1 else 1
//│ ║        	                       ^
//│ ╟── bool is the type of if-then-else `condition`; ?a flows into it
//│ ║  l.80: 	let text x = if x then x + 1 else 1
//│ ╙──      	                ^
//│ text: nothing -> int

:unifyDbg
let destructEither x = if x then
  match x with
   | Left l -> l + 1
   | Right r -> r && true
  else x
//│ unified α107' with:
//│   Bool: lb(Bool <: α107')
//│   α103': ub(α107' <: α103')
//│ unified α106' with:
//│   ([Bool] -> α107'): ub(α106' <: ([Bool] -> α107'))
//│   (Bool -> Bool): lb((Bool -> Bool) <: α106')
//│ unified α105' with:
//│   Int: lb(Int <: α105')
//│   α103': ub(α105' <: α103')
//│ unified α104' with:
//│   (Int -> Int): lb((Int -> Int) <: α104')
//│   (Int -> α105'): ub(α104' <: (Int -> α105'))
//│ unified α103' with:
//│   Bool: lb([[[Bool]]] <: α103')
//│   Int: lb([[[Int]]] <: α103')
//│   α100': ub(α103' <: α100')
//│ unified 'b102' with:
//│   Bool: ub('b102' <: Bool)
//│ unified 'a101' with:
//│   Int: ub('a101' <: Int)
//│ unified α100' with:
//│   Bool: ub(α99' <: α100'),ub(α99' <: Bool)
//│   Int: lb([[[[Int]]]] <: α100')
//│   either['a101','b102']: ub(α99' <: α100'),ub(α99' <: either['a101','b102'])
//│ unified α99' with:
//│   Bool: ub(α99' <: Bool)
//│   either['a101','b102']: ub(α99' <: either['a101','b102'])
//│   α100': ub(α99' <: α100')
//│ ╔══[ERROR] [level 1] Cannot unify (?a, ?b) either and bool because ub(α99' <: either['a101','b102']),ub(α99' <: Bool)
//│ ╟── (ub(α99' <: either['a101','b102']),false), (ub(α99' <: Bool),true)   (?a, ?b) either <--- ?c ---> bool 
//│ ╟── (?a, ?b) either is the type of case `expression`
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	     ^^^^
//│ ╟── ?c is the type of reference; (?a, ?b) either flows from here
//│ ║  l.107: 	  match x with
//│ ║         	        ^
//│ ╟── bool is the type of if-then-else `condition`; ?c flows into it
//│ ║  l.106: 	let destructEither x = if x then
//│ ╙──       	                          ^
//│ ╔══[ERROR] [level 1] Cannot unify int and bool because lb([[[Int]]] <: α103'),lb([[[Bool]]] <: α103')
//│ ╟── (lb([[[Int]]] <: α103'),true), (lb([[[Bool]]] <: α103'),false)   int ---> ?a <--- bool 
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is the type of operator application
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── ?a is the type of match expression; int flows here
//│ ║  l.107: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── bool is the type of operator application; ?a flows here
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── bool is here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ╙──      	                          ^^^^
//│ ╔══[ERROR] [level 1] Cannot unify bool and int because lb([[[[Bool]]]] <: α100'),lb([[[[Int]]]] <: α100')
//│ ╟── (lb([[[[Bool]]]] <: α100'),true), (lb([[[[Int]]]] <: α100'),false)   bool ---> ?a <--- int 
//│ ╟── bool is here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ║        	                          ^^^^
//│ ╟── bool is the type of operator application
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── ?a is the type of match expression; bool flows here
//│ ║  l.107: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── int is the type of operator application; ?a flows here
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	                       ^^^
//│ ╔══[ERROR] [level 1] Cannot unify int and (?a, ?b) either because lb([[[[[Int]]]]] <: either['a101','b102']),ub(α99' <: either['a101','b102'])
//│ ╟── (lb([[[[[Int]]]]] <: either['a101','b102']),true), (ub(α99' <: either['a101','b102']),false)   int ---> (?a, ?b) either <--- ?c 
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is the type of operator application
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── int is the type of match expression
//│ ║  l.107: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── int is the type of if-then-else `expression`
//│ ║  l.106: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.107: 	  match x with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	  else x
//│ ║         	^^^^^^^^^
//│ ╟── int is the type of variable
//│ ║  l.106: 	let destructEither x = if x then
//│ ║         	                   ^
//│ ╟── int is the type of `else` branch
//│ ║  l.110: 	  else x
//│ ║         	       ^^
//│ ╟── (?a, ?b) either is the type of if-then-else `expression`; int flows here
//│ ║  l.106: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.107: 	  match x with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	  else x
//│ ║         	^^^^^^^^^
//│ ╟── (?a, ?b) either is the type of case `expression`
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	     ^^^^
//│ ╟── (?a, ?b) either is the type of reference; it flows from ?c
//│ ║  l.107: 	  match x with
//│ ╙──       	        ^
//│ ╔══[ERROR] [level 1] Cannot unify bool and (?a, ?b) either because lb([[[[[Bool]]]]] <: either['a101','b102']),ub(α99' <: either['a101','b102'])
//│ ╟── (lb([[[[[Bool]]]]] <: either['a101','b102']),true), (ub(α99' <: either['a101','b102']),false)   bool ---> (?a, ?b) either <--- ?c 
//│ ╟── bool is here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ║        	                          ^^^^
//│ ╟── bool is the type of operator application
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── bool is the type of match expression
//│ ║  l.107: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── bool is the type of if-then-else `expression`
//│ ║  l.106: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.107: 	  match x with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	  else x
//│ ║         	^^^^^^^^^
//│ ╟── bool is the type of variable
//│ ║  l.106: 	let destructEither x = if x then
//│ ║         	                   ^
//│ ╟── bool is the type of `else` branch
//│ ║  l.110: 	  else x
//│ ║         	       ^^
//│ ╟── (?a, ?b) either is the type of if-then-else `expression`; bool flows here
//│ ║  l.106: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.107: 	  match x with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	  else x
//│ ║         	^^^^^^^^^
//│ ╟── (?a, ?b) either is the type of case `expression`
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	     ^^^^
//│ ╟── (?a, ?b) either is the type of reference; it flows from ?c
//│ ║  l.107: 	  match x with
//│ ╙──       	        ^
//│ ╔══[ERROR] [level 1] Cannot unify int and bool because lb([[[[[Int]]]]] <: Bool),ub(α99' <: Bool)
//│ ╟── (lb([[[[[Int]]]]] <: Bool),true), (ub(α99' <: Bool),false)   int ---> bool <--- ?a 
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is the type of operator application
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── int is the type of match expression
//│ ║  l.107: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── int is the type of if-then-else `expression`
//│ ║  l.106: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.107: 	  match x with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	  else x
//│ ║         	^^^^^^^^^
//│ ╟── int is the type of variable
//│ ║  l.106: 	let destructEither x = if x then
//│ ║         	                   ^
//│ ╟── int is the type of `else` branch
//│ ║  l.110: 	  else x
//│ ║         	       ^^
//│ ╟── bool is the type of if-then-else `expression`; int flows here
//│ ║  l.106: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.107: 	  match x with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.108: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.109: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.110: 	  else x
//│ ║         	^^^^^^^^^
//│ ╟── bool is the type of if-then-else `condition`; it flows from ?a
//│ ║  l.106: 	let destructEither x = if x then
//│ ╙──       	                          ^
//│ destructEither: (either[int, bool] & bool) -> (bool | int)

let test2 x = match x with
 | true -> succ x
//│ ╔══[ERROR] [level 1] Cannot unify int and bool because ub(α112' <: Int),ub(α112' <: Bool)
//│ ╟── (ub(α112' <: Int),false), (ub(α112' <: Bool),true)   int <--- ?a ---> bool 
//│ ╟── int is here
//│ ║  l.23: 	let succ: int -> int
//│ ║        	          ^^^
//│ ╟── ?a is the type of reference; int flows from here
//│ ║  l.339: 	 | true -> succ x
//│ ║         	                ^
//│ ╟── bool is the type of reference; ?a flows into it
//│ ║  l.338: 	let test2 x = match x with
//│ ║         	                    ^
//│ ╟── bool is the type of case `expression`
//│ ║  l.339: 	 | true -> succ x
//│ ╙──       	   ^^^^
//│ test2: nothing -> int
