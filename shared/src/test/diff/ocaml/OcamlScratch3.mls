:OcamlParser
:OcamlLoadLibrary

:unifyDbg
let boolToInt x = if x then "0" else 1
//│ unified α57' with:
//│   String: lb(String <: α57')
//│   Int: lb(Int <: α57')
//│ unified α56' with:
//│   Bool: ub(α56' <: Bool)
//│ ╔══[ERROR] Cannot unify string and int
//│ ╟──        string ---> ?a <--- int 
//│ ╟── string is the type of `then` branch
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                            ^^^
//│ ╟── ?a is the type of if-then-else `expression`; string flows here
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── int is the type of `else` branch; ?a flows here
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ╙──     	                                     ^
//│ boolToInt: bool -> (int | string)

type ('a, 'b) either = Left of 'a | Right of 'b
//│ Defined type alias either[+'a, +'b]
//│ Defined class Left[+'a]
//│ Defined class Right[+'b]
//│ Left: 'a -> either['a, nothing]
//│ Right: 'a -> either[nothing, 'a]

:unifyDbg
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ unified α88' with:
//│   α84': ub(α88' <: α84')
//│ unified α87' with:
//│   ([Bool] -> α88'): ub(α87' <: ([Bool] -> α88'))
//│ unified α86' with:
//│   α84': ub(α86' <: α84')
//│ unified α85' with:
//│   (Int -> α86'): ub(α85' <: (Int -> α86'))
//│ unified α84' with:
//│   Bool: lb(Bool <: α84')
//│   Int: lb(Int <: α84')
//│ unified 'b83' with:
//│ unified 'a82' with:
//│ unified α81' with:
//│   either['a82','b83']: ub(α81' <: either['a82','b83'])
//│ ╔══[ERROR] Cannot unify int and bool
//│ ╟──        int ---> ?a <--- bool 
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is the type of operator application
//│ ║  l.33: 	 | Left l -> l + 1
//│ ║        	             ^^^^^
//│ ╟── ?a is the type of match expression; int flows here
//│ ║  l.32: 	let destructEither x = match x with
//│ ║        	                       ^^^^^^^^^^^^
//│ ║  l.33: 	 | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.34: 	 | Right r -> r && true
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── bool is the type of operator application; ?a flows here
//│ ║  l.34: 	 | Right r -> r && true
//│ ║        	              ^^^^^^^^^^
//│ ╟── bool is here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ╙──      	                          ^^^^
//│ destructEither: either[int, bool] -> (bool | int)

:unifyDbg
:d
let test x = if x then x + 1 else 1
//│ 1. Typing term x => if x(true) then + x 1 then (false) then 1
//│ | 1. Typing pattern x
//│ | 1. : α93'
//│ | 1. Typing term if x(true) then + x 1 then (false) then 1
//│ | | If(Var(x), List(IfThen(Var(true), App(App(Var(+), Var(x)), IntLit(1)), IfThen(Var(false), IntLit(1)))
//│ | | 1. Typing term x
//│ | | 1. : [α93']
//│ | | CONSTRAIN [α93'] <! Bool
//│ | |   where 
//│ | | C [α93'] <! Bool    (0) where ProvType <: TypeRef}
//│ | | | C α93' <! Bool    (0) where TypeVariable <: TypeRef}
//│ | | UT [α93'] <: Bool) len: 2
//│ | | | UT  Bool with
//│ | | | UT  α93' += (Bool,List(ub(α93' <: Bool)))
//│ | | 1. Typing term + x 1
//│ | | | 1. Typing term + x
//│ | | | | 1. Typing term +
//│ | | | | 1. : [(Int -> (Int -> Int))]
//│ | | | | 1. Typing term x
//│ | | | | 1. : [α93']
//│ | | | | CONSTRAIN [(Int -> (Int -> Int))] <! ([α93'] -> α95')
//│ | | | |   where 
//│ 		α93' <: [[[Bool]]]
//│ | | | | C [(Int -> (Int -> Int))] <! ([α93'] -> α95')    (0) where ProvType <: FunctionType}
//│ | | | | | C (Int -> (Int -> Int)) <! ([α93'] -> α95')    (0) where FunctionType <: FunctionType}
//│ | | | | | | C [α93'] <! Int    (1) where ProvType <: TypeRef}
//│ | | | | | | | C α93' <! Int    (1) where TypeVariable <: TypeRef}
//│ | | | | | | C (Int -> Int) <! α95'    (2) where FunctionType <: TypeVariable}
//│ | | | | UT [(Int -> (Int -> Int))] <: ([α93'] -> α95')) len: 2
//│ | | | | | U [(Int -> (Int -> Int))] = ([α93'] -> α95') because lb([(Int -> (Int -> Int))] <: ([α93'] -> α95'))
//│ | | | 1. : α95'
//│ | | | 1. Typing term 1
//│ | | | 1. : Int
//│ | | | CONSTRAIN α95' <! (Int -> α96')
//│ | | |   where 
//│ 		α95' :> [[[(Int -> Int)]]]
//│ | | | C α95' <! (Int -> α96')    (0) where TypeVariable <: FunctionType}
//│ | | | | C [[[(Int -> Int)]]] <! (Int -> α96')    (1) where ProvType <: FunctionType}
//│ | | | | | C [[(Int -> Int)]] <! (Int -> α96')    (1) where ProvType <: FunctionType}
//│ | | | | | | C [(Int -> Int)] <! (Int -> α96')    (1) where ProvType <: FunctionType}
//│ | | | | | | | C (Int -> Int) <! (Int -> α96')    (1) where FunctionType <: FunctionType}
//│ | | | | | | | | C Int <! Int    (2) where TypeRef <: TypeRef}
//│ | | | | | | | | C Int <! α96'    (2) where TypeRef <: TypeVariable}
//│ | | | UT α95' <: (Int -> α96')) len: 1
//│ | | | | UT  (Int -> α96') with
//│ | | | | UT  [[[(Int -> Int)]]] <: α95' <: (Int -> α96')
//│ | | | | UT [[[(Int -> Int)]]] <: (Int -> α96')) len: 4
//│ | | | | | U [[[(Int -> Int)]]] = (Int -> α96') because lb([[[(Int -> Int)]]] <: (Int -> α96'))
//│ | | | | UT  (Int -> α96') with
//│ | | | | UT  α95' += ((Int -> α96'),List(ub(α95' <: (Int -> α96'))))
//│ | | 1. : α96'
//│ | | CONSTRAIN α96' <! α94'
//│ | |   where 
//│ 		α96' :> [[[Int]]]
//│ | | C α96' <! α94'    (0) where TypeVariable <: TypeVariable}
//│ | | | C [[[Int]]] <! α94'    (1) where ProvType <: TypeVariable}
//│ | | | | C [[Int]] <! α94'    (1) where ProvType <: TypeVariable}
//│ | | | | | C [Int] <! α94'    (1) where ProvType <: TypeVariable}
//│ | | | | | | C Int <! α94'    (1) where TypeRef <: TypeVariable}
//│ | | UT α96' <: α94') len: 2
//│ | | | UT  α94' with
//│ | | | UT  [[[Int]]] <: α96' <: α94'
//│ | | | UT [[[Int]]] <: α94') len: 5
//│ | | | | UT  Int with
//│ | | | | UT  α94' += (Int,List(lb(Int <: α94')))
//│ | | | UT  α94' with
//│ | | | UT  α96' += (α94',List(ub(α96' <: α94')))
//│ | | 1. Typing term 1
//│ | | 1. : Int
//│ | | CONSTRAIN Int <! α94'
//│ | |   where 
//│ 		α94' :> [[[[Int]]]]
//│ | | C Int <! α94'    (0) where TypeRef <: TypeVariable}
//│ | | UT Int <: α94') len: 2
//│ | | | UT  Int with
//│ | | | UT  α94' :> Int for lb(Int <: α94')
//│ | | | U [[Int]] = Int because lb(Int <: α94'), lb(Int <: α94')
//│ | | | UT  α94' :> Int for lb(Int <: α94')
//│ | | | U [[[[Int]]]] = Int because lb(Int <: α94'), lb(Int <: α94')
//│ | | | UT  α94' += (Int,List(lb(Int <: α94')))
//│ | 1. : α94'
//│ 1. : (α93' -> α94')
//│ ⬤ Typed as: (α93' -> α94')
//│  where: 
//│ 		α93' <: [[[[Int]]]] & [[[Bool]]]
//│ 		α94' :> [[Int]] | [[[[Int]]]]
//│ unified α96' with:
//│   α94': ub(α96' <: α94')
//│ unified α95' with:
//│   (Int -> α96'): ub(α95' <: (Int -> α96'))
//│ unified α94' with:
//│   Int: lb(Int <: α94')
//│ unified α93' with:
//│   Bool: ub(α93' <: Bool)
//│ test: nothing -> int

:unifyDbg
:d
let destructEither x = if x then
  match x with
   | Left l -> l + 1
   | Right r -> r && true
  else x
//│ 1. Typing term x => if x(true) then if x(Left l) then + l 1 then (Right r) then && r true then (false) then x
//│ | 1. Typing pattern x
//│ | 1. : α99'
//│ | 1. Typing term if x(true) then if x(Left l) then + l 1 then (Right r) then && r true then (false) then x
//│ | | If(Var(x), List(IfThen(Var(true), If(Var(x), List(IfThen(App(Var(Left), Var(l)), App(App(Var(+), Var(l)), IntLit(1)), IfThen(App(Var(Right), Var(r)), App(App(Var(&&), Var(r)), Var(true)))), IfThen(Var(false), Var(x)))
//│ | | 1. Typing term x
//│ | | 1. : [α99']
//│ | | CONSTRAIN [α99'] <! Bool
//│ | |   where 
//│ | | C [α99'] <! Bool    (0) where ProvType <: TypeRef}
//│ | | | C α99' <! Bool    (0) where TypeVariable <: TypeRef}
//│ | | UT [α99'] <: Bool) len: 2
//│ | | | UT  Bool with
//│ | | | UT  α99' += (Bool,List(ub(α99' <: Bool)))
//│ | | 1. Typing term if x(Left l) then + l 1 then (Right r) then && r true
//│ | | | If(Var(x), List(IfThen(App(Var(Left), Var(l)), App(App(Var(+), Var(l)), IntLit(1)), IfThen(App(Var(Right), Var(r)), App(App(Var(&&), Var(r)), Var(true))))
//│ | | | ADT name: TypeName(either)
//│ | | | ADT type: [either['a101','b102']]
//│ | | | typed condition term x
//│ | | | 1. Typing term x
//│ | | | 1. : [α99']
//│ | | | CONSTRAIN [α99'] <! [either['a101','b102']]
//│ | | |   where 
//│ 		α99' <: [[[Bool]]]
//│ | | | C [α99'] <! [either['a101','b102']]    (0) where ProvType <: ProvType}
//│ | | | | C α99' <! [either['a101','b102']]    (0) where TypeVariable <: ProvType}
//│ | | | | | C α99' <! either['a101','b102']    (0) where TypeVariable <: TypeRef}
//│ | | | UT [α99'] <: [either['a101','b102']]) len: 4
//│ | | | | UT  either['a101','b102'] with
//│ | | | | UT  α99' <: [[[Bool]]]  for ub(α99' <: Bool)
//│ | | | | U [[[Bool]]] = either['a101','b102'] because ub(α99' <: Bool), ub(α99' <: either['a101','b102'])
//│ | | | | | (ub(α99' <: Bool),false) -> (ub(α99' <: either['a101','b102']),true) showFirst: true leftSame: true
//│ | | | | | show 1 locations for (ub(α99' <: Bool),false)
//│ | | | | | (ub(α99' <: Bool),false) -> (ub(α99' <: either['a101','b102']),true) showFirst: false leftSame: true
//│ | | | | | show 2 locations for (ub(α99' <: either['a101','b102']),true)
//│ | | | | UT  α99' += (either['a101','b102'],List(ub(α99' <: either['a101','b102'])))
//│ | | | fields l ~> List(l)
//│ | | | Typing case 0 (Left)
//│ | | | ctor type: (α69' -> either[α69',α70'])
//│ | | | fieldTypes: List('a101')
//│ | | | Typing field l (Left)
//│ | | | Field l : 'a101'
//│ | | | 1. Typing term + l 1
//│ | | | | 1. Typing term + l
//│ | | | | | 1. Typing term +
//│ | | | | | 1. : [(Int -> (Int -> Int))]
//│ | | | | | 1. Typing term l
//│ | | | | | 1. : ['a101']
//│ | | | | | CONSTRAIN [(Int -> (Int -> Int))] <! (['a101'] -> α104')
//│ | | | | |   where 
//│ | | | | | C [(Int -> (Int -> Int))] <! (['a101'] -> α104')    (0) where ProvType <: FunctionType}
//│ | | | | | | C (Int -> (Int -> Int)) <! (['a101'] -> α104')    (0) where FunctionType <: FunctionType}
//│ | | | | | | | C ['a101'] <! Int    (1) where ProvType <: TypeRef}
//│ | | | | | | | | C 'a101' <! Int    (1) where TypeVariable <: TypeRef}
//│ | | | | | | | C (Int -> Int) <! α104'    (2) where FunctionType <: TypeVariable}
//│ | | | | | UT [(Int -> (Int -> Int))] <: (['a101'] -> α104')) len: 2
//│ | | | | | | U [(Int -> (Int -> Int))] = (['a101'] -> α104') because lb([(Int -> (Int -> Int))] <: (['a101'] -> α104'))
//│ | | | | 1. : α104'
//│ | | | | 1. Typing term 1
//│ | | | | 1. : Int
//│ | | | | CONSTRAIN α104' <! (Int -> α105')
//│ | | | |   where 
//│ 		α104' :> [[[(Int -> Int)]]]
//│ | | | | C α104' <! (Int -> α105')    (0) where TypeVariable <: FunctionType}
//│ | | | | | C [[[(Int -> Int)]]] <! (Int -> α105')    (1) where ProvType <: FunctionType}
//│ | | | | | | C [[(Int -> Int)]] <! (Int -> α105')    (1) where ProvType <: FunctionType}
//│ | | | | | | | C [(Int -> Int)] <! (Int -> α105')    (1) where ProvType <: FunctionType}
//│ | | | | | | | | C (Int -> Int) <! (Int -> α105')    (1) where FunctionType <: FunctionType}
//│ | | | | | | | | | C Int <! Int    (2) where TypeRef <: TypeRef}
//│ | | | | | | | | | C Int <! α105'    (2) where TypeRef <: TypeVariable}
//│ | | | | UT α104' <: (Int -> α105')) len: 1
//│ | | | | | UT  (Int -> α105') with
//│ | | | | | UT  [[[(Int -> Int)]]] <: α104' <: (Int -> α105')
//│ | | | | | UT [[[(Int -> Int)]]] <: (Int -> α105')) len: 4
//│ | | | | | | U [[[(Int -> Int)]]] = (Int -> α105') because lb([[[(Int -> Int)]]] <: (Int -> α105'))
//│ | | | | | UT  (Int -> α105') with
//│ | | | | | UT  α104' += ((Int -> α105'),List(ub(α104' <: (Int -> α105'))))
//│ | | | 1. : α105'
//│ | | | CONSTRAIN α105' <! α103'
//│ | | |   where 
//│ 		α105' :> [[[Int]]]
//│ | | | C α105' <! α103'    (0) where TypeVariable <: TypeVariable}
//│ | | | | C [[[Int]]] <! α103'    (1) where ProvType <: TypeVariable}
//│ | | | | | C [[Int]] <! α103'    (1) where ProvType <: TypeVariable}
//│ | | | | | | C [Int] <! α103'    (1) where ProvType <: TypeVariable}
//│ | | | | | | | C Int <! α103'    (1) where TypeRef <: TypeVariable}
//│ | | | UT α105' <: α103') len: 2
//│ | | | | UT  α103' with
//│ | | | | UT  [[[Int]]] <: α105' <: α103'
//│ | | | | UT [[[Int]]] <: α103') len: 5
//│ | | | | | UT  Int with
//│ | | | | | UT  α103' += (Int,List(lb(Int <: α103')))
//│ | | | | UT  α103' with
//│ | | | | UT  α105' += (α103',List(ub(α105' <: α103')))
//│ | | | fields r ~> List(r)
//│ | | | Typing case 1 (Right)
//│ | | | ctor type: (α76' -> either[α75',α76'])
//│ | | | fieldTypes: List('b102')
//│ | | | Typing field r (Right)
//│ | | | Field r : 'b102'
//│ | | | 1. Typing term && r true
//│ | | | | 1. Typing term && r
//│ | | | | | 1. Typing term &&
//│ | | | | | 1. : [(Bool -> (Bool -> Bool))]
//│ | | | | | 1. Typing term r
//│ | | | | | 1. : ['b102']
//│ | | | | | CONSTRAIN [(Bool -> (Bool -> Bool))] <! (['b102'] -> α106')
//│ | | | | |   where 
//│ | | | | | C [(Bool -> (Bool -> Bool))] <! (['b102'] -> α106')    (0) where ProvType <: FunctionType}
//│ | | | | | | C (Bool -> (Bool -> Bool)) <! (['b102'] -> α106')    (0) where FunctionType <: FunctionType}
//│ | | | | | | | C ['b102'] <! Bool    (1) where ProvType <: TypeRef}
//│ | | | | | | | | C 'b102' <! Bool    (1) where TypeVariable <: TypeRef}
//│ | | | | | | | C (Bool -> Bool) <! α106'    (2) where FunctionType <: TypeVariable}
//│ | | | | | UT [(Bool -> (Bool -> Bool))] <: (['b102'] -> α106')) len: 2
//│ | | | | | | U [(Bool -> (Bool -> Bool))] = (['b102'] -> α106') because lb([(Bool -> (Bool -> Bool))] <: (['b102'] -> α106'))
//│ | | | | 1. : α106'
//│ | | | | 1. Typing term true
//│ | | | | 1. : [Bool]
//│ | | | | CONSTRAIN α106' <! ([Bool] -> α107')
//│ | | | |   where 
//│ 		α106' :> [[[(Bool -> Bool)]]]
//│ | | | | C α106' <! ([Bool] -> α107')    (0) where TypeVariable <: FunctionType}
//│ | | | | | C [[[(Bool -> Bool)]]] <! ([Bool] -> α107')    (1) where ProvType <: FunctionType}
//│ | | | | | | C [[(Bool -> Bool)]] <! ([Bool] -> α107')    (1) where ProvType <: FunctionType}
//│ | | | | | | | C [(Bool -> Bool)] <! ([Bool] -> α107')    (1) where ProvType <: FunctionType}
//│ | | | | | | | | C (Bool -> Bool) <! ([Bool] -> α107')    (1) where FunctionType <: FunctionType}
//│ | | | | | | | | | C [Bool] <! Bool    (2) where ProvType <: TypeRef}
//│ | | | | | | | | | C Bool <! α107'    (2) where TypeRef <: TypeVariable}
//│ | | | | UT α106' <: ([Bool] -> α107')) len: 1
//│ | | | | | UT  ([Bool] -> α107') with
//│ | | | | | UT  [[[(Bool -> Bool)]]] <: α106' <: ([Bool] -> α107')
//│ | | | | | UT [[[(Bool -> Bool)]]] <: ([Bool] -> α107')) len: 4
//│ | | | | | | U [[[(Bool -> Bool)]]] = ([Bool] -> α107') because lb([[[(Bool -> Bool)]]] <: ([Bool] -> α107'))
//│ | | | | | UT  ([Bool] -> α107') with
//│ | | | | | UT  α106' += (([Bool] -> α107'),List(ub(α106' <: ([Bool] -> α107'))))
//│ | | | 1. : α107'
//│ | | | CONSTRAIN α107' <! α103'
//│ | | |   where 
//│ 		α103' :> [[[[Int]]]]
//│ 		α107' :> [[[Bool]]]
//│ | | | C α107' <! α103'    (0) where TypeVariable <: TypeVariable}
//│ | | | | C [[[Bool]]] <! α103'    (1) where ProvType <: TypeVariable}
//│ | | | | | C [[Bool]] <! α103'    (1) where ProvType <: TypeVariable}
//│ | | | | | | C [Bool] <! α103'    (1) where ProvType <: TypeVariable}
//│ | | | | | | | C Bool <! α103'    (1) where TypeRef <: TypeVariable}
//│ | | | UT α107' <: α103') len: 2
//│ | | | | UT  α103' with
//│ | | | | UT  [[[Bool]]] <: α107' <: α103'
//│ | | | | UT [[[Bool]]] <: α103') len: 5
//│ | | | | | UT  Bool with
//│ | | | | | UT  α103' :> Int for lb(Int <: α103')
//│ | | | | | U [[[[Int]]]] = Bool because lb(Int <: α103'), lb(Bool <: α103')
//│ | | | | | | (lb(Int <: α103'),true) -> (lb(Bool <: α103'),false) showFirst: true leftSame: false
//│ | | | | | | show 3 locations for (lb(Int <: α103'),true)
//│ | | | | | | (lb(Int <: α103'),true) -> (lb(Bool <: α103'),false) showFirst: false leftSame: false
//│ | | | | | | show 2 locations for (lb(Bool <: α103'),false)
//│ | | | | | UT  α103' += (Bool,List(lb(Bool <: α103')))
//│ | | | | UT  α103' with
//│ | | | | UT  α107' += (α103',List(ub(α107' <: α103')))
//│ | | 1. : α103'
//│ | | CONSTRAIN α103' <! α100'
//│ | |   where 
//│ 		α103' :> [[[[Bool]]]] | [[[[Int]]]]
//│ | | C α103' <! α100'    (0) where TypeVariable <: TypeVariable}
//│ | | | C [[[[Bool]]]] <! α100'    (1) where ProvType <: TypeVariable}
//│ | | | | C [[[Bool]]] <! α100'    (1) where ProvType <: TypeVariable}
//│ | | | | | C [[Bool]] <! α100'    (1) where ProvType <: TypeVariable}
//│ | | | | | | C [Bool] <! α100'    (1) where ProvType <: TypeVariable}
//│ | | | | | | | C Bool <! α100'    (1) where TypeRef <: TypeVariable}
//│ | | | C [[[[Int]]]] <! α100'    (2) where ProvType <: TypeVariable}
//│ | | | | C [[[Int]]] <! α100'    (2) where ProvType <: TypeVariable}
//│ | | | | | C [[Int]] <! α100'    (2) where ProvType <: TypeVariable}
//│ | | | | | | C [Int] <! α100'    (2) where ProvType <: TypeVariable}
//│ | | | | | | | C Int <! α100'    (2) where TypeRef <: TypeVariable}
//│ | | UT α103' <: α100') len: 2
//│ | | | UT  α100' with
//│ | | | UT  [[[[Bool]]]] <: α103' <: α100'
//│ | | | UT [[[[Bool]]]] <: α100') len: 6
//│ | | | | UT  Bool with
//│ | | | | UT  α100' += (Bool,List(lb(Bool <: α100')))
//│ | | | UT  [[[[Int]]]] <: α103' <: α100'
//│ | | | UT [[[[Int]]]] <: α100') len: 6
//│ | | | | UT  Int with
//│ | | | | UT  α100' :> Bool for lb(Bool <: α100')
//│ | | | | U [[[[[Bool]]]]] = Int because lb(Bool <: α100'), lb(Int <: α100')
//│ | | | | | (lb(Bool <: α100'),true) -> (lb(Int <: α100'),false) showFirst: true leftSame: false
//│ | | | | | show 3 locations for (lb(Bool <: α100'),true)
//│ | | | | | (lb(Bool <: α100'),true) -> (lb(Int <: α100'),false) showFirst: false leftSame: false
//│ | | | | | show 2 locations for (lb(Int <: α100'),false)
//│ | | | | UT  α100' += (Int,List(lb(Int <: α100')))
//│ | | | UT  α100' with
//│ | | | UT  α103' += (α100',List(ub(α103' <: α100')))
//│ | | 1. Typing term x
//│ | | 1. : [α99']
//│ | | CONSTRAIN [α99'] <! α100'
//│ | |   where 
//│ 		α99' <: [[[[either['a101','b102']]]]] & [[[Bool]]]
//│ 		α100' :> [[[[[Int]]]]] | [[[[[Bool]]]]]
//│ 		'a101' <: [[[[Int]]]]
//│ 		'b102' <: [[[[Bool]]]]
//│ | | C [α99'] <! α100'    (0) where ProvType <: TypeVariable}
//│ | | | C α99' <! α100'    (0) where TypeVariable <: TypeVariable}
//│ | | UT [α99'] <: α100') len: 3
//│ | | | UT  α100' with
//│ | | | UT  α99' <: [[[[either['a101','b102']]]]]  for ub(α99' <: either['a101','b102'])
//│ | | | U [[[[either['a101','b102']]]]] = α100' because ub(α99' <: either['a101','b102']), ub(α99' <: α100')
//│ | | | | U   either['a101','b102'] with
//│ | | | |     α100' = Bool for lb(Bool <: α100')
//│ | | | | U Bool = either['a101','b102'] because lb(Bool <: α100'), ub(α99' <: α100'), ub(α99' <: either['a101','b102'])
//│ | | | | | (lb(Bool <: α100'),true) -> (ub(α99' <: α100'),false) showFirst: true leftSame: false
//│ | | | | | show 4 locations for (lb(Bool <: α100'),true)
//│ | | | | | (lb(Bool <: α100'),true) -> (ub(α99' <: α100'),false) showFirst: false leftSame: false
//│ | | | | | show 1 locations for (ub(α99' <: α100'),false)
//│ | | | | | (ub(α99' <: α100'),false) -> (ub(α99' <: either['a101','b102']),true) showFirst: false leftSame: true
//│ | | | | | show 2 locations for (ub(α99' <: either['a101','b102']),true)
//│ | | | |     α100' = Int for lb(Int <: α100')
//│ | | | | U Int = either['a101','b102'] because lb(Int <: α100'), ub(α99' <: α100'), ub(α99' <: either['a101','b102'])
//│ | | | | | (lb(Int <: α100'),true) -> (ub(α99' <: α100'),false) showFirst: true leftSame: false
//│ | | | | | show 4 locations for (lb(Int <: α100'),true)
//│ | | | | | (lb(Int <: α100'),true) -> (ub(α99' <: α100'),false) showFirst: false leftSame: false
//│ | | | | | show 1 locations for (ub(α99' <: α100'),false)
//│ | | | | | (ub(α99' <: α100'),false) -> (ub(α99' <: either['a101','b102']),true) showFirst: false leftSame: true
//│ | | | | | show 2 locations for (ub(α99' <: either['a101','b102']),true)
//│ | | | UT  α99' <: [[[Bool]]]  for ub(α99' <: Bool)
//│ | | | U [[[Bool]]] = α100' because ub(α99' <: Bool), ub(α99' <: α100')
//│ | | | | U   Bool with
//│ | | | |     α100' = Bool for lb(Bool <: α100')
//│ | | | | U Bool = Bool because lb(Bool <: α100'), ub(α99' <: α100'), ub(α99' <: Bool)
//│ | | | |     α100' = Int for lb(Int <: α100')
//│ | | | | U Int = Bool because lb(Int <: α100'), ub(α99' <: α100'), ub(α99' <: Bool)
//│ | | | | | (lb(Int <: α100'),true) -> (ub(α99' <: α100'),false) showFirst: true leftSame: false
//│ | | | | | show 4 locations for (lb(Int <: α100'),true)
//│ | | | | | (lb(Int <: α100'),true) -> (ub(α99' <: α100'),false) showFirst: false leftSame: false
//│ | | | | | show 1 locations for (ub(α99' <: α100'),false)
//│ | | | | | (ub(α99' <: α100'),false) -> (ub(α99' <: Bool),true) showFirst: false leftSame: true
//│ | | | | | show 1 locations for (ub(α99' <: Bool),true)
//│ | | | UT  α99' += (α100',List(ub(α99' <: α100')))
//│ | 1. : α100'
//│ 1. : (α99' -> α100')
//│ ⬤ Typed as: (α99' -> α100')
//│  where: 
//│ 		α99' <: [[[α100']]] & [[[[either['a101','b102']]]]] & [[[Bool]]]
//│ 		α100' :> [[[[[Int]]]]] | [[[[[Bool]]]]]
//│ 		'a101' <: [[[[Int]]]]
//│ 		'b102' <: [[[[Bool]]]]
//│ unified α107' with:
//│   α103': ub(α107' <: α103')
//│ unified α106' with:
//│   ([Bool] -> α107'): ub(α106' <: ([Bool] -> α107'))
//│ unified α105' with:
//│   α103': ub(α105' <: α103')
//│ unified α104' with:
//│   (Int -> α105'): ub(α104' <: (Int -> α105'))
//│ unified α103' with:
//│   Bool: lb(Bool <: α103')
//│   Int: lb(Int <: α103')
//│   α100': ub(α103' <: α100')
//│ unified 'b102' with:
//│ unified 'a101' with:
//│ unified α100' with:
//│   Bool: lb(Bool <: α100')
//│   Int: lb(Int <: α100')
//│ unified α99' with:
//│   Bool: ub(α99' <: Bool)
//│   either['a101','b102']: ub(α99' <: either['a101','b102'])
//│   α100': ub(α99' <: α100')
//│ ╔══[ERROR] Cannot unify bool and (?a, ?b) either
//│ ╟──        bool <--- ?c ---> (?a, ?b) either 
//│ ╟── ?c is the type of if-then-else `condition`; bool flows from here
//│ ║  l.174: 	let destructEither x = if x then
//│ ║         	                          ^
//│ ╟── (?a, ?b) either is the type of reference; ?c flows into it
//│ ║  l.175: 	  match x with
//│ ║         	        ^
//│ ╟── (?a, ?b) either is the type of case `expression`
//│ ║  l.176: 	   | Left l -> l + 1
//│ ╙──       	     ^^^^
//│ ╔══[ERROR] Cannot unify int and bool
//│ ╟──        int ---> ?a <--- bool 
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is the type of operator application
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── ?a is the type of match expression; int flows here
//│ ║  l.175: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── bool is the type of operator application; ?a flows here
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── bool is here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ╙──      	                          ^^^^
//│ ╔══[ERROR] Cannot unify bool and int
//│ ╟──        bool ---> ?a <--- int 
//│ ╟── bool is here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ║        	                          ^^^^
//│ ╟── bool is the type of operator application
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── ?a is the type of match expression; bool flows here
//│ ║  l.175: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── int is the type of operator application; ?a flows here
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	                       ^^^
//│ ╔══[ERROR] Cannot unify bool and (?a, ?b) either
//│ ╟──        bool ---> ?c <--- ?d ---> (?a, ?b) either 
//│ ╟── bool is here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ║        	                          ^^^^
//│ ╟── bool is the type of operator application
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── bool is the type of match expression
//│ ║  l.175: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ?c is the type of if-then-else `expression`; bool flows here
//│ ║  l.174: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.175: 	  match x with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.178: 	  else x
//│ ║         	^^^^^^^^^
//│ ╟── ?c is the type of `else` branch; it flows from ?d
//│ ║  l.178: 	  else x
//│ ║         	       ^^
//│ ╟── (?a, ?b) either is the type of reference; ?d flows into it
//│ ║  l.175: 	  match x with
//│ ║         	        ^
//│ ╟── (?a, ?b) either is the type of case `expression`
//│ ║  l.176: 	   | Left l -> l + 1
//│ ╙──       	     ^^^^
//│ ╔══[ERROR] Cannot unify int and (?a, ?b) either
//│ ╟──        int ---> ?c <--- ?d ---> (?a, ?b) either 
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is the type of operator application
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── int is the type of match expression
//│ ║  l.175: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ?c is the type of if-then-else `expression`; int flows here
//│ ║  l.174: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.175: 	  match x with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.178: 	  else x
//│ ║         	^^^^^^^^^
//│ ╟── ?c is the type of `else` branch; it flows from ?d
//│ ║  l.178: 	  else x
//│ ║         	       ^^
//│ ╟── (?a, ?b) either is the type of reference; ?d flows into it
//│ ║  l.175: 	  match x with
//│ ║         	        ^
//│ ╟── (?a, ?b) either is the type of case `expression`
//│ ║  l.176: 	   | Left l -> l + 1
//│ ╙──       	     ^^^^
//│ ╔══[ERROR] Cannot unify int and bool
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ╟── int is here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is the type of operator application
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── int is the type of match expression
//│ ║  l.175: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ?a is the type of if-then-else `expression`; int flows here
//│ ║  l.174: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.175: 	  match x with
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.176: 	   | Left l -> l + 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	   | Right r -> r && true
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.178: 	  else x
//│ ║         	^^^^^^^^^
//│ ╟── ?a is the type of `else` branch; it flows from ?b
//│ ║  l.178: 	  else x
//│ ║         	       ^^
//│ ╟── bool is the type of if-then-else `condition`; ?b flows into it
//│ ║  l.174: 	let destructEither x = if x then
//│ ╙──       	                          ^
//│ destructEither: (either[int, bool] & bool) -> (bool | int)

let succ: int -> int
//│ succ: int -> int

:unify
let test2 x = match x with
 | true -> succ x
//│ test2: nothing -> int
