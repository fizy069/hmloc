:unifyDbg
// nested prov not shown in collision error
let a = 1
let b = a
let f x = if x then true else false
let g = f
g b
//│ unified α66 with:
//│ unified α65 with:
//│ unified α64 with:
//│   [[Int]]: lb([[Int]] <: α64)
//│ unified α61' with:
//│ unified α60' with:
//│ unified α57' with:
//│   [Bool]: lb([Bool] <: α57')
//│ unified α56' with:
//│   Bool: ub(α56' <: Bool)
//│ α66 bounds
//│ α65 bounds
//│  α65 <: [[[Bool]]] with lb([[[Bool]]] <: α65) length: 4
//│ UT α65 <: [[[Bool]]] len: 5 
//│ | UT  Bool with
//│ | UT  [[[Bool]]] <: α65 <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | | U [[[Bool]]] = [[[Bool]]] because lb([[[Bool]]] <: [[[Bool]]]) skipCache
//│ | UT  [[[Bool]]] <: α65 <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  α65 += ([[[Bool]]],List(ub(α65 <: [[[Bool]]])))
//│  α65 <: [[[Bool]]] with lb([[[Bool]]] <: α65) length: 4
//│ UT α65 <: [[[Bool]]] len: 5 
//│  α65 :> [[[Bool]]] with ub(α65 <: [[[Bool]]]) length: 4
//│ UT α65 <: [[[Bool]]] len: 5 
//│  α65 :> [[[Bool]]] with ub(α65 <: [[[Bool]]]) length: 4
//│ UT α65 <: [[[Bool]]] len: 5 
//│ α64 bounds
//│  α64 <: [[[[Int]]]] with lb([[[[Int]]]] <: α64) length: 5
//│ UT α64 <: [[[[Int]]]] len: 6 
//│ | UT  Int with
//│ | UT  [[[[Int]]]] <: α64 <: Int
//│ | UT [[[[Int]]]] <: [[[[Int]]]] len: 11 
//│ | | U [[[[Int]]]] = [[[[Int]]]] because lb([[[[Int]]]] <: [[[[Int]]]]) skipCache
//│ | UT  Int with
//│ | UT  α64 += ([[[[Int]]]],List(ub(α64 <: [[[[Int]]]])))
//│  α64 :> [[[[Int]]]] with ub(α64 <: [[[[Int]]]]) length: 5
//│ UT α64 <: [[[[Int]]]] len: 6 
//│ α61' bounds
//│  α61' <: [[[Bool]]] with lb([[[Bool]]] <: α61') length: 4
//│ UT α61' <: [[[Bool]]] len: 5 
//│ | UT  Bool with
//│ | UT  [[[Bool]]] <: α61' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  [[[Bool]]] <: α61' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  α61' += ([[[Bool]]],List(ub(α61' <: [[[Bool]]])))
//│  α61' <: [[[Bool]]] with lb([[[Bool]]] <: α61') length: 4
//│ UT α61' <: [[[Bool]]] len: 5 
//│  α61' :> [[[Bool]]] with ub(α61' <: [[[Bool]]]) length: 4
//│ UT α61' <: [[[Bool]]] len: 5 
//│  α61' :> [[[Bool]]] with ub(α61' <: [[[Bool]]]) length: 4
//│ UT α61' <: [[[Bool]]] len: 5 
//│ α60' bounds
//│ α57' bounds
//│  α57' <: [[[Bool]]] with lb([[[Bool]]] <: α57') length: 4
//│ UT α57' <: [[[Bool]]] len: 5 
//│ | UT  Bool with
//│ | UT  [[[Bool]]] <: α57' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  [[[Bool]]] <: α57' <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  α57' += ([[[Bool]]],List(ub(α57' <: [[[Bool]]])))
//│  α57' <: [[[Bool]]] with lb([[[Bool]]] <: α57') length: 4
//│ UT α57' <: [[[Bool]]] len: 5 
//│  α57' :> [[[Bool]]] with ub(α57' <: [[[Bool]]]) length: 4
//│ UT α57' <: [[[Bool]]] len: 5 
//│  α57' :> [[[Bool]]] with ub(α57' <: [[[Bool]]]) length: 4
//│ UT α57' <: [[[Bool]]] len: 5 
//│ α56' bounds
//│ ╔══[WARNING] ?a is unified with bool because ub(α65 <: [[[Bool]]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `then` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with int because ub(α64 <: [[[[Int]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	      ^
//│ ╟── reference
//│ ║  l.7: 	g b
//│ ║       	  ^
//│ ╟── reference
//│ ║  l.4: 	let b = a
//│ ║       	        ^
//│ ╟── integer literal
//│ ║  l.3: 	let a = 1
//│ ║       	        ^
//│ ╟── integer literal
//│ ║  l.3: 	let a = 1
//│ ╙──     	        ^
//│ ╔══[WARNING] ?a is unified with bool because ub(α61' <: [[[Bool]]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `then` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with bool because ub(α57' <: [[[Bool]]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `then` branch
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	                    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with bool because ub(α56' <: Bool))
//│ ║  
//│ ╟── variable
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	      ^
//│ ╟── if-then-else condition
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	             ^
//│ ╙── type
//│ a: int
//│ b: int
//│ f: bool -> bool
//│ g: bool -> bool
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟── this integer literal has type `int`
//│ ║  l.3: 	let a = 1
//│ ║       	        ^
//│ ╟── this reference has type `int`
//│ ║  l.4: 	let b = a
//│ ║       	        ^
//│ ╟── this reference has type `int`
//│ ║  l.7: 	g b
//│ ║       	  ^
//│ ╟── this variable has type `bool`
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	      ^
//│ ╟── this if-then-else condition has type `bool`
//│ ║  l.5: 	let f x = if x then true else false
//│ ║       	             ^
//│ ╙── `bool` comes from this type expression
//│ res: bool

:d
:unifyDbg
let a = 1
let b = a
let f x y = if y then x else "x"
let g = f
g b true
//│ 1. Typing term 1
//│ 1. : Int
//│ ⬤ Typed as: Int
//│  where: 
//│ 1. Typing term a
//│ 1. : [Int]
//│ ⬤ Typed as: [Int]
//│  where: 
//│ 1. Typing term x => y => if y(true) then x then (false) then "x"
//│ | 1. Typing pattern x
//│ | 1. : α68'
//│ | 1. Typing term y => if y(true) then x then (false) then "x"
//│ | | 1. Typing pattern y
//│ | | 1. : α69'
//│ | | 1. Typing term if y(true) then x then (false) then "x"
//│ | | | If(Var(y), List(IfThen(Var(true), Var(x), IfThen(Var(false), StrLit(x)))
//│ | | | 1. Typing term y
//│ | | | 1. : [α69']
//│ | | | CONSTRAIN [α69'] <! Bool
//│ | | |   where 
//│ | | | C [α69'] <! Bool    (0) where ProvType <: TypeRef}
//│ | | | | C α69' <! Bool    (0) where TypeVariable <: TypeRef}
//│ | | | UT [α69'] <: Bool len: 3 
//│ | | | | UT  Bool with
//│ | | | | UT  α69' += (Bool,List(ub(α69' <: Bool)))
//│ | | | 1. Typing term x
//│ | | | 1. : [α68']
//│ | | | CONSTRAIN [α68'] <! α70'
//│ | | |   where 
//│ | | | C [α68'] <! α70'    (0) where ProvType <: TypeVariable}
//│ | | | | C α68' <! α70'    (0) where TypeVariable <: TypeVariable}
//│ | | | UT [α68'] <: α70' len: 3 
//│ | | | | UT  α70' with
//│ | | | | UT  α68' += (α70',List(ub(α68' <: α70')))
//│ | | | 1. Typing term "x"
//│ | | | 1. : String
//│ | | | CONSTRAIN String <! α70'
//│ | | |   where 
//│ | | | C String <! α70'    (0) where TypeRef <: TypeVariable}
//│ | | | UT String <: α70' len: 2 
//│ | | | | UT  String with
//│ | | | | UT  α70' += (String,List(lb(String <: α70')))
//│ | | 1. : α70'
//│ | 1. : (α69' -> α70')
//│ 1. : (α68' -> (α69' -> α70'))
//│ ⬤ Typed as: (α68' -> (α69' -> α70'))
//│  where: 
//│ 		α68' <: [[[α70']]]
//│ 		α69' <: [[[Bool]]]
//│ 		α70' :> [[String]]
//│ 1. Typing term f
//│ 1. : [(α76' -> (α78' -> α77'))]
//│ ⬤ Typed as: [(α76' -> (α78' -> α77'))]
//│  where: 
//│ 		α76' <: [[[α77']]]
//│ 		α77' :> [[String]]
//│ 		α78' <: [[[Bool]]]
//│ 0. Typing term g b true
//│ | 0. Typing term g b
//│ | | 0. Typing term g
//│ | | 0. : [[(α84 -> (α86 -> α85))]]
//│ | | 0. Typing term b
//│ | | 0. : [[Int]]
//│ | | CONSTRAIN [[Int]] <! α84
//│ | |   where 
//│ 		α84 <: [[[α85]]]
//│ 		α85 :> [[String]]
//│ | | C [[Int]] <! α84    (0) where ProvType <: TypeVariable}
//│ | | | C [Int] <! α84    (0) where ProvType <: TypeVariable}
//│ | | | | C Int <! α84    (0) where TypeRef <: TypeVariable}
//│ | | | | | C Int <! [[[α85]]]    (1) where TypeRef <: ProvType}
//│ | | | | | | C Int <! [[α85]]    (1) where TypeRef <: ProvType}
//│ | | | | | | | C Int <! [α85]    (1) where TypeRef <: ProvType}
//│ | | | | | | | | C Int <! α85    (1) where TypeRef <: TypeVariable}
//│ | | UT [[Int]] <: α84 len: 4 
//│ | | | UT  [[Int]] with
//│ | | | UT  [[Int]] <: α84 <: [[[α85]]]
//│ | | | UT [[Int]] <: [[[α85]]] len: 8 
//│ | | | | UT  [[Int]] with
//│ | | | | UT  α85 += ([[Int]],List(lb([[Int]] <: α85)))
//│ | | | UT  [[Int]] with
//│ | | | UT  α84 += ([[Int]],List(lb([[Int]] <: α84)))
//│ | 0. : [(α86 -> α85)]
//│ | 0. Typing term true
//│ | 0. : [Bool]
//│ | CONSTRAIN [Bool] <! α86
//│ |   where 
//│ 		α86 <: [[[Bool]]]
//│ | C [Bool] <! α86    (0) where ProvType <: TypeVariable}
//│ | | C Bool <! α86    (0) where TypeRef <: TypeVariable}
//│ | | | C Bool <! [[[Bool]]]    (1) where TypeRef <: ProvType}
//│ | UT [Bool] <: α86 len: 3 
//│ | | UT  [Bool] with
//│ | | UT  [Bool] <: α86 <: [[[Bool]]]
//│ | | UT [Bool] <: [[[Bool]]] len: 7 
//│ | | | U [Bool] = [[[Bool]]] because lb([Bool] <: [[[Bool]]]) skipCache
//│ | | UT  [Bool] with
//│ | | UT  α86 += ([Bool],List(lb([Bool] <: α86)))
//│ 0. : [α85]
//│ ⬤ Typed as: [α85]
//│  where: 
//│ 		α85 :> [[[[[[[Int]]]]]]] | [[String]]
//│ unified α88 with:
//│ unified α87 with:
//│ unified α86 with:
//│   [Bool]: lb([Bool] <: α86)
//│ unified α85 with:
//│   [[Int]]: lb([[Int]] <: α85)
//│ unified α84 with:
//│   [[Int]]: lb([[Int]] <: α84)
//│ unified α78' with:
//│ unified α77' with:
//│ unified α76' with:
//│ unified α70' with:
//│   String: lb(String <: α70')
//│ unified α69' with:
//│   Bool: ub(α69' <: Bool)
//│ unified α68' with:
//│   α70': ub(α68' <: α70')
//│ α88 bounds
//│ α87 bounds
//│ α86 bounds
//│  α86 <: [[[Bool]]] with lb([[[Bool]]] <: α86) length: 4
//│ UT α86 <: [[[Bool]]] len: 5 
//│ | UT  Bool with
//│ | UT  [[[Bool]]] <: α86 <: Bool
//│ | UT [[[Bool]]] <: [[[Bool]]] len: 9 
//│ | UT  Bool with
//│ | UT  α86 <: [[[Bool]]]  for lb([Bool] <: α86)
//│ | U [[[Bool]]] = [[[Bool]]] because lb([Bool] <: α86), ub(α86 <: [[[Bool]]]) ()
//│ | UT  α86 += ([[[Bool]]],List(ub(α86 <: [[[Bool]]])))
//│  α86 :> [[[Bool]]] with ub(α86 <: [[[Bool]]]) length: 4
//│ UT α86 <: [[[Bool]]] len: 5 
//│ α85 bounds
//│  α85 <: [[[[[[[Int]]]]]]] with lb([[[[[[[Int]]]]]]] <: α85) length: 8
//│ UT α85 <: [[[[[[[Int]]]]]]] len: 9 
//│ | UT  Int with
//│ | UT  [[[[[[[Int]]]]]]] <: α85 <: Int
//│ | UT [[[[[[[Int]]]]]]] <: [[[[[[[Int]]]]]]] len: 17 
//│ | UT  [[String]] <: α85 <: Int
//│ | UT [[String]] <: [[[[[[[Int]]]]]]] len: 12 
//│ | | U [[String]] = [[[[[[[Int]]]]]]] because lb([[String]] <: [[[[[[[Int]]]]]]]) skipCache
//│ | | | UERR  [[String]] = [[[[[[[Int]]]]]]] because lb([[String]] <: [[[[[[[Int]]]]]]])
//│ ╔══[ERROR] Type `string` does not match `int`
//│ ║  
//│ ╟── this `else` branch has type `string`
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── this if-then-else expression has type `string`
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `int`
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── this `then` branch has type `int`
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	                      ^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `int`
//│ ║  l.164: 	g b true
//│ ║         	  ^
//│ ╟── this reference has type `int`
//│ ║  l.161: 	let b = a
//│ ║         	        ^
//│ ╟── this integer literal has type `int`
//│ ║  l.160: 	let a = 1
//│ ╙──       	        ^
//│ | UT  α85 += ([[[[[[[Int]]]]]]],List(ub(α85 <: [[[[[[[Int]]]]]]])))
//│  α85 <: [[String]] with lb([[String]] <: α85) length: 3
//│ UT α85 <: [[String]] len: 4 
//│ | UT  String with
//│ | UT  [[[[[[[Int]]]]]]] <: α85 <: String
//│ | UT [[[[[[[Int]]]]]]] <: [[String]] len: 12 
//│ | UT  [[String]] <: α85 <: String
//│ | UT [[String]] <: [[String]] len: 7 
//│ | | U [[String]] = [[String]] because lb([[String]] <: [[String]]) skipCache
//│ | UT  α85 += ([[String]],List(ub(α85 <: [[String]])))
//│  α85 :> [[[[[[[Int]]]]]]] with ub(α85 <: [[[[[[[Int]]]]]]]) length: 8
//│ UT α85 <: [[[[[[[Int]]]]]]] len: 9 
//│  α85 :> [[String]] with ub(α85 <: [[String]]) length: 3
//│ UT α85 <: [[String]] len: 4 
//│ α84 bounds
//│  α84 <: [[[[Int]]]] with lb([[[[Int]]]] <: α84) length: 5
//│ UT α84 <: [[[[Int]]]] len: 6 
//│ | UT  Int with
//│ | UT  [[[[Int]]]] <: α84 <: Int
//│ | UT [[[[Int]]]] <: [[[[Int]]]] len: 11 
//│ | UT  Int with
//│ | UT  α84 += ([[[[Int]]]],List(ub(α84 <: [[[[Int]]]])))
//│  α84 :> [[[[Int]]]] with ub(α84 <: [[[[Int]]]]) length: 5
//│ UT α84 <: [[[[Int]]]] len: 6 
//│ α78' bounds
//│ α77' bounds
//│  α77' <: [[String]] with lb([[String]] <: α77') length: 3
//│ UT α77' <: [[String]] len: 4 
//│ | UT  String with
//│ | UT  [[String]] <: α77' <: String
//│ | UT [[String]] <: [[String]] len: 7 
//│ | UT  α77' += ([[String]],List(ub(α77' <: [[String]])))
//│  α77' :> [[String]] with ub(α77' <: [[String]]) length: 3
//│ UT α77' <: [[String]] len: 4 
//│ α76' bounds
//│ α70' bounds
//│  α70' <: [[String]] with lb([[String]] <: α70') length: 3
//│ UT α70' <: [[String]] len: 4 
//│ | UT  String with
//│ | UT  [[String]] <: α70' <: String
//│ | UT [[String]] <: [[String]] len: 7 
//│ | UT  α70' += ([[String]],List(ub(α70' <: [[String]])))
//│  α70' :> [[String]] with ub(α70' <: [[String]]) length: 3
//│ UT α70' <: [[String]] len: 4 
//│ α69' bounds
//│ α68' bounds
//│ ╔══[WARNING] ?a is unified with bool because ub(α86 <: [[[Bool]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	        ^
//│ ╟── reference
//│ ║  l.164: 	g b true
//│ ║         	    ^^^^
//│ ╟── type
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with string because ub(α85 <: [[String]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ ╔══[WARNING] ?a is unified with int because ub(α85 <: [[[[[[[Int]]]]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── `then` branch
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	                      ^
//│ ╟── if-then-else expression
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── if-then-else expression
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference
//│ ║  l.164: 	g b true
//│ ║         	  ^
//│ ╟── reference
//│ ║  l.161: 	let b = a
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.160: 	let a = 1
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.160: 	let a = 1
//│ ╙──       	        ^
//│ ╔══[WARNING] ?a is unified with int because ub(α84 <: [[[[Int]]]]))
//│ ║  
//│ ╟── variable
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── reference
//│ ║  l.164: 	g b true
//│ ║         	  ^
//│ ╟── reference
//│ ║  l.161: 	let b = a
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.160: 	let a = 1
//│ ║         	        ^
//│ ╟── integer literal
//│ ║  l.160: 	let a = 1
//│ ╙──       	        ^
//│ ╔══[WARNING] ?a is unified with string because ub(α77' <: [[String]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ ╔══[WARNING] ?a is unified with string because ub(α70' <: [[String]]))
//│ ║  
//│ ╟── if-then-else expression
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── `else` branch
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	                             ^^^
//│ ╟── `else` branch
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ╙──       	                             ^^^
//│ ╔══[WARNING] ?a is unified with bool because ub(α69' <: Bool))
//│ ║  
//│ ╟── variable
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	        ^
//│ ╟── if-then-else condition
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	               ^
//│ ╙── type
//│ ╔══[WARNING] ?a is unified with ?b because ub(α68' <: α70'))
//│ ║  
//│ ╟── variable
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	      ^
//│ ╟── `then` branch
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ║         	                      ^
//│ ╟── if-then-else expression
//│ ║  l.162: 	let f x y = if y then x else "x"
//│ ╙──       	            ^^^^^^^^^^^^^^^^^^^^
//│ a: int
//│ b: int
//│ f: 'a -> bool -> (string | 'a)
//│ g: 'a -> bool -> (string | 'a)
//│ res: int | string
