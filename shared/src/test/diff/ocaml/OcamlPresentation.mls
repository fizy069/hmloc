:OcamlParser
:OcamlLoadLibrary

:unify
let boolToInt x = if x then "0" else 1
//│ ╔══[WARNING] [UNIFICATION ERROR 1] int and string cannot be unified but flows into the same location
//│ ╟── int is if-then-else false condition return type
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                                     ^
//│ ╟── string is if-then-else true condition return type
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                            ^^^
//│ ╟── both flow into if-then-else return type
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ╙──     	                  ^^^^^^^^^^^^^^^^^^^^
//│ boolToInt: bool -> (int | string)

type ('a, 'b) either = Left of 'a | Right of 'b
//│ Defined type alias either[+'a, +'b]
//│ Defined class Left[+'a]
//│ Defined class Right[+'b]
//│ Left: 'a -> either['a, nothing]
//│ Right: 'a -> either[nothing, 'a]

:unify
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ ╔══[WARNING] [UNIFICATION ERROR 1] error and int cannot be unified but flows into the same location
//│ ╟── error is operator application
//│ ║  l.28: 	 | Right r -> r && true
//│ ║        	              ^^^^^^^^^^
//│ ╟── int is type reference
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── both flow into match-case return type
//│ ║  l.26: 	let destructEither x = match x with
//│ ║        	                       ^^^^^^^^^^^^
//│ ║  l.27: 	 | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.28: 	 | Right r -> r && true
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[WARNING] [UNIFICATION ERROR 0] bool -> ?a and error cannot be unified but flows into the same location [([[Bool]] -> α88')] = [[error<>]] because α87' <: [([[Bool]] -> α88')] and α87' :> [[error<>]]
//│ ╟── bool -> ?b is used as operator application
//│ ║  l.28: 	 | Right r -> r && true
//│ ║        	              ^^^^
//│ ╟── error is used as operator application
//│ ║  l.28: 	 | Right r -> r && true
//│ ╙──      	              ^^^^
//│ ╔══[ERROR] identifier not found: &&
//│ ║  l.28: 	 | Right r -> r && true
//│ ╙──      	                ^^
//│ destructEither: either[int, error] -> (error | int)

:unify
let destructEither x = if x
  then match x with
    | Left l -> l + 1
    | Right r -> r - 1
  else x
//│ ╔══[WARNING] [UNIFICATION ERROR 1] either[?a, ?b] and bool cannot be unified but flows into the same location
//│ ╟── either[?a0, ?b0] is match-case condition type
//│ ║  l.57: 	  then match x with
//│ ║        	             ^
//│ ╟── bool is if-then-else condition type
//│ ║  l.56: 	let destructEither x = if x
//│ ╙──      	                          ^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] bool and int cannot be unified but flows into the same location [[[Bool]]] = [[[[[Int]]]]] because [[[α98']]] & [[[Bool]]] :> α97' and α98' :> [[[[[Int]]]]]
//│ ╟── bool is used as if-then-else condition type
//│ ║  l.56: 	let destructEither x = if x
//│ ║        	                          ^
//│ ╟── int is type reference
//│ ║  l.17: 	let (-): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is if-then-else return type
//│ ║  l.56: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.57: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.58: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.59: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.60: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── The following tvars cannot be resolved: 
//│ ╟── ?a is if-then-else return type
//│ ║  l.56: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.57: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.58: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.59: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.60: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── ?b is if-then-else false condition return type
//│ ║  l.60: 	  else x
//│ ╙──      	       ^^
//│ ╔══[WARNING] [UNIFICATION ERROR 2] either[?a, ?b] and int cannot be unified but flows into the same location [[[either['a99','b100']]]] = [[[[[Int]]]]] because [[[α98']]] & [[[either['a99','b100']]]] :> α97' and α98' :> [[[[[Int]]]]]
//│ ╟── either[?a0, ?b0] is used as reference
//│ ║  l.57: 	  then match x with
//│ ║        	             ^
//│ ╟── int is type reference
//│ ║  l.17: 	let (-): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── int is if-then-else return type
//│ ║  l.56: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.57: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.58: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.59: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.60: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── The following tvars cannot be resolved: 
//│ ╟── ?c is if-then-else return type
//│ ║  l.56: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.57: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.58: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.59: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.60: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── ?d is if-then-else false condition return type
//│ ║  l.60: 	  else x
//│ ╙──      	       ^^
//│ destructEither: (either[int, int] & bool & 'a) -> (int | 'a)
