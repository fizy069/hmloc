:OcamlParser
:OcamlLoadLibrary

:unify
let boolToInt x = if x then "0" else 1
//│ ╔══[WARNING] Type `int` does not match `string`
//│ ╟── int ---> ?a <--- string
//│ ╟── else branch has type `int`
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                                     ^
//│ ╟── else branch has type `int`
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                                     ^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `string`
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── then branch has type `string`
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ║       	                            ^^^
//│ ╟── then branch has type `string`
//│ ║  l.5: 	let boolToInt x = if x then "0" else 1
//│ ╙──     	                            ^^^
//│ boolToInt: bool -> (int | string)

type ('a, 'b) either = Left of 'a | Right of 'b
//│ Defined type alias either[+'a, +'b]
//│ Defined class Left[+'a]
//│ Defined class Right[+'b]
//│ Left: 'a -> either['a, nothing]
//│ Right: 'a -> either[nothing, 'a]

:unify
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ ╔══[WARNING] Type `bool` does not match `int`
//│ ╟── bool ---> ?a <--- int
//│ ╟── `bool` is found here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ║        	                          ^^^^
//│ ╟── `bool` is found here
//│ ║  l.54: 	let (&&): bool -> bool -> bool
//│ ║        	                          ^^^^
//│ ╟── operator application `bool`
//│ ║  l.41: 	 | Right r -> r && true
//│ ║        	              ^^^^^^^^^^
//│ ╟── this match expression has type `bool`
//│ ║  l.39: 	let destructEither x = match x with
//│ ║        	                       ^^^^^^^^^^^^
//│ ║  l.40: 	 | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	 | Right r -> r && true
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?b`
//│ ║  l.39: 	let destructEither x = match x with
//│ ║        	                       ^^^^^^^^^^^^
//│ ║  l.40: 	 | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	 | Right r -> r && true
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `int`
//│ ║  l.39: 	let destructEither x = match x with
//│ ║        	                       ^^^^^^^^^^^^
//│ ║  l.40: 	 | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	 | Right r -> r && true
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application `int`
//│ ║  l.40: 	 | Left l -> l + 1
//│ ║        	             ^^^^^
//│ ╟── `int` is found here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── `int` is found here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	                       ^^^
//│ destructEither: either[int, bool] -> (bool | int)

:unify
let destructEither x = if x
  then match x with
    | Left l -> l + 1
    | Right r -> r - 1
  else x
//│ ╔══[WARNING] Type `either[?a, ?b]` does not match `bool`
//│ ╟── either[?a0, ?b0] <--- ?c ---> bool
//│ ╟── this case expression has type `either[?a1, ?b1]`
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	      ^^^^
//│ ╟── this match condition has type `either[?a2, ?b2]`
//│ ║  l.87: 	  then match x with
//│ ║        	             ^
//│ ╟── this case expression has type `either[?a3, ?b3]`
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	      ^^^^
//│ ╟── reference `either[?a4, ?b4]`
//│ ║  l.87: 	  then match x with
//│ ║        	             ^
//│ ╟── this if condition has type `bool`
//│ ║  l.86: 	let destructEither x = if x
//│ ╙──      	                          ^
//│ ╔══[WARNING] Type `bool` does not match `int`
//│ ╟── bool <--- ?a ---> ?b <--- int
//│ ╟── this if condition has type `bool`
//│ ║  l.86: 	let destructEither x = if x
//│ ║        	                          ^
//│ ╟── else branch has type `?c`
//│ ║  l.90: 	  else x
//│ ║        	       ^^
//│ ╟── this if-then-else expression has type `?d`
//│ ║  l.86: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.87: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.90: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── this if-then-else expression has type `?e`
//│ ║  l.86: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.87: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.90: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.86: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.87: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.90: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── this match expression has type `int`
//│ ║  l.87: 	  then match x with
//│ ║        	       ^^^^^^^^^^^^
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application `int`
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	                 ^^^^^
//│ ╟── `int` is found here
//│ ║  l.17: 	let (-): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── `int` is found here
//│ ║  l.17: 	let (-): int -> int -> int
//│ ╙──      	                       ^^^
//│ ╔══[WARNING] Type `either[?a, ?b]` does not match `int`
//│ ╟── either[?a0, ?b0] <--- ?c ---> ?d <--- int
//│ ╟── this case expression has type `either[?a1, ?b1]`
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	      ^^^^
//│ ╟── this match condition has type `either[?a2, ?b2]`
//│ ║  l.87: 	  then match x with
//│ ║        	             ^
//│ ╟── this case expression has type `either[?a3, ?b3]`
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	      ^^^^
//│ ╟── reference `either[?a4, ?b4]`
//│ ║  l.87: 	  then match x with
//│ ║        	             ^
//│ ╟── else branch has type `?e`
//│ ║  l.90: 	  else x
//│ ║        	       ^^
//│ ╟── this if-then-else expression has type `?f`
//│ ║  l.86: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.87: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.90: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── this if-then-else expression has type `?g`
//│ ║  l.86: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.87: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.90: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.86: 	let destructEither x = if x
//│ ║        	                       ^^^^
//│ ║  l.87: 	  then match x with
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.90: 	  else x
//│ ║        	^^^^^^^^^
//│ ╟── this match expression has type `int`
//│ ║  l.87: 	  then match x with
//│ ║        	       ^^^^^^^^^^^^
//│ ║  l.88: 	    | Left l -> l + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application `int`
//│ ║  l.89: 	    | Right r -> r - 1
//│ ║        	                 ^^^^^
//│ ╟── `int` is found here
//│ ║  l.17: 	let (-): int -> int -> int
//│ ║        	                       ^^^
//│ ╟── `int` is found here
//│ ║  l.17: 	let (-): int -> int -> int
//│ ╙──      	                       ^^^
//│ destructEither: (either[int, int] & bool & 'a) -> (int | 'a)

:unify
1 + 1.0
//│ ╔══[WARNING] Type `int` does not match `float`
//│ ╟── float ---> int
//│ ╟── decimal literal `float`
//│ ║  l.234: 	1 + 1.0
//│ ║         	    ^^^
//│ ╟── argument `float`
//│ ║  l.234: 	1 + 1.0
//│ ║         	    ^^^
//│ ╟── `int` is found here
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.234: 	1 + 1.0
//│ ║         	^^^^^^^
//│ ╟── decimal literal of type `float` is not an instance of `int`
//│ ║  l.234: 	1 + 1.0
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.16: 	let (+): int -> int -> int
//│ ╙──      	                ^^^
//│ res: int
