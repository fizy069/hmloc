:AllowTypeErrors

let boolToInt x = if x then "0" else 1
//│ boolToInt: bool -> (int | string)
//│ U max: 4, total: 7
//│ UERR 1 errors
//│ L: 0 [string ~ [[int]], [[string]] <: α68', [[int]] <: α68']



// TODO add Left definition location to pattern type
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ destructEither: either[int, bool] -> (bool | int)
//│ U max: 5, total: 11
//│ UERR 1 errors
//│ L: 0 [int ~ [[[bool]]], [[[int]]] <: α72', [[[bool]]] <: α72']


let destructEither x = if x then
  match x with
   | Left l -> l + 1
   | Right r -> r && true
  else x
//│ destructEither: bool -> (bool | int)
//│ U max: 10, total: 22
//│ UERR 3 errors
//│ L: 0 [int ~ [[[[either['a86','b87']]]]], [[[[int]]]] <: α84', [[[α83']]] <: α84', α83' <: [[[[either['a86','b87']]]]]]
//│ L: 0 [[[[[either['a86','b87']]]]] ~ bool, α83' <: [[[[either['a86','b87']]]]], α83' <: [[[bool]]]]
//│ L: 0 [int ~ [[[bool]]], [[[int]]] <: α85', [[[bool]]] <: α85']

let succ: int -> int
  
let test2 x = match x with
 | true -> succ x
//│ succ: int -> int
//│ test2: nothing -> int
//│ U max: 4, total: 6
//│ UERR 1 errors
//│ L: 0 [[[[int]]] ~ bool, α97' <: [[[int]]], α97' <: [[[[bool]]]]]

let g x = (not x, (if true then x else 5))
//│ g: (bool & 'a) -> (bool, int | 'a,)
//│ U max: 5, total: 9
//│ UERR 1 errors
//│ L: 0 [bool ~ [[int]], α102' <: [[[bool]]], [[[α102']]] <: α104', [[int]] <: α104']

// Jonathan
let confluence z = if true then z else 5
let mkpair x y = (x, confluence y)
  
let conflict x = mkpair (not x) x
//│ confluence: 'a -> (int | 'a)
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)
//│ conflict: (bool & 'a) -> (bool, int | 'a,)
//│ U max: 18, total: 33
//│ UERR 1 errors
//│ L: 0 [int ~ [[[bool]]], [[int]] <: α131', [[[[[[[α128']]]]]]] <: α131', α128' <: [[[bool]]]]

let test =
  let f x = x in
  (f 1, f true)
//│ test: (bool | int, bool | int,)
//│ U max: 3, total: 5
//│ UERR 1 errors
//│ L: 0 [int ~ [[[bool]]], [[int]] <: α143', [[[bool]]] <: α143']



let wrap x = x :: []
let rec t = wrap (if true then 1 else t)
//│ wrap: 'a -> list['a]
//│ t: 't
//│   where
//│     't :> list[int | 't]
//│ U max: 18, total: 27
//│ UERR 1 errors
//│ L: 0 [int ~ [[[[[[list['a158']]]]]]], [[int]] <: α160', [[[[[[list['a158']]]]]]] <: α160']

let rec length ls = match ls with | hd :: tl -> 1 + length tl | [] -> 0
let weird x = (x + 1, length x)
//│ length: list[?] -> int
//│ weird: nothing -> (int, int,)
//│ U max: 21, total: 66
//│ UERR 2 errors
//│ L: 1 [[[[int]]] ~ list['a187'], α182' <: [[[int]]], [[α182'] - ([α182'] -> α191') ~ ([list['a187']] -> α189') - [list['a187']], length185' <: [[[([α182'] -> α191')]]], length185' <: [[[([list['a187']] -> α189')]]]]]
//│ L: 0 [[[[[[[[list['a187']]]]]]]] ~ int, α182' <: [[[[[[[list['a187']]]]]]]], α182' <: [[[int]]]]


let len ls = match ls with | "hd :: tl" -> 1 | [] -> 0
//│ len: nothing -> int
//│ U max: 4, total: 8
//│ UERR 1 errors
//│ L: 0 [[[[[list['a199']]]]] ~ string, α197' <: [[[[list['a199']]]]], α197' <: [[[string]]]]
