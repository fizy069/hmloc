:AllowTypeErrors

let boolToInt x = if x then "0" else 1
//│ ╔══[ERROR] Type `int` does not match `string`
//│ ║  
//│ ╟──        int ---> ?a <--- string 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1: 	let boolToInt x = if x then "0" else 1
//│ ║       	                                     ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `string` and it flows into `?a`
//│ ║  l.1: 	let boolToInt x = if x then "0" else 1
//│ ╙──     	                            ^^^
//│ boolToInt: bool -> (int | string)



// TODO add Left definition location to pattern type
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ║  builtin: 	let (&&): bool -> bool -> bool
//│ ║           	                          ^^^^
//│ ╟── this operator application has type `bool` and it flows into `?a`
//│ ║  l.3: 	 | Right r -> r && true
//│ ║       	              ^^^^^^^^^^
//│ ╟── this match expression has type `?a`
//│ ║  l.1: 	let destructEither x = match x with
//│ ║       	                       ^^^^^^^^^^^^
//│ ║  l.2: 	 | Left l -> l + 1 ...
//│ ║       	^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?a` and it flows from `int`
//│ ║  l.2: 	 | Left l -> l + 1
//│ ║       	             ^^^^^
//│ ╟── this type reference has type `int`
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	                       ^^^
//│ destructEither: either[int, bool] -> (bool | int)


let destructEither x = if x then
  match x with
   | Left l -> l + 1
   | Right r -> r && true
  else x
//│ ╔══[ERROR] Type `(?a, ?b) either` does not match `bool`
//│ ║  
//│ ╟──        (?a, ?b) either <--- ?c ---> bool 
//│ ║  
//│ ╟── this pattern has type `(?a, ?b) either`
//│ ║  l.3: 	   | Left l -> l + 1
//│ ║       	     ^^^^
//│ ╟── this reference has type `(?a, ?b) either` and it flows from `?c`
//│ ║  l.2: 	  match x with
//│ ║       	        ^
//│ ╟── this variable has type `?c`
//│ ║  l.1: 	let destructEither x = if x then
//│ ║       	                   ^
//│ ╟── this if-then-else condition has type `?c` and it flows into `bool`
//│ ║  l.1: 	let destructEither x = if x then
//│ ╙──     	                          ^
//│ ╔══[ERROR] Type `int` does not match `(?a, ?b) either`
//│ ║  
//│ ╟──        int ---> ?c <--- ?d ---> (?a, ?b) either 
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ║           	                       ^^^
//│ ╟── this operator application has type `int`
//│ ║  l.3: 	   | Left l -> l + 1
//│ ║       	               ^^^^^
//│ ╟── this match expression has type `int` and it flows into `?c`
//│ ║  l.2: 	  match x with
//│ ║       	  ^^^^^^^^^^^^
//│ ║  l.3: 	   | Left l -> l + 1 ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.1: 	let destructEither x = if x then
//│ ║       	                       ^^^^^^^^^
//│ ║  l.2: 	  match x with ...
//│ ║       	^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?c` and it flows from `?d`
//│ ║  l.5: 	  else x
//│ ║       	       ^^
//│ ╟── this variable has type `?d`
//│ ║  l.1: 	let destructEither x = if x then
//│ ║       	                   ^
//│ ╟── this reference has type `?d` and it flows into `(?a, ?b) either`
//│ ║  l.2: 	  match x with
//│ ║       	        ^
//│ ╟── this pattern has type `(?a, ?b) either`
//│ ║  l.3: 	   | Left l -> l + 1
//│ ╙──     	     ^^^^
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- bool 
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ║           	                       ^^^
//│ ╟── this operator application has type `int` and it flows into `?a`
//│ ║  l.3: 	   | Left l -> l + 1
//│ ║       	               ^^^^^
//│ ╟── this match expression has type `?a`
//│ ║  l.2: 	  match x with
//│ ║       	  ^^^^^^^^^^^^
//│ ║  l.3: 	   | Left l -> l + 1 ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?a` and it flows from `bool`
//│ ║  l.4: 	   | Right r -> r && true
//│ ║       	                ^^^^^^^^^
//│ ╟── this type reference has type `bool`
//│ ║  builtin: 	let (&&): bool -> bool -> bool
//│ ╙──         	                          ^^^^
//│ ╔══[ERROR] Type `bool` does not match `(?a, ?b) either`
//│ ║  
//│ ╟──        bool ---> ?c <--- ?d ---> (?a, ?b) either 
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ║  builtin: 	let (&&): bool -> bool -> bool
//│ ║           	                          ^^^^
//│ ╟── this operator application has type `bool`
//│ ║  l.4: 	   | Right r -> r && true
//│ ║       	                ^^^^^^^^^
//│ ╟── this match expression has type `bool` and it flows into `?c`
//│ ║  l.2: 	  match x with
//│ ║       	  ^^^^^^^^^^^^
//│ ║  l.3: 	   | Left l -> l + 1 ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.1: 	let destructEither x = if x then
//│ ║       	                       ^^^^^^^^^
//│ ║  l.2: 	  match x with ...
//│ ║       	^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?c` and it flows from `?d`
//│ ║  l.5: 	  else x
//│ ║       	       ^^
//│ ╟── this variable has type `?d`
//│ ║  l.1: 	let destructEither x = if x then
//│ ║       	                   ^
//│ ╟── this reference has type `?d` and it flows into `(?a, ?b) either`
//│ ║  l.2: 	  match x with
//│ ║       	        ^
//│ ╟── this pattern has type `(?a, ?b) either`
//│ ║  l.3: 	   | Left l -> l + 1
//│ ╙──     	     ^^^^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ║  builtin: 	let (&&): bool -> bool -> bool
//│ ║           	                          ^^^^
//│ ╟── this operator application has type `bool` and it flows into `?a`
//│ ║  l.4: 	   | Right r -> r && true
//│ ║       	                ^^^^^^^^^
//│ ╟── this match expression has type `?a`
//│ ║  l.2: 	  match x with
//│ ║       	  ^^^^^^^^^^^^
//│ ║  l.3: 	   | Left l -> l + 1 ...
//│ ║       	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?a` and it flows from `int`
//│ ║  l.3: 	   | Left l -> l + 1
//│ ║       	               ^^^^^
//│ ╟── this type reference has type `int`
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	                       ^^^
//│ destructEither: bool -> (bool | int)

let succ: int -> int
  
let test2 x = match x with
 | true -> succ x
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int <--- ?a ---> bool 
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  l.1: 	let succ: int -> int
//│ ║       	          ^^^
//│ ╟── this reference has type `int` and it flows from `?a`
//│ ║  l.4: 	 | true -> succ x
//│ ║       	                ^
//│ ╟── this variable has type `?a`
//│ ║  l.3: 	let test2 x = match x with
//│ ║       	          ^
//│ ╟── this reference has type `?a` and it flows into `bool`
//│ ║  l.3: 	let test2 x = match x with
//│ ║       	                    ^
//│ ╟── this pattern has type `bool`
//│ ║  l.4: 	 | true -> succ x
//│ ╙──     	   ^^^^
//│ succ: int -> int
//│ test2: nothing -> int

let g x = (not x, (if true then x else 5))
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1: 	let g x = (not x, (if true then x else 5))
//│ ║       	                                       ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1: 	let g x = (not x, (if true then x else 5))
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a` and it flows from `?b`
//│ ║  l.1: 	let g x = (not x, (if true then x else 5))
//│ ║       	                                ^
//│ ╟── this variable has type `?b`
//│ ║  l.1: 	let g x = (not x, (if true then x else 5))
//│ ║       	      ^
//│ ╟── this reference has type `?b` and it flows into `bool`
//│ ║  l.1: 	let g x = (not x, (if true then x else 5))
//│ ║       	               ^
//│ ╟── this type reference has type `bool`
//│ ║  builtin: 	let not: bool -> bool
//│ ╙──         	         ^^^^
//│ g: (bool & 'a) -> (bool, int | 'a,)

// Jonathan
let confluence z = if true then z else 5
let mkpair x y = (x, confluence y)
  
let conflict x = mkpair (not x) x
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── this variable has type `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── this reference has type `?a`
//│ ║  l.2: 	let mkpair x y = (x, confluence y)
//│ ║       	                                ^
//│ ╟── this variable has type `?a`
//│ ║  l.2: 	let mkpair x y = (x, confluence y)
//│ ║       	             ^
//│ ╟── this reference has type `?a` and it flows from `?b`
//│ ║  l.4: 	let conflict x = mkpair (not x) x
//│ ║       	                                ^
//│ ╟── this variable has type `?b`
//│ ║  l.4: 	let conflict x = mkpair (not x) x
//│ ║       	             ^
//│ ╟── this reference has type `?b` and it flows into `bool`
//│ ║  l.4: 	let conflict x = mkpair (not x) x
//│ ║       	                             ^
//│ ╟── this type reference has type `bool`
//│ ║  builtin: 	let not: bool -> bool
//│ ╙──         	         ^^^^
//│ confluence: 'a -> (int | 'a)
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)
//│ conflict: (bool & 'a) -> (bool, int | 'a,)

let test =
  let f x = x in
  (f 1, f true)
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── this reference has type `bool` and it flows into `?a`
//│ ║  l.3: 	  (f 1, f true)
//│ ║       	          ^^^^
//│ ╟── this variable has type `?a`
//│ ║  l.2: 	  let f x = x in
//│ ║       	        ^
//│ ╟── this integer literal has type `int` and it flows into `?a`
//│ ║  l.3: 	  (f 1, f true)
//│ ╙──     	     ^
//│ test: (bool | int, bool | int,)


// TODO: deduplicate errors
let wrap x = x :: []
let rec t = wrap (if true then 1 else t)
//│ ╔══[ERROR] Type `int` does not match `?a list`
//│ ║  
//│ ╟──        int ---> ?b <--- ?a list 
//│ ║  
//│ ╟── this `then` branch has type `int` and it flows into `?b`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                               ^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                                      ^
//│ ╟── this recursive binding has type `?a`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ║       	        ^
//│ ╟── this application has type `?a` and it flows from `?a list`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.1: 	let wrap x = x :: []
//│ ╙──     	             ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- int 
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.1: 	let wrap x = x :: []
//│ ║       	             ^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this recursive binding has type `?a list`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ║       	        ^
//│ ╟── this `else` branch has type `?a list` and it flows into `?b`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                                      ^
//│ ╟── this if-then-else expression has type `?b`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `int` and it flows into `?b`
//│ ║  l.2: 	let rec t = wrap (if true then 1 else t)
//│ ╙──     	                               ^
//│ wrap: 'a -> list['a]
//│ t: 't
//│   where
//│     't :> list[int | 't]
