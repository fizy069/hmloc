:AllowTypeErrors

let boolToInt x = if x then "0" else 1
//│ [ERROR] Type `int` does not match `string`
//│ 
//│         (int) ---> (?a) <--- (string)
//│ 
//│ ◉ (int) comes from
//│ │  - l.1  let boolToInt x = if x then "0" else 1
//│ │                                              ^
//│ │  - l.1  let boolToInt x = if x then "0" else 1
//│ │                           ^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.1  let boolToInt x = if x then "0" else 1
//│ │                           ^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (string) comes from
//│    - l.1  let boolToInt x = if x then "0" else 1
//│                                       ^^^
//│ boolToInt: bool -> 'a
//│   where
//│     'a = int, string
//│ U max: 1, total: 4
//│ UERR 1 errors
//│ L: 0 [int ~ string, int <: α65', α65' :> string]



// TODO add Left definition location to pattern type
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) ---> (?a) <--- (int)
//│ 
//│ ◉ (bool) comes from
//│ │  - lib. let (&&): bool -> bool -> bool
//│ │                                   ^^^^
//│ │  - l.3   | Right r -> r && true
//│ │                       ^^^^^^^^^^
//│ │  - l.1  let destructEither x = match x with
//│ │                                ^^^^^^^^^^^^
//│ │          | Left l -> l + 1 ...
//│ │          ^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.1  let destructEither x = match x with
//│ │                                ^^^^^^^^^^^^
//│ │          | Left l -> l + 1 ...
//│ │          ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2   | Left l -> l + 1
//│ │                      ^^^^^
//│ │ 
//│ ◉ (int) comes from
//│    - lib. let (+): int -> int -> int
//│                                  ^^^
//│ destructEither: either[int, bool] -> 'a
//│   where
//│     'a = bool, int
//│ U max: 1, total: 8
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool <: α67', α67' :> int]


let destructEither x = if x then
  match x with
   | Left l -> l + 1
   | Right r -> r && true
  else x
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) ---> (?a) <--- (int)
//│ 
//│ ◉ (bool) comes from
//│ │  - lib. let (&&): bool -> bool -> bool
//│ │                                   ^^^^
//│ │  - l.4     | Right r -> r && true
//│ │                         ^^^^^^^^^
//│ │  - l.2    match x with
//│ │           ^^^^^^^^^^^^
//│ │            | Left l -> l + 1 ...
//│ │            ^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.2    match x with
//│ │           ^^^^^^^^^^^^
//│ │            | Left l -> l + 1 ...
//│ │            ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3     | Left l -> l + 1
//│ │                        ^^^^^
//│ │ 
//│ ◉ (int) comes from
//│    - lib. let (+): int -> int -> int
//│                                  ^^^
//│ [ERROR] Type `bool` does not match `(_, _) either`
//│ 
//│         (bool) <--- (?a) ---> ((_, _) either)
//│ 
//│ ◉ (bool) comes from
//│ ▲  - l.1  let destructEither x = if x then
//│ │                                   ^
//│ │  - l.1  let destructEither x = if x then
//│ │                            ^
//│ │ 
//│ ◉ (?a) is assumed for
//│ │  - l.1  let destructEither x = if x then
//│ │                            ^
//│ │  - l.2    match x with
//│ │                 ^
//│ ▼ 
//│ ◉ ((_, _) either) comes from
//│    - l.3     | Left l -> l + 1
//│                ^^^^^^
//│ [ERROR] Type `(_, _) either` does not match `int`
//│ 
//│         ((_, _) either) <--- (?a) ---> (?b) <--- (?c) <--- (int)
//│ 
//│ ◉ ((_, _) either) comes from
//│ ▲  - l.3     | Left l -> l + 1
//│ │              ^^^^^^
//│ │  - l.2    match x with
//│ │                 ^
//│ │  - l.1  let destructEither x = if x then
//│ │                            ^
//│ │ 
//│ ◉ (?a) is assumed for
//│ │  - l.1  let destructEither x = if x then
//│ │                            ^
//│ │  - l.5    else x
//│ │                ^^
//│ │  - l.1  let destructEither x = if x then
//│ │                                ^^^^^^^^^
//│ │           match x with ...
//│ │           ^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.1  let destructEither x = if x then
//│ │                                ^^^^^^^^^
//│ │           match x with ...
//│ │           ^^^^^^^^^^^^^^^^
//│ │  - l.2    match x with
//│ │           ^^^^^^^^^^^^
//│ │            | Left l -> l + 1 ...
//│ │            ^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed for
//│ ▲  - l.2    match x with
//│ │           ^^^^^^^^^^^^
//│ │            | Left l -> l + 1 ...
//│ │            ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3     | Left l -> l + 1
//│ │                        ^^^^^
//│ │ 
//│ ◉ (int) comes from
//│    - lib. let (+): int -> int -> int
//│                                  ^^^
//│ destructEither: 'a -> 'a
//│   where
//│     'a = either[int, bool], bool
//│ U max: 2, total: 17
//│ UERR 3 errors
//│ L: 0 [bool ~ int, bool <: α76', α76' :> int]
//│ L: 0 [bool ~ either['a77','b78'], bool :> α74', α74' <: either['a77','b78']]
//│ L: 0 [either['a77','b78'] ~ int, either['a77','b78'] :> α74', α74' <: α75', α75' :> α76', α76' :> int]

let succ: int -> int
  
let test2 x = match x with
 | true -> succ x
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) <--- (?a) ---> (int)
//│ 
//│ ◉ (bool) comes from
//│ ▲  - l.4   | true -> succ x
//│ │            ^^^^
//│ │  - l.3  let test2 x = match x with
//│ │                             ^
//│ │  - l.3  let test2 x = match x with
//│ │                   ^
//│ │ 
//│ ◉ (?a) is assumed for
//│ │  - l.3  let test2 x = match x with
//│ │                   ^
//│ │  - l.4   | true -> succ x
//│ │                         ^
//│ ▼ 
//│ ◉ (int) comes from
//│    - l.1  let succ: int -> int
//│                     ^^^
//│ succ: int -> int
//│ test2: 'a -> int
//│   where
//│     'a = int, bool
//│ U max: 1, total: 4
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool :> α84', α84' <: int]

let g x = (not x, (if true then x else 5))
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) ---> (?a) <--- (?b) ---> (bool)
//│ 
//│ ◉ (int) comes from
//│ │  - l.1  let g x = (not x, (if true then x else 5))
//│ │                                                ^
//│ │  - l.1  let g x = (not x, (if true then x else 5))
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.1  let g x = (not x, (if true then x else 5))
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let g x = (not x, (if true then x else 5))
//│ │                                         ^
//│ │  - l.1  let g x = (not x, (if true then x else 5))
//│ │               ^
//│ │ 
//│ ◉ (?b) is assumed for
//│ │  - l.1  let g x = (not x, (if true then x else 5))
//│ │               ^
//│ │  - l.1  let g x = (not x, (if true then x else 5))
//│ │                        ^
//│ ▼ 
//│ ◉ (bool) comes from
//│    - lib. let not: bool -> bool
//│                    ^^^^
//│ g: 'a -> (bool, 'a,)
//│   where
//│     'a = int, bool
//│ U max: 2, total: 7
//│ UERR 1 errors
//│ L: 0 [int ~ bool, int <: α89', α89' :> α87', α87' <: bool]

// Jonathan
let confluence z = if true then z else 5
let mkpair x y = (x, confluence y)
  
let conflict x = mkpair (not x) x
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) <--- (?a) ---> (?b) ---> (?c) ---> (?d) <--- (int)
//│ 
//│ ◉ (bool) comes from
//│ ▲  - lib. let not: bool -> bool
//│ │                  ^^^^
//│ │  - l.4  let conflict x = mkpair (not x) x
//│ │                                      ^
//│ │  - l.4  let conflict x = mkpair (not x) x
//│ │                      ^
//│ │ 
//│ ◉ (?a) is assumed for
//│ │  - l.4  let conflict x = mkpair (not x) x
//│ │                      ^
//│ │  - l.4  let conflict x = mkpair (not x) x
//│ │                                         ^
//│ │  - l.2  let mkpair x y = (x, confluence y)
//│ │                      ^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.2  let mkpair x y = (x, confluence y)
//│ │                      ^
//│ │  - l.2  let mkpair x y = (x, confluence y)
//│ │                                         ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                        ^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                        ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                                         ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│ ▲  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) comes from
//│    - l.1  let confluence z = if true then z else 5
//│                                                  ^
//│ confluence: int -> int
//│ mkpair: 'a -> 'b -> ('a, int,)
//│ conflict: bool -> (bool, 'a,)
//│   where
//│     'a = bool, int
//│ U max: 2, total: 12
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool :> α101', α101' <: α103', α103' <: α104', α104' <: α105', α105' :> int]

let test =
  let f x = x in
  (f 1, f true)
//│ test: (int, bool,)



let wrap x = x :: []
let rec t = wrap (if true then 1 else t)
//│ [ERROR] Type `_ list` does not match `int`
//│ 
//│         (_ list) ---> (?t) ---> (?a) ---> (?b) <--- (?a) <--- (int)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.1  let wrap x = x :: []
//│ │                      ^^^^^^^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                 ^
//│ ▼ 
//│ ◉ (?t) is assumed for
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                 ^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                                               ^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let wrap x = x :: []
//│ │                  ^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.1  let wrap x = x :: []
//│ │                  ^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) comes from
//│    - l.2  let rec t = wrap (if true then 1 else t)
//│                                          ^
//│ [ERROR] Type `_ list` does not match `int`
//│ 
//│         (?a list) ---> (?t) ---> (?b) ---> (?c) ~~~~ (?a) ~~~~ (?c) <--- (?b) <--- (int)
//│ 
//│ ◉ (?a list) comes from
//│ │  - l.1  let wrap x = x :: []
//│ │                      ^^^^^^^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                 ^
//│ ▼ 
//│ ◉ (?t) is assumed for
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                 ^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                                               ^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.1  let wrap x = x :: []
//│                    ^
//│   ◉ (?c * _ list) comes from
//│   │  - l.1  let wrap x = x :: []
//│   │                      ^^^^^^^
//│   ▼ 
//│   ◉ (?a * ?a list) comes from
//│      - l.1  let wrap x = x :: []
//│                          ^^^^^^^
//│ ◉ (?a) is assumed for
//│   ◉ (?a * ?a list) comes from
//│   ▲  - l.1  let wrap x = x :: []
//│   │                      ^^^^^^^
//│   │ 
//│   ◉ (?c * _ list) comes from
//│      - l.1  let wrap x = x :: []
//│                          ^^^^^^^
//│ ◉ (?c) is assumed for
//│ ▲  - l.1  let wrap x = x :: []
//│ │                  ^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) comes from
//│    - l.2  let rec t = wrap (if true then 1 else t)
//│                                          ^
//│ [ERROR] Type `_ list` does not match `int`
//│ 
//│         (?a list) ---> (?t) ---> (?b) ---> (?c) ~~~~ (?a) ~~~~ (?a0) ~~~~ (?a) ~~~~ (?c) <--- (?b) <--- (int)
//│ 
//│ ◉ (?a list) comes from
//│ │  - l.1  let wrap x = x :: []
//│ │                      ^^^^^^^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                 ^
//│ ▼ 
//│ ◉ (?t) is assumed for
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                 ^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                                               ^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.1  let wrap x = x :: []
//│                    ^
//│   ◉ (?c * ?a0 list) comes from
//│   │  - l.1  let wrap x = x :: []
//│   │                      ^^^^^^^
//│   ▼ 
//│   ◉ (?a * ?a list) comes from
//│      - l.1  let wrap x = x :: []
//│                          ^^^^^^^
//│ ◉ (?a) is assumed for
//│   ◉ (?a list) comes from
//│     ◉ (?a * ?a list) comes from
//│     ▲  - l.1  let wrap x = x :: []
//│     │                      ^^^^^^^
//│     │ 
//│     ◉ (?c * ?a0 list) comes from
//│        - l.1  let wrap x = x :: []
//│                            ^^^^^^^
//│   ◉ (?a0 list) comes from
//│      - l.1  let wrap x = x :: []
//│                               ^^
//│ ◉ (?a0) is assumed for
//│   ◉ (?a0 list) comes from
//│      - l.1  let wrap x = x :: []
//│                               ^^
//│     ◉ (?c * ?a0 list) comes from
//│     │  - l.1  let wrap x = x :: []
//│     │                      ^^^^^^^
//│     ▼ 
//│     ◉ (?a * ?a list) comes from
//│        - l.1  let wrap x = x :: []
//│                            ^^^^^^^
//│   ◉ (?a list) comes from
//│ ◉ (?a) is assumed for
//│   ◉ (?a * ?a list) comes from
//│   ▲  - l.1  let wrap x = x :: []
//│   │                      ^^^^^^^
//│   │ 
//│   ◉ (?c * ?a0 list) comes from
//│      - l.1  let wrap x = x :: []
//│                          ^^^^^^^
//│ ◉ (?c) is assumed for
//│ ▲  - l.1  let wrap x = x :: []
//│ │                  ^
//│ │  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.2  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) comes from
//│    - l.2  let rec t = wrap (if true then 1 else t)
//│                                          ^
//│ wrap: 'a -> list['a]
//│ t: 't
//│   where
//│     't = list['a], int
//│     'a = list['a], int
//│ U max: 5, total: 41
//│ UERR 3 errors
//│ L: 2 [list['a123'] ~ int, list['a123'] <: t121', t121' <: α125', α125' <: α122', [α122' - ([[α122']], [[list['a124']]],) ~ ('a123', list['a123'],) - 'a123', L: 0 [([[α122']], [[list['a124']]],) ~ ('a123', list['a123'],), ([[α122']], [[list['a124']]],) <: ('a123', list['a123'],)]], ['a123' - list['a123'] ~ list['a124'] - 'a124', L: 1 [list['a123'] ~ list['a124'], [list['a123'] - ('a123', list['a123'],) ~ ([[α122']], [[list['a124']]],) - list['a124'], L: 0 [('a123', list['a123'],) ~ ([[α122']], [[list['a124']]],), ('a123', list['a123'],) :> ([[α122']], [[list['a124']]],)]]]], ['a124' - list['a124'] ~ list['a123'] - 'a123', L: 1 [list['a124'] ~ list['a123'], [list['a124'] - ([[α122']], [[list['a124']]],) ~ ('a123', list['a123'],) - list['a123'], L: 0 [([[α122']], [[list['a124']]],) ~ ('a123', list['a123'],), ([[α122']], [[list['a124']]],) <: ('a123', list['a123'],)]]]], ['a123' - ('a123', list['a123'],) ~ ([[α122']], [[list['a124']]],) - α122', L: 0 [('a123', list['a123'],) ~ ([[α122']], [[list['a124']]],), ('a123', list['a123'],) :> ([[α122']], [[list['a124']]],)]], α122' :> α125', α125' :> int]
//│ L: 1 [list['a123'] ~ int, list['a123'] <: t121', t121' <: α125', α125' <: α122', [α122' - ([[α122']], [[list['a124']]],) ~ ('a123', list['a123'],) - 'a123', L: 0 [([[α122']], [[list['a124']]],) ~ ('a123', list['a123'],), ([[α122']], [[list['a124']]],) <: ('a123', list['a123'],)]], ['a123' - ('a123', list['a123'],) ~ ([[α122']], [[list['a124']]],) - α122', L: 0 [('a123', list['a123'],) ~ ([[α122']], [[list['a124']]],), ('a123', list['a123'],) :> ([[α122']], [[list['a124']]],)]], α122' :> α125', α125' :> int]
//│ L: 0 [list['a123'] ~ int, list['a123'] <: t121', t121' <: α125', α125' <: α122', α122' :> α125', α125' :> int]


let rec length ls = match ls with | hd :: tl -> 1 + length tl | [] -> 0
let weird x = (x + 1, length x)
//│ [ERROR] Type `_ list` does not match `int`
//│ 
//│         (_ list) ~~~~ (?a) ---> (int)
//│ 
//│ ◉ (_ list) comes from
//│    - l.1  let rec length ls = match ls with | hd :: tl -> 1 + length tl | [] -> 0
//│                                                                      ^^
//│   ◉ (_ list -> _) comes from
//│   ▲  - l.1  let rec length ls = match ls with | hd :: tl -> 1 + length tl | [] -> 0
//│   │                                                             ^^^^^^
//│   │  - l.1  let rec length ls = match ls with | hd :: tl -> 1 + length tl | [] -> 0
//│   │                 ^^^^^^
//│   │ 
//│   ◉ (?length) is assumed for
//│   │  - l.1  let rec length ls = match ls with | hd :: tl -> 1 + length tl | [] -> 0
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (?a -> _) comes from
//│      - l.2  let weird x = (x + 1, length x)
//│                                   ^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.2  let weird x = (x + 1, length x)
//│ │                   ^
//│ │  - l.2  let weird x = (x + 1, length x)
//│ │                        ^
//│ ▼ 
//│ ◉ (int) comes from
//│    - lib. let (+): int -> int -> int
//│                    ^^^
//│ length: list['a] -> int
//│ weird: 'b -> (int, int,)
//│   where
//│     'b = list['a], int
//│ U max: 4, total: 29
//│ UERR 1 errors
//│ L: 1 [list['a143'] ~ int, [list['a143'] - ([list['a143']] -> α145') ~ ([α138'] -> α147') - α138', L: 0 [([list['a143']] -> α145') ~ ([α138'] -> α147'), ([list['a143']] -> α145') :> length141', length141' <: ([α138'] -> α147')]], α138' <: int]


let len ls = match ls with | "hd :: tl" -> 1 | [] -> 0
//│ [ERROR] Type `string` does not match `_ list`
//│ 
//│         (string) <--- (?a) ---> (_ list)
//│ 
//│ ◉ (string) comes from
//│ ▲  - l.1  let len ls = match ls with | "hd :: tl" -> 1 | [] -> 0
//│ │                                      ^^^^^^^^^^
//│ │  - l.1  let len ls = match ls with | "hd :: tl" -> 1 | [] -> 0
//│ │                            ^^
//│ │  - l.1  let len ls = match ls with | "hd :: tl" -> 1 | [] -> 0
//│ │                 ^^
//│ │ 
//│ ◉ (?a) is assumed for
//│ │  - l.1  let len ls = match ls with | "hd :: tl" -> 1 | [] -> 0
//│ │                 ^^
//│ │  - l.1  let len ls = match ls with | "hd :: tl" -> 1 | [] -> 0
//│ │                            ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - l.1  let len ls = match ls with | "hd :: tl" -> 1 | [] -> 0
//│                                                          ^^
//│ len: 'b -> int
//│   where
//│     'b = list['a], string
//│ U max: 1, total: 4
//│ UERR 1 errors
//│ L: 0 [string ~ list['a152'], string :> α150', α150' <: list['a152']]
