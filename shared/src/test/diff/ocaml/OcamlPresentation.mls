:AllowTypeErrors

let boolToInt x = if x then "0" else 1
//│ ╔══[ERROR] Type `string` does not match `int`
//│ ║  
//│ ╟──        (string) ---> (?a) <--- (int) 
//│ ║  
//│ ╟── (string) is the type of this `then` branch and it flows into `?a`
//│ ║  l.1:	let boolToInt x = if x then "0" else 1
//│ ║      	                            ^^^
//│ ╟── (?a) is assumed as the type of this if-then-else expression
//│ ║  l.1:	let boolToInt x = if x then "0" else 1
//│ ║      	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── (int) is the type of this `else` branch and it flows into `?a`
//│ ║  l.1:	let boolToInt x = if x then "0" else 1
//│ ╙──    	                                     ^
//│ boolToInt: bool -> (int | string)



// TODO add Left definition location to pattern type
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        (bool) ---> (?a) <--- (int) 
//│ ║  
//│ ╟── (bool) comes from this type expression
//│ ║  builtin:	let (&&): bool -> bool -> bool
//│ ║          	                          ^^^^
//│ ╟── so this operator application has type `bool` and it flows into `?a`
//│ ║  l.3:	 | Right r -> r && true
//│ ║      	              ^^^^^^^^^^
//│ ╟── (?a) is assumed as the type of this match expression
//│ ║  l.1:	let destructEither x = match x with
//│ ║      	                       ^^^^^^^^^^^^
//│ ║      	 | Left l -> l + 1 ...
//│ ║      	 ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this operator application has type `?a`. However `int` flows into `?a`
//│ ║  l.2:	 | Left l -> l + 1
//│ ║      	             ^^^^^
//│ ╟── (int) is assumed as the type of this type reference
//│ ║  builtin:	let (+): int -> int -> int
//│ ╙──        	                       ^^^
//│ destructEither: either[int, bool] -> (bool | int)


let destructEither x = if x then
  match x with
   | Left l -> l + 1
   | Right r -> r && true
  else x
//│ ╔══[ERROR] Type `(_, _) either` does not match `int`
//│ ║  
//│ ╟──        ((_, _) either) <--- (?a) ---> (?b) <--- (int) 
//│ ║  
//│ ╟── ((_, _) either) is assumed as the type of this pattern
//│ ║  l.3:	   | Left l -> l + 1
//│ ║      	     ^^^^
//│ ╟── so this reference has type `(_, _) either`. However `?a` flows into `(_, _) either`
//│ ║  l.2:	  match x with
//│ ║      	        ^
//│ ╟── (?a) is assumed as the type of this variable
//│ ║  l.1:	let destructEither x = if x then
//│ ║      	                   ^
//│ ╟── so this `else` branch has type `?a` and it flows into `?b`
//│ ║  l.5:	  else x
//│ ║      	       ^^
//│ ╟── (?b) is assumed as the type of this if-then-else expression
//│ ║  l.1:	let destructEither x = if x then
//│ ║      	                       ^^^^^^^^^
//│ ║      	  match x with ...
//│ ║      	  ^^^^^^^^^^^^^^^^
//│ ╟── so this match expression has type `?b`
//│ ║  l.2:	  match x with
//│ ║      	  ^^^^^^^^^^^^
//│ ║      	   | Left l -> l + 1 ...
//│ ║      	   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this operator application has type `?b`. However `int` flows into `?b`
//│ ║  l.3:	   | Left l -> l + 1
//│ ║      	               ^^^^^
//│ ╟── (int) is assumed as the type of this type reference
//│ ║  builtin:	let (+): int -> int -> int
//│ ╙──        	                       ^^^
//│ ╔══[ERROR] Type `bool` does not match `(_, _) either`
//│ ║  
//│ ╟──        (bool) <--- (?a) ---> ((_, _) either) 
//│ ║  
//│ ╟── (bool) is the type of this if-then-else condition. However `?a` flows into `bool`
//│ ║  l.1:	let destructEither x = if x then
//│ ║      	                          ^
//│ ╟── (?a) is assumed as the type of this variable
//│ ║  l.1:	let destructEither x = if x then
//│ ║      	                   ^
//│ ╟── so this reference has type `?a` and it flows into `(_, _) either`
//│ ║  l.2:	  match x with
//│ ║      	        ^
//│ ╟── ((_, _) either) is assumed as the type of this pattern
//│ ║  l.3:	   | Left l -> l + 1
//│ ╙──    	     ^^^^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        (bool) ---> (?a) <--- (int) 
//│ ║  
//│ ╟── (bool) comes from this type expression
//│ ║  builtin:	let (&&): bool -> bool -> bool
//│ ║          	                          ^^^^
//│ ╟── so this operator application has type `bool` and it flows into `?a`
//│ ║  l.4:	   | Right r -> r && true
//│ ║      	                ^^^^^^^^^
//│ ╟── (?a) is assumed as the type of this match expression
//│ ║  l.2:	  match x with
//│ ║      	  ^^^^^^^^^^^^
//│ ║      	   | Left l -> l + 1 ...
//│ ║      	   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this operator application has type `?a`. However `int` flows into `?a`
//│ ║  l.3:	   | Left l -> l + 1
//│ ║      	               ^^^^^
//│ ╟── (int) is assumed as the type of this type reference
//│ ║  builtin:	let (+): int -> int -> int
//│ ╙──        	                       ^^^
//│ destructEither: bool -> (bool | int)

let succ: int -> int
  
let test2 x = match x with
 | true -> succ x
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        (bool) <--- (?a) ---> (int) 
//│ ║  
//│ ╟── (bool) is assumed as the type of this pattern
//│ ║  l.4:	 | true -> succ x
//│ ║      	   ^^^^
//│ ╟── so this reference has type `bool`. However `?a` flows into `bool`
//│ ║  l.3:	let test2 x = match x with
//│ ║      	                    ^
//│ ╟── (?a) is assumed as the type of this variable
//│ ║  l.3:	let test2 x = match x with
//│ ║      	          ^
//│ ╟── so this reference has type `?a` and it flows into `int`
//│ ║  l.4:	 | true -> succ x
//│ ║      	                ^
//│ ╟── (int) is assumed as the type of this type reference
//│ ║  l.1:	let succ: int -> int
//│ ╙──    	          ^^^
//│ succ: int -> int
//│ test2: nothing -> int

let g x = (not x, (if true then x else 5))
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        (bool) <--- (?a) ---> (?b) <--- (int) 
//│ ║  
//│ ╟── (bool) comes from this type expression
//│ ║  builtin:	let not: bool -> bool
//│ ║          	         ^^^^
//│ ╟── so this reference has type `bool`. However `?a` flows into `bool`
//│ ║  l.1:	let g x = (not x, (if true then x else 5))
//│ ║      	               ^
//│ ╟── (?a) is assumed as the type of this variable
//│ ║  l.1:	let g x = (not x, (if true then x else 5))
//│ ║      	      ^
//│ ╟── so this `then` branch has type `?a` and it flows into `?b`
//│ ║  l.1:	let g x = (not x, (if true then x else 5))
//│ ║      	                                ^
//│ ╟── (?b) is assumed as the type of this if-then-else expression
//│ ║  l.1:	let g x = (not x, (if true then x else 5))
//│ ║      	                  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── (int) is the type of this `else` branch and it flows into `?b`
//│ ║  l.1:	let g x = (not x, (if true then x else 5))
//│ ╙──    	                                       ^
//│ g: (bool & 'a) -> (bool, int | 'a,)

// Jonathan
let confluence z = if true then z else 5
let mkpair x y = (x, confluence y)
  
let conflict x = mkpair (not x) x
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        (bool) <--- (?a) ---> (?b) <--- (int) 
//│ ║  
//│ ╟── (bool) comes from this type expression
//│ ║  builtin:	let not: bool -> bool
//│ ║          	         ^^^^
//│ ╟── so this reference has type `bool`. However `?a` flows into `bool`
//│ ║  l.4:	let conflict x = mkpair (not x) x
//│ ║      	                             ^
//│ ╟── (?a) is assumed as the type of this variable
//│ ║  l.4:	let conflict x = mkpair (not x) x
//│ ║      	             ^
//│ ╟── so this reference has type `?a`
//│ ║  l.4:	let conflict x = mkpair (not x) x
//│ ║      	                                ^
//│ ╟── so this variable has type `?a`
//│ ║  l.2:	let mkpair x y = (x, confluence y)
//│ ║      	             ^
//│ ╟── so this reference has type `?a`
//│ ║  l.2:	let mkpair x y = (x, confluence y)
//│ ║      	                                ^
//│ ╟── so this variable has type `?a`
//│ ║  l.1:	let confluence z = if true then z else 5
//│ ║      	               ^
//│ ╟── so this `then` branch has type `?a` and it flows into `?b`
//│ ║  l.1:	let confluence z = if true then z else 5
//│ ║      	                                ^
//│ ╟── (?b) is assumed as the type of this if-then-else expression
//│ ║  l.1:	let confluence z = if true then z else 5
//│ ║      	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── (int) is the type of this `else` branch and it flows into `?b`
//│ ║  l.1:	let confluence z = if true then z else 5
//│ ╙──    	                                       ^
//│ confluence: 'a -> (int | 'a)
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)
//│ conflict: (bool & 'a) -> (bool, int | 'a,)

let test =
  let f x = x in
  (f 1, f true)
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        (bool) ---> (?a) <--- (int) 
//│ ║  
//│ ╟── (bool) is the type of this reference and it flows into `?a`
//│ ║  l.3:	  (f 1, f true)
//│ ║      	          ^^^^
//│ ╟── (?a) is assumed as the type of this variable
//│ ║  l.2:	  let f x = x in
//│ ║      	        ^
//│ ╟── (int) is the type of this integer literal and it flows into `?a`
//│ ║  l.3:	  (f 1, f true)
//│ ╙──    	     ^
//│ test: (bool | int, bool | int,)



let wrap x = x :: []
let rec t = wrap (if true then 1 else t)
//│ ╔══[ERROR] Type `int` does not match `_ list`
//│ ║  
//│ ╟──        (int) ---> (?a) <--- (_ list) 
//│ ║  
//│ ╟── (int) is the type of this `then` branch and it flows into `?a`
//│ ║  l.2:	let rec t = wrap (if true then 1 else t)
//│ ║      	                               ^
//│ ╟── (?a) is assumed as the type of this if-then-else expression
//│ ║  l.2:	let rec t = wrap (if true then 1 else t)
//│ ║      	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this `else` branch has type `?a`
//│ ║  l.2:	let rec t = wrap (if true then 1 else t)
//│ ║      	                                      ^
//│ ╟── so this recursive binding has type `?a`
//│ ║  l.2:	let rec t = wrap (if true then 1 else t)
//│ ║      	        ^
//│ ╟── so this application has type `?a`. However `_ list` flows into `?a`
//│ ║  l.2:	let rec t = wrap (if true then 1 else t)
//│ ║      	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── (_ list) is assumed as the type of this application
//│ ║  l.1:	let wrap x = x :: []
//│ ╙──    	             ^^^^^^^
//│ wrap: 'a -> list['a]
//│ t: 't
//│   where
//│     't :> list[int | 't]
