:unify
let boolToInt x = if x then "0" else 1
//│ ╔══[ERROR] Type `string` does not match `int`
//│ ║  
//│ ╟── this `then` branch has type `string`
//│ ║  l.2: 	let boolToInt x = if x then "0" else 1
//│ ║       	                            ^^^
//│ ╟── this if-then-else expression has type `string`
//│ ║  l.2: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.2: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `int`
//│ ║  l.2: 	let boolToInt x = if x then "0" else 1
//│ ╙──     	                                     ^
//│ ╔══[ERROR] Type `string` does not match `int`
//│ ║  
//│ ╟──        string ---> ?a <--- int 
//│ ║  
//│ ╟── this `then` branch has type `string` and it flows into `?a`
//│ ║  l.2: 	let boolToInt x = if x then "0" else 1
//│ ║       	                            ^^^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.2: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `int` and it flows into `?a`
//│ ║  l.2: 	let boolToInt x = if x then "0" else 1
//│ ╙──     	                                     ^
//│ boolToInt: bool -> (int | string)

type ('a, 'b) either = Left of 'a | Right of 'b
//│ Defined type alias either[+'a, +'b]
//│ Defined class Left[+'a]
//│ Defined class Right[+'b]
//│ Left: 'a -> either['a, nothing]
//│ Right: 'a -> either[nothing, 'a]

:e
Left 1 : int
//│ ╔══[ERROR] Type `(?a, ?b) either` does not match `int`
//│ ║  
//│ ╟── `(?a, ?b) either` comes from this type expression
//│ ║  l.32: 	type ('a, 'b) either = Left of 'a | Right of 'b
//│ ║        	                       ^^^^^^^^^^
//│ ╟── this application has type `(?a, ?b) either`
//│ ║  l.40: 	Left 1 : int
//│ ║        	^^^^^^
//│ ╟── `int` comes from this type expression
//│ ║  l.40: 	Left 1 : int
//│ ╙──      	         ^^^
//│ res: int

// TODO add Left definition location to pattern type
:unify
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ║              	                       ^^^
//│ ╟── this operator application has type `int`
//│ ║  l.57: 	 | Left l -> l + 1
//│ ║        	             ^^^^^
//│ ╟── this match expression has type `int`
//│ ║  l.56: 	let destructEither x = match x with
//│ ║        	                       ^^^^^^^^^^^^
//│ ║  l.57: 	 | Left l -> l + 1 ...
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `bool`
//│ ║  l.56: 	let destructEither x = match x with
//│ ║        	                       ^^^^^^^^^^^^
//│ ║  l.57: 	 | Left l -> l + 1 ...
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `bool`
//│ ║  l.58: 	 | Right r -> r && true
//│ ║        	              ^^^^^^^^^^
//│ ╟── `bool` comes from this type expression
//│ ║  builtin:54: 	let (&&): bool -> bool -> bool
//│ ╙──            	                          ^^^^
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- bool 
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ║              	                       ^^^
//│ ╟── this operator application has type `int` and it flows into `?a`
//│ ║  l.57: 	 | Left l -> l + 1
//│ ║        	             ^^^^^
//│ ╟── this match expression has type `?a`
//│ ║  l.56: 	let destructEither x = match x with
//│ ║        	                       ^^^^^^^^^^^^
//│ ║  l.57: 	 | Left l -> l + 1 ...
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?a` and it flows from `bool`
//│ ║  l.58: 	 | Right r -> r && true
//│ ║        	              ^^^^^^^^^^
//│ ╟── this type reference has type `bool`
//│ ║  builtin:54: 	let (&&): bool -> bool -> bool
//│ ╙──            	                          ^^^^
//│ destructEither: either[int, bool] -> (bool | int)

:unify // TODO unnecessary errors reported
let destructEither x = if x then
  match x with
   | Left l -> l + 1
   | Right r -> r && true
  else x
//│ ╔══[ERROR] Type `bool` does not match `(?a, ?b) either`
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ║  builtin:54: 	let (&&): bool -> bool -> bool
//│ ║              	                          ^^^^
//│ ╟── this operator application has type `bool`
//│ ║  l.110: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── this match expression has type `bool`
//│ ║  l.108: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.109: 	   | Left l -> l + 1 ...
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `(?a, ?b) either`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                   ^
//│ ╟── this reference has type `(?a, ?b) either`
//│ ║  l.108: 	  match x with
//│ ║         	        ^
//│ ╟── this pattern has type `(?a, ?b) either`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ╙──       	     ^^^^
//│ ╔══[ERROR] Type `int` does not match `(?a, ?b) either`
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ║              	                       ^^^
//│ ╟── this operator application has type `int`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── this match expression has type `int`
//│ ║  l.108: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.109: 	   | Left l -> l + 1 ...
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `(?a, ?b) either`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                   ^
//│ ╟── this reference has type `(?a, ?b) either`
//│ ║  l.108: 	  match x with
//│ ║         	        ^
//│ ╟── this pattern has type `(?a, ?b) either`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ╙──       	     ^^^^
//│ ╔══[ERROR] Type `bool` does not match `(?a, ?b) either`
//│ ║  
//│ ╟──        bool <--- ?c ---> (?a, ?b) either 
//│ ║  
//│ ╟── this if-then-else condition has type `bool` and it flows from `?c`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                          ^
//│ ╟── this variable has type `?c`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                   ^
//│ ╟── this reference has type `?c` and it flows into `(?a, ?b) either`
//│ ║  l.108: 	  match x with
//│ ║         	        ^
//│ ╟── this pattern has type `(?a, ?b) either`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ╙──       	     ^^^^
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- bool 
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ║              	                       ^^^
//│ ╟── this operator application has type `int` and it flows into `?a`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── this match expression has type `?a`
//│ ║  l.108: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.109: 	   | Left l -> l + 1 ...
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?a` and it flows from `bool`
//│ ║  l.110: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── this type reference has type `bool`
//│ ║  builtin:54: 	let (&&): bool -> bool -> bool
//│ ╙──            	                          ^^^^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ║  builtin:54: 	let (&&): bool -> bool -> bool
//│ ║              	                          ^^^^
//│ ╟── this operator application has type `bool` and it flows into `?a`
//│ ║  l.110: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── this match expression has type `?a`
//│ ║  l.108: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.109: 	   | Left l -> l + 1 ...
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?a` and it flows from `int`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── this type reference has type `int`
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ╙──            	                       ^^^
//│ ╔══[ERROR] Type `bool` does not match `(?a, ?b) either`
//│ ║  
//│ ╟──        bool ---> ?c <--- ?d ---> (?a, ?b) either 
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ║  builtin:54: 	let (&&): bool -> bool -> bool
//│ ║              	                          ^^^^
//│ ╟── this operator application has type `bool`
//│ ║  l.110: 	   | Right r -> r && true
//│ ║         	                ^^^^^^^^^
//│ ╟── this match expression has type `bool` and it flows into `?c`
//│ ║  l.108: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.109: 	   | Left l -> l + 1 ...
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.108: 	  match x with ...
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?c` and it flows from `?d`
//│ ║  l.111: 	  else x
//│ ║         	       ^^
//│ ╟── this variable has type `?d`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                   ^
//│ ╟── this reference has type `?d` and it flows into `(?a, ?b) either`
//│ ║  l.108: 	  match x with
//│ ║         	        ^
//│ ╟── this pattern has type `(?a, ?b) either`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ╙──       	     ^^^^
//│ ╔══[ERROR] Type `int` does not match `(?a, ?b) either`
//│ ║  
//│ ╟──        int ---> ?c <--- ?d ---> (?a, ?b) either 
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ║              	                       ^^^
//│ ╟── this operator application has type `int`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── this match expression has type `int` and it flows into `?c`
//│ ║  l.108: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.109: 	   | Left l -> l + 1 ...
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?c`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.108: 	  match x with ...
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?c` and it flows from `?d`
//│ ║  l.111: 	  else x
//│ ║         	       ^^
//│ ╟── this variable has type `?d`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                   ^
//│ ╟── this reference has type `?d` and it flows into `(?a, ?b) either`
//│ ║  l.108: 	  match x with
//│ ║         	        ^
//│ ╟── this pattern has type `(?a, ?b) either`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ╙──       	     ^^^^
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b ---> bool 
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ║              	                       ^^^
//│ ╟── this operator application has type `int`
//│ ║  l.109: 	   | Left l -> l + 1
//│ ║         	               ^^^^^
//│ ╟── this match expression has type `int` and it flows into `?a`
//│ ║  l.108: 	  match x with
//│ ║         	  ^^^^^^^^^^^^
//│ ║  l.109: 	   | Left l -> l + 1 ...
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                       ^^^^^^^^^
//│ ║  l.108: 	  match x with ...
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `?a` and it flows from `?b`
//│ ║  l.111: 	  else x
//│ ║         	       ^^
//│ ╟── this variable has type `?b`
//│ ║  l.107: 	let destructEither x = if x then
//│ ║         	                   ^
//│ ╟── this if-then-else condition has type `?b` and it flows into `bool`
//│ ║  l.107: 	let destructEither x = if x then
//│ ╙──       	                          ^
//│ destructEither: (either[int, bool] & bool) -> (bool | int)

let succ: int -> int
//│ succ: int -> int

:unify
let test2 x = match x with
 | true -> succ x
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool <--- ?a ---> int 
//│ ║  
//│ ╟── this pattern has type `bool`
//│ ║  l.314: 	 | true -> succ x
//│ ║         	   ^^^^
//│ ╟── this reference has type `bool` and it flows from `?a`
//│ ║  l.313: 	let test2 x = match x with
//│ ║         	                    ^
//│ ╟── this variable has type `?a`
//│ ║  l.313: 	let test2 x = match x with
//│ ║         	          ^
//│ ╟── this reference has type `?a` and it flows into `int`
//│ ║  l.314: 	 | true -> succ x
//│ ║         	                ^
//│ ╟── this type reference has type `int`
//│ ║  l.309: 	let succ: int -> int
//│ ╙──       	          ^^^
//│ test2: nothing -> int

let x: int list
let y: string list
let f: string list -> unit
//│ x: list[int]
//│ y: list[string]
//│ f: list[string] -> unit

:unify
f x
//│ ╔══[ERROR] Type `int` does not match `string`
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  l.336: 	let x: int list
//│ ║         	       ^^^
//│ ╟── `int list` comes from this type expression
//│ ║  l.336: 	let x: int list
//│ ║         	       ^^^^^^^^
//│ ╟── this reference has type `int list`
//│ ║  l.344: 	f x
//│ ║         	  ^
//│ ╟── `string list` comes from this type expression
//│ ║  l.338: 	let f: string list -> unit
//│ ║         	       ^^^^^^^^^^^
//│ ╟── `string` comes from this type expression
//│ ║  l.338: 	let f: string list -> unit
//│ ╙──       	       ^^^^^^

:unify
if true then x else y
//│ ╔══[ERROR] Type `int` does not match `string`
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  l.336: 	let x: int list
//│ ║         	       ^^^
//│ ╟── `int list` comes from this type expression
//│ ║  l.336: 	let x: int list
//│ ║         	       ^^^^^^^^
//│ ╟── this `then` branch has type `int list`
//│ ║  l.364: 	if true then x else y
//│ ║         	             ^
//│ ╟── this if-then-else expression has type `int list`
//│ ║  l.364: 	if true then x else y
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `string list`
//│ ║  l.364: 	if true then x else y
//│ ║         	                    ^
//│ ╟── `string list` comes from this type expression
//│ ║  l.337: 	let y: string list
//│ ║         	       ^^^^^^^^^^^
//│ ╟── `string` comes from this type expression
//│ ║  l.337: 	let y: string list
//│ ╙──       	       ^^^^^^
//│ res: list[int | string]
