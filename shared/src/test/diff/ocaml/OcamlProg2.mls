
:OcamlParser
:OcamlLoadLibrary

(****** Note: Problem 1 does not use Caml; see the assignment *****)


exception Unimplemented
exception RuntimeTypeError
exception BadSourceProgram
exception BadPrecomputation
//│ Unimplemented: anything
//│ RuntimeTypeError: anything
//│ BadSourceProgram: anything
//│ BadPrecomputation: anything

(* ############################################################### *)
(* ######################################## *)
let empty_set = []
let add str lst = if List.mem str lst then lst else str::lst
let remove str lst = List.filter (fun x -> x <> str) lst
let rec union lst1 lst2 = 
   match lst1 with
     [] -> lst2
   | hd::tl -> add hd (union tl lst2)
//│ empty_set: list[nothing]
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.20: 	let add str lst = if List.mem str lst then lst else str::lst
//│ ╙──      	                     ^^^^
//│ add: 'a -> list['a] -> list['a]
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.21: 	let remove str lst = List.filter (fun x -> x <> str) lst
//│ ╙──      	                     ^^^^
//│ remove: anything -> anything -> error
//│ ╔══[ERROR] identifier not found: hd
//│ ║  l.25: 	   | hd::tl -> add hd (union tl lst2)
//│ ╙──      	     ^^
//│ ╔══[ERROR] identifier not found: hd
//│ ║  l.25: 	   | hd::tl -> add hd (union tl lst2)
//│ ╙──      	                   ^^
//│ ╔══[ERROR] identifier not found: tl
//│ ║  l.25: 	   | hd::tl -> add hd (union tl lst2)
//│ ╙──      	                             ^^
//│ union: list[error] -> (list['a] & 'b) -> (list[error | 'a] | 'b)

(* ################################################ *)

:dp
type exp = Var of string 
         | Lam of string * exp * (string list option)(*last part for problem3*)
         | Apply of exp * exp
         | Closure of string * exp * env
	 | Int of int
	 | Plus of exp * exp
	 | If of exp * exp * exp
	 | Pair of exp * exp
	 | First of exp
	 | Second of exp
  and env = (string * exp) list
//│ Parsed: TypeDef(Als, TypeName(exp), List(), Union(TypeName(Second),Union(TypeName(First),Union(TypeName(Pair),Union(TypeName(If),Union(TypeName(Plus),Union(TypeName(Int),Union(TypeName(Closure),Union(TypeName(Apply),Union(TypeName(Lam),Union(TypeName(Var),TypeName(Var))))))))))), List())
//│ TypeDef(Cls, TypeName(Var), List(), Record(List((_0,Field(None,TypeName(string))))), List(_0)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Lam), List(), Record(List((_0,Field(None,TypeName(string))), (_1,Field(None,TypeName(exp))), (_2,Field(None,AppliedType(TypeName(option),List(AppliedType(TypeName(list),List(TypeName(string))))))))), List(_0, _1, _2)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Apply), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Closure), List(), Record(List((_0,Field(None,TypeName(string))), (_1,Field(None,TypeName(exp))), (_2,Field(None,TypeName(env))))), List(_0, _1, _2)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Int), List(), Record(List((_0,Field(None,TypeName(int))))), List(_0)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Plus), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(If), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))), (_2,Field(None,TypeName(exp))))), List(_0, _1, _2)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Pair), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(First), List(), Record(List((_0,Field(None,TypeName(exp))))), List(_0)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Second), List(), Record(List((_0,Field(None,TypeName(exp))))), List(_0)) of adt: Some((TypeName(exp),List()))
//│ Def(false, Var, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(string))))),TypeName(exp))), true)
//│ Def(false, Lam, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))), (None,Field(None,AppliedType(TypeName(option),List(AppliedType(TypeName(list),List(TypeName(string))))))))),TypeName(exp))), true)
//│ Def(false, Apply, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, Closure, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))), (None,Field(None,TypeName(env))))),TypeName(exp))), true)
//│ Def(false, Int, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(int))))),TypeName(exp))), true)
//│ Def(false, Plus, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, If, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, Pair, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, First, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, Second, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ TypeDef(Als, TypeName(env), List(), AppliedType(TypeName(list),List(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))))))), List())
//│ Defined type alias exp
//│ Defined class Var
//│ Defined class Lam
//│ Defined class Apply
//│ Defined class Closure
//│ Defined class Int
//│ Defined class Plus
//│ Defined class If
//│ Defined class Pair
//│ Defined class First
//│ Defined class Second
//│ Defined type alias env
//│ Var: string -> exp
//│ Lam: (string, exp, option[list[string]],) -> exp
//│ Apply: (exp, exp,) -> exp
//│ Closure: (string, exp, env,) -> exp
//│ Int: int -> exp
//│ Plus: (exp, exp,) -> exp
//│ If: (exp, exp, exp,) -> exp
//│ Pair: (exp, exp,) -> exp
//│ First: exp -> exp
//│ Second: exp -> exp



(******* Problem 2: complete this function *********)
(* ###################################################################
################################################ *)
let rec interp f env e =
  let interp = interp f in
  match e with
   Var s -> List.assoc s env (* ############# *)
 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
 | Closure _ -> e (* ################### *)
 | Apply(e1,e2) ->
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    (match v1 with
      Closure(s,e3,env2) -> interp((s,v2)::env2) e3
     | _ -> raise RuntimeTypeError)
 | Int(i) -> e
 | Plus(e1,e2) -> 
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    (match v1 with
      Int(i1) -> (match v2 with
                   Int(i2) -> Int(i1 + i2)
                  | _ -> raise RuntimeTypeError)
     | _ -> raise RuntimeTypeError)
 | If(e1,e2,e3) ->
    let v1 = interp env e1 in
    (match v1 with
      Int(i1) -> if v1 = 0 then interp env e3 else interp env e2 (* FOUND ERROR: 0 should be Int(0) *)
     | _ -> raise RuntimeTypeError)
 | Pair(e1,e2) ->
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    Pair(v1,v2) 
 | First(e) ->
    let v1 = interp env e in
    (match v1 with
      Pair(e1,e2) -> e1
     | _ -> raise RuntimeTypeError)
 | Second(e) ->
    let v1 = interp env e in
    (match v1 with
      Pair(e1,e2) -> e2
     | _ -> raise RuntimeTypeError)
 | _ -> raise Unimplemented (* ############## *)
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.113: 	   Var s -> List.assoc s env (* ############# *)
//│ ╙──       	            ^^^^
//│ ╔══[ERROR] identifier not found: s
//│ ║  l.113: 	   Var s -> List.assoc s env (* ############# *)
//│ ╙──       	                       ^
//│ ╔══[ERROR] identifier not found: s
//│ ║  l.114: 	 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
//│ ╙──       	                            ^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.114: 	 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
//│ ╙──       	                              ^^
//│ ╔══[ERROR] identifier not found: opt
//│ ║  l.114: 	 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
//│ ╙──       	                                       ^^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.117: 	    let v1 = interp env e1 in
//│ ╙──       	                        ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.118: 	    let v2 = interp env e2 in
//│ ╙──       	                        ^^
//│ ╔══[ERROR] identifier not found: s
//│ ║  l.120: 	      Closure(s,e3,env2) -> interp((s,v2)::env2) e3
//│ ╙──       	                                    ^
//│ ╔══[ERROR] identifier not found: env2
//│ ║  l.120: 	      Closure(s,e3,env2) -> interp((s,v2)::env2) e3
//│ ╙──       	                                           ^^^^
//│ ╔══[ERROR] identifier not found: e3
//│ ║  l.120: 	      Closure(s,e3,env2) -> interp((s,v2)::env2) e3
//│ ╙──       	                                                 ^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.124: 	    let v1 = interp env e1 in
//│ ╙──       	                        ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.125: 	    let v2 = interp env e2 in
//│ ╙──       	                        ^^
//│ ╔══[ERROR] identifier not found: i1
//│ ║  l.128: 	                   Int(i2) -> Int(i1 + i2)
//│ ╙──       	                                  ^^
//│ ╔══[ERROR] identifier not found: i2
//│ ║  l.128: 	                   Int(i2) -> Int(i1 + i2)
//│ ╙──       	                                       ^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.132: 	    let v1 = interp env e1 in
//│ ╙──       	                        ^^
//│ ╔══[ERROR] identifier not found: e3
//│ ║  l.134: 	      Int(i1) -> if v1 = 0 then interp env e3 else interp env e2 (* FOUND ERROR: 0 should be Int(0) *)
//│ ╙──       	                                           ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.134: 	      Int(i1) -> if v1 = 0 then interp env e3 else interp env e2 (* FOUND ERROR: 0 should be Int(0) *)
//│ ╙──       	                                                              ^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.137: 	    let v1 = interp env e1 in
//│ ╙──       	                        ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.138: 	    let v2 = interp env e2 in
//│ ╙──       	                        ^^
//│ ╔══[ERROR] identifier not found: e1
//│ ║  l.143: 	      Pair(e1,e2) -> e1
//│ ╙──       	                     ^^
//│ ╔══[ERROR] identifier not found: e2
//│ ║  l.148: 	      Pair(e1,e2) -> e2
//│ ╙──       	                     ^^
//│ interp: ((list[(error, error | exp,)] | 'a) -> error -> env) -> 'a -> (exp & 'b) -> 'b
//│   where
//│     'b :> error | exp
//│        <: exp

let interp1 = interp (fun x _ -> x)
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.219: 	let interp1 = interp (fun x _ -> x)
//│ ╙──       	                          ^^^
//│ ╔══[ERROR] identifier not found: x
//│ ║  l.219: 	let interp1 = interp (fun x _ -> x)
//│ ╙──       	                                 ^
//│ interp1: error -> (exp & 'a) -> 'a
//│   where
//│     'a :> error | exp
//│        <: exp

(****** Problem 3: complete this function *******)

let rec computeFreeVars e = raise Unimplemented
//│ computeFreeVars: anything -> nothing

let interp2 = interp (fun (env:env) opt ->
  match opt with
     None -> raise BadPrecomputation
   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.236: 	let interp2 = interp (fun (env:env) opt ->
//│ ╙──       	                          ^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: opt
//│ ║  l.237: 	  match opt with
//│ ╙──       	        ^^^
//│ ╔══[ERROR] identifier not found: lst
//│ ║  l.239: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	          ^^^
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.239: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                 ^^^^
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.239: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                                        ^^^^
//│ ╔══[ERROR] identifier not found: env
//│ ║  l.239: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                                                     ^^^
//│ ╔══[ERROR] identifier not found: lst
//│ ║  l.239: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                                                           ^^^
//│ interp2: error -> (exp & 'a) -> 'a
//│   where
//│     'a :> error | exp
//│        <: exp

(******* Problem 4: not programming (see assignment) ********)

(******* Problem 5a: explain this function *********)

let interp3 = interp (fun (env:env) _ -> [])
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.270: 	let interp3 = interp (fun (env:env) _ -> [])
//│ ╙──       	                          ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.270: 	let interp3 = interp (fun (env:env) _ -> [])
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not a function
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── but it flows into reference with expected type `error -> ?a`
//│ ║  l.270: 	let interp3 = interp (fun (env:env) _ -> [])
//│ ║         	                                         ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.114: 	 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
//│ ╙──       	                                 ^^^^^
//│ interp3: error -> (exp & 'a) -> 'a
//│   where
//│     'a :> error | exp
//│        <: exp

(****** Problem 5b (EXTRA CREDIT): explain the next two functions ******)

let rec depthToExp s varlist exp =
   match varlist with
    [] -> raise BadSourceProgram
  | hd::tl -> if s=hd then First exp else depthToExp s tl (Second exp)
   
let rec translate varlist exp = 
   match exp with
   Var s -> depthToExp s varlist (Var "arg")
 | Lam(s,e2,_) -> Pair(Lam("arg",translate (s::varlist) e2, None), 
                       match varlist with [] -> Int 0 | _ -> Var "arg")
 | Closure _ -> raise BadSourceProgram
 | Apply(e1,e2) -> 
   let e1' = translate varlist e1 in
   let e2' = translate varlist e2 in
   (* ############################################# *)
   Apply(Lam("f",Apply(First(First(Var "f")), 
                       Pair(Second(Var "f"),Second(First(Var "f")))),None),
         Pair(e1',e2'))
 | Int _ -> exp
 | Pair(e1,e2) -> Pair(translate varlist e1, translate varlist e2)
 | Plus(e1,e2) -> Plus(translate varlist e1, translate varlist e2)
 | First(e1) -> First(translate varlist e1)
 | Second(e1) -> Second(translate varlist e1)
 | If(e1,e2,e3) -> If(translate varlist e1,
                      translate varlist e2,
                      translate varlist e3)
//│ /!\ Parse error: Expected (Index ~ parens | Index ~ record | Index ~ ("-".? ~ floatnumber | number | stringliteral | lit) | Index ~ filter | ocamlList):9:24, found "match varl" at l.302:24:                        match varlist with [] -> Int 0 | _ -> Var "arg")

(********** examples and testing ***********)

(* ################################
#############################
###########################################################
############################################
 *)

(* ##################################################### *)
let ex1 = (Apply(Apply(Lam("x",Lam("y", Plus(Var"x",Var "y"),None),None), 
		      Int 17),
		Int 19))
//│ ex1: exp

(* #####################################################################
################################# *)

(* ################################################################### *)
let lam x e = Lam(x,e,None)
let app e1 e2 = Apply(e1,e2)
let vx = Var "x"
let vy = Var "y"
let vf = Var "f"
//│ lam: string -> exp -> exp
//│ app: exp -> exp -> exp
//│ vx: exp
//│ vy: exp
//│ vf: exp

(* ########################### *)
let fix = 
   let e = lam "x" (app vf (lam "y" (app (app vx vx) vy))) in
   lam "f" (app e e)
//│ fix: exp

(* ################################################ *)
let sum = 
  lam "f" (lam "x" (If(vx,
		       Plus(vx, app vf (Plus(vx, Int (-1)))),
		       Int 0)))
//│ sum: exp

(* ############################################################### *)
let ex2 = (app (app fix sum) (Int 1000))
//│ ex2: exp

(* ########################################################### *)

let ans1 = interp1 [] ex1
let ans2 = interp1 [] ex2
//│ ans1: error | exp
//│ ans2: error | exp

let ans3 = interp2 [] (fst (computeFreeVars ex1))
let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.374: 	let ans3 = interp2 [] (fst (computeFreeVars ex1))
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `(?b, ?c,)`
//│ ║  l.374: 	let ans3 = interp2 [] (fst (computeFreeVars ex1))
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.5: 	let fst: ('a * 'b) -> 'a
//│ ╙──     	          ^^^^^^^
//│ ans3: error | exp
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.375: 	let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `(?b, ?c,)`
//│ ║  l.375: 	let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.5: 	let fst: ('a * 'b) -> 'a
//│ ╙──     	          ^^^^^^^
//│ ans4: error | exp

let ans5 = interp3 [] (translate [] ex1)
let ans6 = interp3 [] (translate [] ex2)
//│ ╔══[ERROR] identifier not found: translate
//│ ║  l.397: 	let ans5 = interp3 [] (translate [] ex1)
//│ ╙──       	                       ^^^^^^^^^
//│ ans5: error | exp
//│ ╔══[ERROR] identifier not found: translate
//│ ║  l.398: 	let ans6 = interp3 [] (translate [] ex2)
//│ ╙──       	                       ^^^^^^^^^
//│ ans6: error | exp

