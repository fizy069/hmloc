
:OcamlParser
:OcamlLoadLibrary

(****** Note: Problem 1 does not use Caml; see the assignment *****)


exception Unimplemented
exception RuntimeTypeError
exception BadSourceProgram
exception BadPrecomputation
//│ Unimplemented: anything
//│ RuntimeTypeError: anything
//│ BadSourceProgram: anything
//│ BadPrecomputation: anything

(* ############################################################### *)
(* ######################################## *)
let empty_set = []
let add str lst = if List.mem str lst then lst else str::lst
let remove str lst = List.filter (fun x -> x <> str) lst
let rec union lst1 lst2 = 
   match lst1 with
     [] -> lst2
   | hd::tl -> add hd (union tl lst2)
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Cannot handle case expression ((:: hd tl) then add hd '(' union tl lst2 ')',1)
//│ 	at: mlscript.utils.package$.lastWords(package.scala:185)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$29(Typer.scala:845)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:765)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:854)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:656)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:854)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:656)

(* ################################################ *)

:dp
type exp = Var of string 
         | Lam of string * exp * (string list option)(*last part for problem3*)
         | Apply of exp * exp
         | Closure of string * exp * env
	 | Int of int
	 | Plus of exp * exp
	 | If of exp * exp * exp
	 | Pair of exp * exp
	 | First of exp
	 | Second of exp
  and env = (string * exp) list
//│ Parsed: TypeDef(Als, TypeName(exp), List(), Union(TypeName(Second),Union(TypeName(First),Union(TypeName(Pair),Union(TypeName(If),Union(TypeName(Plus),Union(TypeName(Int),Union(TypeName(Closure),Union(TypeName(Apply),Union(TypeName(Lam),Union(TypeName(Var),TypeName(Var))))))))))), List())
//│ TypeDef(Cls, TypeName(Var), List(), Record(List((_0,Field(None,TypeName(string))))), List(_0)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Lam), List(), Record(List((_0,Field(None,TypeName(string))), (_1,Field(None,TypeName(exp))), (_2,Field(None,AppliedType(TypeName(option),List(AppliedType(TypeName(list),List(TypeName(string))))))))), List(_0, _1, _2)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Apply), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Closure), List(), Record(List((_0,Field(None,TypeName(string))), (_1,Field(None,TypeName(exp))), (_2,Field(None,TypeName(env))))), List(_0, _1, _2)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Int), List(), Record(List((_0,Field(None,TypeName(int))))), List(_0)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Plus), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(If), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))), (_2,Field(None,TypeName(exp))))), List(_0, _1, _2)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Pair), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(First), List(), Record(List((_0,Field(None,TypeName(exp))))), List(_0)) of adt: Some((TypeName(exp),List()))
//│ TypeDef(Cls, TypeName(Second), List(), Record(List((_0,Field(None,TypeName(exp))))), List(_0)) of adt: Some((TypeName(exp),List()))
//│ Def(false, Var, PolyType(List(),Function(TypeName(string),TypeName(exp))), true)
//│ Def(false, Lam, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))), (None,Field(None,AppliedType(TypeName(option),List(AppliedType(TypeName(list),List(TypeName(string))))))))),TypeName(exp))), true)
//│ Def(false, Apply, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, Closure, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))), (None,Field(None,TypeName(env))))),TypeName(exp))), true)
//│ Def(false, Int, PolyType(List(),Function(TypeName(int),TypeName(exp))), true)
//│ Def(false, Plus, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, If, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, Pair, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, First, PolyType(List(),Function(TypeName(exp),TypeName(exp))), true)
//│ Def(false, Second, PolyType(List(),Function(TypeName(exp),TypeName(exp))), true)
//│ TypeDef(Als, TypeName(env), List(), AppliedType(TypeName(list),List(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))))))), List())
//│ Defined type alias exp
//│ Defined class Var
//│ Defined class Lam
//│ Defined class Apply
//│ Defined class Closure
//│ Defined class Int
//│ Defined class Plus
//│ Defined class If
//│ Defined class Pair
//│ Defined class First
//│ Defined class Second
//│ Defined type alias env
//│ Var: string -> exp
//│ Lam: (string, exp, option[list[string]],) -> exp
//│ Apply: (exp, exp,) -> exp
//│ Closure: (string, exp, env,) -> exp
//│ Int: int -> exp
//│ Plus: (exp, exp,) -> exp
//│ If: (exp, exp, exp,) -> exp
//│ Pair: (exp, exp,) -> exp
//│ First: exp -> exp
//│ Second: exp -> exp



(******* Problem 2: complete this function *********)
(* ###################################################################
################################################ *)
let rec interp f env e =
  let interp = interp f in
  match e with
   Var s -> List.assoc s env (* ############# *)
 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
 | Closure _ -> e (* ################### *)
 | Apply(e1,e2) ->
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    (match v1 with
      Closure(s,e3,env2) -> interp((s,v2)::env2) e3
     | _ -> raise RuntimeTypeError)
 | Int(i) -> e
 | Plus(e1,e2) -> 
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    (match v1 with
      Int(i1) -> (match v2 with
                   Int(i2) -> Int(i1 + i2)
                  | _ -> raise RuntimeTypeError)
     | _ -> raise RuntimeTypeError)
 | If(e1,e2,e3) ->
    let v1 = interp env e1 in
    (match v1 with
      Int(i1) -> if v1 = 0 then interp env e3 else interp env e2 (* FOUND ERROR: 0 should be Int(0) *)
     | _ -> raise RuntimeTypeError)
 | Pair(e1,e2) ->
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    Pair(v1,v2) 
 | First(e) ->
    let v1 = interp env e in
    (match v1 with
      Pair(e1,e2) -> e1
     | _ -> raise RuntimeTypeError)
 | Second(e) ->
    let v1 = interp env e in
    (match v1 with
      Pair(e1,e2) -> e2
     | _ -> raise RuntimeTypeError)
 | _ -> raise Unimplemented (* ############## *)
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: Unsupported arg: '(' i ')'
//│ 	at: mlscript.utils.package$.lastWords(package.scala:185)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$38(Typer.scala:837)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$38$adapted(Typer.scala:823)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$29(Typer.scala:823)
//│ 	at: scala.collection.immutable.List.foreach(List.scala:333)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:765)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:31)
//│ 	at: mlscript.Typer.typeTerm(Typer.scala:854)
//│ 	at: mlscript.Typer.$anonfun$typeTerm$2(Typer.scala:694)

let interp1 = interp (fun x _ -> x)
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.155: 	let interp1 = interp (fun x _ -> x)
//│ ╙──       	                          ^^^
//│ ╔══[ERROR] identifier not found: x
//│ ║  l.155: 	let interp1 = interp (fun x _ -> x)
//│ ╙──       	                                 ^
//│ interp1: nothing

(****** Problem 3: complete this function *******)

let rec computeFreeVars e = raise Unimplemented
//│ computeFreeVars: anything -> nothing

let interp2 = interp (fun (env:env) opt ->
  match opt with
     None -> raise BadPrecomputation
   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.169: 	let interp2 = interp (fun (env:env) opt ->
//│ ╙──       	                          ^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: opt
//│ ║  l.170: 	  match opt with
//│ ╙──       	        ^^^
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.172: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                 ^^^^
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.172: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                                        ^^^^
//│ ╔══[ERROR] identifier not found: env
//│ ║  l.172: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                                                     ^^^
//│ interp2: nothing

(******* Problem 4: not programming (see assignment) ********)

(******* Problem 5a: explain this function *********)

let interp3 = interp (fun (env:env) _ -> [])
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.194: 	let interp3 = interp (fun (env:env) _ -> [])
//│ ╙──       	                          ^^^^^^^^^^^
//│ interp3: nothing

(****** Problem 5b (EXTRA CREDIT): explain the next two functions ******)

let rec depthToExp s varlist exp =
   match varlist with
    [] -> raise BadSourceProgram
  | hd::tl -> if s=hd then First exp else depthToExp s tl (Second exp)
   
let rec translate varlist exp = 
   match exp with
   Var s -> depthToExp s varlist (Var "arg")
 | Lam(s,e2,_) -> Pair(Lam("arg",translate (s::varlist) e2, None), 
                       match varlist with [] -> Int 0 | _ -> Var "arg")
 | Closure _ -> raise BadSourceProgram
 | Apply(e1,e2) -> 
   let e1' = translate varlist e1 in
   let e2' = translate varlist e2 in
   (* ############################################# *)
   Apply(Lam("f",Apply(First(First(Var "f")), 
                       Pair(Second(Var "f"),Second(First(Var "f")))),None),
         Pair(e1',e2'))
 | Int _ -> exp
 | Pair(e1,e2) -> Pair(translate varlist e1, translate varlist e2)
 | Plus(e1,e2) -> Plus(translate varlist e1, translate varlist e2)
 | First(e1) -> First(translate varlist e1)
 | Second(e1) -> Second(translate varlist e1)
 | If(e1,e2,e3) -> If(translate varlist e1,
                      translate varlist e2,
                      translate varlist e3)
//│ /!\ Parse error: Expected (Index ~ parens | Index ~ record | Index ~ ("-".? ~ floatnumber | number | stringliteral | lit) | Index ~ filter | ocamlList):9:24, found "match varl" at l.211:24:                        match varlist with [] -> Int 0 | _ -> Var "arg")

(********** examples and testing ***********)

(* ################################
#############################
###########################################################
############################################
 *)

(* ##################################################### *)
let ex1 = (Apply(Apply(Lam("x",Lam("y", Plus(Var"x",Var "y"),None),None), 
		      Int 17),
		Int 19))
//│ ex1: exp

(* #####################################################################
################################# *)

(* ################################################################### *)
let lam x e = Lam(x,e,None)
let app e1 e2 = Apply(e1,e2)
let vx = Var "x"
let vy = Var "y"
let vf = Var "f"
//│ lam: string -> exp -> exp
//│ app: exp -> exp -> exp
//│ vx: exp
//│ vy: exp
//│ vf: exp

(* ########################### *)
let fix = 
   let e = lam "x" (app vf (lam "y" (app (app vx vx) vy))) in
   lam "f" (app e e)
//│ fix: exp

(* ################################################ *)
let sum = 
  lam "f" (lam "x" (If(vx,
		       Plus(vx, app vf (Plus(vx, Int (-1)))),
		       Int 0)))
//│ sum: exp

(* ############################################################### *)
let ex2 = (app (app fix sum) (Int 1000))
//│ ex2: exp

(* ########################################################### *)

let ans1 = interp1 [] ex1
let ans2 = interp1 [] ex2
//│ ans1: nothing
//│ ans2: nothing

let ans3 = interp2 [] (fst (computeFreeVars ex1))
let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ans3: nothing
//│ ans4: nothing

let ans5 = interp3 [] (translate [] ex1)
let ans6 = interp3 [] (translate [] ex2)
//│ ╔══[ERROR] identifier not found: translate
//│ ║  l.288: 	let ans5 = interp3 [] (translate [] ex1)
//│ ╙──       	                       ^^^^^^^^^
//│ ans5: nothing
//│ ╔══[ERROR] identifier not found: translate
//│ ║  l.289: 	let ans6 = interp3 [] (translate [] ex2)
//│ ╙──       	                       ^^^^^^^^^
//│ ans6: nothing

