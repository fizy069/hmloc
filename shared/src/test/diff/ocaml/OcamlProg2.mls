:NoJS
:OcamlParser
:OcamlLoadLibrary

(****** Note: Problem 1 does not use Caml; see the assignment *****)


exception Unimplemented
exception RuntimeTypeError
exception BadSourceProgram
exception BadPrecomputation
//│ Unimplemented: anything
//│ RuntimeTypeError: anything
//│ BadSourceProgram: anything
//│ BadPrecomputation: anything

(* ############################################################### *)
(* ######################################## *)
let empty_set = []
let add str lst = if List.mem str lst then lst else str::lst
let remove str lst = List.filter (fun x -> x <> str) lst
let rec union lst1 lst2 = 
   match lst1 with
     [] -> lst2
   | hd::tl -> add hd (union tl lst2)
//│ empty_set: Nil
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.20: 	let add str lst = if List.mem str lst then lst else str::lst
//│ ╙──      	                     ^^^^
//│ add: ('_0 & 'a) -> (list['a] & '_1) -> ((Cons['a] with {_0: '_0, _1: '_1}) | '_1)
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.21: 	let remove str lst = List.filter (fun x -> x <> str) lst
//│ ╙──      	                     ^^^^
//│ remove: anything -> anything -> error
//│ union: 'b -> (list['a] & '_1) -> '_1
//│   where
//│     '_1 :> Cons['a] with {_0: '_0, _1: '_1}
//│     'b <: (Cons[?] with {_0: '_0 & 'a, _1: 'b}) | Nil

(* ################################################ *)

:dp
type exp = Var of string 
         | Lam of string * exp * (string list option)(*last part for problem3*)
         | Apply of exp * exp
         | Closure of string * exp * env
	 | Int of int
	 | Plus of exp * exp
	 | If of exp * exp * exp
	 | Pair of exp * exp
	 | First of exp
	 | Second of exp
  and env = (string * exp) list
//│ Parsed: TypeDef(Als, TypeName(exp), List(), Union(TypeName(Second),Union(TypeName(First),Union(TypeName(Pair),Union(TypeName(If),Union(TypeName(Plus),Union(TypeName(Int),Union(TypeName(Closure),Union(TypeName(Apply),Union(TypeName(Lam),Union(TypeName(Var),TypeName(Var))))))))))), List())
//│ TypeDef(Cls, TypeName(Var), List(), Record(List((_0,Field(None,TypeName(string))))), List(_0))
//│ TypeDef(Cls, TypeName(Lam), List(), Record(List((_0,Field(None,TypeName(string))), (_1,Field(None,TypeName(exp))), (_2,Field(None,AppliedType(TypeName(option),List(AppliedType(TypeName(list),List(TypeName(string))))))))), List(_0, _1, _2))
//│ TypeDef(Cls, TypeName(Apply), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1))
//│ TypeDef(Cls, TypeName(Closure), List(), Record(List((_0,Field(None,TypeName(string))), (_1,Field(None,TypeName(exp))), (_2,Field(None,TypeName(env))))), List(_0, _1, _2))
//│ TypeDef(Cls, TypeName(Int), List(), Record(List((_0,Field(None,TypeName(int))))), List(_0))
//│ TypeDef(Cls, TypeName(Plus), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1))
//│ TypeDef(Cls, TypeName(If), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))), (_2,Field(None,TypeName(exp))))), List(_0, _1, _2))
//│ TypeDef(Cls, TypeName(Pair), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1))
//│ TypeDef(Cls, TypeName(First), List(), Record(List((_0,Field(None,TypeName(exp))))), List(_0))
//│ TypeDef(Cls, TypeName(Second), List(), Record(List((_0,Field(None,TypeName(exp))))), List(_0))
//│ TypeDef(Als, TypeName(env), List(), AppliedType(TypeName(list),List(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))))))), List())
//│ Def(false, Var, Lam(Tup(_: Var(a)), App(Var(Var), Tup(_: Rcd(Var(_0) = Var(a))))), true)
//│ Def(false, Lam, Lam(Tup(_: Var(a), _: Var(b), _: Var(c)), App(Var(Lam), Tup(_: Rcd(Var(_0) = Var(a), Var(_1) = Var(b), Var(_2) = Var(c))))), true)
//│ Def(false, Apply, Lam(Tup(_: Var(a), _: Var(b)), App(Var(Apply), Tup(_: Rcd(Var(_0) = Var(a), Var(_1) = Var(b))))), true)
//│ Def(false, Closure, Lam(Tup(_: Var(a), _: Var(b), _: Var(c)), App(Var(Closure), Tup(_: Rcd(Var(_0) = Var(a), Var(_1) = Var(b), Var(_2) = Var(c))))), true)
//│ Def(false, Int, Lam(Tup(_: Var(a)), App(Var(Int), Tup(_: Rcd(Var(_0) = Var(a))))), true)
//│ Def(false, Plus, Lam(Tup(_: Var(a), _: Var(b)), App(Var(Plus), Tup(_: Rcd(Var(_0) = Var(a), Var(_1) = Var(b))))), true)
//│ Def(false, If, Lam(Tup(_: Var(a), _: Var(b), _: Var(c)), App(Var(If), Tup(_: Rcd(Var(_0) = Var(a), Var(_1) = Var(b), Var(_2) = Var(c))))), true)
//│ Def(false, Pair, Lam(Tup(_: Var(a), _: Var(b)), App(Var(Pair), Tup(_: Rcd(Var(_0) = Var(a), Var(_1) = Var(b))))), true)
//│ Def(false, First, Lam(Tup(_: Var(a)), App(Var(First), Tup(_: Rcd(Var(_0) = Var(a))))), true)
//│ Def(false, Second, Lam(Tup(_: Var(a)), App(Var(Second), Tup(_: Rcd(Var(_0) = Var(a))))), true)
//│ Defined type alias exp
//│ Defined class Var
//│ Defined class Lam
//│ Defined class Apply
//│ Defined class Closure
//│ Defined class Int
//│ Defined class Plus
//│ Defined class If
//│ Defined class Pair
//│ Defined class First
//│ Defined class Second
//│ Defined type alias env
//│ Var: (string & '_0) -> (Var with {_0: '_0})
//│ Lam: (string & '_0, exp & '_1, option[list[string]] & '_2,) -> (Lam with {_0: '_0, _1: '_1, _2: '_2})
//│ Apply: (exp & '_0, exp & '_1,) -> (Apply with {_0: '_0, _1: '_1})
//│ Closure: (string & '_0, exp & '_1, env & '_2,) -> (Closure with {_0: '_0, _1: '_1, _2: '_2})
//│ Int: (int & '_0) -> (int & {_0: '_0})
//│ Plus: (exp & '_0, exp & '_1,) -> (Plus with {_0: '_0, _1: '_1})
//│ If: (exp & '_0, exp & '_1, exp & '_2,) -> (If with {_0: '_0, _1: '_1, _2: '_2})
//│ Pair: (exp & '_0, exp & '_1,) -> (Pair with {_0: '_0, _1: '_1})
//│ First: (exp & '_0) -> (First with {_0: '_0})
//│ Second: (exp & '_0) -> (Second with {_0: '_0})



(******* Problem 2: complete this function *********)
(* ###################################################################
################################################ *)
let rec interp f env e =
  let interp = interp f in
  match e with
   Var s -> List.assoc s env (* ############# *)
 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
 | Closure _ -> e (* ################### *)
 | Apply(e1,e2) ->
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    (match v1 with
      Closure(s,e3,env2) -> interp((s,v2)::env2) e3
     | _ -> raise RuntimeTypeError)
 | Int(i) -> e
 | Plus(e1,e2) -> 
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    (match v1 with
      Int(i1) -> (match v2 with
                   Int(i2) -> Int(i1 + i2)
                  | _ -> raise RuntimeTypeError)
     | _ -> raise RuntimeTypeError)
 | If(e1,e2,e3) ->
    let v1 = interp env e1 in
    (match v1 with
      Int(i1) -> if v1 = 0 then interp env e3 else interp env e2 (* FOUND ERROR: 0 should be Int(0) *)
     | _ -> raise RuntimeTypeError)
 | Pair(e1,e2) ->
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    Pair(v1,v2) 
 | First(e) ->
    let v1 = interp env e in
    (match v1 with
      Pair(e1,e2) -> e1
     | _ -> raise RuntimeTypeError)
 | Second(e) ->
    let v1 = interp env e in
    (match v1 with
      Pair(e1,e2) -> e2
     | _ -> raise RuntimeTypeError)
 | _ -> raise Unimplemented (* ############## *)
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.107: 	   Var s -> List.assoc s env (* ############# *)
//│ ╙──       	            ^^^^
//│ interp: (((Cons['a | ('b, '_1,)] with {_0: ('b, '_1,), _1: '_10}) | 'c) -> 'd -> (env & list['a] & '_10 & '_2)) -> 'c -> 'e -> '_1
//│   where
//│     '_1 :> 'f | (Pair with {_0: '_1, _1: '_1}) | (Closure with {_0: '_0, _1: '_11, _2: '_2}) | int & {_0: int} | 'g
//│     'f :> '_1
//│        <: Closure & 'h | exp & int & {_0: int} | exp & int & {_0: anything} & ~int | exp & ~#Closure & ~int & ~#Pair | 'i & (Pair & 'j | Pair & ~#Pair)
//│     'h <: {_0: 'b, _1: 'e, _2: list['a] & '_10}
//│     'e <: (Apply with {_0: 'e, _1: 'e}) | Closure & 'f | (First with {_0: 'e}) | (If with {_0: 'e, _1: 'e, _2: 'e}) | int & 'g | (Lam with {_0: string & 'b & '_0, _1: '_11, _2: 'd}) | (Pair with {_0: 'e, _1: 'e}) | (Plus with {_0: 'e, _1: 'e}) | (Second with {_0: 'e}) | Var | ~Apply & ~Closure & ~First & ~If & ~int & ~Lam & ~Pair & ~Plus & ~Second & ~Var
//│     '_11 <: exp & 'e
//│     'g <: Closure\_1\_2 & 'h | exp & int & {_0: int} | exp & int & {_0: anything} & ~int | exp & {_0: anything} & ~#Closure & ~int & ~#Pair | 'i & (Pair\_1 & 'j | Pair\_1 & ~#Pair)
//│     'j <: {_0: 'f, _1: anything}
//│     'i <: {_0: anything, _1: 'f}

let interp1 = interp (fun x _ -> x)
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.160: 	let interp1 = interp (fun x _ -> x)
//│ ╙──       	                          ^^^
//│ ╔══[ERROR] identifier not found: x
//│ ║  l.160: 	let interp1 = interp (fun x _ -> x)
//│ ╙──       	                                 ^
//│ interp1: error -> 'a -> '_1
//│   where
//│     'a <: (Apply with {_0: 'a, _1: 'a}) | Closure & 'b | (First with {_0: 'a}) | (If with {_0: 'a, _1: 'a, _2: 'a}) | int & 'c | (Lam with {_0: string & '_0, _1: '_10}) | (Pair with {_0: 'a, _1: 'a}) | (Plus with {_0: 'a, _1: 'a}) | (Second with {_0: 'a}) | Var | ~Apply & ~Closure & ~First & ~If & ~int & ~Lam & ~Pair & ~Plus & ~Second & ~Var
//│     'b :> '_1
//│        <: Closure & 'd | exp & int & {_0: int} | exp & int & {_0: anything} & ~int | exp & ~#Closure & ~int & ~#Pair | 'e & (Pair & 'f | Pair & ~#Pair)
//│     '_1 :> 'b | (Pair with {_0: '_1, _1: '_1}) | (Closure with {_0: '_0, _1: '_10, _2: error}) | int & {_0: int} | 'c
//│     'c <: Closure\_1\_2 & 'd | exp & int & {_0: int} | exp & int & {_0: anything} & ~int | exp & {_0: anything} & ~#Closure & ~int & ~#Pair | 'e & (Pair\_1 & 'f | Pair\_1 & ~#Pair)
//│     'f <: {_0: 'b, _1: anything}
//│     'e <: {_0: anything, _1: 'b}
//│     'd <: {_0: anything, _1: 'a, _2: list[?]}
//│     '_10 <: exp & 'a

(****** Problem 3: complete this function *******)

let rec computeFreeVars e = raise Unimplemented
//│ computeFreeVars: anything -> nothing

let interp2 = interp (fun (env:env) opt ->
  match opt with
     None -> raise BadPrecomputation
   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.184: 	let interp2 = interp (fun (env:env) opt ->
//│ ╙──       	                          ^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: opt
//│ ║  l.185: 	  match opt with
//│ ╙──       	        ^^^
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.187: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                 ^^^^
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.187: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                                        ^^^^
//│ ╔══[ERROR] identifier not found: env
//│ ║  l.187: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                                                     ^^^
//│ interp2: error -> 'a -> '_1
//│   where
//│     'a <: (Apply with {_0: 'a, _1: 'a}) | Closure & 'b | (First with {_0: 'a}) | (If with {_0: 'a, _1: 'a, _2: 'a}) | int & 'c | (Lam with {_0: string & '_0, _1: '_10}) | (Pair with {_0: 'a, _1: 'a}) | (Plus with {_0: 'a, _1: 'a}) | (Second with {_0: 'a}) | Var | ~Apply & ~Closure & ~First & ~If & ~int & ~Lam & ~Pair & ~Plus & ~Second & ~Var
//│     'b :> '_1
//│        <: Closure & 'd | exp & int & {_0: int} | exp & int & {_0: anything} & ~int | exp & ~#Closure & ~int & ~#Pair | 'e & (Pair & 'f | Pair & ~#Pair)
//│     '_1 :> (Pair with {_0: '_1, _1: '_1}) | (Closure with {_0: '_0, _1: '_10, _2: error}) | int & {_0: int} | 'b | 'c
//│     'c <: Closure\_1\_2 & 'd | exp & int & {_0: int} | exp & int & {_0: anything} & ~int | exp & {_0: anything} & ~#Closure & ~int & ~#Pair | 'e & (Pair\_1 & 'f | Pair\_1 & ~#Pair)
//│     'f <: {_0: 'b, _1: anything}
//│     'e <: {_0: anything, _1: 'b}
//│     'd <: {_0: anything, _1: 'a, _2: list[?]}
//│     '_10 <: exp & 'a

(******* Problem 4: not programming (see assignment) ********)

(******* Problem 5a: explain this function *********)

let interp3 = interp (fun (env:env) _ -> [])
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.219: 	let interp3 = interp (fun (env:env) _ -> [])
//│ ╙──       	                          ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.219: 	let interp3 = interp (fun (env:env) _ -> [])
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` does not match type `?a`
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;
//│ ║       	                                      ^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.108: 	 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
//│ ╙──       	                                 ^^^^^
//│ interp3: error -> 'a -> '_1 | error
//│   where
//│     'a <: (Apply with {_0: 'a, _1: 'a}) | Closure & 'b | (First with {_0: 'a}) | (If with {_0: 'a, _1: 'a, _2: 'a}) | int & 'c | (Lam with {_0: string & '_0, _1: '_10}) | (Pair with {_0: 'a, _1: 'a}) | (Plus with {_0: 'a, _1: 'a}) | (Second with {_0: 'a}) | Var | ~Apply & ~Closure & ~First & ~If & ~int & ~Lam & ~Pair & ~Plus & ~Second & ~Var
//│     'b :> '_1
//│        <: Closure & 'd | exp & int & {_0: int} | exp & int & {_0: anything} & ~int | exp & ~#Closure & ~int & ~#Pair | 'e & (Pair & 'f | Pair & ~#Pair)
//│     '_1 :> 'b | (Pair with {_0: '_1, _1: '_1}) | (Closure with {_0: '_0, _1: '_10, _2: nothing}) | int & {_0: int} | 'c
//│     'c <: Closure\_1\_2 & 'd | exp & int & {_0: int} | exp & int & {_0: anything} & ~int | exp & {_0: anything} & ~#Closure & ~int & ~#Pair | 'e & (Pair\_1 & 'f | Pair\_1 & ~#Pair)
//│     'f <: {_0: 'b, _1: anything}
//│     'e <: {_0: anything, _1: 'b}
//│     'd <: {_0: anything, _1: 'a, _2: list[?]}
//│     '_10 <: exp & 'a

(****** Problem 5b (EXTRA CREDIT): explain the next two functions ******)

let rec depthToExp s varlist exp =
   match varlist with
    [] -> raise BadSourceProgram
  | hd::tl -> if s=hd then First exp else depthToExp s tl (Second exp)
   
let rec translate varlist exp = 
   match exp with
   Var s -> depthToExp s varlist (Var "arg")
 | Lam(s,e2,_) -> Pair(Lam("arg",translate (s::varlist) e2, None), 
                       match varlist with [] -> Int 0 | _ -> Var "arg")
 | Closure _ -> raise BadSourceProgram
 | Apply(e1,e2) -> 
   let e1' = translate varlist e1 in
   let e2' = translate varlist e2 in
   (* ############################################# *)
   Apply(Lam("f",Apply(First(First(Var "f")), 
                       Pair(Second(Var "f"),Second(First(Var "f")))),None),
         Pair(e1',e2'))
 | Int _ -> exp
 | Pair(e1,e2) -> Pair(translate varlist e1, translate varlist e2)
 | Plus(e1,e2) -> Plus(translate varlist e1, translate varlist e2)
 | First(e1) -> First(translate varlist e1)
 | Second(e1) -> Second(translate varlist e1)
 | If(e1,e2,e3) -> If(translate varlist e1,
                      translate varlist e2,
                      translate varlist e3)
//│ /!\ Parse error: Expected (Index ~ parens | Index ~ record | Index ~ (number | stringliteral | lit) | Index ~ filter | ocamlList):9:24, found "match varl" at l.255:24:                        match varlist with [] -> Int 0 | _ -> Var "arg")

(********** examples and testing ***********)

(* ################################
#############################
###########################################################
############################################
 *)

(* ##################################################### *)
let ex1 = (Apply(Apply(Lam("x",Lam("y", Plus(Var"x",Var "y"),None),None), 
		      Int 17),
		Int 19))
//│ ex1: Apply with {_0: Apply with {_0: Lam with {_0: "x", _1: Lam with {_0: "y", _1: Plus with {_0: Var & {_0: "x"}, _1: Var & {_0: "y"}}, _2: None}, _2: None}, _1: int & {_0: 17}}, _1: int & {_0: 19}}

(* #####################################################################
################################# *)

(* ################################################################### *)
let lam x e = Lam(x,e,None)
let app e1 e2 = Apply(e1,e2)
let vx = Var "x"
let vy = Var "y"
let vf = Var "f"
//│ lam: (string & '_0) -> (exp & '_1) -> (Lam with {_0: '_0, _1: '_1, _2: None})
//│ app: (exp & '_0) -> (exp & '_1) -> (Apply with {_0: '_0, _1: '_1})
//│ vx: Var & {_0: "x"}
//│ vy: Var & {_0: "y"}
//│ vf: Var & {_0: "f"}

(* ########################### *)
let fix = 
   let e = lam "x" (app vf (lam "y" (app (app vx vx) vy))) in
   lam "f" (app e e)
//│ fix: Lam with {_0: "f", _1: Apply with {_0: Lam with {_0: "x", _1: Apply with {_0: Var & {_0: "f"}, _1: Lam with {_0: "y", _1: Apply with {_0: Apply with {_0: Var & {_0: "x"}, _1: Var & {_0: "x"}}, _1: Var & {_0: "y"}}, _2: None}}, _2: None}, _1: Lam with {_0: "x", _1: Apply with {_0: Var & {_0: "f"}, _1: Lam with {_0: "y", _1: Apply with {_0: Apply with {_0: Var & {_0: "x"}, _1: Var & {_0: "x"}}, _1: Var & {_0: "y"}}, _2: None}}, _2: None}}, _2: None}

(* ################################################ *)
let sum = 
  lam "f" (lam "x" (If(vx,
		       Plus(vx, app vf (Plus(vx, Int (-1)))),
		       Int 0)))
//│ /!\ Parse error: Expected ")":3:41, found "-1)))),\n\t\t" at l.312:41: 		       Plus(vx, app vf (Plus(vx, Int (-1)))),

(* ############################################################### *)
let ex2 = (app (app fix sum) (Int 1000))
//│ ╔══[ERROR] identifier not found: sum
//│ ║  l.317: 	let ex2 = (app (app fix sum) (Int 1000))
//│ ╙──       	                        ^^^
//│ ex2: Apply with {_0: Apply with {_0: Lam with {_0: "f", _1: Apply with {_0: Lam with {_0: "x", _1: Apply with {_0: Var & {_0: "f"}, _1: Lam with {_0: "y", _1: Apply with {_0: Apply with {_0: Var & {_0: "x"}, _1: Var & {_0: "x"}}, _1: Var & {_0: "y"}}, _2: None}}, _2: None}, _1: Lam with {_0: "x", _1: Apply with {_0: Var & {_0: "f"}, _1: Lam with {_0: "y", _1: Apply with {_0: Apply with {_0: Var & {_0: "x"}, _1: Var & {_0: "x"}}, _1: Var & {_0: "y"}}, _2: None}}, _2: None}}, _2: None}, _1: error}, _1: int & {_0: 1000}}

(* ########################################################### *)

let ans1 = interp1 [] ex1
let ans2 = interp1 [] ex2
//│ ans1: '_1
//│   where
//│     '_1 :> (Pair with {_0: '_1, _1: '_1}) | (Closure with {_0: "x" | "y", _1: (Lam with {_0: "y", _1: Plus with {_0: Var & {_0: "x"}, _1: Var & {_0: "y"}}, _2: None}) | (Plus with {_0: Var & {_0: "x"}, _1: Var & {_0: "y"}}), _2: error}) | error | int & {_0: int}
//│ ans2: '_1
//│   where
//│     '_1 :> (Pair with {_0: '_1, _1: '_1}) | (Closure with {_0: "f" | "x" | "y", _1: Apply with {_0: (Apply with {_0: Var & {_0: "x"}, _1: Var & {_0: "x"}}) | (Lam with {_0: "x", _1: Apply with {_0: Var & {_0: "f"}, _1: Lam with {_0: "y", _1: Apply with {_0: Apply with {_0: Var & {_0: "x"}, _1: Var & {_0: "x"}}, _1: Var & {_0: "y"}}, _2: None}}, _2: None}) | Var & {_0: "f"}, _1: (Lam with {_0: "x" | "y", _1: Apply with {_0: (Apply with {_0: Var & {_0: "x"}, _1: Var & {_0: "x"}}) | Var & {_0: "f"}, _1: (Lam with {_0: "y", _1: Apply with {_0: Apply with {_0: Var & {_0: "x"}, _1: Var & {_0: "x"}}, _1: Var & {_0: "y"}}, _2: None}) | Var & {_0: "y"}}, _2: None}) | Var & {_0: "y"}}, _2: error}) | error | int & {_0: int}

let ans3 = interp2 [] (fst (computeFreeVars ex1))
let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.334: 	let ans3 = interp2 [] (fst (computeFreeVars ex1))
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `(?b, ?c,)`
//│ ║  l.334: 	let ans3 = interp2 [] (fst (computeFreeVars ex1))
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;
//│ ╙──     	                                                                                                            ^^^^
//│ ans3: '_1
//│   where
//│     '_1 :> (Pair with {_0: '_1, _1: '_1}) | (Closure with {_0: nothing, _1: nothing, _2: error}) | error | int & {_0: int}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.335: 	let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `(?b, ?c,)`
//│ ║  l.335: 	let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.0: 	type 'a list = Cons of 'a * 'a list | Nil;type 'a option = None | Some of 'a;let raise a = nothing;let fst (a, b) = a;let snd (a, b) = b;
//│ ╙──     	                                                                                                            ^^^^
//│ ans4: '_1
//│   where
//│     '_1 :> (Pair with {_0: '_1, _1: '_1}) | (Closure with {_0: nothing, _1: nothing, _2: error}) | error | int & {_0: int}

let ans5 = interp3 [] (translate [] ex1)
let ans6 = interp3 [] (translate [] ex2)
//│ ╔══[ERROR] identifier not found: translate
//│ ║  l.361: 	let ans5 = interp3 [] (translate [] ex1)
//│ ╙──       	                       ^^^^^^^^^
//│ ans5: '_1 | error
//│   where
//│     '_1 :> (Pair with {_0: '_1, _1: '_1}) | Closure & {_0: nothing, _1: nothing, _2: nothing} | error | int & {_0: int}
//│ ╔══[ERROR] identifier not found: translate
//│ ║  l.362: 	let ans6 = interp3 [] (translate [] ex2)
//│ ╙──       	                       ^^^^^^^^^
//│ ans6: '_1 | error
//│   where
//│     '_1 :> (Pair with {_0: '_1, _1: '_1}) | Closure & {_0: nothing, _1: nothing, _2: nothing} | error | int & {_0: int}

