
:OcamlParser
:OcamlLoadLibrary

(****** Note: Problem 1 does not use Caml; see the assignment *****)


exception Unimplemented
exception RuntimeTypeError
exception BadSourceProgram
exception BadPrecomputation
//│ Unimplemented: anything
//│ RuntimeTypeError: anything
//│ BadSourceProgram: anything
//│ BadPrecomputation: anything

(* ############################################################### *)
(* ######################################## *)
let empty_set = []
let add str lst = if List.mem str lst then lst else str::lst
let remove str lst = List.filter (fun x -> x <> str) lst
let rec union lst1 lst2 = 
   match lst1 with
     [] -> lst2
   | hd::tl -> add hd (union tl lst2)
//│ empty_set: list[nothing]
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.20: 	let add str lst = if List.mem str lst then lst else str::lst
//│ ╙──      	                     ^^^^
//│ add: 'a -> list['a] -> list['a]
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.21: 	let remove str lst = List.filter (fun x -> x <> str) lst
//│ ╙──      	                     ^^^^
//│ remove: anything -> anything -> error
//│ union: 'a -> 'b -> 'c
//│   where
//│     'b <: list['d] & 'c
//│     'c :> list['d]
//│        <: 'b
//│     'a <: (Cons[?] with {_0: 'd, _1: 'a}) | Nil

(* ################################################ *)

:dp
type exp = Var of string 
         | Lam of string * exp * (string list option)(*last part for problem3*)
         | Apply of exp * exp
         | Closure of string * exp * env
	 | Int of int
	 | Plus of exp * exp
	 | If of exp * exp * exp
	 | Pair of exp * exp
	 | First of exp
	 | Second of exp
  and env = (string * exp) list
//│ Parsed: TypeDef(Als, TypeName(exp), List(), Union(TypeName(Second),Union(TypeName(First),Union(TypeName(Pair),Union(TypeName(If),Union(TypeName(Plus),Union(TypeName(Int),Union(TypeName(Closure),Union(TypeName(Apply),Union(TypeName(Lam),Union(TypeName(Var),TypeName(Var))))))))))), List())
//│ TypeDef(Cls, TypeName(Var), List(), Record(List((_0,Field(None,TypeName(string))))), List(_0))
//│ TypeDef(Cls, TypeName(Lam), List(), Record(List((_0,Field(None,TypeName(string))), (_1,Field(None,TypeName(exp))), (_2,Field(None,AppliedType(TypeName(option),List(AppliedType(TypeName(list),List(TypeName(string))))))))), List(_0, _1, _2))
//│ TypeDef(Cls, TypeName(Apply), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1))
//│ TypeDef(Cls, TypeName(Closure), List(), Record(List((_0,Field(None,TypeName(string))), (_1,Field(None,TypeName(exp))), (_2,Field(None,TypeName(env))))), List(_0, _1, _2))
//│ TypeDef(Cls, TypeName(Int), List(), Record(List((_0,Field(None,TypeName(int))))), List(_0))
//│ TypeDef(Cls, TypeName(Plus), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1))
//│ TypeDef(Cls, TypeName(If), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))), (_2,Field(None,TypeName(exp))))), List(_0, _1, _2))
//│ TypeDef(Cls, TypeName(Pair), List(), Record(List((_0,Field(None,TypeName(exp))), (_1,Field(None,TypeName(exp))))), List(_0, _1))
//│ TypeDef(Cls, TypeName(First), List(), Record(List((_0,Field(None,TypeName(exp))))), List(_0))
//│ TypeDef(Cls, TypeName(Second), List(), Record(List((_0,Field(None,TypeName(exp))))), List(_0))
//│ Def(false, Var, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(string))))),TypeName(exp))), true)
//│ Def(false, Lam, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))), (None,Field(None,AppliedType(TypeName(option),List(AppliedType(TypeName(list),List(TypeName(string))))))))),TypeName(exp))), true)
//│ Def(false, Apply, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, Closure, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))), (None,Field(None,TypeName(env))))),TypeName(exp))), true)
//│ Def(false, Int, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(int))))),TypeName(exp))), true)
//│ Def(false, Plus, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, If, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, Pair, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))), (None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, First, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ Def(false, Second, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(exp))))),TypeName(exp))), true)
//│ TypeDef(Als, TypeName(env), List(), AppliedType(TypeName(list),List(Tuple(List((None,Field(None,TypeName(string))), (None,Field(None,TypeName(exp))))))), List())
//│ Defined type alias exp
//│ Defined class Var
//│ Defined class Lam
//│ Defined class Apply
//│ Defined class Closure
//│ Defined class Int
//│ Defined class Plus
//│ Defined class If
//│ Defined class Pair
//│ Defined class First
//│ Defined class Second
//│ Defined type alias env
//│ Var: string -> exp
//│ Lam: (string, exp, option[list[string]],) -> exp
//│ Apply: (exp, exp,) -> exp
//│ Closure: (string, exp, env,) -> exp
//│ Int: int -> exp
//│ Plus: (exp, exp,) -> exp
//│ If: (exp, exp, exp,) -> exp
//│ Pair: (exp, exp,) -> exp
//│ First: exp -> exp
//│ Second: exp -> exp



(******* Problem 2: complete this function *********)
(* ###################################################################
################################################ *)
let rec interp f env e =
  let interp = interp f in
  match e with
   Var s -> List.assoc s env (* ############# *)
 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
 | Closure _ -> e (* ################### *)
 | Apply(e1,e2) ->
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    (match v1 with
      Closure(s,e3,env2) -> interp((s,v2)::env2) e3
     | _ -> raise RuntimeTypeError)
 | Int(i) -> e
 | Plus(e1,e2) -> 
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    (match v1 with
      Int(i1) -> (match v2 with
                   Int(i2) -> Int(i1 + i2)
                  | _ -> raise RuntimeTypeError)
     | _ -> raise RuntimeTypeError)
 | If(e1,e2,e3) ->
    let v1 = interp env e1 in
    (match v1 with
      Int(i1) -> if v1 = 0 then interp env e3 else interp env e2 (* FOUND ERROR: 0 should be Int(0) *)
     | _ -> raise RuntimeTypeError)
 | Pair(e1,e2) ->
    let v1 = interp env e1 in
    let v2 = interp env e2 in
    Pair(v1,v2) 
 | First(e) ->
    let v1 = interp env e in
    (match v1 with
      Pair(e1,e2) -> e1
     | _ -> raise RuntimeTypeError)
 | Second(e) ->
    let v1 = interp env e in
    (match v1 with
      Pair(e1,e2) -> e2
     | _ -> raise RuntimeTypeError)
 | _ -> raise Unimplemented (* ############## *)
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.109: 	   Var s -> List.assoc s env (* ############# *)
//│ ╙──       	            ^^^^
//│ interp: ((list[(string | 'a, Closure | error | int & {_0: int} | exp,) | 'b] | 'c) -> (option[list[string]] | 'd) -> env) -> 'c -> 'e -> ('f | 'g)
//│   where
//│     'e <: (Apply with {_0: 'e, _1: 'e}) | Closure & 'h & 'f & (exp & int & {_0: int} | exp & ~int) | (First with {_0: 'e}) | (If with {_0: 'e, _1: 'e, _2: 'e}) | int & 'g | (Lam with {_2: 'd}) | (Pair with {_0: 'e, _1: 'e}) | (Plus with {_0: 'e, _1: 'e}) | (Second with {_0: 'e}) | Var | ~Apply & ~Closure & ~First & ~If & ~int & ~Lam & ~Pair & ~Plus & ~Second & ~Var
//│     'g :> int & {_0: int}
//│        <: 'h & 'f & (exp & int & {_0: int} | exp & {_0: anything} & ~int)
//│     'h <: 'f & (exp & int & {_0: int} | exp & ~int) & ((Closure with {_0: 'a, _1: 'e, _2: list['b]}) | ~Closure)
//│     'f :> Closure | error | int & {_0: int} | exp
//│        <: 'h & (exp & int & {_0: int} | exp & ~int)

let interp1 = interp (fun x _ -> x)
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.159: 	let interp1 = interp (fun x _ -> x)
//│ ╙──       	                          ^^^
//│ ╔══[ERROR] identifier not found: x
//│ ║  l.159: 	let interp1 = interp (fun x _ -> x)
//│ ╙──       	                                 ^
//│ interp1: error -> 'a -> ('b | 'c)
//│   where
//│     'a <: (Apply with {_0: 'a, _1: 'a}) | Closure & 'd & 'b & (exp & int & {_0: int} | exp & ~int) | (First with {_0: 'a}) | (If with {_0: 'a, _1: 'a, _2: 'a}) | int & 'c | Lam | (Pair with {_0: 'a, _1: 'a}) | (Plus with {_0: 'a, _1: 'a}) | (Second with {_0: 'a}) | Var | ~Apply & ~Closure & ~First & ~If & ~int & ~Lam & ~Pair & ~Plus & ~Second & ~Var
//│     'c :> int & {_0: int}
//│        <: 'd & 'b & (exp & int & {_0: int} | exp & {_0: anything} & ~int)
//│     'd <: 'b & (exp & int & {_0: int} | exp & ~int) & ((Closure with {_1: 'a, _2: list[?]}) | ~Closure)
//│     'b :> Closure | error | int & {_0: int} | exp
//│        <: 'd & (exp & int & {_0: int} | exp & ~int)

(****** Problem 3: complete this function *******)

let rec computeFreeVars e = raise Unimplemented
//│ computeFreeVars: anything -> nothing

let interp2 = interp (fun (env:env) opt ->
  match opt with
     None -> raise BadPrecomputation
   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.180: 	let interp2 = interp (fun (env:env) opt ->
//│ ╙──       	                          ^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: opt
//│ ║  l.181: 	  match opt with
//│ ╙──       	        ^^^
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.183: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                 ^^^^
//│ ╔══[ERROR] identifier not found: List
//│ ║  l.183: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                                        ^^^^
//│ ╔══[ERROR] identifier not found: env
//│ ║  l.183: 	   | Some lst -> List.map (fun s -> (s, List.assoc s env)) lst)
//│ ╙──       	                                                     ^^^
//│ interp2: error -> 'a -> ('b | 'c)
//│   where
//│     'a <: (Apply with {_0: 'a, _1: 'a}) | Closure & 'd & 'b & (exp & int & {_0: int} | exp & ~int) | (First with {_0: 'a}) | (If with {_0: 'a, _1: 'a, _2: 'a}) | int & 'c | Lam | (Pair with {_0: 'a, _1: 'a}) | (Plus with {_0: 'a, _1: 'a}) | (Second with {_0: 'a}) | Var | ~Apply & ~Closure & ~First & ~If & ~int & ~Lam & ~Pair & ~Plus & ~Second & ~Var
//│     'c :> int & {_0: int}
//│        <: 'd & 'b & (exp & int & {_0: int} | exp & {_0: anything} & ~int)
//│     'd <: 'b & (exp & int & {_0: int} | exp & ~int) & ((Closure with {_1: 'a, _2: list[?]}) | ~Closure)
//│     'b :> Closure | error | int & {_0: int} | exp
//│        <: 'd & (exp & int & {_0: int} | exp & ~int)

(******* Problem 4: not programming (see assignment) ********)

(******* Problem 5a: explain this function *********)

let interp3 = interp (fun (env:env) _ -> [])
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.212: 	let interp3 = interp (fun (env:env) _ -> [])
//│ ╙──       	                          ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.212: 	let interp3 = interp (fun (env:env) _ -> [])
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Nil` is not a function
//│ ║  l.1: 	type 'a list = Cons of 'a * 'a list | Nil
//│ ║       	                                      ^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.110: 	 | Lam(s,e2,opt) -> Closure(s,e2,f env opt) (*store env!*) 
//│ ╙──       	                                 ^^^^^
//│ interp3: error -> 'a -> ('b | 'c)
//│   where
//│     'a <: (Apply with {_0: 'a, _1: 'a}) | Closure & 'd & 'b & (exp & int & {_0: int} | exp & ~int) | (First with {_0: 'a}) | (If with {_0: 'a, _1: 'a, _2: 'a}) | int & 'c | Lam | (Pair with {_0: 'a, _1: 'a}) | (Plus with {_0: 'a, _1: 'a}) | (Second with {_0: 'a}) | Var | ~Apply & ~Closure & ~First & ~If & ~int & ~Lam & ~Pair & ~Plus & ~Second & ~Var
//│     'c :> int & {_0: int}
//│        <: 'd & 'b & (exp & int & {_0: int} | exp & {_0: anything} & ~int)
//│     'd <: 'b & (exp & int & {_0: int} | exp & ~int) & ((Closure with {_1: 'a, _2: list[?]}) | ~Closure)
//│     'b :> Closure | error | int & {_0: int} | exp
//│        <: 'd & (exp & int & {_0: int} | exp & ~int)

(****** Problem 5b (EXTRA CREDIT): explain the next two functions ******)

let rec depthToExp s varlist exp =
   match varlist with
    [] -> raise BadSourceProgram
  | hd::tl -> if s=hd then First exp else depthToExp s tl (Second exp)
   
let rec translate varlist exp = 
   match exp with
   Var s -> depthToExp s varlist (Var "arg")
 | Lam(s,e2,_) -> Pair(Lam("arg",translate (s::varlist) e2, None), 
                       match varlist with [] -> Int 0 | _ -> Var "arg")
 | Closure _ -> raise BadSourceProgram
 | Apply(e1,e2) -> 
   let e1' = translate varlist e1 in
   let e2' = translate varlist e2 in
   (* ############################################# *)
   Apply(Lam("f",Apply(First(First(Var "f")), 
                       Pair(Second(Var "f"),Second(First(Var "f")))),None),
         Pair(e1',e2'))
 | Int _ -> exp
 | Pair(e1,e2) -> Pair(translate varlist e1, translate varlist e2)
 | Plus(e1,e2) -> Plus(translate varlist e1, translate varlist e2)
 | First(e1) -> First(translate varlist e1)
 | Second(e1) -> Second(translate varlist e1)
 | If(e1,e2,e3) -> If(translate varlist e1,
                      translate varlist e2,
                      translate varlist e3)
//│ /!\ Parse error: Expected (Index ~ parens | Index ~ record | Index ~ ("-".? ~ floatnumber | number | stringliteral | lit) | Index ~ filter | ocamlList):9:24, found "match varl" at l.245:24:                        match varlist with [] -> Int 0 | _ -> Var "arg")

(********** examples and testing ***********)

(* ################################
#############################
###########################################################
############################################
 *)

(* ##################################################### *)
let ex1 = (Apply(Apply(Lam("x",Lam("y", Plus(Var"x",Var "y"),None),None), 
		      Int 17),
		Int 19))
//│ ex1: exp

(* #####################################################################
################################# *)

(* ################################################################### *)
let lam x e = Lam(x,e,None)
let app e1 e2 = Apply(e1,e2)
let vx = Var "x"
let vy = Var "y"
let vf = Var "f"
//│ lam: string -> exp -> exp
//│ app: exp -> exp -> exp
//│ vx: exp
//│ vy: exp
//│ vf: exp

(* ########################### *)
let fix = 
   let e = lam "x" (app vf (lam "y" (app (app vx vx) vy))) in
   lam "f" (app e e)
//│ fix: exp

(* ################################################ *)
let sum = 
  lam "f" (lam "x" (If(vx,
		       Plus(vx, app vf (Plus(vx, Int (-1)))),
		       Int 0)))
//│ /!\ Parse error: Expected ")":3:41, found "-1)))),\n\t\t" at l.302:41: 		       Plus(vx, app vf (Plus(vx, Int (-1)))),

(* ############################################################### *)
let ex2 = (app (app fix sum) (Int 1000))
//│ ╔══[ERROR] identifier not found: sum
//│ ║  l.307: 	let ex2 = (app (app fix sum) (Int 1000))
//│ ╙──       	                        ^^^
//│ ex2: exp

(* ########################################################### *)

let ans1 = interp1 [] ex1
let ans2 = interp1 [] ex2
//│ ans1: Closure | error | int & {_0: int} | exp
//│ ans2: Closure | error | int & {_0: int} | exp

let ans3 = interp2 [] (fst (computeFreeVars ex1))
let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.320: 	let ans3 = interp2 [] (fst (computeFreeVars ex1))
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `(?b, ?c,)`
//│ ║  l.320: 	let ans3 = interp2 [] (fst (computeFreeVars ex1))
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.5: 	let fst: ('a * 'b) -> 'a
//│ ╙──     	          ^^^^^^^
//│ ans3: Closure | error | int & {_0: int} | exp
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.321: 	let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `(?b, ?c,)`
//│ ║  l.321: 	let ans4 = interp2 [] (fst (computeFreeVars ex2))
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.5: 	let fst: ('a * 'b) -> 'a
//│ ╙──     	          ^^^^^^^
//│ ans4: Closure | error | int & {_0: int} | exp

let ans5 = interp3 [] (translate [] ex1)
let ans6 = interp3 [] (translate [] ex2)
//│ ╔══[ERROR] identifier not found: translate
//│ ║  l.343: 	let ans5 = interp3 [] (translate [] ex1)
//│ ╙──       	                       ^^^^^^^^^
//│ ans5: Closure | error | int & {_0: int} | exp
//│ ╔══[ERROR] identifier not found: translate
//│ ║  l.344: 	let ans6 = interp3 [] (translate [] ex2)
//│ ╙──       	                       ^^^^^^^^^
//│ ans6: Closure | error | int & {_0: int} | exp

