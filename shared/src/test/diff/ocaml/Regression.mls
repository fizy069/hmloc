:AllowTypeErrors



let test =
  let f x = x in
  (f 1 + f true)
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) ---> (?a) ---> (int)
//│ 
//│ ◉ (bool) is here
//│ │  - l.3    (f 1 + f true)
//│ │                    ^^^^
//│ │  - l.2    let f x = x in
//│ │                 ^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.2    let f x = x in
//│ │                 ^
//│ │  - l.2    let f x = x in
//│ │                     ^
//│ │  - l.3    (f 1 + f true)
//│ │                  ^^^^^^
//│ ▼ 
//│ ◉ (int) is here
//│    - lib. let (+): int -> int -> int
//│                           ^^^
//│ test: int
//│ test: int
//│ U max: 1, total: 4
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool <: α71', α71' <: int]

// TODO: show error
let test2 = let (a, b) = test in [[b]] + 1
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) ---> (_ * _)
//│ 
//│ ◉ (int) is here
//│ │  - lib. let (+): int -> int -> int
//│ │                                ^^^
//│ │  - l.-28  (f 1 + f true)
//│ │           ^^^^^^^^^^^^^^^
//│ │  - l.1  let test2 = let (a, b) = test in [[b]] + 1
//│ │                                  ^^^^
//│ ▼ 
//│ ◉ (_ * _) is here
//│    - l.1  let test2 = let (a, b) = test in [[b]] + 1
//│                           ^^^^^^
//│ [ERROR] Type `_ list` does not match `int`
//│ 
//│         (_ list) ---> (int)
//│ 
//│ ◉ (_ list) is here
//│ │  - l.1  let test2 = let (a, b) = test in [[b]] + 1
//│ │                                           ^^^
//│ ▼ 
//│ ◉ (int) is here
//│    - lib. let (+): int -> int -> int
//│                    ^^^
//│ test2: int
//│ test2: int
//│ U max: 2, total: 12
//│ UERR 2 errors
//│ L: 0 [list['a77'] ~ int, list['a77'] <: int]
//│ L: 0 [int ~ ([α75'], [α76'],), int <: ([α75'], [α76'],)]

// TODO: show error
let f x = x + 1
not (f 1)
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) ---> (bool)
//│ 
//│ ◉ (int) is here
//│ │  - lib. let (+): int -> int -> int
//│ │                                ^^^
//│ │  - l.1  let f x = x + 1
//│ │                   ^^^^^
//│ │  - l.2  not (f 1)
//│ │             ^^^^^
//│ ▼ 
//│ ◉ (bool) is here
//│    - lib. let not: bool -> bool
//│                    ^^^^
//│ f: int -> int
//│ f: int -> int
//│ res: bool
//│ resU: bool
//│ U max: 1, total: 4
//│ UERR 1 errors
//│ L: 0 [int ~ bool, int <: bool]

// TODO: show error
:d
let a = 1
not a
//│ 1. Typing term 1 IntLit
//│ 1. : int
//│ ⬤ Typed as: int
//│  where: 
//│ ⬤ U Typed as: int
//│  where: 
//│ 0. Typing term not a App
//│ | 0. Typing term not Var
//│ | 0. : [(bool -> bool)]
//│ | 0. Typing term a Var
//│ | 0. : [int]
//│ | CONSTRAIN [int] <! bool
//│ |   where 
//│ | C [int] <! bool    (0) where ProvType <: TypeRef}
//│ | | C int <! bool    (0) where TypeRef <: TypeRef}
//│ | | | !! COLLISION ERROR (List(int, [int]),List(bool))
//│ | U Q [int] ~ bool
//│ | U L: 0 [int ~ bool, int <: bool]
//│ | UERR L: 0 [int ~ bool, int <: bool]
//│ 0. : [bool]
//│ ⬤ Typed as: [bool]
//│  where: 
//│ ⬤ U Typed as: [bool]
//│  where: 
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) ---> (bool)
//│ 
//│ ◉ (int) is here
//│ │  - l.1  let a = 1
//│ │                 ^
//│ │  - l.2  not a
//│ │             ^
//│ ▼ 
//│ ◉ (bool) is here
//│    - lib. let not: bool -> bool
//│                    ^^^^
//│ a: int
//│ a: int
//│ res: bool
//│ resU: bool
//│ U max: 1, total: 1
//│ UERR 1 errors
//│ L: 0 [int ~ bool, int <: bool]


let confluence z = if true then z else 5
confluence true
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) ---> (?a) ---> (?b) <--- (int)
//│ 
//│ ◉ (bool) is here
//│ │  - l.2  confluence true
//│ │                    ^^^^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                        ^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                        ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                                         ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ ▲  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) is here
//│    - l.1  let confluence z = if true then z else 5
//│                                                  ^
//│ confluence: 'a -> (int | 'a)
//│ confluence: int -> int
//│ res: bool | int
//│ resU: 'a
//│   where
//│     'a = bool, int
//│ U max: 2, total: 7
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool <: α101, α101 <: α102, α102 :> int]


let x: int list
let y: string list
let f: string list -> unit
//│ x: list[int]
//│ x: list[int]
//│ y: list[string]
//│ y: list[string]
//│ f: list[string] -> unit
//│ f: list[string] -> unit

// TODO: this won't show error because there are no type variables
f x
//│ [ERROR] Type `int` does not match `string`
//│ 
//│         (int) ~~~~ (string)
//│ 
//│   ◉ (int list) is here
//│   │  - l.-10let x: int list
//│   │                ^^^^^^^^
//│   │  - l.1  f x
//│   │           ^
//│   ▼ 
//│   ◉ (string list) is here
//│      - l.-8 let f: string list -> unit
//│                    ^^^^^^^^^^^
//│ U max: 1, total: 2
//│ UERR 1 errors
//│ L: 1 [int ~ string, [int - list[int] ~ list[string] - string, L: 0 [list[int] ~ list[string], list[int] <: list[string]]]]

// Should show
// ╔══[ERROR] Type `string list` does not match `int list`
// ║  
// ╟──        string list ---> ?a <--- int list 
// ║  
// ╟── `string list` comes from this type expression
// ║  l.-10: 	let y: string list
// ║         	       ^^^^^^^^^^^
// ╟── this `else` branch has type `string list` and it flows into `?a`
// ║  l.1: 	if true then x else y
// ║       	                    ^
// ╟── this if-then-else expression has type `?a`
// ║  l.1: 	if true then x else y
// ║       	^^^^^^^^^^^^^^^^^^^^^
// ╟── this `then` branch has type `?a` and it flows from `int list`
// ║  l.1: 	if true then x else y
// ║       	             ^
// ╟── this applied type reference has type `int list`
// ║  l.-11: 	let x: int list
// ╙──       	       ^^^^^^^^
// res: list[int | string]
if true then x else y
//│ [ERROR] Type `string` does not match `int`
//│ 
//│         (string) ~~~~ (int)
//│ 
//│   ◉ (string list) is here
//│   │  - l.-48let y: string list
//│   │                ^^^^^^^^^^^
//│   │  - l.1  if true then x else y
//│   │                             ^
//│   │  - l.1  if true then x else y
//│   │         ^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a) is assumed here
//│   ▲  - l.1  if true then x else y
//│   │         ^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  if true then x else y
//│   │                      ^
//│   │ 
//│   ◉ (int list) is here
//│      - l.-49let x: int list
//│                    ^^^^^^^^
//│ res: list[string] | list[int]
//│ resU: 'a
//│   where
//│     'a = list[string], list[int]
//│ U max: 1, total: 5
//│ UERR 1 errors
//│ L: 1 [string ~ int, [string - list[string] ~ list[int] - int, L: 0 [list[string] ~ list[int], list[string] <: α108, α108 :> list[int]]]]

// TODO: show error
Left 1 : int
//│ [ERROR] Type `(_, _) either` does not match `int`
//│ 
//│         ((_, _) either) ---> (int)
//│ 
//│ ◉ ((_, _) either) is here
//│ │  - lib. type ('a, 'b) either = Left of 'a | Right of 'b
//│ │                                ^^^^^^^^^^
//│ │  - l.1  Left 1 : int
//│ │         ^^^^^^
//│ ▼ 
//│ ◉ (int) is here
//│    - l.1  Left 1 : int
//│                    ^^^
//│ res: int
//│ resU: int
//│ U max: 1, total: 2
//│ UERR 1 errors
//│ L: 0 [either[α110,α111] ~ int, either[α110,α111] <: int]


let confluence z = if true then z else 5
let mkpair x y = (x, confluence y)
mkpair 1 "2"
//│ [ERROR] Type `string` does not match `int`
//│ 
//│         (string) ---> (?a) ---> (?b) ---> (?c) <--- (int)
//│ 
//│ ◉ (string) is here
//│ │  - l.3  mkpair 1 "2"
//│ │                  ^^^
//│ │  - l.2  let mkpair x y = (x, confluence y)
//│ │                      ^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ │  - l.2  let mkpair x y = (x, confluence y)
//│ │                      ^
//│ │  - l.2  let mkpair x y = (x, confluence y)
//│ │                                         ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                        ^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                        ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                                         ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│ ▲  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) is here
//│    - l.1  let confluence z = if true then z else 5
//│                                                  ^
//│ confluence: 'a -> (int | 'a)
//│ confluence: int -> int
//│ mkpair: 'a -> anything -> ('a, anything,)
//│ mkpair: 'a -> 'b -> ('a, int,)
//│ res: (anything, anything,)
//│ resU: (int, 'a,)
//│   where
//│     'a = string, int
//│ U max: 2, total: 10
//│ UERR 1 errors
//│ L: 0 [string ~ int, string <: α135, α135 <: α137, α137 <: α136, α136 :> int]

// TODO nested prov not shown in collision error
let a = 1
let b = a
let f x = if x then true else false
let g = f
g b
//│ [ERROR] Type `int` does not match `string list`
//│ 
//│         (int) ---> (string list)
//│ 
//│ ◉ (int) is here
//│ │  - l.1  let a = 1
//│ │                 ^
//│ │  - l.2  let b = a
//│ │                 ^
//│ │  - l.5  g b
//│ │           ^
//│ ▼ 
//│ ◉ (string list) is here
//│    - l.-148let f: string list -> unit
//│                   ^^^^^^^^^^^
//│ a: int
//│ a: int
//│ b: int
//│ b: int
//│ bool -> bool
//│   <:  f:
//│ list[string] -> unit
//│ f: bool -> bool
//│ g: list[string] -> unit
//│ g: list[string] -> unit
//│ U max: 1, total: 3
//│ UERR 1 errors
//│ L: 0 [int ~ list[string], int <: list[string]]

let wrap x = x :: []
  
// TODO: show error
if true then wrap 1 else wrap true
//│ wrap: 'a -> list['a]
//│ wrap: 'a -> list['a]


if true then wrap (if true then 1 else false) else wrap true
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) ---> (?a) <--- (int)
//│ 
//│ ◉ (bool) is here
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                                                ^^^^^
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed here
//│ ▲  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) is here
//│    - l.1  if true then wrap (if true then 1 else false) else wrap true
//│                                           ^
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) ---> (?b) ---> (?c) ~~~~ (?a) ~~~~ (?c) <--- (?b) <--- (bool)
//│ 
//│ ◉ (int) is here
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                                         ^
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│    - l.-7 let wrap x = x :: []
//│                    ^
//│   ◉ (?c * _ list) is here
//│   │  - l.-7 let wrap x = x :: []
//│   │                      ^
//│   ▼ 
//│   ◉ (?a * ?a list) is here
//│      - l.-7 let wrap x = x :: []
//│                          ^
//│   ◉ (?a * ?a list) is here
//│   ▲  - l.-7 let wrap x = x :: []
//│   │                      ^
//│   │ 
//│   ◉ (?c * _ list) is here
//│      - l.-7 let wrap x = x :: []
//│                          ^
//│ ◉ (?c) is assumed here
//│ ▲  - l.-7 let wrap x = x :: []
//│ │                  ^
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed here
//│ ▲  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (bool) is here
//│    - l.1  if true then wrap (if true then 1 else false) else wrap true
//│                                                  ^^^^^
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) ---> (?b) ---> (?c) ~~~~ (?a) ~~~~ (?a0) ~~~~ (?a) ~~~~ (?c) <--- (?b) <--- (bool)
//│ 
//│ ◉ (int) is here
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                                         ^
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│    - l.-7 let wrap x = x :: []
//│                    ^
//│   ◉ (?c * ?a list) is here
//│   │  - l.-7 let wrap x = x :: []
//│   │                      ^
//│   ▼ 
//│   ◉ (?a0 * ?a0 list) is here
//│      - l.-7 let wrap x = x :: []
//│                          ^
//│     ◉ (?a0 * ?a0 list) is here
//│     ▲  - l.-7 let wrap x = x :: []
//│     │                      ^
//│     │ 
//│     ◉ (?c * ?a list) is here
//│        - l.-7 let wrap x = x :: []
//│                            ^
//│     ◉ (?c * ?a list) is here
//│     │  - l.-7 let wrap x = x :: []
//│     │                      ^
//│     ▼ 
//│     ◉ (?a0 * ?a0 list) is here
//│        - l.-7 let wrap x = x :: []
//│                            ^
//│   ◉ (?a0 * ?a0 list) is here
//│   ▲  - l.-7 let wrap x = x :: []
//│   │                      ^
//│   │ 
//│   ◉ (?c * ?a list) is here
//│      - l.-7 let wrap x = x :: []
//│                          ^
//│ ◉ (?c) is assumed here
//│ ▲  - l.-7 let wrap x = x :: []
//│ │                  ^
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed here
//│ ▲  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (bool) is here
//│    - l.1  if true then wrap (if true then 1 else false) else wrap true
//│                                                  ^^^^^
//│ res: list[bool] | list[bool | int]
//│ resU: list[bool]
//│ U max: 8, total: 42
//│ UERR 3 errors
//│ L: 2 [int ~ bool, int <: α166, α166 <: α163, [α163 - ([[α163]], [[list['a165]]],) ~ ('a164, list['a164],) - 'a164, L: 0 [([[α163]], [[list['a165]]],) ~ ('a164, list['a164],), ([[α163]], [[list['a165]]],) <: ('a164, list['a164],)]], ['a164 - list['a164] ~ list['a165] - 'a165, L: 1 [list['a164] ~ list['a165], [list['a164] - ('a164, list['a164],) ~ ([[α163]], [[list['a165]]],) - list['a165], L: 0 [('a164, list['a164],) ~ ([[α163]], [[list['a165]]],), ('a164, list['a164],) :> ([[α163]], [[list['a165]]],)]]]], ['a165 - list['a165] ~ list['a164] - 'a164, L: 1 [list['a165] ~ list['a164], [list['a165] - ([[α163]], [[list['a165]]],) ~ ('a164, list['a164],) - list['a164], L: 0 [([[α163]], [[list['a165]]],) ~ ('a164, list['a164],), ([[α163]], [[list['a165]]],) <: ('a164, list['a164],)]]]], ['a164 - ('a164, list['a164],) ~ ([[α163]], [[list['a165]]],) - α163, L: 0 [('a164, list['a164],) ~ ([[α163]], [[list['a165]]],), ('a164, list['a164],) :> ([[α163]], [[list['a165]]],)]], α163 :> α166, α166 :> bool]
//│ L: 0 [bool ~ int, bool <: α166, α166 :> int]
//│ L: 1 [int ~ bool, int <: α166, α166 <: α163, [α163 - ([[α163]], [[list['a165]]],) ~ ('a164, list['a164],) - 'a164, L: 0 [([[α163]], [[list['a165]]],) ~ ('a164, list['a164],), ([[α163]], [[list['a165]]],) <: ('a164, list['a164],)]], ['a164 - ('a164, list['a164],) ~ ([[α163]], [[list['a165]]],) - α163, L: 0 [('a164, list['a164],) ~ ([[α163]], [[list['a165]]],), ('a164, list['a164],) :> ([[α163]], [[list['a165]]],)]], α163 :> α166, α166 :> bool]


let rec t = wrap (if true then 1 else t)
//│ t: 't
//│   where
//│     't :> list['t | int]
//│ t: int


let test z = if true then wrap z else wrap true
 
let rec m = test (if true then 1 else m)
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) ---> (?b) ---> (?c) ---> (?d) ~~~~ (?a) ~~~~ (?a0) ~~~~ (?e) <--- (bool)
//│ 
//│ ◉ (int) is here
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                                        ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                  ^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                  ^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                        ^
//│ ▼ 
//│ ◉ (?d) is assumed here
//│    - l.-143let wrap x = x :: []
//│                     ^
//│   ◉ (?d * _ list) is here
//│   │  - l.-143let wrap x = x :: []
//│   │                       ^
//│   ▼ 
//│   ◉ (?a * ?a list) is here
//│      - l.-143let wrap x = x :: []
//│                           ^
//│   ◉ (?a list) is here
//│   │  - l.-143let wrap x = x :: []
//│   │                       ^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                   ^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e) is assumed here
//│   ▲  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                               ^^^^^^^^^
//│   │ 
//│   ◉ (?a0 list) is here
//│      - l.-143let wrap x = x :: []
//│                           ^^^^^^^
//│   ◉ (?a0 * ?a0 list) is here
//│   ▲  - l.-143let wrap x = x :: []
//│   │                       ^
//│   │ 
//│   ◉ (?f * _ list) is here
//│      - l.-143let wrap x = x :: []
//│                           ^
//│ ◉ (?f) is assumed here
//│ ▲  - l.-143let wrap x = x :: []
//│ │                   ^
//│ │ 
//│ ◉ (bool) is here
//│    - l.1  let test z = if true then wrap z else wrap true
//│                                                      ^^^^
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│         (int) ---> (?b) ---> (?c) ---> (?d) ~~~~ (?a) ~~~~ (?a0) ~~~~ (?a1) ~~~~ (?a0) ~~~~ (?e) <--- (bool)
//│ 
//│ ◉ (int) is here
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                                        ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed here
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                  ^
//│ ▼ 
//│ ◉ (?c) is assumed here
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                  ^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                        ^
//│ ▼ 
//│ ◉ (?d) is assumed here
//│    - l.-143let wrap x = x :: []
//│                     ^
//│   ◉ (?d * _ list) is here
//│   │  - l.-143let wrap x = x :: []
//│   │                       ^
//│   ▼ 
//│   ◉ (?a * ?a list) is here
//│      - l.-143let wrap x = x :: []
//│                           ^
//│   ◉ (?a list) is here
//│   │  - l.-143let wrap x = x :: []
//│   │                       ^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                   ^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e) is assumed here
//│   ▲  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                               ^^^^^^^^^
//│   │ 
//│   ◉ (?a0 list) is here
//│      - l.-143let wrap x = x :: []
//│                           ^^^^^^^
//│     ◉ (?a0 * ?a0 list) is here
//│     ▲  - l.-143let wrap x = x :: []
//│     │                       ^
//│     │ 
//│     ◉ (?f * ?a1 list) is here
//│        - l.-143let wrap x = x :: []
//│                             ^
//│     ◉ (?f * ?a1 list) is here
//│     │  - l.-143let wrap x = x :: []
//│     │                       ^
//│     ▼ 
//│     ◉ (?a0 * ?a0 list) is here
//│        - l.-143let wrap x = x :: []
//│                             ^
//│   ◉ (?a0 * ?a0 list) is here
//│   ▲  - l.-143let wrap x = x :: []
//│   │                       ^
//│   │ 
//│   ◉ (?f * ?a1 list) is here
//│      - l.-143let wrap x = x :: []
//│                           ^
//│ ◉ (?f) is assumed here
//│ ▲  - l.-143let wrap x = x :: []
//│ │                   ^
//│ │ 
//│ ◉ (bool) is here
//│    - l.1  let test z = if true then wrap z else wrap true
//│                                                      ^^^^
//│ test: 'a -> (list[bool] | list['a])
//│ test: bool -> list[bool]
//│ m: 'm
//│   where
//│     'm :> list[bool] | list['a]
//│     'a :> 'm | int
//│ m: int
//│ U max: 7, total: 53
//│ UERR 2 errors
//│ L: 1 [int ~ bool, int <: α227', α227' <: α219', α219' <: α226', [α226' - ([[α226']], [[list['a221']]],) ~ ('a220', list['a220'],) - 'a220', L: 0 [([[α226']], [[list['a221']]],) ~ ('a220', list['a220'],), ([[α226']], [[list['a221']]],) <: ('a220', list['a220'],)]], ['a220' - list['a220'] ~ list['a223'] - 'a223', L: 0 [list['a220'] ~ list['a223'], list['a220'] <: α225', α225' :> list['a223']]], ['a223' - ('a223', list['a223'],) ~ ([[α222']], [[list['a224']]],) - α222', L: 0 [('a223', list['a223'],) ~ ([[α222']], [[list['a224']]],), ('a223', list['a223'],) :> ([[α222']], [[list['a224']]],)]], α222' :> bool]
//│ L: 2 [int ~ bool, int <: α227', α227' <: α219', α219' <: α226', [α226' - ([[α226']], [[list['a221']]],) ~ ('a220', list['a220'],) - 'a220', L: 0 [([[α226']], [[list['a221']]],) ~ ('a220', list['a220'],), ([[α226']], [[list['a221']]],) <: ('a220', list['a220'],)]], ['a220' - list['a220'] ~ list['a223'] - 'a223', L: 0 [list['a220'] ~ list['a223'], list['a220'] <: α225', α225' :> list['a223']]], ['a223' - list['a223'] ~ list['a224'] - 'a224', L: 1 [list['a223'] ~ list['a224'], [list['a223'] - ('a223', list['a223'],) ~ ([[α222']], [[list['a224']]],) - list['a224'], L: 0 [('a223', list['a223'],) ~ ([[α222']], [[list['a224']]],), ('a223', list['a223'],) :> ([[α222']], [[list['a224']]],)]]]], ['a224' - list['a224'] ~ list['a223'] - 'a223', L: 1 [list['a224'] ~ list['a223'], [list['a224'] - ([[α222']], [[list['a224']]],) ~ ('a223', list['a223'],) - list['a223'], L: 0 [([[α222']], [[list['a224']]],) ~ ('a223', list['a223'],), ([[α222']], [[list['a224']]],) <: ('a223', list['a223'],)]]]], ['a223' - ('a223', list['a223'],) ~ ([[α222']], [[list['a224']]],) - α222', L: 0 [('a223', list['a223'],) ~ ([[α222']], [[list['a224']]],), ('a223', list['a223'],) :> ([[α222']], [[list['a224']]],)]], α222' :> bool]


// FIXME implementation exception
let rec digitsOfInt n =
  ((digitsOfInt n) / 10) @ [remainder];;
//│ [ERROR] Type `int` does not match `_ list`
//│ 
//│         (int) ---> (_ list)
//│ 
//│ ◉ (int) is here
//│ │  - lib. let ( / ): int -> int -> int
//│ │                                  ^^^
//│ │  - l.2    ((digitsOfInt n) / 10) @ [remainder];;
//│ │           ^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ list) is here
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                    ^^^^^^^
//│ ╔══[ERROR] identifier not found: remainder
//│ ║  
//│ ║  l.671:	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                            ^^^^^^^^^
//│ digitsOfInt: anything -> list[error]
//│ digitsOfInt: 'a -> int
//│ U max: 3, total: 18
//│ UERR 1 errors
//│ L: 0 [int ~ list[α246'], int <: list[α246']]
