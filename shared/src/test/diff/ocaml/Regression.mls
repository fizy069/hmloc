:AllowTypeErrors



let test =
  let f x = x in
  (f 1 + f true)
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│ ◉ (int) is here
//│ │  - l.3    (f 1 + f true)
//│ │              ^
//│ │  - l.2    let f x = x in
//│ │                 ^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ ▲  - l.2    let f x = x in
//│ │                 ^
//│ │ 
//│ ◉ (bool) is here
//│    - l.3    (f 1 + f true)
//│                      ^^^^
//│ test: int
//│ U max: 3, total: 5
//│ UERR 1 errors
//│ L: 0 [int ~ [[[bool]]], [[int]] <: α67', α67' :> [[[bool]]]]

// TODO: show error
let test2 = let (a, b) = test in [[b]] + 1
//│ test2: int

// TODO: show error
let f x = x + 1
not (f 1)
//│ f: int -> int
//│ res: bool

// TODO: show error
:d
let a = 1
not a
//│ 1. Typing term 1
//│ 1. : int
//│ ⬤ Typed as: int
//│  where: 
//│ 0. Typing term not a
//│ | 0. Typing term not
//│ | 0. : [(bool -> bool)]
//│ | 0. Typing term a
//│ | 0. : [int]
//│ | CONSTRAIN [int] <! bool
//│ |   where 
//│ | C [int] <! bool    (0) where ProvType <: TypeRef}
//│ | | C int <! bool    (0) where TypeRef <: TypeRef}
//│ | | | !! COLLISION ERROR (List(int, [int]),List(bool))
//│ 0. : [bool]
//│ ⬤ Typed as: [bool]
//│  where: 
//│ a: int
//│ res: bool


let confluence z = if true then z else 5
confluence true
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│ ◉ (int) is here
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                                                ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ ▲  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                                         ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                        ^
//│ │ 
//│ ◉ (bool) is here
//│    - l.2  confluence true
//│                      ^^^^
//│ confluence: 'a -> (int | 'a)
//│ res: bool | int
//│ U max: 8, total: 13
//│ UERR 1 errors
//│ L: 0 [int ~ [[[[[bool]]]]], [[int]] <: α99, α99 :> [[[[[bool]]]]]]


let x: int list
let y: string list
let f: string list -> unit
//│ x: list[int]
//│ y: list[string]
//│ f: list[string] -> unit

// TODO: this won't show error because there are no type variables
f x

// Should show
// ╔══[ERROR] Type `string list` does not match `int list`
// ║  
// ╟──        string list ---> ?a <--- int list 
// ║  
// ╟── `string list` comes from this type expression
// ║  l.-10: 	let y: string list
// ║         	       ^^^^^^^^^^^
// ╟── this `else` branch has type `string list` and it flows into `?a`
// ║  l.1: 	if true then x else y
// ║       	                    ^
// ╟── this if-then-else expression has type `?a`
// ║  l.1: 	if true then x else y
// ║       	^^^^^^^^^^^^^^^^^^^^^
// ╟── this `then` branch has type `?a` and it flows from `int list`
// ║  l.1: 	if true then x else y
// ║       	             ^
// ╟── this applied type reference has type `int list`
// ║  l.-11: 	let x: int list
// ╙──       	       ^^^^^^^^
// res: list[int | string]
if true then x else y
//│   ◉ (int list) is here
//│   │  - l.-30let x: int list
//│   │                ^^^^^^^^
//│   │  - l.1  if true then x else y
//│   │                      ^
//│   │  - l.1  if true then x else y
//│   │         ^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ ('a) is assumed here
//│   ▲  - l.1  if true then x else y
//│   │         ^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  if true then x else y
//│   │                             ^
//│   │ 
//│   ◉ (string list) is here
//│      - l.-29let y: string list
//│                    ^^^^^^^^^^^
//│ res: list[int | string]
//│ U max: 3, total: 8
//│ UERR 1 errors
//│ L: 1 [int ~ string, [int - list[int] ~ list[string] - string, [[[list[int]]]] <: α104, α104 :> [[[list[string]]]]]]

// TODO: show error
Left 1 : int
//│ res: int


let confluence z = if true then z else 5
let mkpair x y = (x, confluence y)
mkpair 1 "2"
//│ [ERROR] Type `int` does not match `string`
//│ 
//│ ◉ (int) is here
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                                                ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ ▲  - l.1  let confluence z = if true then z else 5
//│ │                            ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                                         ^
//│ │  - l.1  let confluence z = if true then z else 5
//│ │                        ^
//│ │  - l.2  let mkpair x y = (x, confluence y)
//│ │                                         ^
//│ │  - l.2  let mkpair x y = (x, confluence y)
//│ │                      ^
//│ │ 
//│ ◉ (string) is here
//│    - l.3  mkpair 1 "2"
//│                    ^^^
//│ confluence: 'a -> (int | 'a)
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)
//│ res: (int, int | string,)
//│ U max: 17, total: 27
//│ UERR 1 errors
//│ L: 0 [int ~ [[[[[[string]]]]]], [[int]] <: α130, α130 :> [[[[[[string]]]]]]]

// TODO nested prov not shown in collision error
let a = 1
let b = a
let f x = if x then true else false
let g = f
g b
//│ [ERROR] Type `bool` does not match `unit`
//│ 
//│ ◉ (bool) is here
//│ │  - l.3  let f x = if x then true else false
//│ │                             ^^^^
//│ │  - l.3  let f x = if x then true else false
//│ │                   ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ │  - l.3  let f x = if x then true else false
//│ │                   ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (unit) is here
//│    - l.-90let f: string list -> unit
//│                                 ^^^^
//│ [ERROR] Type `string list` does not match `bool`
//│ 
//│ ◉ (string list) is here
//│ │  - l.-90let f: string list -> unit
//│ │                ^^^^^^^^^^^
//│ │  - l.3  let f x = if x then true else false
//│ │               ^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ │  - l.3  let f x = if x then true else false
//│ │               ^
//│ ▼ 
//│ ◉ (bool) is here
//│    - l.3  let f x = if x then true else false
//│                        ^
//│ a: int
//│ b: int
//│ bool -> bool
//│   <:  f:
//│ list[string] -> unit
//│ g: list[string] -> unit
//│ U max: 8, total: 12
//│ UERR 2 errors
//│ L: 0 [list[string] ~ [[[bool]]], [[[list[string]]]] <: α142, α142 <: [[[bool]]]]
//│ L: 0 [bool ~ [[[unit]]], [[[bool]]] <: α143, α143 <: [[[unit]]]]

let wrap x = x :: []
  
// TODO: show error
if true then wrap 1 else wrap true
//│ wrap: 'a -> list['a]


if true then wrap (if true then 1 else false) else wrap true
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│ ◉ (int) is here
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                                         ^
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ ▲  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (bool) is here
//│    - l.1  if true then wrap (if true then 1 else false) else wrap true
//│                                                  ^^^^^
//│ [ERROR] Type `int` does not match `bool`
//│ 
//│ ◉ (int) is here
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                                         ^
//│ │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-6 let wrap x = x :: []
//│ │                  ^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│    - l.-6 let wrap x = x :: []
//│                        ^
//│   ◉ (_ list) is here
//│   │  - l.-6 let wrap x = x :: []
//│   │                      ^^^^^^^
//│   │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ ('b) is assumed here
//│   ▲  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  if true then wrap (if true then 1 else false) else wrap true
//│   │                                                            ^^^^^^^^^
//│   │ 
//│   ◉ (_ list) is here
//│      - l.-6 let wrap x = x :: []
//│                          ^^^^^^^
//│ ◉ ('a0) is assumed here
//│ ▲  - l.-6 let wrap x = x :: []
//│ │                      ^
//│ │  - l.-6 let wrap x = x :: []
//│ │                  ^
//│ │ 
//│ ◉ (bool) is here
//│    - l.1  if true then wrap (if true then 1 else false) else wrap true
//│                                                                   ^^^^
//│ res: list[bool | int]
//│ U max: 16, total: 42
//│ UERR 2 errors
//│ L: 0 [int ~ [[[bool]]], [[int]] <: α158, α158 :> [[[bool]]]]
//│ L: 1 [int ~ [[[[[bool]]]]], [[[[[int]]]]] <: 'a156, ['a156 - list['a156] ~ list['a161] - 'a161, [[[[list['a156]]]]] <: α154, α154 :> [[[[list['a161]]]]]], 'a161 :> [[[[[bool]]]]]]


let rec t = wrap (if true then 1 else t)
//│ [ERROR] Type `int` does not match `_ list`
//│ 
//│ ◉ (int) is here
//│ │  - l.1  let rec t = wrap (if true then 1 else t)
//│ │                                        ^
//│ │  - l.1  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ ▲  - l.1  let rec t = wrap (if true then 1 else t)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let rec t = wrap (if true then 1 else t)
//│ │                                               ^
//│ │  - l.1  let rec t = wrap (if true then 1 else t)
//│ │                 ^
//│ │  - l.1  let rec t = wrap (if true then 1 else t)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list) is here
//│    - l.-68let wrap x = x :: []
//│                        ^^^^^^^
//│ t: 't
//│   where
//│     't :> list[int | 't]
//│ U max: 16, total: 24
//│ UERR 1 errors
//│ L: 0 [int ~ [[[[[[list['a174']]]]]]], [[int]] <: α176', α176' :> [[[[[[list['a174']]]]]]]]


let test z = if true then wrap z else wrap true
 
let rec m = test (if true then 1 else m)
//│ [ERROR] Type `bool` does not match `_ list`
//│ 
//│ ◉ (bool) is here
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                                    ^^^^
//│ │  - l.-98let wrap x = x :: []
//│ │                  ^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│    - l.-98let wrap x = x :: []
//│                        ^
//│   ◉ (_ list) is here
//│   │  - l.-98let wrap x = x :: []
//│   │                      ^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                               ^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                 ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                                               ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ ('b) is assumed here
//│   ▲  - l.3  let rec m = test (if true then 1 else m)
//│   │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                                               ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                 ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                   ^^^^^^
//│   │ 
//│   ◉ (_ list) is here
//│      - l.-98let wrap x = x :: []
//│                          ^^^^^^^
//│ ◉ ('a0) is assumed here
//│ ▲  - l.-98let wrap x = x :: []
//│ │                      ^
//│ │  - l.-98let wrap x = x :: []
//│ │                  ^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                        ^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                  ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                                               ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                 ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                   ^^^^^^
//│ │ 
//│ ◉ ('a0 list) is here
//│    - l.-98let wrap x = x :: []
//│                        ^^^^^^^
//│ [ERROR] Type `bool` does not match `_ list`
//│ 
//│ ◉ (bool) is here
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                                    ^^^^
//│ │  - l.-98let wrap x = x :: []
//│ │                  ^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│    - l.-98let wrap x = x :: []
//│                        ^
//│   ◉ (_ list) is here
//│   │  - l.-98let wrap x = x :: []
//│   │                      ^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                               ^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                 ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                                               ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ ('b) is assumed here
//│   ▲  - l.3  let rec m = test (if true then 1 else m)
//│   │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                                               ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                 ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                   ^^^^^^
//│   │ 
//│   ◉ (_ list) is here
//│      - l.-98let wrap x = x :: []
//│                          ^^^^^^^
//│ ◉ ('a0) is assumed here
//│ ▲  - l.-98let wrap x = x :: []
//│ │                      ^
//│ │  - l.-98let wrap x = x :: []
//│ │                  ^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                        ^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                  ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                                               ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                 ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                               ^^^^^^^^^
//│ │ 
//│ ◉ ('a list) is here
//│    - l.-98let wrap x = x :: []
//│                        ^^^^^^^
//│ [ERROR] Type `int` does not match `_ list`
//│ 
//│ ◉ (int) is here
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                                        ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ ▲  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                                               ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                 ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                   ^^^^^^
//│ │ 
//│ ◉ (_ list) is here
//│    - l.-98let wrap x = x :: []
//│                        ^^^^^^^
//│ [ERROR] Type `int` does not match `_ list`
//│ 
//│ ◉ (int) is here
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                                        ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ ▲  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                                               ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                 ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                               ^^^^^^^^^
//│ │ 
//│ ◉ (_ list) is here
//│    - l.-98let wrap x = x :: []
//│                        ^^^^^^^
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│ ◉ (bool) is here
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                                    ^^^^
//│ │  - l.-98let wrap x = x :: []
//│ │                  ^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│    - l.-98let wrap x = x :: []
//│                        ^
//│   ◉ (_ list) is here
//│   │  - l.-98let wrap x = x :: []
//│   │                      ^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                               ^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                 ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                                               ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ ('b) is assumed here
//│   ▲  - l.3  let rec m = test (if true then 1 else m)
//│   │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                                               ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                 ^
//│   │  - l.3  let rec m = test (if true then 1 else m)
//│   │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  let test z = if true then wrap z else wrap true
//│   │                                   ^^^^^^
//│   │ 
//│   ◉ (_ list) is here
//│      - l.-98let wrap x = x :: []
//│                          ^^^^^^^
//│ ◉ ('a0) is assumed here
//│ ▲  - l.-98let wrap x = x :: []
//│ │                      ^
//│ │  - l.-98let wrap x = x :: []
//│ │                  ^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                                        ^
//│ │  - l.1  let test z = if true then wrap z else wrap true
//│ │                  ^
//│ │  - l.3  let rec m = test (if true then 1 else m)
//│ │                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) is here
//│    - l.3  let rec m = test (if true then 1 else m)
//│                                          ^
//│ test: 'a -> list[bool | 'a]
//│ m: 'm
//│   where
//│     'm :> list[int | 'm | bool]
//│ U max: 51, total: 93
//│ UERR 5 errors
//│ L: 1 [bool ~ [[[[[[[[[[[[[list['a212']]]]]]]]]]]]]], [[[[[bool]]]]] <: 'a212', ['a212' - list['a212'] ~ list['a208'] - 'a208', [[[[[[[[list['a212']]]]]]]]] <: α215', α215' :> [[[[[[[[list['a208']]]]]]]]]], 'a208' :> [[[[[[[[[[[[[list['a212']]]]]]]]]]]]]]]
//│ L: 1 [bool ~ [[[[[[[[[[[[[list['a208']]]]]]]]]]]]]], [[[[[bool]]]]] <: 'a212', ['a212' - list['a212'] ~ list['a208'] - 'a208', [[[[[[[[list['a212']]]]]]]]] <: α215', α215' :> [[[[[[[[list['a208']]]]]]]]]], 'a208' :> [[[[[[[[[[[[[list['a208']]]]]]]]]]]]]]]
//│ L: 0 [int ~ [[[[[[[[list['a208']]]]]]]]], [[int]] <: α215', α215' :> [[[[[[[[list['a208']]]]]]]]]]
//│ L: 0 [int ~ [[[[[[[[list['a212']]]]]]]]], [[int]] <: α215', α215' :> [[[[[[[[list['a212']]]]]]]]]]
//│ L: 1 [bool ~ [[[[[[[int]]]]]]], [[[[[bool]]]]] <: 'a212', ['a212' - list['a212'] ~ list['a208'] - 'a208', [[[[[[[[list['a212']]]]]]]]] <: α215', α215' :> [[[[[[[[list['a208']]]]]]]]]], 'a208' :> [[[[[[[int]]]]]]]]


// FIXME implementation exception
let rec digitsOfInt n =
  ((digitsOfInt n) / 10) @ [remainder];;
//│ [ERROR] Type `_ list` does not match `int`
//│ 
//│   ◉ (_ -> _ list) is here
//│   │  - l.1  let rec digitsOfInt n =
//│   │                             ^^^
//│   │           ((digitsOfInt n) / 10) @ [remainder];;
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.1  let rec digitsOfInt n =
//│   │                 ^^^^^^^^^^^
//│   ▼ 
//│   ◉ ('digitsOfInt) is assumed here
//│   │  - l.1  let rec digitsOfInt n =
//│   │                 ^^^^^^^^^^^
//│   ▼ 
//│   ◉ (_ -> _) is here
//│      - l.2    ((digitsOfInt n) / 10) @ [remainder];;
//│                 ^^^^^^^^^^^
//│ ◉ ('a) is assumed here
//│ │  - l.2    ((digitsOfInt n) / 10) @ [remainder];;
//│ │            ^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (int) is here
//│    - lib. let ( / ): int -> int -> int
//│                      ^^^
//│ [ERROR] Type `_ list` does not match `int`
//│ 
//│ ◉ (_ list) is here
//│ │  - lib. let (@): 'a list -> 'a list -> 'a list
//│ │                                        ^^^^^^^
//│ │  - l.2    ((digitsOfInt n) / 10) @ [remainder];;
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2    ((digitsOfInt n) / 10) @ [remainder];;
//│ │            ^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ ('a) is assumed here
//│ │  - l.2    ((digitsOfInt n) / 10) @ [remainder];;
//│ │            ^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (int) is here
//│    - lib. let ( / ): int -> int -> int
//│                      ^^^
//│ ╔══[ERROR] identifier not found: remainder
//│ ║  
//│ ║  l.594:	  ((digitsOfInt n) / 10) @ [remainder];;
//│ ╙──      	                            ^^^^^^^^^
//│ digitsOfInt: anything -> list[error]
//│ U max: 10, total: 26
//│ UERR 2 errors
//│ L: 0 [list[α232'] ~ [[int]], [[[[list[α232']]]]] <: α234', α234' <: [[int]]]
//│ L: 1 [list[α232'] ~ [[int]], [[list[α232']] - (α231' -> [list[α232']]) ~ ([α231'] -> α234') - α234', [[(α231' -> [list[α232']])]] <: digitsOfInt230', digitsOfInt230' <: [[[([α231'] -> α234')]]]], α234' <: [[int]]]
