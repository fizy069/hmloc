:AllowTypeErrors

// TODO: show better error
:e
let test =
  let f x = x in
  (f 1 + f true)
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── this reference has type `bool`
//│ ║  l.3: 	  (f 1 + f true)
//│ ║       	           ^^^^
//│ ╟── so this variable has type `bool`
//│ ║  l.2: 	  let f x = x in
//│ ║       	        ^
//│ ╟── but `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	                ^^^
//│ test: int

// TODO: show error
let test2 = let (a, b) = test in [[b]] + 1
//│ test2: int

// TODO: show error
let f x = x + 1
not (f 1)
//│ f: int -> int
//│ res: bool

// TODO: show error
:d
let a = 1
not a
//│ 1. Typing term 1
//│ 1. : int
//│ ⬤ Typed as: int
//│  where: 
//│ 0. Typing term not a
//│ | 0. Typing term not
//│ | 0. : [(bool -> bool)]
//│ | 0. Typing term a
//│ | 0. : [int]
//│ | CONSTRAIN [int] <! bool
//│ |   where 
//│ | C [int] <! bool    (0) where ProvType <: TypeRef}
//│ | | C int <! bool    (0) where TypeRef <: TypeRef}
//│ | | | !! COLLISION ERROR (List(int, [int]),List(bool))
//│ 0. : [bool]
//│ ⬤ Typed as: [bool]
//│  where: 
//│ a: int
//│ res: bool

// TODO fix my sequence
let confluence z = if true then z else 5
confluence true
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- ?b 
//│ ║  
//│ ╟── [`int`] comes from this `else` branch and it flows into `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                       ^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this `then` branch has type `?a`. However `?b` flows into `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── [`?b`] comes from this variable
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	               ^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── [`bool`] comes from this reference
//│ ║  l.2: 	confluence true
//│ ║       	           ^^^^
//│ ╟── so this variable has type `bool`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	               ^
//│ ╟── so this `then` branch has type `bool` and it flows into `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                                ^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ║       	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`int`] comes from this `else` branch and it flows into `?a`
//│ ║  l.1: 	let confluence z = if true then z else 5
//│ ╙──     	                                       ^
//│ confluence: 'a -> (int | 'a)
//│ res: bool | int


let x: int list
let y: string list
let f: string list -> unit
//│ x: list[int]
//│ y: list[string]
//│ f: list[string] -> unit

// TODO: this won't show error because there are no type variables
f x

// Should show
// ╔══[ERROR] Type `string list` does not match `int list`
// ║  
// ╟──        string list ---> ?a <--- int list 
// ║  
// ╟── `string list` comes from this type expression
// ║  l.-10: 	let y: string list
// ║         	       ^^^^^^^^^^^
// ╟── this `else` branch has type `string list` and it flows into `?a`
// ║  l.1: 	if true then x else y
// ║       	                    ^
// ╟── this if-then-else expression has type `?a`
// ║  l.1: 	if true then x else y
// ║       	^^^^^^^^^^^^^^^^^^^^^
// ╟── this `then` branch has type `?a` and it flows from `int list`
// ║  l.1: 	if true then x else y
// ║       	             ^
// ╟── this applied type reference has type `int list`
// ║  l.-11: 	let x: int list
// ╙──       	       ^^^^^^^^
// res: list[int | string]
if true then x else y
//│ ╔══[ERROR] Type `string list` does not match `int list`
//│ ║  
//│ ╟──        string list ---> ?a <--- int list 
//│ ║  
//│ ╟── [`string list`] comes from this type expression
//│ ║  l.-29: 	let y: string list
//│ ║         	       ^^^^^^^^^^^
//│ ╟── so this `else` branch has type `string list` and it flows into `?a`
//│ ║  l.1: 	if true then x else y
//│ ║       	                    ^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.1: 	if true then x else y
//│ ║       	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this `then` branch has type `?a`. However `int list` flows into `?a`
//│ ║  l.1: 	if true then x else y
//│ ║       	             ^
//│ ╟── [`int list`] comes from this applied type reference
//│ ║  l.-30: 	let x: int list
//│ ╙──       	       ^^^^^^^^
//│ res: list[int | string]

// TODO: show error
Left 1 : int
//│ res: int

// Jonathan
// TODO: show sequence properly
// let confluence z = if true then z else 5
// let mkpair x y = (x, confluence y)
// mkpair 1 "2"

// TODO nested prov not shown in collision error
let a = 1
let b = a
let f x = if x then true else false
let g = f
g b
//│ ╔══[ERROR] Type `bool` does not match `unit`
//│ ║  
//│ ╟── this `else` branch has type `bool`
//│ ║  l.3: 	let f x = if x then true else false
//│ ║       	                              ^^^^^
//│ ╟── so this if-then-else expression has type `bool`
//│ ║  l.3: 	let f x = if x then true else false
//│ ║       	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but `unit` comes from this type expression
//│ ║  l.-61: 	let f: string list -> unit
//│ ╙──       	                      ^^^^
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: head of empty list

let wrap x = x :: []
  
// TODO: show error
if true then wrap 1 else wrap true
//│ wrap: 'a -> list['a]

// TODO: investigate double error
if true then wrap (if true then 1 else false) else wrap true
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- bool 
//│ ║  
//│ ╟── [`int`] comes from this `then` branch and it flows into `?a`
//│ ║  l.1: 	if true then wrap (if true then 1 else false) else wrap true
//│ ║       	                                ^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.1: 	if true then wrap (if true then 1 else false) else wrap true
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`bool`] comes from this `else` branch and it flows into `?a`
//│ ║  l.1: 	if true then wrap (if true then 1 else false) else wrap true
//│ ╙──     	                                       ^^^^^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── [`bool`] comes from this `else` branch and it flows into `?a`
//│ ║  l.1: 	if true then wrap (if true then 1 else false) else wrap true
//│ ║       	                                       ^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.1: 	if true then wrap (if true then 1 else false) else wrap true
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`int`] comes from this `then` branch and it flows into `?a`
//│ ║  l.1: 	if true then wrap (if true then 1 else false) else wrap true
//│ ╙──     	                                ^
//│ res: list[bool | int]

// TODO: duplicate error
let rec t = wrap (if true then 1 else t)
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- int 
//│ ║  
//│ ╟── [`?a list`] comes from this application
//│ ║  l.-36: 	let wrap x = x :: []
//│ ║         	             ^^^^^^^
//│ ╟── so this application has type `?a list`
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this recursive binding has type `?a list`
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ║       	        ^
//│ ╟── so this `else` branch has type `?a list` and it flows into `?b`
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                                      ^
//│ ╟── [`?b`] comes from this if-then-else expression
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`int`] comes from this `then` branch and it flows into `?b`
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ╙──     	                               ^
//│ ╔══[ERROR] Type `int` does not match `?a list`
//│ ║  
//│ ╟──        int ---> ?b <--- ?a list 
//│ ║  
//│ ╟── [`int`] comes from this `then` branch and it flows into `?b`
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                               ^
//│ ╟── [`?b`] comes from this if-then-else expression
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this `else` branch has type `?a`
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ║       	                                      ^
//│ ╟── so this recursive binding has type `?a`
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ║       	        ^
//│ ╟── so this application has type `?a`. However `?a list` flows into `?a`
//│ ║  l.1: 	let rec t = wrap (if true then 1 else t)
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a list`] comes from this application
//│ ║  l.-36: 	let wrap x = x :: []
//│ ╙──       	             ^^^^^^^
//│ t: 't
//│   where
//│     't :> list[int | 't]

// TODO show proper sequence
let test z = if true then wrap z else wrap true
 
let rec m = test (if true then 1 else m)
//│ ╔══[ERROR] Type `int` does not match `?a list`
//│ ║  
//│ ╟──        int ---> ?b <--- ?c 
//│ ║  
//│ ╟── [`int`] comes from this `then` branch and it flows into `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                               ^
//│ ╟── [`?b`] comes from this if-then-else expression
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this `else` branch has type `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                                      ^
//│ ╟── so this recursive binding has type `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	        ^
//│ ╟── so this application has type `?b`. However `?c` flows into `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?c`] comes from this if-then-else expression
//│ ║  l.1: 	let test z = if true then wrap z else wrap true
//│ ╙──     	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- int 
//│ ║  
//│ ╟── [`?a list`] comes from this application
//│ ║  l.-86: 	let wrap x = x :: []
//│ ║         	             ^^^^^^^
//│ ╟── so this `then` branch has type `?a list`
//│ ║  l.1: 	let test z = if true then wrap z else wrap true
//│ ║       	                          ^^^^^^
//│ ╟── so this if-then-else expression has type `?a list`
//│ ║  l.1: 	let test z = if true then wrap z else wrap true
//│ ║       	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this application has type `?a list`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this recursive binding has type `?a list`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	        ^
//│ ╟── so this `else` branch has type `?a list` and it flows into `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                                      ^
//│ ╟── [`?b`] comes from this if-then-else expression
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`int`] comes from this `then` branch and it flows into `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ╙──     	                               ^
//│ ╔══[ERROR] Type `int` does not match `?a list`
//│ ║  
//│ ╟──        int ---> ?b <--- ?c 
//│ ║  
//│ ╟── [`int`] comes from this `then` branch and it flows into `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                               ^
//│ ╟── [`?b`] comes from this if-then-else expression
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this `else` branch has type `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                                      ^
//│ ╟── so this recursive binding has type `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	        ^
//│ ╟── so this application has type `?b`. However `?c` flows into `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?c`] comes from this if-then-else expression
//│ ║  l.1: 	let test z = if true then wrap z else wrap true
//│ ╙──     	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- int 
//│ ║  
//│ ╟── [`?a list`] comes from this application
//│ ║  l.-86: 	let wrap x = x :: []
//│ ║         	             ^^^^^^^
//│ ╟── so this `else` branch has type `?a list`
//│ ║  l.1: 	let test z = if true then wrap z else wrap true
//│ ║       	                                      ^^^^^^^^^
//│ ╟── so this if-then-else expression has type `?a list`
//│ ║  l.1: 	let test z = if true then wrap z else wrap true
//│ ║       	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this application has type `?a list`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this recursive binding has type `?a list`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	        ^
//│ ╟── so this `else` branch has type `?a list` and it flows into `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                                      ^
//│ ╟── [`?b`] comes from this if-then-else expression
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`int`] comes from this `then` branch and it flows into `?b`
//│ ║  l.3: 	let rec m = test (if true then 1 else m)
//│ ╙──     	                               ^
//│ test: 'a -> list[bool | 'a]
//│ m: 'm
//│   where
//│     'm :> list[int | 'm | bool]


// FIXME implementation exception
let rec digitsOfInt n =
  ((digitsOfInt n) / 10) @ [remainder];;
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
