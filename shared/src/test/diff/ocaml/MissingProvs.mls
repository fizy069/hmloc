

// FIXME missing provenances:
//    let f x = [[x]] in
//    (f 1 + [[f true]])

let test =
  let f x = x in
  (f 1 + f true)
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟── this integer literal has type `int`
//│ ║  l.9: 	  (f 1 + f true)
//│ ║       	     ^
//│ ╟── this variable has type `int`
//│ ║  l.8: 	  let f x = x in
//│ ║       	        ^
//│ ╟── this variable has type `bool`
//│ ║  l.8: 	  let f x = x in
//│ ║       	        ^
//│ ╟── this reference has type `bool`
//│ ║  l.9: 	  (f 1 + f true)
//│ ║       	           ^^^^
//│ ╙── `bool` comes from this type expression
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ╟── this reference has type `bool`
//│ ║  l.9: 	  (f 1 + f true)
//│ ║       	           ^^^^
//│ ╟── this variable has type `int`
//│ ║  l.8: 	  let f x = x in
//│ ║       	        ^
//│ ╟── this reference has type `int`
//│ ║  l.8: 	  let f x = x in
//│ ║       	            ^
//│ ╟── this application has type `int`
//│ ║  l.9: 	  (f 1 + f true)
//│ ║       	   ^^^
//│ ╟── `int` comes from this type expression
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ╙──            	         ^^^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ╟── this reference has type `bool`
//│ ║  l.9: 	  (f 1 + f true)
//│ ║       	           ^^^^
//│ ╟── this variable has type `bool`
//│ ║  l.8: 	  let f x = x in
//│ ║       	        ^
//│ ╟── `int` comes from this type expression
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ╙──            	                ^^^
//│ test: int



// FIXME missing provenances:
//    let test2 = let (a, [[b]]) = test in b + 1
//    let test2 = let (a, b) = test in [[b]] + 1

let test =
  let f x = x in
  (f 1, f true)
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- bool 
//│ ║  
//│ ╟── this integer literal has type `int` and it flows into `?a`
//│ ║  l.65: 	  (f 1, f true)
//│ ║        	     ^
//│ ╟── this variable has type `?a`
//│ ║  l.64: 	  let f x = x in
//│ ║        	        ^
//│ ╙── `bool` comes from this type expression and it flows into `?a`
//│ test: (bool | int, bool | int,)

let test2 = let (a, b) = test in b + 1
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── `bool` comes from this type expression and it flows into `?a`
//│ ╟── this variable has type `?a`
//│ ║  l.64: 	  let f x = x in
//│ ║        	        ^
//│ ╟── this integer literal has type `int` and it flows into `?a`
//│ ║  l.65: 	  (f 1, f true)
//│ ╙──      	     ^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ╟── this reference has type `bool`
//│ ║  l.65: 	  (f 1, f true)
//│ ║        	          ^^^^
//│ ╟── this variable has type `bool`
//│ ║  l.64: 	  let f x = x in
//│ ║        	        ^
//│ ╟── this reference has type `bool`
//│ ║  l.64: 	  let f x = x in
//│ ║        	            ^
//│ ╟── this application has type `bool`
//│ ║  l.65: 	  (f 1, f true)
//│ ║        	        ^^^^^^
//│ ╟── this <nested> has type `bool`
//│ ╟── this 1 element of this tuple has type `bool`
//│ ║  l.79: 	let test2 = let (a, b) = test in b + 1
//│ ║        	                ^^^^^^
//│ ╟── `int` comes from this type expression
//│ ║  builtin:16: 	let (+): int -> int -> int
//│ ╙──            	         ^^^
//│ test2: int




