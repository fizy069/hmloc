





let test =
  let f x = x in
  (f 1 + f true)
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── this reference has type `bool`
//│ ║  l.3: 	  (f 1 + f true)
//│ ║       	           ^^^^
//│ ╟── this variable has type `bool`
//│ ║  l.2: 	  let f x = x in
//│ ║       	        ^
//│ ╟── this reference has type `bool`
//│ ║  l.2: 	  let f x = x in
//│ ║       	            ^
//│ ╟── this application has type `bool`
//│ ║  l.3: 	  (f 1 + f true)
//│ ║       	         ^^^^^^
//│ ╟── this variable has type `int`
//│ ║  l.2: 	  let f x = x in
//│ ║       	        ^
//│ ╟── this reference has type `int`
//│ ║  l.2: 	  let f x = x in
//│ ║       	            ^
//│ ╟── this application has type `int`
//│ ║  l.3: 	  (f 1 + f true)
//│ ║       	         ^^^^^^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	                ^^^
//│ test: int


// FIXME: list[?a] <: int not being detected by unification
// :e
let test2 = let (a, b) = test in [[b]] + 1
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.1: 	let test2 = let (a, b) = test in [[b]] + 1
//│ ║       	                                   ^
//│ ╟── this application has type `int`
//│ ║  l.1: 	let test2 = let (a, b) = test in [[b]] + 1
//│ ║       	                                   ^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	         ^^^
//│ ╔══[ERROR] Type `int` does not match `?a * ?b`
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ║           	                       ^^^
//│ ╟── this operator application has type `int`
//│ ║  l.-31: 	  (f 1 + f true)
//│ ║         	  ^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?a * ?b`
//│ ║  l.-31: 	  (f 1 + f true)
//│ ║         	  ^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a * ?b`
//│ ║  l.1: 	let test2 = let (a, b) = test in [[b]] + 1
//│ ║       	                         ^^^^
//│ ╟── this pattern has type `?a * ?b`
//│ ║  l.1: 	let test2 = let (a, b) = test in [[b]] + 1
//│ ╙──     	                ^^^^^^
//│ test2: int

let test =
  let f x = x in
  (f 1, f true)
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟──        int ---> ?a <--- bool 
//│ ║  
//│ ╟── this integer literal has type `int` and it flows into `?a`
//│ ║  l.3: 	  (f 1, f true)
//│ ║       	     ^
//│ ╟── this variable has type `?a`
//│ ║  l.2: 	  let f x = x in
//│ ║       	        ^
//│ ╟── this reference has type `bool` and it flows into `?a`
//│ ║  l.3: 	  (f 1, f true)
//│ ╙──     	          ^^^^
//│ test: (bool | int, bool | int,)



let test2 = let (a, b) = test in b + 1
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── this reference has type `bool`
//│ ║  l.-17: 	  (f 1, f true)
//│ ║         	          ^^^^
//│ ╟── this variable has type `bool`
//│ ║  l.-18: 	  let f x = x in
//│ ║         	        ^
//│ ╟── this reference has type `bool`
//│ ║  l.-18: 	  let f x = x in
//│ ║         	            ^
//│ ╟── this application has type `bool`
//│ ║  l.-17: 	  (f 1, f true)
//│ ║         	        ^^^^^^
//│ ╟── this variable has type `int`
//│ ║  l.-18: 	  let f x = x in
//│ ║         	        ^
//│ ╟── this reference has type `int`
//│ ║  l.-18: 	  let f x = x in
//│ ║         	            ^
//│ ╟── this application has type `int`
//│ ║  l.-17: 	  (f 1, f true)
//│ ║         	        ^^^^^^
//│ ╟── this 1 element of this tuple has type `int`
//│ ║  l.1: 	let test2 = let (a, b) = test in b + 1
//│ ║       	                ^^^^^^
//│ ╟── this reference has type `int`
//│ ║  l.1: 	let test2 = let (a, b) = test in b + 1
//│ ║       	                                 ^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	         ^^^
//│ test2: int





[["1"]] + 1
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.1: 	[["1"]] + 1
//│ ║       	  ^^^
//│ ╟── this application has type `int`
//│ ║  l.1: 	[["1"]] + 1
//│ ║       	  ^^^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	         ^^^
//│ res: int
