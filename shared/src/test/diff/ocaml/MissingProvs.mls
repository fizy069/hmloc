





let test =
  let f x = x in
  (f 1 + f true)
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── this reference has type `bool` and it flows into `?a`
//│ ║  l.3: 	  (f 1 + f true)
//│ ║       	           ^^^^
//│ ╟── this variable has type `?a`
//│ ║  l.2: 	  let f x = x in
//│ ║       	        ^
//│ ╟── this integer literal has type `int` and it flows into `?a`
//│ ║  l.3: 	  (f 1 + f true)
//│ ╙──     	     ^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── this reference has type `bool`
//│ ║  l.3: 	  (f 1 + f true)
//│ ║       	           ^^^^
//│ ╟── this variable has type `bool`
//│ ║  l.2: 	  let f x = x in
//│ ║       	        ^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	                ^^^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── this reference has type `bool`
//│ ║  l.3: 	  (f 1 + f true)
//│ ║       	           ^^^^
//│ ╟── this variable has type `bool`
//│ ║  l.2: 	  let f x = x in
//│ ║       	        ^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	         ^^^
//│ test: int



:e
let test2 = let (a, b) = test in [[b]] + 1
//│ test2: int

let test =
  let f x = x in
  (f 1, f true)
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── this reference has type `bool` and it flows into `?a`
//│ ║  l.3: 	  (f 1, f true)
//│ ║       	          ^^^^
//│ ╟── this variable has type `?a`
//│ ║  l.2: 	  let f x = x in
//│ ║       	        ^
//│ ╟── this integer literal has type `int` and it flows into `?a`
//│ ║  l.3: 	  (f 1, f true)
//│ ╙──     	     ^
//│ test: (bool | int, bool | int,)



let test2 = let (a, b) = test in b + 1
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── this reference has type `bool` and it flows into `?a`
//│ ║  l.-17: 	  (f 1, f true)
//│ ║         	          ^^^^
//│ ╟── this variable has type `?a`
//│ ║  l.-18: 	  let f x = x in
//│ ║         	        ^
//│ ╟── this integer literal has type `int` and it flows into `?a`
//│ ║  l.-17: 	  (f 1, f true)
//│ ╙──       	     ^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── this reference has type `bool`
//│ ║  l.-17: 	  (f 1, f true)
//│ ║         	          ^^^^
//│ ╟── this variable has type `bool`
//│ ║  l.-18: 	  let f x = x in
//│ ║         	        ^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	         ^^^
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── this reference has type `bool` and it flows into `?a`
//│ ║  l.-17: 	  (f 1, f true)
//│ ║         	          ^^^^
//│ ╟── this variable has type `?a`
//│ ║  l.-18: 	  let f x = x in
//│ ║         	        ^
//│ ╟── this integer literal has type `int` and it flows into `?b`
//│ ║  l.-17: 	  (f 1, f true)
//│ ╙──       	     ^
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.UnificationSolver.makeMessagesUR$1(UnificationSolver.scala:221)
//│ 	at: mlscript.UnificationSolver.createErrorMessage(UnificationSolver.scala:267)
//│ 	at: mlscript.UnificationSolver.createErrorMessage$(UnificationSolver.scala:171)
//│ 	at: mlscript.TypeDefs.createErrorMessage(TypeDefs.scala:11)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:161)
//│ 	at: mlscript.UnificationSolver$$anonfun$1.applyOrElse(UnificationSolver.scala:160)
//│ 	at: scala.collection.Iterator$$anon$7.hasNext(Iterator.scala:525)
//│ 	at: scala.collection.immutable.List.prependedAll(List.scala:152)
//│ 	at: scala.collection.IterableOnceOps.toList(IterableOnce.scala:1288)





[["1"]] + 1
//│ res: int
