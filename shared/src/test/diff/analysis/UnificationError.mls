:ns
:unify
 def s x = if x then x else 3
//│ ╔══[WARNING] Level 7 unification error with 3 and bool
//│ ╟── unifies with α25' because [[[3<int,number>]]] flows into α25'
//│ ╟── unifies with α24' because α24' flows into [[[[α25']]]]
//│ ╟── unifies with (α24',) because α24' is type of index 0 in tuple type (α24',)
//│ ╟── unifies with (α24' -> α28') because (α24',) is argument type of function (α24' -> α28')
//│ ║  l.3: 	 def s x = if x then x else 3
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── unifies with (α24' -> α28') because (α24',) is argument type of function (α24' -> α28')
//│ ║  l.3: 	 def s x = if x then x else 3
//│ ║       	       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── unifies with (α24',) because α24' is type of index 0 in tuple type (α24',)
//│ ╙── unifies with α24' because α24' flows into [[[[[bool<>]]]]]
//│ s: 'a -> 'b
//│   where
//│     'a <: 'c & bool
//│     'c :> 3
//│        <: 'b
//│     'b :> 3
//│  = [Function: s]

:ns
:unify
 rec def clone x n =
   let rec helper acc n' =
     if acc <= 0 then acc else helper (acc + 1) (n' - 1) in
   helper x (n - 1)
//│ ╔══[WARNING] Level 10 unification error with int and number
//│ ╟── unifies with α48' because [[[[[[[[[[int<number>]]]]]]]]]] flows into α48'
//│ ╟── unifies with α30' because α30' flows into [[[[[[α48']]]]]]
//│ ╟── unifies with (α30',) because α30' is type of index 0 in tuple type (α30',)
//│ ╟── unifies with (α30' -> (α31' -> α59')) because (α30',) is argument type of function (α30' -> (α31' -> α59'))
//│ ║  l.26: 	 rec def clone x n =
//│ ║        	               ^^^^^
//│ ║  l.27: 	   let rec helper acc n' =
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.28: 	     if acc <= 0 then acc else helper (acc + 1) (n' - 1) in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.29: 	   helper x (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── unifies with clone29' because [(α30' -> (α31' -> α59'))] flows into clone29'
//│ ╟── unifies with clone29' because [(α30' -> (α31' -> α59'))] flows into clone29'
//│ ╟── unifies with (α30' -> (α31' -> α59')) because (α30',) is argument type of function (α30' -> (α31' -> α59'))
//│ ║  l.26: 	 rec def clone x n =
//│ ║        	               ^^^^^
//│ ║  l.27: 	   let rec helper acc n' =
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.28: 	     if acc <= 0 then acc else helper (acc + 1) (n' - 1) in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.29: 	   helper x (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── unifies with (α30',) because α30' is type of index 0 in tuple type (α30',)
//│ ╟── unifies with α30' because α30' flows into [[[[[[α48']]]]]]
//│ ╙── unifies with α48' because α48' flows into [[[[[[number<>]]]]]]
//│ clone: 'clone
//│   where
//│     'clone :> 'a -> 'b -> 'c
//│     'b <: int
//│     'a <: 'd
//│     'd :> int
//│        <: int & 'e & number
//│     'e :> int
//│        <: 'f
//│     'f :> int
//│        <: 'c & 'g
//│     'g :> int
//│        <: 'e
//│     'c :> int
//│      = [Function: clone]

:ns
:unify
let rec l = fun a -> fun a -> l in let rec r = fun a -> r in if true then l else r
//│ res: 'a
//│   where
//│     'a :> 'b -> 'c -> 'l | 'd -> 'r
//│     'l :> 'b -> 'c -> 'l
//│        <: 'e
//│     'e :> 'd -> 'r | 'b -> 'c -> 'l
//│        <: 'a
//│     'r :> 'd -> 'r
//│        <: 'e
//│    = [Function: l]
