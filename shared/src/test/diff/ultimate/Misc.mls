:NewParser


1
//│ res: int

2 + 2
//│ res: int

let r = { x: 1 }
//│ r: {x: int}

r.x + 1
//│ res: int


x => x + 1
//│ res: int -> int

{ y } => y
//│ res: {y: 'a} -> 'a

fun f({ y }) = y
//│ f: {y: 'a} -> 'a

fun f of { y } = y
//│ f: {y: 'a} -> 'a

f({y: 1})
//│ res: int


let f = (x, y) => x + y
//│ f: (int, int,) -> int

f(1, 2)
//│ res: int

:e
f([1, 2])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.40: 	f([1, 2])
//│ ║        	^^^^^^^^^
//│ ╟── argument of type `((int, int,),)` does not match type `(?a, ?b,)`
//│ ║  l.40: 	f([1, 2])
//│ ║        	 ^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.33: 	let f = (x, y) => x + y
//│ ╙──      	         ^^^^
//│ res: int



let f = ((x, y)) => x + y
//│ f: (int, int,) -> int

:e
f(1, 2)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.58: 	f(1, 2)
//│ ║        	^^^^^^^
//│ ╟── tuple literal of type `(int, int,)` does not match type `((?a, ?b,),)`
//│ ║  l.58: 	f(1, 2)
//│ ╙──      	 ^^^^^^
//│ res: int



f((1, 2))
//│ res: int

f([1, 2])
//│ res: int

let f = (((x, y))) => x + y
//│ f: (int, int,) -> int

// TODO parse as tuple arg!
let f = [x, y] => x + y
//│ f: (int, int,) -> int

f(1, 2)
//│ res: int

// TODO...
let f = [[[x, y]]] => x + y
//│ f: (int, int,) -> int


