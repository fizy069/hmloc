
class Expr
class Lit: Expr & { val: int }
class Add: Expr & { lhs: Expr; rhs: Expr }
//│ Defined class Expr
//│ Defined class Lit
//│ Defined class Add

rec def eval x = case x of {
  Lit -> x.val
  | Add -> eval x.lhs + eval x.rhs
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.11: 	  | Add -> eval x.lhs + eval x.rhs
//│ ║        	           ^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.11: 	  | Add -> eval x.lhs + eval x.rhs
//│ ╙──      	           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.11: 	  | Add -> eval x.lhs + eval x.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.11: 	  | Add -> eval x.lhs + eval x.rhs
//│ ╙──      	                        ^^^^^^^^^^
//│ eval: 'a -> (int | 'val)
//│   where
//│     'a <: (Add with {lhs: 'a, rhs: 'a}) | (Lit with {val: 'val})

def eval eval x = case x of {
  Lit -> x.val
  | Add -> eval eval x.lhs + eval eval x.rhs
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.31: 	  | Add -> eval eval x.lhs + eval eval x.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.31: 	  | Add -> eval eval x.lhs + eval eval x.rhs
//│ ╙──      	           ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.31: 	  | Add -> eval eval x.lhs + eval eval x.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.31: 	  | Add -> eval eval x.lhs + eval eval x.rhs
//│ ╙──      	                             ^^^^^^^^^^^^^^^
//│ eval: ('a -> 'rhs -> anything & 'a) -> ((Add with {lhs: 'rhs, rhs: 'rhs}) | (Lit with {val: 'val})) -> (int | 'val)

eval eval
//│ res: ((Add with {lhs: 'a, rhs: 'a}) | (Lit with {val: 'val})) -> (int | 'val)
//│   where
//│     'a <: (Add with {lhs: 'a, rhs: 'a}) | Lit

class Neg: Expr & { underlying: Expr }
//│ Defined class Neg

def evalN evalN x = case x of {
  Neg -> 0 - (evalN evalN x.underlying)
  | _ -> eval evalN x
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.56: 	  Neg -> 0 - (evalN evalN x.underlying)
//│ ║        	         ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.56: 	  Neg -> 0 - (evalN evalN x.underlying)
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.56: 	  Neg -> 0 - (evalN evalN x.underlying)
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.56: 	  Neg -> 0 - (evalN evalN x.underlying)
//│ ╙──      	             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ evalN: ('a -> 'rhs -> anything & 'a) -> ((Add with {lhs: 'rhs, rhs: 'rhs}) | (Lit with {val: 'b}) | (Neg with {underlying: 'rhs})) -> (int | 'b)

evalN evalN
//│ res: ((Add with {lhs: 'a, rhs: 'a}) | (Lit with {val: 'b}) | (Neg with {underlying: 'a})) -> (int | 'b)
//│   where
//│     'a <: (Add with {lhs: 'a, rhs: 'a}) | Lit | (Neg with {underlying: 'a})

e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.78: 	e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ ║        	              ^^^^^^^^^^^^
//│ ╟── argument of type `({val: int},)` does not have field 'val'
//│ ║  l.78: 	e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ ╙──      	                 ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.78: 	e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ ║        	                                                   ^^^^^^^^^^^^
//│ ╟── argument of type `({val: int},)` does not have field 'val'
//│ ║  l.78: 	e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ ╙──      	                                                      ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.78: 	e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ ║        	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({underlying: ?a},)` does not have field 'underlying'
//│ ║  l.78: 	e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ ╙──      	                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.78: 	e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.78: 	e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ e: Add & {lhs: nothing, rhs: nothing}

evalN evalN e
//│ res: int




// === === === ERROR CASES === === === //



:ShowRelativeLineNums
:AllowTypeErrors



def evalN2 evalN2 x = case x of {
  Neg -> 0 - (evalN2 evalN2 x.underlying)
  | _ -> eval eval x
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 evalN2 x.underlying)
//│ ║        	         ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 evalN2 x.underlying)
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 evalN2 x.underlying)
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 evalN2 x.underlying)
//│ ╙──      	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ evalN2: ('a -> 'underlying -> anything & 'a) -> ((Add with {lhs: 'b, rhs: 'b}) | (Lit with {val: 'c}) | (Neg with {underlying: 'underlying})) -> (int | 'c)
//│   where
//│     'b <: (Add with {lhs: 'b, rhs: 'b}) | Lit

evalN2 evalN2 e
//│ res: int






def evalN3 evalN3 x = case x of {
  Neg -> 0 - (evalN2 x.underlying)
  | _ -> eval evalN3 x
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 x.underlying)
//│ ║        	         ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 x.underlying)
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 x.underlying)
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 x.underlying)
//│ ╙──      	             ^^^^^^^^^^^^^^^^^^^^^
//│ evalN3: ('a -> 'rhs -> anything & 'a) -> ((Add with {lhs: 'rhs, rhs: 'rhs}) | (Lit with {val: 'b}) | (Neg with {underlying: 'c -> nothing -> anything & 'c})) -> (int | 'b)







def evalN3 evalN3 x = case x of {
  Neg -> 0 - (evalN3 x.underlying)
  | _ -> eval evalN3 x
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+2: 	  Neg -> 0 - (evalN3 x.underlying)
//│ ║        	         ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.+2: 	  Neg -> 0 - (evalN3 x.underlying)
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+2: 	  Neg -> 0 - (evalN3 x.underlying)
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.+2: 	  Neg -> 0 - (evalN3 x.underlying)
//│ ╙──      	             ^^^^^^^^^^^^^^^^^^^^^
//│ evalN3: ('underlying -> 'rhs -> anything & 'underlying) -> ((Add with {lhs: 'rhs, rhs: 'rhs}) | (Lit with {val: 'a}) | (Neg with {underlying: 'underlying})) -> (int | 'a)

evalN3 evalN3 e
//│ res: int












