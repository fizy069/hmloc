

def test f =
  let local g x = g (f x)
  in (local add 1, local (fun y -> fun z -> y + z) 2)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.5: 	  in (local add 1, local (fun y -> fun z -> y + z) 2)
//│ ║       	      ^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.4: 	  let local g x = g (f x)
//│ ╙──     	                    ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.5: 	  in (local add 1, local (fun y -> fun z -> y + z) 2)
//│ ║       	                                            ^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.5: 	  in (local add 1, local (fun y -> fun z -> y + z) 2)
//│ ╙──     	                                            ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.5: 	  in (local add 1, local (fun y -> fun z -> y + z) 2)
//│ ║       	                                            ^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.5: 	  in (local add 1, local (fun y -> fun z -> y + z) 2)
//│ ╙──     	                                                ^
//│ test: (int -> anything) -> (int -> int, anything -> int,)

:re // TODO
f_g = test succ
f_g._1 42
f_g._2 42
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.27: 	f_g = test succ
//│ ║        	      ^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.4: 	  let local g x = g (f x)
//│ ╙──     	                       ^
//│ f_g: (int -> int, anything -> int,)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.28: 	f_g._1 42
//│ ║        	^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.28: 	f_g._1 42
//│ ╙──      	       ^^
//│ res: int
//│ res: int


def test f =
  let local g x = g (f x)
  in (local add 1, local concat "ok")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.49: 	  in (local add 1, local concat "ok")
//│ ║        	      ^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.48: 	  let local g x = g (f x)
//│ ╙──      	                    ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.49: 	  in (local add 1, local concat "ok")
//│ ║        	                   ^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.48: 	  let local g x = g (f x)
//│ ╙──      	                    ^^^^^
//│ test: ((int | string) -> anything) -> (int -> int, string -> string,)

:e
test succ
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.65: 	test succ
//│ ║        	^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.48: 	  let local g x = g (f x)
//│ ╙──      	                       ^
//│ res: (int -> int, string -> string,)




def test =
  (fun f ->
    let local g x = f (g x)
    in local
  ) add
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.78: 	  (fun f ->
//│ ║        	  ^^^^^^^^^
//│ ║  l.79: 	    let local g x = f (g x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	    in local
//│ ║        	^^^^^^^^^^^^
//│ ║  l.81: 	  ) add
//│ ║        	^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.79: 	    let local g x = f (g x)
//│ ╙──      	                      ^^^^^
//│ test: ('a -> anything) -> 'a -> int -> int

def test =
  (fun f -> fun x ->
    let local g = f (g x)
    in local
  ) add "1"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.97: 	  (fun f -> fun x ->
//│ ║        	  ^^^^^^^^^^^^^^^^^^
//│ ║  l.98: 	    let local g = f (g x)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	    in local
//│ ║        	^^^^^^^^^^^^
//│ ║  l.100: 	  ) add "1"
//│ ║         	^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.98: 	    let local g = f (g x)
//│ ╙──      	                    ^^^^^
//│ test: (string -> anything) -> int -> int

def test =
  (fun f -> fun x ->
    let local g = f (g x)
    in local add "1"
  )
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.118: 	    in local add "1"
//│ ║         	       ^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.117: 	    let local g = f (g x)
//│ ╙──       	                       ^
//│ test: ((int -> int) -> string -> 'a) -> anything -> 'a

fun f -> fun x ->
  let local = (fun y -> f y) x
  in ()
//│ res: ('a -> anything) -> 'a -> ()

:e
res add "1"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.134: 	res add "1"
//│ ║         	^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.129: 	  let local = (fun y -> f y) x
//│ ╙──       	                          ^
//│ res: ()






fun f -> fun x ->
  let local = f ((fun y -> y) x)
  in ()
//│ res: ('a -> anything) -> 'a -> ()

:e
res add "1"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.154: 	res add "1"
//│ ║         	^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.149: 	  let local = f ((fun y -> y) x)
//│ ╙──       	                ^^^^^^^^^^^^^^^^
//│ res: ()





def id: 'a -> 'a
//│ id: 'a -> 'a

fun f -> fun x ->
  let local = f (id x)
  in ()
//│ res: ('a -> anything) -> 'a -> ()


