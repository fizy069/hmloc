
class Addable[A]
  method Add: A -> A
//│ Defined class Addable[=A]
//│ Declared Addable.Add: Addable['A] -> 'A -> 'A

class Num: Addable[Num] & { val: int }
  method Add that = Num { val = this.val + that.val }
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.8: 	  method Add that = Num { val = this.val + that.val }
//│ ║       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Num` is not an instance of type `Addable`
//│ ║  l.8: 	  method Add that = Num { val = this.val + that.val }
//│ ║       	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── from applied type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ╙──     	           ^^^^^^^^^^^^
//│ Defined class Num
//│ Defined Num.Add: Num -> {val: int} -> Num

class Str: Addable[Str] & { val: string }
  method Add that = Str { val = concat this.val that.val }
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.25: 	  method Add that = Str { val = concat this.val that.val }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Str` is not an instance of type `Addable`
//│ ║  l.25: 	  method Add that = Str { val = concat this.val that.val }
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── from applied type reference:
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	           ^^^^^^^^^^^^
//│ Defined class Str
//│ Defined Str.Add: Str -> {val: string} -> Str

n = Num { val = 1 }
//│ n: Num

n.Add n
//│ ╔══[ERROR] Implicit call to method Add is forbidden because it is ambiguous.
//│ ║  l.44: 	n.Add n
//│ ║        	^^^^^
//│ ╟── Unrelated methods named Add are defined by:
//│ ╟── • class Addable
//│ ║  l.2: 	class Addable[A]
//│ ║       	      ^^^^^^^
//│ ╟── • class Num
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	      ^^^
//│ ╟── • class Str
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	      ^^^
//│ res: error

n.Add
//│ ╔══[ERROR] Implicit call to method Add is forbidden because it is ambiguous.
//│ ║  l.60: 	n.Add
//│ ║        	^^^^^
//│ ╟── Unrelated methods named Add are defined by:
//│ ╟── • class Addable
//│ ║  l.2: 	class Addable[A]
//│ ║       	      ^^^^^^^
//│ ╟── • class Num
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	      ^^^
//│ ╟── • class Str
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	      ^^^
//│ res: error


def addTwo a0 a1 = a0.Add a1
//│ ╔══[ERROR] Implicit call to method Add is forbidden because it is ambiguous.
//│ ║  l.77: 	def addTwo a0 a1 = a0.Add a1
//│ ║        	                   ^^^^^^
//│ ╟── Unrelated methods named Add are defined by:
//│ ╟── • class Addable
//│ ║  l.2: 	class Addable[A]
//│ ║       	      ^^^^^^^
//│ ╟── • class Num
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	      ^^^
//│ ╟── • class Str
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	      ^^^
//│ addTwo: anything -> anything -> error


addTwo n n
//│ res: error

s = Str { val = "hey" }
//│ s: Str

s.Add s
//│ ╔══[ERROR] Implicit call to method Add is forbidden because it is ambiguous.
//│ ║  l.100: 	s.Add s
//│ ║         	^^^^^
//│ ╟── Unrelated methods named Add are defined by:
//│ ╟── • class Addable
//│ ║  l.2: 	class Addable[A]
//│ ║       	      ^^^^^^^
//│ ╟── • class Num
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	      ^^^
//│ ╟── • class Str
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	      ^^^
//│ res: error

addTwo s s
//│ res: error



def addSame a = a.Add a
//│ ╔══[ERROR] Implicit call to method Add is forbidden because it is ambiguous.
//│ ║  l.121: 	def addSame a = a.Add a
//│ ║         	                ^^^^^
//│ ╟── Unrelated methods named Add are defined by:
//│ ╟── • class Addable
//│ ║  l.2: 	class Addable[A]
//│ ║       	      ^^^^^^^
//│ ╟── • class Num
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	      ^^^
//│ ╟── • class Str
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	      ^^^
//│ addSame: anything -> error

addSame n
//│ res: error


rec def addNTimes a n =
  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ╔══[ERROR] Implicit call to method Add is forbidden because it is ambiguous.
//│ ║  l.142: 	  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ║         	                        ^^^^^
//│ ╟── Unrelated methods named Add are defined by:
//│ ╟── • class Addable
//│ ║  l.2: 	class Addable[A]
//│ ║       	      ^^^^^^^
//│ ╟── • class Num
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	      ^^^
//│ ╟── • class Str
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	      ^^^
//│ addNTimes: 'a -> int -> (error | 'a)

addNTimes n 12
//│ res: error | Num

addNTimes s 5
//│ res: error | Str




// === === === ERROR CASES === === === //


:ShowRelativeLineNums
:AllowTypeErrors


rec def addNTimes a n =
  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
addNTimes n 12
//│ ╔══[ERROR] Implicit call to method Add is forbidden because it is ambiguous.
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                       ^^^^^
//│ ╟── Unrelated methods named Add are defined by:
//│ ╟── • class Addable
//│ ║  l.2: 	class Addable[A]
//│ ║       	      ^^^^^^^
//│ ╟── • class Num
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	      ^^^
//│ ╟── • class Str
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	      ^^^
//│ addNTimes: anything -> int -> (error | int)
//│ res: error | int




rec def addNTimes a n =
  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╔══[ERROR] Implicit call to method Add is forbidden because it is ambiguous.
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	                        ^^^^^
//│ ╟── Unrelated methods named Add are defined by:
//│ ╟── • class Addable
//│ ║  l.2: 	class Addable[A]
//│ ║       	      ^^^^^^^
//│ ╟── • class Num
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	      ^^^
//│ ╟── • class Str
//│ ║  l.24: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	      ^^^
//│ addNTimes: anything -> int -> (error | int)

addNTimes n 12
//│ res: error | int





addSame n n
//│ res: error




addTwo s n
//│ res: error






class Str_bad_0: Addable[Str_bad_0] & { val: string }
  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `string`
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	                                      ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.+1: 	class Str_bad_0: Addable[Str_bad_0] & { val: string }
//│ ╙──      	                                             ^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Str_bad_0 & {val: ?val}` is not an instance of type `Addable`
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.+1: 	class Str_bad_0: Addable[Str_bad_0] & { val: string }
//│ ║        	                         ^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.+1: 	class Str_bad_0: Addable[Str_bad_0] & { val: string }
//│ ╙──      	                 ^^^^^^^^^^^^^^^^^^
//│ Defined class Str_bad_0
//│ Defined Str_bad_0.Add: Str_bad_0 -> {val: int} -> (Str_bad_0 with {val: int})










