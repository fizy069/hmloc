
class N
class M
//│ Defined class N
//│ Defined class M

def eval_expr v =
  case v of {
    | M -> let tmp = v.l in v
    | N -> v
    }
//│ eval_expr: (M & {l: anything} & 'a | N & 'a) -> 'a

eval_expr (N {})
//│ res: N

:e
eval_expr (M {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.18: 	eval_expr (M {})
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── application of type `M` does not have field 'l'
//│ ║  l.18: 	eval_expr (M {})
//│ ║        	           ^^^^
//│ ╟── but it flows into argument with expected type `{l: ?l}`
//│ ║  l.18: 	eval_expr (M {})
//│ ║        	          ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.8: 	  case v of {
//│ ║       	       ^
//│ ╟── from receiver:
//│ ║  l.9: 	    | M -> let tmp = v.l in v
//│ ║       	                     ^
//│ ╟── Note: class M is defined at:
//│ ║  l.3: 	class M
//│ ╙──     	      ^
//│ res: M






def eval_expr v =
  case v of {
    | M -> let tmp = v.l in tmp
    | N -> v
    }
//│ eval_expr: (M & {l: 'l} | N & 'l) -> 'l

eval_expr (N {})
//│ res: N

:e
eval_expr (M {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.55: 	eval_expr (M {})
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── application of type `M` does not have field 'l'
//│ ║  l.55: 	eval_expr (M {})
//│ ║        	           ^^^^
//│ ╟── but it flows into argument with expected type `{l: ?l}`
//│ ║  l.55: 	eval_expr (M {})
//│ ║        	          ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.45: 	  case v of {
//│ ║        	       ^
//│ ╟── from receiver:
//│ ║  l.46: 	    | M -> let tmp = v.l in tmp
//│ ║        	                     ^
//│ ╟── Note: class M is defined at:
//│ ║  l.3: 	class M
//│ ╙──     	      ^
//│ res: nothing






