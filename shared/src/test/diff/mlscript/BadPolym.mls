

def foo1: (int -> int & string -> string)
//│ foo1: (int | string) -> nothing

def foo: (int -> int & string -> string) -> ()
//│ foo: ((int | string) -> nothing) -> ()

fooImpl f = f 1
//│ fooImpl: (int -> 'a) -> 'a

foo = fooImpl
//│ (int -> 'a) -> 'a
//│   <:  foo:
//│ ((int | string) -> nothing) -> ()

:e
foo id
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.18: 	foo id
//│ ║        	^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.6: 	def foo: (int -> int & string -> string) -> ()
//│ ║       	          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.6: 	def foo: (int -> int & string -> string) -> ()
//│ ╙──     	                                 ^^^^^^
//│ res: ()




fooImpl id
//│ res: int


fooImpl2 (f: int -> int & string -> string) = f 1
//│ fooImpl2: ((int | string) -> nothing) -> nothing

:e
fooImpl2 id
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.41: 	fooImpl2 id
//│ ║        	^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.37: 	fooImpl2 (f: int -> int & string -> string) = f 1
//│ ║        	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.37: 	fooImpl2 (f: int -> int & string -> string) = f 1
//│ ╙──      	                                    ^^^^^^
//│ res: nothing




:re
res "oops"
//│ res: nothing

