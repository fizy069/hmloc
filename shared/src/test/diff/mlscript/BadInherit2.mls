

// ———


trait S0[A]
  method Foo0: A -> A
trait T0[B]: S0[B]
//│ Defined trait S0[=A]
//│ Declared S0.Foo0: S0['A] -> 'A -> 'A
//│ Defined trait T0[=B]

:e
class A0: S0[int] & T0[string]
(A0{}).Foo0
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ╙──      	                       ^^^^^^
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	                       ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ╙──      	             ^^^
//│ Defined class A0
//│ ╔══[ERROR] Instantiation of an abstract type is forbidden
//│ ║  l.15: 	(A0{}).Foo0
//│ ║        	 ^^
//│ ╟── Note that class A0 is abstract:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Hint: method Foo0 is abstract
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: 'A -> ('A | error)










:e
class A0_2: S0[int] & T0[string]
  method Foo0 x = 1
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.56: 	class A0_2: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.56: 	class A0_2: S0[int] & T0[string]
//│ ║        	               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.56: 	class A0_2: S0[int] & T0[string]
//│ ╙──      	                         ^^^^^^
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.56: 	class A0_2: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.56: 	class A0_2: S0[int] & T0[string]
//│ ║        	                         ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.56: 	class A0_2: S0[int] & T0[string]
//│ ╙──      	               ^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.57: 	  method Foo0 x = 1
//│ ║        	         ^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `string`
//│ ║  l.57: 	  method Foo0 x = 1
//│ ║        	                  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.56: 	class A0_2: S0[int] & T0[string]
//│ ╙──      	                         ^^^^^^
//│ Defined class A0_2
//│ Defined A0_2.Foo0: A0_2 -> anything -> int










(A0_2{}).Foo0
//│ ╔══[ERROR] Implicit call to method Foo0 is forbidden because it is ambiguous.
//│ ║  l.97: 	(A0_2{}).Foo0
//│ ║        	^^^^^^^^^^^^^
//│ ╟── Unrelated methods named Foo0 are defined by:
//│ ╟── • trait S0
//│ ║  l.6: 	trait S0[A]
//│ ║       	      ^^
//│ ╟── • class A0_2
//│ ║  l.56: 	class A0_2: S0[int] & T0[string]
//│ ╙──      	      ^^^^
//│ res: error


// ———


trait R1[A]
  method Foo1: A -> A
//│ Defined trait R1[=A]
//│ Declared R1.Foo1: R1['A] -> 'A -> 'A

trait S1: R1[int]
  method Foo1 x = 1
trait T1: R1[string]
  method Foo1 x = "a"
//│ Defined trait S1
//│ Defined S1.Foo1: S1 -> anything -> int
//│ Defined trait T1
//│ Defined T1.Foo1: T1 -> anything -> string

:e
class A1: S1 & T1
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.129: 	class A1: S1 & T1
//│ ║         	      ^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.119: 	trait S1: R1[int]
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.121: 	trait T1: R1[string]
//│ ╙──       	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.129: 	class A1: S1 & T1
//│ ║         	      ^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.121: 	trait T1: R1[string]
//│ ║         	             ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.119: 	trait S1: R1[int]
//│ ╙──       	             ^^^
//│ ╔══[ERROR] An overriding method definition must be given when inheriting from multiple method definitions
//│ ║  l.129: 	class A1: S1 & T1
//│ ║         	      ^^
//│ ╟── Definitions of method Foo1 inherited from:
//│ ╟── • S1
//│ ║  l.120: 	  method Foo1 x = 1
//│ ║         	         ^^^^^^^^^^
//│ ╟── • T1
//│ ║  l.122: 	  method Foo1 x = "a"
//│ ╙──       	         ^^^^^^^^^^^^
//│ Defined class A1










a1 = A1{}
//│ a1: A1

a1.Foo1
//│ ╔══[ERROR] Implicit call to method Foo1 is forbidden because it is ambiguous.
//│ ║  l.172: 	a1.Foo1
//│ ║         	^^^^^^^
//│ ╟── Unrelated methods named Foo1 are defined by:
//│ ╟── • trait R1
//│ ║  l.114: 	trait R1[A]
//│ ║         	      ^^
//│ ╟── • trait S1
//│ ║  l.119: 	trait S1: R1[int]
//│ ║         	      ^^
//│ ╟── • trait T1
//│ ║  l.121: 	trait T1: R1[string]
//│ ╙──       	      ^^
//│ res: error

a1: S1
a1: R1[int]
a1: R1[string]
a1: R1['_]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.188: 	a1: S1
//│ ║         	^^
//│ ╟── application of type `A1` does not match type `R1[int] & #S1`
//│ ║  l.169: 	a1 = A1{}
//│ ║         	     ^^^^
//│ ╟── but it flows into reference with expected type `R1[int] & #S1`
//│ ║  l.188: 	a1: S1
//│ ║         	^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.188: 	a1: S1
//│ ╙──       	    ^^
//│ res: S1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.189: 	a1: R1[int]
//│ ║         	^^
//│ ╟── application of type `A1` does not match type `#R1`
//│ ║  l.169: 	a1 = A1{}
//│ ║         	     ^^^^
//│ ╟── but it flows into reference with expected type `#R1`
//│ ║  l.189: 	a1: R1[int]
//│ ║         	^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.189: 	a1: R1[int]
//│ ╙──       	    ^^^^^^^
//│ res: R1[int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.190: 	a1: R1[string]
//│ ║         	^^
//│ ╟── application of type `A1` does not match type `#R1`
//│ ║  l.169: 	a1 = A1{}
//│ ║         	     ^^^^
//│ ╟── but it flows into reference with expected type `#R1`
//│ ║  l.190: 	a1: R1[string]
//│ ║         	^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.190: 	a1: R1[string]
//│ ╙──       	    ^^^^^^^^^^
//│ res: R1[string]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.191: 	a1: R1['_]
//│ ║         	^^
//│ ╟── application of type `A1` does not match type `#R1`
//│ ║  l.169: 	a1 = A1{}
//│ ║         	     ^^^^
//│ ╟── but it flows into reference with expected type `#R1`
//│ ║  l.191: 	a1: R1['_]
//│ ║         	^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.191: 	a1: R1['_]
//│ ╙──       	    ^^^^^^
//│ res: R1['_]
//│   where
//│     '_ <: int | string

:ns
a1: R1['_]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.248: 	a1: R1['_]
//│ ║         	^^
//│ ╟── application of type `A1` does not match type `#R1`
//│ ║  l.169: 	a1 = A1{}
//│ ║         	     ^^^^
//│ ╟── but it flows into reference with expected type `#R1`
//│ ║  l.248: 	a1: R1['_]
//│ ║         	^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.248: 	a1: R1['_]
//│ ╙──       	    ^^^^^^
//│ res: R1['_]
//│   where
//│     '_ <: int | string


:e
:js
//│ /!\ Unrecognized option :js
class A1_2: S1 & T1
  method Foo1 = error
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.269: 	class A1_2: S1 & T1
//│ ║         	      ^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.119: 	trait S1: R1[int]
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.121: 	trait T1: R1[string]
//│ ╙──       	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.269: 	class A1_2: S1 & T1
//│ ║         	      ^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.121: 	trait T1: R1[string]
//│ ║         	             ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.119: 	trait S1: R1[int]
//│ ╙──       	             ^^^
//│ Defined class A1_2
//│ Defined A1_2.Foo1: A1_2 -> nothing







:re
(A1_2{}).Foo1
//│ ╔══[ERROR] Implicit call to method Foo1 is forbidden because it is ambiguous.
//│ ║  l.299: 	(A1_2{}).Foo1
//│ ║         	^^^^^^^^^^^^^
//│ ╟── Unrelated methods named Foo1 are defined by:
//│ ╟── • trait R1
//│ ║  l.114: 	trait R1[A]
//│ ║         	      ^^
//│ ╟── • trait S1
//│ ║  l.119: 	trait S1: R1[int]
//│ ║         	      ^^
//│ ╟── • trait T1
//│ ║  l.121: 	trait T1: R1[string]
//│ ║         	      ^^
//│ ╟── • class A1_2
//│ ║  l.269: 	class A1_2: S1 & T1
//│ ╙──       	      ^^^^
//│ res: error


def f = 0
//│ f: int

def f' = 1
//│ f': int

f'
//│ res: int



class C0[A]: S0[A]
  method Foo0 = id
//│ Defined class C0[=A]
//│ Defined C0.Foo0: C0['A] -> 'a -> 'a

def s0: S0['a] -> S0['a]
//│ s0: S0['a] -> S0['a]

s0 (C0{})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.338: 	s0 (C0{})
//│ ║         	^^^^^^^^^
//│ ╟── application of type `C0[?A]` is not an instance of type `S0`
//│ ║  l.338: 	s0 (C0{})
//│ ║         	    ^^^^
//│ ╟── but it flows into argument with expected type `#S0`
//│ ║  l.338: 	s0 (C0{})
//│ ║         	   ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.335: 	def s0: S0['a] -> S0['a]
//│ ╙──       	        ^^^^^^
//│ res: S0['a]

def s0: S0[?] -> S0[?]
//│ s0: S0[?] -> S0[?]

:e
s0 (C0{})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.357: 	s0 (C0{})
//│ ║         	^^^^^^^^^
//│ ╟── application of type `C0[?A]` is not an instance of type `S0`
//│ ║  l.357: 	s0 (C0{})
//│ ║         	    ^^^^
//│ ╟── but it flows into argument with expected type `#S0`
//│ ║  l.357: 	s0 (C0{})
//│ ║         	   ^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.353: 	def s0: S0[?] -> S0[?]
//│ ╙──       	        ^^^^^
//│ res: S0[?]





