
class Lit
class Add
class Const
//│ Defined class Lit
//│ Defined class Add
//│ Defined class Const

Lit
//│ res: anything -> Lit

def eval0: ('b -> ('c & int)) -> (Lit & {val: int} | Add & {lhs: 'a; rhs: 'a} | ~lit & ~add & 'b as 'a) -> (int | 'c)
//│ eval0: ('b -> int) -> 'a -> int
//│   where
//│     'a <: 'b & ~#Add & ~#Lit | Add & {lhs: 'a, rhs: 'a} | Lit & {val: int}

def evalUgly: ('b -> ('c & int)) -> (Lit & {val: int} | Add & {lhs: 'a; rhs: 'a} | ~Lit & ~Add & 'b as 'a) -> (int | 'c)
//│ evalUgly: ('b -> int) -> 'a -> int
//│   where
//│     'a <: 'b & ~Add & ~Lit | Add & {lhs: 'a, rhs: 'a} | Lit & {val: int}

def evalBad: ('b -> 'c) -> (Lit & {val: int} | Add & {lhs: 'a; rhs: 'a} | ~Lit & ~Add & 'b as 'a) -> (int | 'c)
//│ evalBad: ('b -> 'c) -> 'a -> ('c | int)
//│   where
//│     'a <: 'b & ~Add & ~Lit | Add & {lhs: 'a, rhs: 'a} | Lit & {val: int}

type Expr[A] = Lit & {val: int} | Add & {lhs: Expr[A]; rhs: Expr[A]} | ~Lit & ~Add & A
//│ Defined type alias Expr[+A]

def eval1: ('b -> ('c & int)) -> Expr['b] -> (int | 'c)
//│ eval1: ('b -> int) -> Expr['b] -> int

def eval: ('b -> int) -> Expr['b] -> int
//│ eval: ('b -> int) -> Expr['b] -> int

rec def evalImpl f e = case e of {
  | Lit -> e.val
  | Add -> evalImpl f e.lhs + evalImpl f e.rhs
  | _ -> f e
  }
//│ evalImpl: ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add & {lhs: 'b, rhs: 'b} | Lit & {val: int} | 'a & ~#Add & ~#Lit

rec def evalPeel f e = case e of {
  | Lit -> e.val
  | Add -> eval f e.lhs + eval f e.rhs
  | _ -> f e
  }
//│ evalPeel: ('b -> int) -> ('b & ~#Add & ~#Lit | Add & {lhs: Expr['b], rhs: Expr['b]} | Lit & {val: 'val}) -> (int | 'val)

eval = evalPeel
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.52: 	eval = evalPeel
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `int`
//│ ║  l.27: 	type Expr[A] = Lit & {val: int} | Add & {lhs: Expr[A]; rhs: Expr[A]} | ~Lit & ~Add & A
//│ ║        	                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.33: 	def eval: ('b -> int) -> Expr['b] -> int
//│ ╙──      	                                     ^^^
//│ ('b -> int) -> ('b & ~#Add & ~#Lit | Add & {lhs: Expr['b], rhs: Expr['b]} | Lit & {val: 'val}) -> (int | 'val)
//│   <:  eval:
//│ ('b -> int) -> Expr['b] -> int

eval = evalImpl
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.66: 	eval = evalImpl
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `int`
//│ ║  l.27: 	type Expr[A] = Lit & {val: int} | Add & {lhs: Expr[A]; rhs: Expr[A]} | ~Lit & ~Add & A
//│ ║        	                           ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.36: 	rec def evalImpl f e = case e of {
//│ ║        	                            ^
//│ ╟── from argument:
//│ ║  l.38: 	  | Add -> evalImpl f e.lhs + evalImpl f e.rhs
//│ ╙──      	           ^^^^^^^^^^^^^^^^
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add & {lhs: 'b, rhs: 'b} | Lit & {val: int} | 'a & ~#Add & ~#Lit
//│   <:  eval:
//│ ('b -> int) -> Expr['b] -> int

eval0 = evalImpl
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.85: 	eval0 = evalImpl
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `int`
//│ ║  l.12: 	def eval0: ('b -> ('c & int)) -> (Lit & {val: int} | Add & {lhs: 'a; rhs: 'a} | ~lit & ~add & 'b as 'a) -> (int | 'c)
//│ ║        	                                              ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.36: 	rec def evalImpl f e = case e of {
//│ ║        	                            ^
//│ ╟── from argument:
//│ ║  l.38: 	  | Add -> evalImpl f e.lhs + evalImpl f e.rhs
//│ ╙──      	           ^^^^^^^^^^^^^^^^
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add & {lhs: 'b, rhs: 'b} | Lit & {val: int} | 'a & ~#Add & ~#Lit
//│   <:  eval0:
//│ ('b -> int) -> 'a -> int
//│   where
//│     'a <: 'b & ~#Add & ~#Lit | Add & {lhs: 'a, rhs: 'a} | Lit & {val: int}

evalUgly = evalImpl
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.106: 	evalUgly = evalImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `int`
//│ ║  l.17: 	def evalUgly: ('b -> ('c & int)) -> (Lit & {val: int} | Add & {lhs: 'a; rhs: 'a} | ~Lit & ~Add & 'b as 'a) -> (int | 'c)
//│ ║        	                                                 ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.36: 	rec def evalImpl f e = case e of {
//│ ║        	                            ^
//│ ╟── from argument:
//│ ║  l.38: 	  | Add -> evalImpl f e.lhs + evalImpl f e.rhs
//│ ╙──      	           ^^^^^^^^^^^^^^^^
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add & {lhs: 'b, rhs: 'b} | Lit & {val: int} | 'a & ~#Add & ~#Lit
//│   <:  evalUgly:
//│ ('b -> int) -> 'a -> int
//│   where
//│     'a <: 'b & ~Add & ~Lit | Add & {lhs: 'a, rhs: 'a} | Lit & {val: int}

eval1 = evalImpl
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.127: 	eval1 = evalImpl
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `int`
//│ ║  l.27: 	type Expr[A] = Lit & {val: int} | Add & {lhs: Expr[A]; rhs: Expr[A]} | ~Lit & ~Add & A
//│ ║        	                           ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.36: 	rec def evalImpl f e = case e of {
//│ ║        	                            ^
//│ ╟── from argument:
//│ ║  l.38: 	  | Add -> evalImpl f e.lhs + evalImpl f e.rhs
//│ ╙──      	           ^^^^^^^^^^^^^^^^
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add & {lhs: 'b, rhs: 'b} | Lit & {val: int} | 'a & ~#Add & ~#Lit
//│   <:  eval1:
//│ ('b -> int) -> Expr['b] -> int

:e
evalBad = eval
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.147: 	evalBad = eval
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `'c` is not an instance of `int`
//│ ║  l.22: 	def evalBad: ('b -> 'c) -> (Lit & {val: int} | Add & {lhs: 'a; rhs: 'a} | ~Lit & ~Add & 'b as 'a) -> (int | 'c)
//│ ║        	                    ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.33: 	def eval: ('b -> int) -> Expr['b] -> int
//│ ╙──      	                 ^^^
//│ ('b -> int) -> Expr['b] -> int
//│   <:  evalBad:
//│ ('b -> 'c) -> 'a -> ('c | int)
//│   where
//│     'a <: 'b & ~Add & ~Lit | Add & {lhs: 'a, rhs: 'a} | Lit & {val: int}




:e
eval {} (Lit{} with { val = 1 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.167: 	eval {} (Lit{} with { val = 1 })
//│ ║         	^^^^^^^
//│ ╟── record literal of type `anything` is not a function
//│ ║  l.167: 	eval {} (Lit{} with { val = 1 })
//│ ║         	     ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.33: 	def eval: ('b -> int) -> Expr['b] -> int
//│ ╙──      	          ^^^^^^^^^^^
//│ res: int




eval (fun x -> x) (Lit{} with { val = 1 })
//│ res: int

eval (fun x -> x) 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.185: 	eval (fun x -> x) 1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `int`
//│ ║  l.185: 	eval (fun x -> x) 1
//│ ║         	                  ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.33: 	def eval: ('b -> int) -> Expr['b] -> int
//│ ║        	                         ^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.33: 	def eval: ('b -> int) -> Expr['b] -> int
//│ ╙──      	                 ^^^
//│ res: int

eval (fun x -> x.hello) (Const{} with {hello=1})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.200: 	eval (fun x -> x.hello) (Const{} with {hello=1})
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `int`
//│ ║  l.200: 	eval (fun x -> x.hello) (Const{} with {hello=1})
//│ ║         	                                             ^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.200: 	eval (fun x -> x.hello) (Const{} with {hello=1})
//│ ║         	                         ^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.33: 	def eval: ('b -> int) -> Expr['b] -> int
//│ ║        	                         ^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.33: 	def eval: ('b -> int) -> Expr['b] -> int
//│ ╙──      	                 ^^^
//│ res: int

:e
eval (fun x -> x.hello) {hello=1}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.219: 	eval (fun x -> x.hello) {hello=1}
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `int`
//│ ║  l.219: 	eval (fun x -> x.hello) {hello=1}
//│ ║         	                               ^
//│ ╟── but it flows into record literal with expected type `int`
//│ ║  l.219: 	eval (fun x -> x.hello) {hello=1}
//│ ║         	                        ^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.33: 	def eval: ('b -> int) -> Expr['b] -> int
//│ ║        	                         ^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.33: 	def eval: ('b -> int) -> Expr['b] -> int
//│ ╙──      	                 ^^^
//│ res: nothing





l = Lit{} with {hello=1}
//│ l: Lit & {hello: int}
l: {hello:1}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.243: 	l: {hello:1}
//│ ║         	^
//│ ╟── integer literal of type `int` does not match type `1`
//│ ║  l.241: 	l = Lit{} with {hello=1}
//│ ║         	                      ^
//│ ╟── but it flows into reference with expected type `1`
//│ ║  l.243: 	l: {hello:1}
//│ ║         	^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.243: 	l: {hello:1}
//│ ║         	   ^^^^^^^^^
//│ ╟── from literal type:
//│ ║  l.243: 	l: {hello:1}
//│ ╙──       	          ^
//│ res: {hello: 1}


