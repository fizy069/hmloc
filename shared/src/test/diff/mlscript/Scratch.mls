class Nil: {}
class Cons[A]: {_0: A; _1: List[A]}
type List[A] = Cons[A] | Nil
def nil = Nil {}
//│ Defined class Nil
//│ Defined class Cons[+A]
//│ Defined type alias List[+A]
//│ nil: Nil

:dp
Nil {}
//│ Parsed: App(Var(Nil), Tup(_: Rcd()))
//│ res: Nil

:dp
def cons a b = Cons {_0 = a; _1 = b}
//│ Parsed: Def(false, cons, Lam(Tup(_: Var(a)), Lam(Tup(_: Var(b)), App(Var(Cons), Tup(_: Rcd(Var(_0) = Var(a), Var(_1) = Var(b)))))), true)
//│ cons: ('_0 & 'A) -> (List['A] & '_1) -> (Cons['A] with {_0: '_0, _1: '_1})

type Heap = List[(string, int)]
//│ Defined type alias Heap

def data = 1 : int
//│ data: int

:dp
def List_length[T]: List[T] -> int
//│ Parsed: Def(true, List_length, PolyType(List(TypeName(T)),Function(Tuple(List((None,Field(None,AppliedType(TypeName(List),List(TypeName(T))))))),TypeName(int))), true)
//│ List_length: List[?] -> int

:dp
def List_map: int -> int
//│ Parsed: Def(true, List_map, PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(int))))),TypeName(int))), true)
//│ List_map: int -> int

:dp
def List_map: int
//│ Parsed: Def(true, List_map, PolyType(List(),TypeName(int)), true)
//│ List_map: int

:dp
def List_init[T, N]: List[T] -> Cons[N]
//│ Parsed: Def(true, List_init, PolyType(List(TypeName(T), TypeName(N)),Function(Tuple(List((None,Field(None,AppliedType(TypeName(List),List(TypeName(T))))))),AppliedType(TypeName(Cons),List(TypeName(N))))), true)
//│ List_init: List[?] -> Cons[nothing]

:dp
def List_init[T, N]: List[T] -> Nil
//│ Parsed: Def(true, List_init, PolyType(List(TypeName(T), TypeName(N)),Function(Tuple(List((None,Field(None,AppliedType(TypeName(List),List(TypeName(T))))))),TypeName(Nil))), true)
//│ List_init: List[?] -> Nil

// TODO
// type heapVar = Heap of (string * int) list
