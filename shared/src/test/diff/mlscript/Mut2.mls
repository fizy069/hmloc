
(mut 1, mut 2): MutArray['a]
//│ res: MutArray['a]
//│   where
//│     'a :> int

((fun t -> let tmp = t._1 <- 3 in t) ((mut 1, mut 2))): MutArray['a]
//│ res: MutArray['a]
//│   where
//│     'a :> int

((fun t -> let tmp = t._1 + 1 in t) ((mut 1, mut 2))): MutArray['a]
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.12: 	((fun t -> let tmp = t._1 + 1 in t) ((mut 1, mut 2))): MutArray['a]
//│ ║        	                     ^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.12: 	((fun t -> let tmp = t._1 + 1 in t) ((mut 1, mut 2))): MutArray['a]
//│ ╙──      	                     ^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.12: 	((fun t -> let tmp = t._1 + 1 in t) ((mut 1, mut 2))): MutArray['a]
//│ ║        	                     ^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.12: 	((fun t -> let tmp = t._1 + 1 in t) ((mut 1, mut 2))): MutArray['a]
//│ ╙──      	                            ^
//│ res: MutArray['a]
//│   where
//│     'a :> int

if true then (mut 1, mut 2) else (mut 3, mut 4)
//│ res: (mut in 'a out int | 'a, mut in 'b out int | 'b,)

def t1: (mut 1, mut 2)
def t2: (mut 3, mut 4)
//│ t1: (mut 1, mut 2,)
//│ t2: (mut 3, mut 4,)

r = if true then t1 else t2
//│ r: (mut out 1 | 3, mut out 2 | 4,)

:e
r._1 <- 1
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.41: 	r._1 <- 1
//│ ║        	^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `3`
//│ ║  l.41: 	r._1 <- 1
//│ ║        	        ^
//│ ╟── Note: constraint arises from assigned selection:
//│ ║  l.41: 	r._1 <- 1
//│ ║        	^^^^
//│ ╟── from literal type:
//│ ║  l.33: 	def t2: (mut 3, mut 4)
//│ ╙──      	             ^






def t1: (mut 1 | 2 | 3)
def t2: (mut 2 | 3 | 4)
//│ t1: (mut 1 | 2 | 3,)
//│ t2: (mut 2 | 3 | 4,)

r = if true then t1 else t2
//│ r: (mut in 2 | 3 out 1 | 2 | 3 | 4,)

r._1 <- if true then 2 else 3
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.68: 	r._1 <- if true then 2 else 3
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `2 | 3 | 4`
//│ ║  l.68: 	r._1 <- if true then 2 else 3
//│ ║        	                            ^
//│ ╟── but it flows into application with expected type `2 | 3 | 4`
//│ ║  l.68: 	r._1 <- if true then 2 else 3
//│ ║        	           ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from assigned selection:
//│ ║  l.68: 	r._1 <- if true then 2 else 3
//│ ║        	^^^^
//│ ╟── from union type:
//│ ║  l.61: 	def t2: (mut 2 | 3 | 4)
//│ ╙──      	             ^^^^^^^^^

:e
r._1 <- if true then 2 else 1
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.86: 	r._1 <- if true then 2 else 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `2 | 3 | 4`
//│ ║  l.86: 	r._1 <- if true then 2 else 1
//│ ║        	                            ^
//│ ╟── but it flows into application with expected type `2 | 3 | 4`
//│ ║  l.86: 	r._1 <- if true then 2 else 1
//│ ║        	           ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from assigned selection:
//│ ║  l.86: 	r._1 <- if true then 2 else 1
//│ ║        	^^^^
//│ ╟── from union type:
//│ ║  l.61: 	def t2: (mut 2 | 3 | 4)
//│ ╙──      	             ^^^^^^^^^





