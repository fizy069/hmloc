
def intToString: int -> string
def intToString x = toString x
def done x = case x of {}
//│ intToString: int -> string
//│ anything -> string
//│   <:  intToString:
//│ int -> string
//│ done: nothing -> nothing



class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
//│ Defined class Lit
//│ Defined class Add[+E]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.15: 	def lit val = Lit { val }
//│ ║        	              ^^^^^^^^^^^
//│ ╟── argument of type `({val: ?a},)` does not have field 'val'
//│ ║  l.15: 	def lit val = Lit { val }
//│ ╙──      	                  ^^^^^^^
//│ lit: anything -> (Lit & {val: nothing})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.16: 	def add lhs rhs = Add { lhs; rhs }
//│ ║        	                  ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.16: 	def add lhs rhs = Add { lhs; rhs }
//│ ╙──      	                      ^^^^^^^^^^^^
//│ add: anything -> anything -> Add[nothing]



rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs
  | _ -> k e
  }
//│ eval1_stub: ('a -> 'b) -> 'c -> 'b
//│   where
//│     'c <: Add[?] & {lhs: 'c} | 'a & ~#Add

rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
  | _ -> k e
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.45: 	  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.45: 	  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
//│ ╙──      	           ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.45: 	  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.45: 	  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
//│ ╙──      	                                ^^^^^^^^^^^^^^^^^^
//│ eval1_stub: ('a -> 'b) -> 'c -> (int | 'b)
//│   where
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | 'a & ~#Add

:ns
rec def eval1_stub e = case e of {
  | Lit -> 1
  | Add -> eval1_stub e.lhs
  | _ -> 0
  }
//│ eval1_stub: 'eval1_stub
//│   where
//│     'eval1_stub :> 'a -> 'b
//│                 <: 'lhs -> 'c
//│     'b :> int | 'c
//│        <: 'c
//│     'c :> int
//│     'a <: #Lit & 'd | (#Add & 'e | 'f & ~#Add) & ~#Lit
//│     'e <: {lhs: 'lhs}
//│     'lhs <: 'a

eval1_stub
//│ res: 'a -> int
//│   where
//│     'a <: Add[?] & {lhs: 'a} | Lit | ~Add[?] & ~Lit

// def eval1: ('b -> int) -> Expr['b] -> int
:stats
rec def eval1 k e = case e of {
  | Lit -> e.val
  | Add -> eval1 k e.lhs + eval1 k e.rhs
  | _ -> k e
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.90: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.90: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ╙──      	           ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.90: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.90: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ╙──      	                           ^^^^^^^^^^^^^
//│ eval1: ('a -> 'val) -> 'b -> (int | 'val)
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | (Lit with {val: 'val}) | 'a & ~#Add & ~#Lit
//│ constrain calls  : 66
//│ annoying  calls  : 0
//│ subtyping calls  : 105

:ns
eval1
//│ res: 'eval1
//│   where
//│     'eval1 :> 'a -> 'b -> 'c
//│            <: 'a -> 'd & 'a -> 'e
//│     'e :> 'b -> 'c
//│        <: 'lhs -> 'f
//│     'd :> 'b -> 'c
//│        <: 'rhs -> 'g
//│     'c :> 'val | 'h | 'i
//│        <: 'f & 'g
//│     'h :> int
//│        <: 'f & 'g
//│     'b <: #Lit & 'j | (#Add & 'k | 'l & ~#Add) & ~#Lit
//│     'k <: {rhs: 'rhs} & {lhs: 'lhs}
//│     'lhs <: 'b
//│     'rhs <: 'b
//│     'j <: {val: 'val}
//│     'val <: 'f & 'g
//│     'a <: 'l -> 'i
//│     'i <: 'f & 'g
//│     'g :> int
//│     'f :> int

:re
error: ~Add[?]
//│ res: ~Add[nothing]

:re
error: ('a & ~Lit) -> 'a
//│ res: ('a & ~Lit) -> 'a

:re
error: ('a) -> ('a & Add[?])
error: ('a) -> ('a & ~Add[?])
error: ('a & ~Add[?]) -> 'a
//│ res: 'a -> (Add[?] & 'a)
//│ res: 'a -> ('a & ~Add[nothing])
//│ res: ('a & ~Add[?]) -> 'a

:re
error: ('a & ~add) -> 'a
//│ res: ('a & ~#Add) -> 'a

:ns
def eval1_ty_ugly: ('a -> int) -> (Lit | Add['b] | 'a & ~Lit & ~Add[?] as 'b) -> int
//│ eval1_ty_ugly: ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~Lit & ~Add[?]

eval1_ty_ugly
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit

:stats
def eval1_ty_ugly = eval1
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.169: 	def eval1_ty_ugly = eval1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `int`
//│ ║  l.13: 	class Lit: { val: int }
//│ ║        	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.158: 	def eval1_ty_ugly: ('a -> int) -> (Lit | Add['b] | 'a & ~Lit & ~Add[?] as 'b) -> int
//│ ╙──       	                                                                                 ^^^
//│ ('a -> 'val) -> 'b -> (int | 'val)
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | (Lit with {val: 'val}) | 'a & ~#Add & ~#Lit
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│ constrain calls  : 94
//│ annoying  calls  : 36
//│ subtyping calls  : 337

:ns
def eval1_ty: ('a -> int) -> (Lit | Add['b] | 'a & ~lit & ~add as 'b) -> int
//│ eval1_ty: ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~#Lit & ~#Add

eval1_ty
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~#Add & ~#Lit | Add['b] | Lit

:stats
def eval1_ty = eval1
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.202: 	def eval1_ty = eval1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `int`
//│ ║  l.13: 	class Lit: { val: int }
//│ ║        	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.191: 	def eval1_ty: ('a -> int) -> (Lit | Add['b] | 'a & ~lit & ~add as 'b) -> int
//│ ╙──       	                                                                         ^^^
//│ ('a -> 'val) -> 'b -> (int | 'val)
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | (Lit with {val: 'val}) | 'a & ~#Add & ~#Lit
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~#Add & ~#Lit | Add['b] | Lit
//│ constrain calls  : 94
//│ annoying  calls  : 36
//│ subtyping calls  : 339

:stats
eval1_ty_ugly = eval1_ty
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~#Add & ~#Lit | Add['b] | Lit
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│ constrain calls  : 20
//│ annoying  calls  : 13
//│ subtyping calls  : 259

:stats
eval1_ty = eval1_ty_ugly
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~#Add & ~#Lit | Add['b] | Lit
//│ constrain calls  : 170
//│ annoying  calls  : 315
//│ subtyping calls  : 4963


// Workaround:
:ns
type E1[A] = Lit | Add[E1[A]] | A & ~lit & ~add
def eval1_ty: ('a -> int) -> E1['a] -> int
//│ Defined type alias E1[+A]
//│ eval1_ty: ('a -> int) -> E1['a] -> int

eval1_ty
//│ res: ('a -> int) -> E1['a] -> int

:stats
def eval1_ty = eval1
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.261: 	def eval1_ty = eval1
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `int`
//│ ║  l.13: 	class Lit: { val: int }
//│ ║        	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.253: 	def eval1_ty: ('a -> int) -> E1['a] -> int
//│ ╙──       	                                       ^^^
//│ ('a -> 'val) -> 'b -> (int | 'val)
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | (Lit with {val: 'val}) | 'a & ~#Add & ~#Lit
//│   <:  eval1_ty:
//│ ('a -> int) -> E1['a] -> int
//│ constrain calls  : 101
//│ annoying  calls  : 38
//│ subtyping calls  : 243


:stats
rec def pretty1 k e = case e of {
  | Lit -> intToString e.val
  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
  | _ -> k e
  }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.284: 	  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.284: 	  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
//│ ╙──       	                  ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.284: 	  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.284: 	  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
//│ ╙──       	                                    ^^^^^^^^^^^^^^^^^
//│ pretty1: ('a -> 'b) -> 'c -> (string | 'b)
//│   where
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit | 'a & ~#Add & ~#Lit
//│ constrain calls  : 80
//│ annoying  calls  : 0
//│ subtyping calls  : 93


:stats
rec def prettier1 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      if ev e.lhs == 0 then prettier1 k ev e.rhs
      else if ev e.rhs == 0 then prettier1 k ev e.lhs
      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
  | _ -> k e
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.311: 	      if ev e.lhs == 0 then prettier1 k ev e.rhs
//│ ║         	         ^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.311: 	      if ev e.lhs == 0 then prettier1 k ev e.rhs
//│ ╙──       	         ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.311: 	      if ev e.lhs == 0 then prettier1 k ev e.rhs
//│ ║         	         ^^^^^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.311: 	      if ev e.lhs == 0 then prettier1 k ev e.rhs
//│ ╙──       	                     ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.312: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ║         	              ^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.312: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.312: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ║         	              ^^^^^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.312: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	                          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.313: 	      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.313: 	      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
//│ ╙──       	                  ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.313: 	      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.313: 	      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
//│ ╙──       	                                         ^^^^^^^^^^^^^^^^^^^^^^
//│ prettier1: ('a -> 'b) -> ('rhs -> anything) -> 'c -> 'b
//│   where
//│     'c <: Add[?] & {lhs: 'rhs & 'c, rhs: 'rhs & 'c} | Lit | 'a & ~#Add & ~#Lit
//│     'b :> string
//│ constrain calls  : 352
//│ annoying  calls  : 0
//│ subtyping calls  : 125

:stats
rec def prettier11 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
  | _ -> k e
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.365: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ║         	            ^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.365: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ╙──       	            ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.365: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ║         	            ^^^^^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.365: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ╙──       	                        ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.365: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ║         	                                        ^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.365: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ╙──       	                                               ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.365: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ║         	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.365: 	      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
//│ ╙──       	                                                   ^^^^^^^^^^^^^^^^^^^^^^^
//│ prettier11: ('a -> 'b) -> ('rhs -> anything) -> 'c -> (string | 'b)
//│   where
//│     'c <: Add[?] & {lhs: 'd, rhs: 'rhs & 'c} | Lit | 'a & ~#Add & ~#Lit
//│     'd <: Add[?] & {lhs: 'd, rhs: 'd} | Lit | 'a & ~#Add & ~#Lit
//│ constrain calls  : 175
//│ annoying  calls  : 0
//│ subtyping calls  : 198

// Doesn't make much sense, but generates very ugly type unless aggressively simplified:
:stats
rec def prettier12 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
  | _ -> k e
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.406: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ║         	            ^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.406: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	            ^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.406: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ║         	            ^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.406: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	                    ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.406: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ║         	                                    ^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.406: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	                                           ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.406: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ║         	                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.406: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	                                               ^^^^^^^^^^^^^^^^^
//│ prettier12: ('a -> 'b) -> ('c -> anything) -> (Add[?] & {lhs: 'd, rhs: 'd} & 'c | Lit | 'a & ~#Add & ~#Lit) -> (string | 'b)
//│   where
//│     'd <: Add[?] & {lhs: 'd, rhs: 'd} | Lit | 'a & ~#Add & ~#Lit
//│ constrain calls  : 168
//│ annoying  calls  : 0
//│ subtyping calls  : 281


:stats
e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
prettier11 done (eval1 done) e1
prettier12 done (eval1 done) e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ║         	               ^^^^^^^^^^^^^
//│ ╟── argument of type `({val: int},)` does not have field 'val'
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ╙──       	                   ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ║         	                                              ^^^^^^^^^^^^^
//│ ╟── argument of type `({val: int},)` does not have field 'val'
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ╙──       	                                                  ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ║         	                                                                   ^^^^^^^^^^^^^
//│ ╟── argument of type `({val: int},)` does not have field 'val'
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ╙──       	                                                                       ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ║         	                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ╙──       	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.442: 	e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ e1: Add[nothing]
//│ res: int
//│ res: string
//│ res: string
//│ res: string
//│ res: string
//│ constrain calls  : 569
//│ annoying  calls  : 115
//│ subtyping calls  : 362


e1 = add (lit 1) (add (lit 2) (lit 3))
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
prettier11 done (eval1 done) e1
prettier12 done (eval1 done) e1
//│ e1: Add[nothing]
//│ res: int
//│ res: string
//│ res: string
//│ res: string
//│ res: string



class Nega[E]: { arg: E }
def nega arg = Nega { arg }
//│ Defined class Nega[+E]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.505: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── argument of type `({arg: ?a},)` does not have field 'arg'
//│ ║  l.505: 	def nega arg = Nega { arg }
//│ ╙──       	                    ^^^^^^^
//│ nega: anything -> Nega[nothing]



rec def eval2 k = eval1 (fun x -> case x of {
  | Nega -> 0 - (eval2 k x.arg)
  | _ -> k x
  })
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.518: 	  | Nega -> 0 - (eval2 k x.arg)
//│ ║         	            ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.518: 	  | Nega -> 0 - (eval2 k x.arg)
//│ ╙──       	            ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.518: 	  | Nega -> 0 - (eval2 k x.arg)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.518: 	  | Nega -> 0 - (eval2 k x.arg)
//│ ╙──       	                ^^^^^^^^^^^^^^^
//│ eval2: ('a -> 'val) -> 'b -> (int | 'val)
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | (Lit with {val: 'val}) | Nega[?] & {arg: 'b} | 'a & ~#Add & ~#Lit & ~#Nega


:stats
rec def prettier2 k ev = prettier1 (fun x -> case x of {
  | Nega -> concat "-" (prettier2 k ev x.arg)
  | _ -> k x
  }) ev
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.540: 	  | Nega -> concat "-" (prettier2 k ev x.arg)
//│ ║         	            ^^^^^^^^^^
//│ ╟── argument of type `(string,)` is not an instance of `string`
//│ ║  l.540: 	  | Nega -> concat "-" (prettier2 k ev x.arg)
//│ ╙──       	                   ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.540: 	  | Nega -> concat "-" (prettier2 k ev x.arg)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.540: 	  | Nega -> concat "-" (prettier2 k ev x.arg)
//│ ╙──       	                       ^^^^^^^^^^^^^^^^^^^^^^
//│ prettier2: ('a -> 'b) -> ('rhs -> anything) -> 'c -> 'b
//│   where
//│     'c <: Add[?] & {lhs: 'rhs & 'c, rhs: 'rhs & 'c} | Lit | Nega[?] & {arg: 'c} | 'a & ~#Add & ~#Lit & ~#Nega
//│     'b :> string
//│ constrain calls  : 193
//│ annoying  calls  : 0
//│ subtyping calls  : 212

:stats
rec def prettier22 k ev = prettier12 (fun x -> case x of {
  | Nega -> concat "-" (prettier22 k ev x.arg)
  | _ -> k x
  }) ev
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.565: 	  | Nega -> concat "-" (prettier22 k ev x.arg)
//│ ║         	            ^^^^^^^^^^
//│ ╟── argument of type `(string,)` is not an instance of `string`
//│ ║  l.565: 	  | Nega -> concat "-" (prettier22 k ev x.arg)
//│ ╙──       	                   ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.565: 	  | Nega -> concat "-" (prettier22 k ev x.arg)
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `string`
//│ ║  l.565: 	  | Nega -> concat "-" (prettier22 k ev x.arg)
//│ ╙──       	                       ^^^^^^^^^^^^^^^^^^^^^^^
//│ prettier22: ('a -> 'b) -> ('c -> anything) -> 'd -> (string | 'b)
//│   where
//│     'c <: {lhs: 'e, rhs: 'e}
//│     'e <: Add[?] & {lhs: 'e, rhs: 'e} | Lit | 'f & ~#Add & ~#Lit
//│     'f <: Nega[?] & {arg: 'd} | 'a & ~#Nega
//│     'd <: Add[?] & 'c | Lit | 'f & ~#Add & ~#Lit
//│ constrain calls  : 189
//│ annoying  calls  : 0
//│ subtyping calls  : 313



:stats
eval2 done e1
//│ res: int
//│ constrain calls  : 66
//│ annoying  calls  : 15
//│ subtyping calls  : 38

e2 = add (lit 1) (nega e1)
//│ e2: Add[nothing]

:stats
eval2 done e2
//│ res: int
//│ constrain calls  : 66
//│ annoying  calls  : 15
//│ subtyping calls  : 38

d2 = nega (add (lit 1) (nega (lit 1)))
//│ d2: Nega[nothing]

:stats
eval2 done d2
//│ res: int
//│ constrain calls  : 72
//│ annoying  calls  : 18
//│ subtyping calls  : 40


prettier2 done
//│ res: ('rhs -> anything) -> 'a -> string
//│   where
//│     'a <: Add[?] & {lhs: 'rhs & 'a, rhs: 'rhs & 'a} | Lit | Nega[?] & {arg: 'a}

prettier22 done
//│ res: ('a -> anything) -> 'b -> string
//│   where
//│     'a <: {lhs: 'c, rhs: 'c}
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit | 'd & ~#Add & ~#Lit
//│     'd <: Nega[?] & {arg: 'b}
//│     'b <: Add[?] & 'a | Lit | 'd & ~#Add & ~#Lit

:stats
prettier2 done (eval1 done)
//│ res: 'a -> string
//│   where
//│     'a <: Add[?] & {lhs: 'a & 'b, rhs: 'a & 'b} | Lit | Nega[?] & {arg: 'a}
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit
//│ constrain calls  : 86
//│ annoying  calls  : 0
//│ subtyping calls  : 216


prettier22 done (eval1 done)
//│ res: 'a -> string
//│   where
//│     'a <: Add[?] & {lhs: 'b, rhs: 'b} & 'c | Lit | 'd & ~#Add & ~#Lit
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'd & ~#Add & ~#Lit
//│     'd <: Nega[?] & {arg: 'a}

// TODO could probably merge `a` and `b` here!
:stats
prettier2 done (eval2 done)
//│ res: 'a -> string
//│   where
//│     'a <: Add[?] & {lhs: 'a & 'b, rhs: 'a & 'b} | Lit | Nega[?] & {arg: 'a}
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | Nega[?] & {arg: 'b}
//│ constrain calls  : 106
//│ annoying  calls  : 0
//│ subtyping calls  : 283

prettier2 done (eval2 done) e2
prettier2 done (eval2 done) d2
//│ res: string
//│ res: string

:stats
prettier22 done (eval2 done)
prettier22 done (eval2 done) e2
prettier22 done (eval2 done) d2
//│ res: 'a -> string
//│   where
//│     'a <: Add[?] & {lhs: 'b, rhs: 'b} & 'c | Lit | 'd & ~#Add & ~#Lit
//│     'c <: Add[?] & {lhs: 'c, rhs: 'c} | Lit | Nega[?] & {arg: 'c}
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Lit | 'd & ~#Add & ~#Lit
//│     'd <: Nega[?] & {arg: 'a}
//│ res: string
//│ res: string
//│ constrain calls  : 421
//│ annoying  calls  : 48
//│ subtyping calls  : 562




// === === === ERROR CASES === === === //


:ShowRelativeLineNums


:e
eval1 done e2
//│ res: int






:e
prettier2 done eval1 e1
//│ res: string













:e
:stats
prettier2 done (eval1 done) e2
//│ res: string
//│ constrain calls  : 198
//│ annoying  calls  : 35
//│ subtyping calls  : 68





:e
:stats
prettier2 done eval2
//│ res: 'a -> string
//│   where
//│     'a <: Add[?] & {lhs: nothing -> anything & 'a, rhs: nothing -> anything & 'a} | Lit | Nega[?] & {arg: 'a}
//│ constrain calls  : 62
//│ annoying  calls  : 0
//│ subtyping calls  : 135








:e
:stats
prettier2 done eval2 e1
//│ res: string
//│ constrain calls  : 174
//│ annoying  calls  : 35
//│ subtyping calls  : 68












:e
:stats
prettier2 done eval2 e2
//│ res: string
//│ constrain calls  : 174
//│ annoying  calls  : 35
//│ subtyping calls  : 68












:e
:stats
prettier2 done eval2 d2
//│ res: string
//│ constrain calls  : 160
//│ annoying  calls  : 18
//│ subtyping calls  : 40












:e
:stats
prettier2 done eval1 e2
//│ res: string
//│ constrain calls  : 166
//│ annoying  calls  : 35
//│ subtyping calls  : 68












