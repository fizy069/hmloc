
class Nil: {}
class Cons[A]: { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons[+A]
//│ Defined type alias List[+A]

def originalCons = Cons  // Note: type still seems over-complicated because we push 'b inside the union, killing a hash-consing opportunity at the outer level...
//│ originalCons: {head: 'head & 'A, tail: List['A] & 'tail} -> (Cons['A] with {head: 'head, tail: 'tail})

def Nil = Nil {}
//│ Nil: Nil

def Cons head tail = Cons { head; tail }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.15: 	def Cons head tail = Cons { head; tail }
//│ ║        	                     ^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({head: ?a, tail: ?b},)` is not a record (expected a record with fields: head, tail)
//│ ║  l.15: 	def Cons head tail = Cons { head; tail }
//│ ╙──      	                          ^^^^^^^^^^^^^^
//│ Cons: anything -> anything -> (Cons[nothing] & {tail: nothing})


Cons 2
//│ res: anything -> (Cons[nothing] & {tail: nothing})

def c = Cons 2 Nil
//│ c: Cons[nothing] & {tail: nothing}

def d = Cons 1 c
//│ d: Cons[nothing] & {tail: nothing}

d.head
//│ res: nothing

res: 1
//│ res: 1

d.tail
//│ res: nothing

Cons 1 res
//│ res: Cons[nothing] & {tail: nothing}

res.tail
//│ res: nothing

Cons 1 (Cons 2 Nil)
//│ res: Cons[nothing] & {tail: nothing}

res.tail
//│ res: nothing

// We can now access the tail's tail, thanks to the refined type
res.tail
//│ res: nothing

:e
res.tail.head
//│ res: nothing







// This used to yield a more precise Cons constructor, but it's no longer necessary in the new class semantics
def Cons head tail = originalCons { head; tail } with { head; tail }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.70: 	def Cons head tail = originalCons { head; tail } with { head; tail }
//│ ║        	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({head: ?a, tail: ?b},)` is not a record (expected a record with fields: head, tail)
//│ ║  l.70: 	def Cons head tail = originalCons { head; tail } with { head; tail }
//│ ╙──      	                                  ^^^^^^^^^^^^^^
//│ Cons: 'a -> 'b -> (Cons[nothing] with {head: 'a, tail: 'b})


Cons 2
//│ res: 'a -> (Cons[nothing] with {tail: 'a})

Cons 2 Nil
//│ res: Cons[nothing] with {tail: Nil}

res.head
//│ res: int

:e
Cons 1 res
//│ res: Cons[nothing] with {tail: int}






// Here there used to be a loss of precision in the older with-field approach.
//    The problem occured when constraining `α8 w/ {head: α5, tail: [α6]}  <!  nil | {head: α2}`
//    as we can't decide whether to constrain `α8 <! nil` or `α5 <! α2`...
// I seemingly solved it by just pushing `with` extensions applied on variables to the right
//    just long enough to push it back on the left after travsering type variable bounds...
//    This is okay because `with` types otherwise never occur in negative position... Note we could
//    have used a different "delayed with" type to be cleaner, though it's just not necessary.
// But then I reverted to the use of simple field-hiding types, as they are simpler!
// 
Cons 1 (Cons 2 Nil)
//│ res: Cons[nothing] with {tail: Cons[nothing] with {tail: Nil}}

{ a = res.head; b = res.tail.head; c = res.tail.tail }
//│ res: {a: int, b: int, c: Nil}

Cons 2 Nil
//│ res: Cons[nothing] with {tail: Nil}

Cons 1 (id res)
//│ res: Cons[nothing] with {tail: (Cons[nothing] with {tail: Nil},)}

{ a = res.head; b = res.tail.head; c = res.tail.tail }
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.119: 	{ a = res.head; b = res.tail.head; c = res.tail.tail }
//│ ║         	                    ^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not have field 'head'
//│ ║  l.116: 	Cons 1 (id res)
//│ ║         	           ^^^
//│ ╟── but it flows into reference with expected type `{head: ?head}`
//│ ║  l.119: 	{ a = res.head; b = res.tail.head; c = res.tail.tail }
//│ ╙──       	                    ^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.119: 	{ a = res.head; b = res.tail.head; c = res.tail.tail }
//│ ║         	                                       ^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not have field 'tail'
//│ ║  l.116: 	Cons 1 (id res)
//│ ║         	           ^^^
//│ ╟── but it flows into reference with expected type `{tail: ?tail}`
//│ ║  l.119: 	{ a = res.head; b = res.tail.head; c = res.tail.tail }
//│ ╙──       	                                       ^^^
//│ res: {a: int, b: nothing, c: nothing}



rec def filter p ls = case ls of
  { Cons -> if p ls.head then Cons ls.head (filter p ls.tail) else filter p ls.tail
  | Nil -> Nil
  }
//│ filter: ('head -> bool) -> 'a -> 'b
//│   where
//│     'b :> (Cons[nothing] with {head: 'head, tail: 'b}) | Nil
//│     'a <: (Cons[?] with {head: 'head, tail: 'a}) | Nil




def Cons head = originalCons { head=0; tail=Nil } with { head }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.154: 	def Cons head = originalCons { head=0; tail=Nil } with { head }
//│ ║         	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({head: int, tail: ?a},)` is not a record (expected a record with fields: head, tail)
//│ ║  l.154: 	def Cons head = originalCons { head=0; tail=Nil } with { head }
//│ ╙──       	                             ^^^^^^^^^^^^^^^^^^^^
//│ Cons: 'a -> (Cons[nothing] with {head: 'a, tail: nothing})

Cons 1
//│ res: Cons[nothing] with {tail: nothing}

res.head
//│ res: int

def c = Cons 1
//│ c: Cons[nothing] with {tail: nothing}

c.head
//│ res: int

def c: 'a -> List['b] -> List['a | 'b]
c 1 (c 2 Nil)
//│ c: 'a -> List['a] -> List['a]
//│ res: List[int]

def c: 'a -> ('l & List['b]) -> (Cons[anything] & { head: 'a; tail: 'l })
c 1 (c 2 Nil)
//│ c: 'a -> (List[?] & 'l) -> (Cons[?] with {head: 'a, tail: 'l})
//│ res: Cons[?] with {head: int, tail: Cons[?] with {head: int, tail: Nil}}
