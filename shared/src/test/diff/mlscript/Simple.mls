
def a = 1
def b = 2
def c = 3
//│ a: int
//│ b: int
//│ c: int

if true then if true then a else b else a
//│ res: int

if true then if true then id a else id b else a
//│ res: (int,) | int

class Foo[A]: { field: A }
class Bar: {}
//│ Defined class Foo[+A]
//│ Defined class Bar

def foo = Foo { field = id 1 }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.20: 	def foo = Foo { field = id 1 }
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({field: ?a},)` does not have field 'field'
//│ ║  l.20: 	def foo = Foo { field = id 1 }
//│ ╙──      	              ^^^^^^^^^^^^^^^^
//│ foo: Foo[nothing]

(if true then foo else { field = 2 }).field
//│ res: int

Foo { field = id 1 }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.32: 	Foo { field = id 1 }
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({field: ?a},)` does not have field 'field'
//│ ║  l.32: 	Foo { field = id 1 }
//│ ╙──      	    ^^^^^^^^^^^^^^^^
//│ res: Foo[nothing]

def test x = case x of { Bar -> 1 | Foo -> 2 }
//│ test: (Bar | Foo[?]) -> int

test foo
//│ res: int

def test x = case x of { Bar -> 1 | Foo -> x.field }
//│ test: (Bar | (Foo[?] with {field: 'field})) -> ('field | int)

test foo
//│ res: int

test (Foo { field = 2 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.53: 	test (Foo { field = 2 })
//│ ║        	      ^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({field: int},)` does not have field 'field'
//│ ║  l.53: 	test (Foo { field = 2 })
//│ ╙──      	          ^^^^^^^^^^^^^
//│ res: int

def test x = case x of { Foo -> x.field | _ -> 1 }
//│ test: ((Foo[?] with {field: 'field}) | ~Foo[?]) -> ('field | int)


def f x = x.u
//│ f: {u: 'u} -> 'u

f { u = 1 }
//│ res: int

f { u = 1; v = 2 }
//│ res: int

f (if true then { u = 1; v = 2 } else { u = 1 })
//│ res: int

if true then { u = 1; v = 2 } else { u = 2 }
//│ res: {u: int}

