
// * Strictly speaking, type preservation does not hold in the MLscript implementation,
// *  though this is merely a technicality that can be addressed in the formal language.
// * Consider the following example:

class C1
class C2: C1
class C3
//│ Defined class C1
//│ Defined class C2
//│ Defined class C3

def foo x = case x of {
  | C2 -> C3{}
  | _ -> x
  }
//│ foo: (C2 | 'a & ~#C2) -> (C3 | 'a)

c1 = C1{}
//│ c1: C1

r = foo c1
//│ r: C1 | C3

// * Here we have the C1{} value typed at ~C2
r : ~C2
//│ res: ~C2

// * But that C1{} value cannot be typed at ~C2 directly!
:e
c1 : ~C2
//│ res: ~C2






// * The problem is resolved by saying that when instantiating a non-final class C1,
// *  we are really instantiating a hidden final C1_Impl version of it:

class C1_Impl: C1
//│ Defined class C1_Impl

c1 = C1_Impl{}
//│ c1: C1_Impl

r = foo c1
//│ r: C1_Impl | C3

r : ~C2
//│ res: ~C2

c1 : ~C2
//│ res: ~C2


// * More concerning: trait constructors are unsound as long as we allow matching on traits!
// * Trait constructors were always a fringe feature that we wanted to eventually remove anyway.

trait T1
//│ Defined trait T1

rec def getNegT1 x = case x of {
  | T1 -> getNegT1 x
  | _ -> x
  }
//│ getNegT1: (#T1 | 'a & ~#T1) -> 'a

nt1 = getNegT1 {}
//│ nt1: ~#T1

T1
//│ res: 'a -> (#T1 & 'a)

t1nt1 = T1 nt1
//│ t1nt1: (~#T1,) & #T1

:re
t1nt1.lol "oops!"
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.80: 	t1nt1.lol "oops!"
//│ ║        	^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not have field 'lol'
//│ ║  l.76: 	t1nt1 = T1 nt1
//│ ║        	           ^^^
//│ ╟── but it flows into reference with expected type `{lol: ?lol}`
//│ ║  l.80: 	t1nt1.lol "oops!"
//│ ╙──      	^^^^^
//│ res: nothing



