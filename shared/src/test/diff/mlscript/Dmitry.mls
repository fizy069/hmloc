
class Class1: { payload: int }
//│ Defined class Class1

:e
class Hidden[A]
  method Foo s = case s of { Class1 -> s.payload | _ -> 123 }
  method Main (a: A) = this.Foo a
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.8: 	  method Main (a: A) = this.Foo a
//│ ║       	                       ^^^^^^^^^^
//│ ╟── reference of type `A & (Class1 | ~?a)` does not have field 'payload'
//│ ║  l.8: 	  method Main (a: A) = this.Foo a
//│ ║       	                                ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.7: 	  method Foo s = case s of { Class1 -> s.payload | _ -> 123 }
//│ ║       	                      ^
//│ ╟── from receiver:
//│ ║  l.7: 	  method Foo s = case s of { Class1 -> s.payload | _ -> 123 }
//│ ╙──     	                                       ^
//│ Defined class Hidden[-A]
//│ Defined Hidden.Foo: Hidden[?] -> ((Class1 with {payload: 'payload}) | ~Class1) -> (int | 'payload)
//│ Defined Hidden.Main: Hidden['A] -> 'A -> int




class Hidden2[A]
  method Foo s = case s of { Class1 -> s.payload | _ -> 123 }
  method Main (a: A) = this.Foo (a with { payload = 1 })
//│ Defined class Hidden2[-A]
//│ Defined Hidden2.Foo: Hidden2[?] -> ((Class1 with {payload: 'payload}) | ~Class1) -> (int | 'payload)
//│ Defined Hidden2.Main: Hidden2['A] -> 'A -> int


def foo: ("A" | "B" | "D" | "E" | "F" | "G" | "H" | "I" | "J") -> int
//│ foo: ("A" | "B" | "D" | "E" | "F" | "G" | "H" | "I" | "J") -> int

arg = if true then "B" else if false then "C" else "D"
//│ arg: string

:e
foo arg
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.43: 	foo arg
//│ ║        	^^^^^^^
//│ ╟── string literal of type `string` does not match type `"A" | "B" | "D" | "E" | "F" | "G" | "H" | "I" | "J"`
//│ ║  l.39: 	arg = if true then "B" else if false then "C" else "D"
//│ ║        	                                                   ^^^
//│ ╟── but it flows into reference with expected type `"A" | "B" | "D" | "E" | "F" | "G" | "H" | "I" | "J"`
//│ ║  l.43: 	foo arg
//│ ║        	    ^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.36: 	def foo: ("A" | "B" | "D" | "E" | "F" | "G" | "H" | "I" | "J") -> int
//│ ╙──      	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: int





foo2 x = case x of {
  | "A" -> 1
  | "B" -> 2
  | "D" -> 3
  | "E" -> 4
  | "F" -> 5
  | "G" -> 6
  | "H" -> 7
  | "I" -> 8
  | "J" -> 9
  }
//│ foo2: ("A" | "B" | "D" | "E" | "F" | "G" | "H" | "I" | "J") -> int

:e
foo2 arg
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.76: 	foo2 arg
//│ ║        	^^^^^^^^
//│ ╟── string literal of type `string` does not match type `"A" & ?a | "B" & ?b | "D" & ?c | "E" & ?d | "F" & ?e | "G" & ?f | "H" & ?g | "I" & ?h | "J" & ?i`
//│ ║  l.39: 	arg = if true then "B" else if false then "C" else "D"
//│ ║        	                                                   ^^^
//│ ╟── but it flows into reference with expected type `"A" & ?a | "B" & ?b | "D" & ?c | "E" & ?d | "F" & ?e | "G" & ?f | "H" & ?g | "I" & ?h | "J" & ?i`
//│ ║  l.76: 	foo2 arg
//│ ║        	     ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	foo2 x = case x of {
//│ ╙──      	              ^
//│ res: int





