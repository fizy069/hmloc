
def absImpl lt x =
  case lt of
    { true -> x
    | false -> 0 - x }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.5: 	    | false -> 0 - x }
//│ ║       	               ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.5: 	    | false -> 0 - x }
//│ ╙──     	               ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.5: 	    | false -> 0 - x }
//│ ║       	               ^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.5: 	    | false -> 0 - x }
//│ ╙──     	                   ^
//│ absImpl: bool -> 'a -> (int | 'a)

:e
def abs x =
  let r = x < 0 in absImpl r x
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.22: 	  let r = x < 0 in absImpl r x
//│ ║        	          ^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.22: 	  let r = x < 0 in absImpl r x
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.22: 	  let r = x < 0 in absImpl r x
//│ ║        	          ^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.22: 	  let r = x < 0 in absImpl r x
//│ ╙──      	              ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.22: 	  let r = x < 0 in absImpl r x
//│ ║        	                   ^^^^^^^^^
//│ ╟── operator application of type `bool` does not match type `false & ?a | true & ?b`
//│ ║  l.22: 	  let r = x < 0 in absImpl r x
//│ ║        	          ^^^^^
//│ ╟── but it flows into reference with expected type `false & ?a | true & ?b`
//│ ║  l.22: 	  let r = x < 0 in absImpl r x
//│ ║        	                           ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.3: 	  case lt of
//│ ╙──     	       ^^
//│ abs: 'a -> (int | 'a)





def neg b = case b of
  { true -> false
  | false -> true }
//│ neg: bool -> bool

