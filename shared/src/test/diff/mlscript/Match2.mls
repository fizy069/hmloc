
class Test: { value: int }
//│ Defined class Test

def foo x = case x of
  { Test -> x.value
  | _ -> 1
  }
//│ foo: ((Test with {value: 'value}) | ~Test) -> (int | 'value)

// Q: why type of `value` widened?
def t = Test { value = 0 }
//│ t: Test

foo Test
//│ res: int

foo t
//│ res: int


class Toast: { name: string }
//│ Defined class Toast

def bar x = case x of
  { Test -> x.value
  | Toast -> x.name
  }
//│ bar: ((Test with {value: 'value}) | (Toast with {name: 'value})) -> 'value

:e
bar Test
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.32: 	bar Test
//│ ║        	^^^^^^^^
//│ ╟── reference of type `{value: ?value} -> (Test & {value: ?value})` does not match type `Test & ?a | Toast & ?b`
//│ ║  l.32: 	bar Test
//│ ║        	    ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.25: 	def bar x = case x of
//│ ║        	                 ^
//│ ╟── Note: class constructor Test is defined at:
//│ ║  l.2: 	class Test: { value: int }
//│ ╙──     	      ^^^^
//│ res: nothing





:e
bar "ops"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.52: 	bar "ops"
//│ ║        	^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `Test & ?a | Toast & ?b`
//│ ║  l.52: 	bar "ops"
//│ ║        	    ^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.25: 	def bar x = case x of
//│ ╙──      	                 ^
//│ res: nothing





def baz x = case x of
  { Test -> x
  | Toast -> x
  }
//│ baz: ('a & (Test | Toast)) -> 'a

:e
baz "oops"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.75: 	baz "oops"
//│ ║        	^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `Test & ?a | Toast & ?b`
//│ ║  l.75: 	baz "oops"
//│ ║        	    ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.68: 	def baz x = case x of
//│ ╙──      	                 ^
//│ res: nothing





