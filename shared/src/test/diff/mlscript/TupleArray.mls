
x = { a = 1 }
//│ x: {a: int}

x with { b = 2 }
//│ res: {a: int, b: int}

def f x = x with { b = 2 }
//│ f: 'a -> ('a\b & {b: int})

def r: {b: string; c: int}\b
//│ r: {c: int}

(1,2,3) with { _4 = "oops" }
//│ res: (int, int, int,) & {_4: string}

(1,2,3) with { _1 = "oops" }
//│ res: {_1: string, _2: int, _3: int}

:e
(res: (int,int,int,))._1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.21: 	(res: (int,int,int,))._1
//│ ║        	 ^^^
//│ ╟── `with` extension of type `{_1: string, _2: int, _3: int}` is not a 3-element tuple
//│ ║  l.17: 	(1,2,3) with { _1 = "oops" }
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(int, int, int,)`
//│ ║  l.21: 	(res: (int,int,int,))._1
//│ ║        	 ^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.21: 	(res: (int,int,int,))._1
//│ ╙──      	      ^^^^^^^^^^^^^^
//│ res: int






def r: int \ _1
//│ r: int

def r: (1,2,3) \ _1
//│ r: {_2: 2, _3: 3}
// (1,2,3).toRecord \ _1

def r: (1,2,3) \ _12345
//│ r: (1, 2, 3,)

def arr: Array[int]
def arr = (1,2)
//│ arr: Array[int]
//│ (int, int,)
//│   <:  arr:
//│ Array[int]

fr = f r
fr : Array[int] & {b: int}
//│ fr: (1, 2, 3,) & {b: int}
//│ res: Array[int] & {b: int}

:e
arr._1
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.64: 	arr._1
//│ ║        	^^^^^^
//│ ╟── type `Array[int]` does not have field '_1'
//│ ║  l.51: 	def arr: Array[int]
//│ ║        	         ^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{_1: ?a}`
//│ ║  l.64: 	arr._1
//│ ╙──      	^^^
//│ res: nothing




rr = arr with { x = 1 }
//│ rr: Array[int] & {x: int}

rr.x
//│ res: int






t = (1, 2, 3) with {x = 1}
// t = (1, 2, 3)
//│ t: (int, int, int,) & {x: int}

t._1
t._2
t.x
//│ res: int
//│ res: int
//│ res: int



// :d
def test: {x: 1} & (1, 2, 3)
//│ test: (1, 2, 3,) & {x: 1}


// def f x = x[1]
// Array['a] -> 'a

// def f x = x.1
// {1: 'a} -> 'a

// f(... : Array[int])
// Array[int] <: {1: 'a}

// { 1 = 3456 }

:e
f(1,2,3) : 1 | 2 | 3
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.120: 	f(1,2,3) : 1 | 2 | 3
//│ ║         	^^^^^^^^
//│ ╟── tuple literal of type `(int, int, int,)` does not match type `(?a,)`
//│ ║  l.120: 	f(1,2,3) : 1 | 2 | 3
//│ ╙──       	 ^^^^^^^
//│ res: 1 | 2 | 3



:e
(arr[0])[1][2]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.132: 	(arr[0])[1][2]
//│ ║         	^^^^^^^^^^^
//│ ╟── type `int` does not match type `Array[?a]`
//│ ║  l.51: 	def arr: Array[int]
//│ ║        	               ^^^
//│ ╟── but it flows into array access with expected type `Array[?b]`
//│ ║  l.132: 	(arr[0])[1][2]
//│ ╙──       	 ^^^^^^
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.132: 	(arr[0])[1][2]
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── possibly-undefined array access of type `undefined` does not match type `Array[?a]`
//│ ║  l.132: 	(arr[0])[1][2]
//│ ╙──       	^^^^^^^^^^^
//│ res: undefined







class A: { x: int }
//│ Defined class A

def myval: A & { x: anything }
//│ myval: A

// def myval: a & { x: string }
// //│ myval: A with {x: string}


def tuuu: (1 | 2, true) & {_1: 2 | 3}
//│ tuuu: (2, true,)
// tuuu: ((1 | 2) & (2 | 3), true,)
// tuuu: (2, true,)

// (S, T, U)
// Array[S | T | U] & { _1: S; _2: T; _3: U }

def f(x: int, y: string) = x
//│ f: (int, string,) -> int

// f(x = 1, y = "asf")

def f x = x
def f(x,) = x
//│ f: 'a -> 'a
//│ f: 'a -> 'a

// (1, 2)
// f((1, 2))

// [1, 2]
// f [1, 2]
// f ([1, 2], 2, 3)


f(1)
f 1
//│ res: int
//│ res: int

f((1,2))
//│ res: (int, int,)


trait T: { x: int }
//│ Defined trait T

def t: T
//│ t: T

t.x
//│ res: int

rcd = { x = 1 }
//│ rcd: {x: int}

T rcd
//│ res: {x: int} & #T

res: { x: int }
//│ res: {x: int}


(1,2, (true, false, ("hello", "world", "bye")))
//│ res: (int, int, (true, false, (string, string, string,),),)

k1 = (6, "hi", false) with {_5=5; _6=true}
k1._1
k1._3
//│ k1: (int, string, false,) & {_5: int, _6: true}
//│ res: int
//│ res: false

(1,2,3) with {_2 = "hello"; _a = true; _4 = 4}
//│ res: {_1: int, _2: string, _3: int, _4: int, _a: true}

(1,2,3) with {_1 = true; _0 = 233}
//│ res: {_0: int, _1: true, _2: int, _3: int}

(1, 2, true) with {_0 = "hello"}
//│ res: (int, int, true,) & {_0: string}

ta1 = (5, 6, true, false, "hahaha")
ta2 = ta1 with {x = 123; _7 = "bye"; _1 = 0}
ta1._1
ta2._2
ta2._3
//│ ta1: (int, int, true, false, string,)
//│ ta2: {_1: int, _2: int, _3: true, _4: false, _5: string, _7: string, x: int}
//│ res: int
//│ res: int
//│ res: true

def rep5: 'a -> Array['a]
def rep5 x = (x,x,x,x,x)
//│ rep5: 'a -> Array['a]
//│ 'a -> ('a, 'a, 'a, 'a, 'a,)
//│   <:  rep5:
//│ 'a -> Array['a]

rep5 1 with {_1 = 10}
a2 = rep5 2 with {_2 = true; x = "haha"}
a2._2
a2.x
//│ res: Array[int] & {_1: int}
//│ a2: Array[int] & {_2: true, x: string}
//│ res: true
//│ res: string

:e
a2._1
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.267: 	a2._1
//│ ║         	^^^^^
//│ ╟── type `Array[?a]` does not have field '_1'
//│ ║  l.250: 	def rep5: 'a -> Array['a]
//│ ║         	                ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{_1: ?b}`
//│ ║  l.267: 	a2._1
//│ ╙──       	^^
//│ res: nothing




(1,2,3,true) with {_a = 1; _b1 = false}
//│ res: (int, int, int, true,) & {_a: int, _b1: false}

ht1 = (1,2,false) with {_1 = 'a'; _2 = 'hello'; _3 = false}
ht1._1
//│ ht1: {_1: string, _2: string, _3: false}
//│ res: string

def hg1 t = (t._1, t._2)
hg1 ht1
hg1 ((5,5,5))
(hg1 ht1)._2
//│ hg1: {_1: 'a, _2: 'b} -> ('a, 'b,)
//│ res: (string, string,)
//│ res: (int, int,)
//│ res: string

def ta1: Array[int] | (int, bool)
def test: (string, 1) & { _1: "hello" }
def test2: (string, 1) & { _1: "hello"; _3: int }
//│ ta1: Array[bool | int]
//│ test: ("hello", 1,)
//│ test2: ("hello", 1,) & {_3: int}

test: { _1: 'a }
//│ res: {_1: "hello"}

// TODO: One could expect ("hello", 1,) here,
//    but we currently don't recover the intersected positional field from the record
//    when constraining refined tuples.
test: ('a, 1)
//│ res: (string, 1,)

// TODO in principe, we could narrow the refinement to ` & { _1: 1 }` here...
def test3: Array[1] & { _1: int }
//│ test3: Array[1] & {_1: int}

def fta1: Array[int | bool] -> int
def tb1: (int, true)
fta1 tb1
r1 = if true then (1,2,3) else (1, 2)
fta1 r1
//│ fta1: Array[bool | int] -> int
//│ tb1: (int, true,)
//│ res: int
//│ r1: Array[int] & {_1: int, _2: int}
//│ res: int


def p1: T | Array[bool] | (int, string) | (true, 3)
def p2: T | (string, bool) | Array[int] | (2, 4)
def pf t = (t[1], t._1)
pf((1,2,3))
//│ p1: Array[bool | int | string] | T
//│ p2: Array[bool | int | string] | T
//│ pf: (Array['a & ~undefined] & {_1: 'b}) -> (undefined | 'a, 'b,)
//│ res: (int | undefined, int,)
