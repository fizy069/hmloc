def toBool = fun x -> true
def b = toBool true
def bb = (fun a -> fun b -> toBool (if b then not a else not a)) true
//│ toBool: anything -> true
//│ b: true
//│ bb: bool -> true

def isInt = fun x -> b
//│ isInt: anything -> true

def selectBoolOrInt = fun x -> if isInt x then 1 else true
def r1 = selectBoolOrInt true
def r2 = selectBoolOrInt 1
def addOneI = fun x -> add x 1
def addOneB = bb
//│ selectBoolOrInt: anything -> (int | true)
//│ r1: int | true
//│ r2: int | true
//│ addOneI: int -> int
//│ addOneB: bool -> true

def addOne = fun x -> 
    if (isInt x) 
    then addOneI x 
    else addOneB x
def r3 = isInt r2
//│ addOne: nothing -> (int | true)
//│ r3: true

:e
def r4 = addOne (selectBoolOrInt 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.31: 	def r4 = addOne (selectBoolOrInt 1)
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.11: 	def selectBoolOrInt = fun x -> if isInt x then 1 else true
//│ ║        	                                                      ^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.31: 	def r4 = addOne (selectBoolOrInt 1)
//│ ║        	                 ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.24: 	    then addOneI x 
//│ ║        	                 ^
//│ ╟── from argument:
//│ ║  l.14: 	def addOneI = fun x -> add x 1
//│ ╙──      	                           ^
//│ r4: int | true






:e
def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp }
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.55: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp }
//│ ║        	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.11: 	def selectBoolOrInt = fun x -> if isInt x then 1 else true
//│ ║        	                                                      ^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.55: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp }
//│ ║        	                                             ^^^
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.55: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp }
//│ ╙──      	                                                      ^^^
//│ r4: int | true





// TODO improve:
//    Note the strange lack of specific provenance flows for `1` and `bool`.
//    This is due to our eagerly collapsing `int & bool` in the previously-inferred type.
//    We should either not collapse them until type simplification or somehow remember the original components
//      so a proper error can later be displayed.
:e
def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp | _ -> 0 }
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.80: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp | _ -> 0 }
//│ ║        	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `bool`
//│ ║  l.11: 	def selectBoolOrInt = fun x -> if isInt x then 1 else true
//│ ║        	                                               ^
//│ ╟── but it flows into reference with expected type `bool`
//│ ║  l.80: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp | _ -> 0 }
//│ ║        	                                             ^^^
//│ ╟── Note: constraint arises from refined scrutinee:
//│ ║  l.80: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp | _ -> 0 }
//│ ║        	                                             ^^^
//│ ╟── from argument:
//│ ║  l.3: 	def bb = (fun a -> fun b -> toBool (if b then not a else not a)) true
//│ ╙──     	                                       ^
//│ r4: int | true




def addOne x = case x of {
  | int -> addOneI x 
  | bool -> addOneB x
  }
//│ addOne: (bool | int) -> (int | true)

def r4 = addOne (selectBoolOrInt 1)
//│ r4: int | true




def addOneS = fun x -> concat x "One"
//│ addOneS: string -> string

addOneI 1
addOneS "Two"
//│ res: int
//│ res: string


// Attempt 1:

def isInt = fun x -> case x of { int -> true | string -> false }
//│ isInt: (int | string) -> bool

isInt 1
isInt "Two"
//│ res: bool
//│ res: bool

def addOne = fun x -> if isInt x then addOneI x else addOneS x
//│ addOne: nothing -> (int | string)

:e
addOne "hello"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.136: 	addOne "hello"
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` is not an instance of type `int`
//│ ║  l.136: 	addOne "hello"
//│ ║         	       ^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.132: 	def addOne = fun x -> if isInt x then addOneI x else addOneS x
//│ ║         	                                              ^
//│ ╟── from argument:
//│ ║  l.14: 	def addOneI = fun x -> add x 1
//│ ╙──      	                           ^
//│ res: int | string






// Attempt 2: use a match instead of isInt

def addOne = fun x -> case x of {
   int -> addOneI x | 
   string -> addOneS x }
//│ addOne: (int | string) -> (int | string)

addOne 1
addOne "Two"
//│ res: int | string
//│ res: int | string

:e
(addOne 1) + 1
concat "Three" (addOne "Two")
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.169: 	(addOne 1) + 1
//│ ║         	^^^^^^^^^^^^
//│ ╟── application of type `string` is not an instance of type `int`
//│ ║  l.113: 	def addOneS = fun x -> concat x "One"
//│ ║         	                       ^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.169: 	(addOne 1) + 1
//│ ╙──       	 ^^^^^^^^
//│ res: int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.170: 	concat "Three" (addOne "Two")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `int` is not an instance of type `string`
//│ ║  l.14: 	def addOneI = fun x -> add x 1
//│ ║        	                       ^^^^^^^
//│ ╟── but it flows into application with expected type `string`
//│ ║  l.170: 	concat "Three" (addOne "Two")
//│ ╙──       	                ^^^^^^^^^^^^
//│ res: string







