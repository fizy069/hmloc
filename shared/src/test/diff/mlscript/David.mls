def toBool = fun x -> true
def b = toBool true
def bb = (fun a -> fun b -> toBool (if b then not a else not a)) true
//│ toBool: anything -> bool
//│ b: bool
//│ bb: bool -> bool

def isInt = fun x -> b
//│ isInt: anything -> bool

def selectBoolOrInt = fun x -> if isInt x then 1 else true
def r1 = selectBoolOrInt true
def r2 = selectBoolOrInt 1
def addOneI = fun x -> add x 1
def addOneB = bb
//│ selectBoolOrInt: anything -> (bool | int)
//│ r1: bool | int
//│ r2: bool | int
//│ addOneI: int -> int
//│ addOneB: bool -> bool

def addOne = fun x -> 
    if (isInt x) 
    then addOneI x 
    else addOneB x
def r3 = isInt r2
//│ addOne: nothing -> (bool | int)
//│ r3: bool

:e
def r4 = addOne (selectBoolOrInt 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.31: 	def r4 = addOne (selectBoolOrInt 1)
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `bool` is not an instance of `int`
//│ ║  l.11: 	def selectBoolOrInt = fun x -> if isInt x then 1 else true
//│ ║        	                                                      ^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.31: 	def r4 = addOne (selectBoolOrInt 1)
//│ ║        	                 ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.24: 	    then addOneI x 
//│ ║        	                 ^
//│ ╟── from argument:
//│ ║  l.14: 	def addOneI = fun x -> add x 1
//│ ╙──      	                           ^
//│ r4: bool | int






:e
def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp }
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.55: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp }
//│ ║        	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `bool` is not an instance of type `int`
//│ ║  l.11: 	def selectBoolOrInt = fun x -> if isInt x then 1 else true
//│ ║        	                                                      ^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.55: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp }
//│ ║        	                                             ^^^
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.55: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp }
//│ ╙──      	                                                      ^^^
//│ r4: bool | int





// TODO improve:
//    Note the strange lack of specific provenance flows for `1` and `bool`.
//    This is due to our eagerly collapsing `int & bool` in the previously-inferred type.
//    We should either not collapse them until type simplification or somehow remember the original components
//      so a proper error can later be displayed.
:e
def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp | _ -> 0 }
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.80: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp | _ -> 0 }
//│ ║        	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `bool`
//│ ║  l.11: 	def selectBoolOrInt = fun x -> if isInt x then 1 else true
//│ ║        	                                               ^
//│ ╟── but it flows into reference with expected type `bool`
//│ ║  l.80: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp | _ -> 0 }
//│ ║        	                                             ^^^
//│ ╟── Note: constraint arises from refined scrutinee:
//│ ║  l.80: 	def r4 = let tmp = selectBoolOrInt 1 in case tmp of { int -> addOne tmp | _ -> 0 }
//│ ║        	                                             ^^^
//│ ╟── from argument:
//│ ║  l.3: 	def bb = (fun a -> fun b -> toBool (if b then not a else not a)) true
//│ ╙──     	                                       ^
//│ r4: bool | int




def addOne x = case x of {
  | int -> addOneI x 
  | bool -> addOneB x
  }
//│ addOne: (bool | int) -> (bool | int)

def r4 = addOne (selectBoolOrInt 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.107: 	def r4 = addOne (selectBoolOrInt 1)
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `bool` is not an instance of `bool`
//│ ║  l.11: 	def selectBoolOrInt = fun x -> if isInt x then 1 else true
//│ ║        	                                                      ^^^^
//│ ╟── but it flows into application with expected type `bool`
//│ ║  l.107: 	def r4 = addOne (selectBoolOrInt 1)
//│ ║         	                 ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.101: 	def addOne x = case x of {
//│ ║         	                    ^
//│ ╟── from argument:
//│ ║  l.3: 	def bb = (fun a -> fun b -> toBool (if b then not a else not a)) true
//│ ╙──     	                                       ^
//│ r4: bool | int




def addOneS = fun x -> concat x "One"
//│ addOneS: string -> string

addOneI 1
addOneS "Two"
//│ res: int
//│ res: string


// Attempt 1:

def isInt = fun x -> case x of { int -> true | string -> false }
//│ isInt: (int | string) -> bool

isInt 1
isInt "Two"
//│ res: bool
//│ res: bool

def addOne = fun x -> if isInt x then addOneI x else addOneS x
//│ addOne: nothing -> (int | string)

:e
addOne "hello"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.151: 	addOne "hello"
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` is not an instance of `int`
//│ ║  l.151: 	addOne "hello"
//│ ║         	       ^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.147: 	def addOne = fun x -> if isInt x then addOneI x else addOneS x
//│ ║         	                                              ^
//│ ╟── from argument:
//│ ║  l.14: 	def addOneI = fun x -> add x 1
//│ ╙──      	                           ^
//│ res: int | string






// Attempt 2: use a match instead of isInt

def addOne = fun x -> case x of {
   int -> addOneI x | 
   string -> addOneS x }
//│ addOne: (int | string) -> (int | string)

addOne 1
addOne "Two"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.178: 	addOne 1
//│ ║         	^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `int`
//│ ║  l.178: 	addOne 1
//│ ║         	       ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.173: 	def addOne = fun x -> case x of {
//│ ║         	                           ^
//│ ╟── from argument:
//│ ║  l.14: 	def addOneI = fun x -> add x 1
//│ ╙──      	                           ^
//│ res: int | string
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.179: 	addOne "Two"
//│ ║         	^^^^^^^^^^^^
//│ ╟── string literal of type `string` is not an instance of `string`
//│ ║  l.179: 	addOne "Two"
//│ ║         	       ^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.173: 	def addOne = fun x -> case x of {
//│ ║         	                           ^
//│ ╟── from argument:
//│ ║  l.128: 	def addOneS = fun x -> concat x "One"
//│ ╙──       	                              ^
//│ res: int | string

:e
(addOne 1) + 1
concat "Three" (addOne "Two")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.208: 	(addOne 1) + 1
//│ ║         	 ^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of `int`
//│ ║  l.208: 	(addOne 1) + 1
//│ ║         	        ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.173: 	def addOne = fun x -> case x of {
//│ ║         	                           ^
//│ ╟── from argument:
//│ ║  l.14: 	def addOneI = fun x -> add x 1
//│ ╙──      	                           ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.208: 	(addOne 1) + 1
//│ ║         	^^^^^^^^^^^^
//│ ╟── application of type `string` is not an instance of `int`
//│ ║  l.128: 	def addOneS = fun x -> concat x "One"
//│ ║         	                       ^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.208: 	(addOne 1) + 1
//│ ╙──       	 ^^^^^^^^
//│ res: int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.209: 	concat "Three" (addOne "Two")
//│ ║         	                ^^^^^^^^^^^^
//│ ╟── string literal of type `string` is not an instance of `string`
//│ ║  l.209: 	concat "Three" (addOne "Two")
//│ ║         	                       ^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.173: 	def addOne = fun x -> case x of {
//│ ║         	                           ^
//│ ╟── from argument:
//│ ║  l.128: 	def addOneS = fun x -> concat x "One"
//│ ╙──       	                              ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.209: 	concat "Three" (addOne "Two")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `int` is not an instance of `string`
//│ ║  l.14: 	def addOneI = fun x -> add x 1
//│ ║        	                       ^^^^^^^
//│ ╟── but it flows into application with expected type `string`
//│ ║  l.209: 	concat "Three" (addOne "Two")
//│ ╙──       	                ^^^^^^^^^^^^
//│ res: string







