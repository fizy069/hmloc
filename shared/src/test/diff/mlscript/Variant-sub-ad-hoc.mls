class None
class Some
//│ Defined class None
//│ Defined class Some

def Some v = Some{} with {v}
def None = None{}
//│ Some: 'a -> (Some & {v: 'a})
//│ None: None

def flatMap = fun f -> fun opt ->
  case opt of { Some -> f opt.v | _ -> opt }
//│ flatMap: ('v -> 'a) -> (Some & {v: 'v} | 'a & ~#Some) -> 'a

f = fun x -> Some x
res = flatMap f (Some 1)
res = flatMap f None
//│ f: 'a -> (Some & {v: 'a})
//│ res: Some & {v: int}
//│ res: None | Some & {v: nothing}

class Lit
class Neg
class Var
class Plus
//│ Defined class Lit
//│ Defined class Neg
//│ Defined class Var
//│ Defined class Plus

:stats
rec def evalOpt = fun x -> case x of {
  | Lit ->
      Some x.v
  | Neg ->
      flatMap (fun s -> Some (0 - s)) (evalOpt x.sub)
  | Var ->
      None with {err = concat "free var: " x.nme}
  | Plus ->
      flatMap (fun l -> flatMap (fun r ->
        Some (l + r)
      ) (evalOpt x.rhs)) (evalOpt x.lhs)
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.36: 	      flatMap (fun s -> Some (0 - s)) (evalOpt x.sub)
//│ ║        	                              ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.36: 	      flatMap (fun s -> Some (0 - s)) (evalOpt x.sub)
//│ ╙──      	                              ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.36: 	      flatMap (fun s -> Some (0 - s)) (evalOpt x.sub)
//│ ║        	                              ^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.36: 	      flatMap (fun s -> Some (0 - s)) (evalOpt x.sub)
//│ ╙──      	                                  ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.38: 	      None with {err = concat "free var: " x.nme}
//│ ║        	                       ^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(string,)` is not an instance of `string`
//│ ║  l.38: 	      None with {err = concat "free var: " x.nme}
//│ ╙──      	                              ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.38: 	      None with {err = concat "free var: " x.nme}
//│ ║        	                       ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?nme,)` is not an instance of `string`
//│ ║  l.38: 	      None with {err = concat "free var: " x.nme}
//│ ╙──      	                                           ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.41: 	        Some (l + r)
//│ ║        	              ^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.41: 	        Some (l + r)
//│ ╙──      	              ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.41: 	        Some (l + r)
//│ ║        	              ^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.41: 	        Some (l + r)
//│ ╙──      	                  ^
//│ evalOpt: 'a -> (None & {err: string} | Some & {v: int | 'b})
//│   where
//│     'a <: Lit & {v: 'b} | Neg & {sub: 'a} | Plus & {lhs: 'a, rhs: 'a} | Var & {nme: anything}
//│ constrain calls  : 759
//│ annoying  calls  : 156
//│ subtyping calls  : 752

:stats
evalOpt (Plus{} with {lhs = Lit{} with {v=2}; rhs = Lit{} with {v=2}})
//│ res: None & {err: string} | Some & {v: int}
//│ constrain calls  : 238
//│ annoying  calls  : 34
//│ subtyping calls  : 397

