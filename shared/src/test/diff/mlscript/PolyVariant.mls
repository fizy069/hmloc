// Examples from Set-Theoretic Types for Polymorphic Variants

//************** PRELIMINARIES *************

class Nil
class Cons[A]: { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons[+A]
//│ Defined type alias List[+A]

def Nil = Nil {}
//│ Nil: Nil

def Cons head tail = Cons { head; tail }
//│ Cons: ('head & 'A) -> (List['A] & 'tail) -> (Cons['A] with {head: 'head, tail: 'tail})

class A
class B
class C
class D
//│ Defined class A
//│ Defined class B
//│ Defined class C
//│ Defined class D

//************** EXAMPLE 1: LOSS OF POLYMORPHISM *************

def id x = x
//│ id: 'a -> 'a


id A{}
//│ res: A

def f x = case x of { A -> true }
//│ f: A -> true

f (id A{})
//│ res: true

// # [`A; `C]
// - : [> `A | `C] list
// # [id `A; `C]
// - : [> `A | `C] list

Cons (A{}) (Cons (C{}) Nil)
//│ res: Cons[A | C] with {head: A, tail: Cons[C] with {tail: Nil}}

Cons (id A{}) (Cons (C{}) Nil)
//│ res: Cons[A | C] with {head: A, tail: Cons[C] with {tail: Nil}}

// val id2 : ([< `A | `B ] as 'a) -> 'a = <fun>

def id2 x = case x of { A -> x | B -> x }
//│ id2: ('a & (A | B)) -> 'a

// id2 `A
// - : [< `A | `B > `A ] = `A

id2 (A{})
//│ res: A

// # [(id2 `A); `C];;
// Error: This expression has type [> `C ] but an expression was expected of
// type [< `A | `B > `A ]. The second variant type does not allow tag(s) `C

Cons (id2 (A{})) (Cons (C{}) Nil)
//│ res: Cons[A | C] with {head: A, tail: Cons[C] with {tail: Nil}}

//************** EXAMPLE 2: ROUGHLY-TYPED PATTERN MATCHING *************

// val f : [ `A | `B ] -> [ `A | `B ] = <fun>

def f x = let xx = id2 x in case xx of { A -> B{} | _ -> xx }
//│ f: (A | B) -> B

// val g : ([< `A | `B > `A ] as 'a) -> 'a = <fun>

// Actually ~A !!
def g x = case x of { A -> id2 x | _ -> x }
//│ g: ('a & (A | ~#A)) -> 'a

g (C{})
//│ res: C

// val map : ('a -> 'a) -> 'a list -> 'a list = <fun>

rec def map f l = case l of {
  | Nil -> l
  | Cons -> Cons (f l.head) (map f l.tail)
  }
//│ map: ('head -> ('head0 & 'A)) -> 'a -> ('b | 'c)
//│   where
//│     'a <: (Cons[?] with {head: 'head, tail: 'a}) | Nil & 'b & 'tail
//│     'tail :> 'c
//│           <: List['A]
//│     'c :> Cons['A] with {head: 'head0, tail: 'tail}

map (fun x -> "lol") (Cons 2 (Cons 3 Nil))
//│ res: 'tail
//│   where
//│     'tail :> (Cons[string] with {tail: 'tail}) | Nil

//************** EXAMPLE 3: ROUGH APPROXIMATIONS *************

// let f x = match x with
//  | (`A, _) -> 1 | (`B, _) -> 2
//  | (_, `A) -> 3 | (_, `B) -> 4
// Warning 8 [partial-match]: this pattern-matching is not exhaustive.
// Here is an example of a case that is not matched:
// (`AnyOtherTag, `AnyOtherTag)
// val f : [> `A | `B ] * [> `A | `B ] -> int = <fun>

// Inferred type is not good enough
def f = fun x -> case x._1 of {
  | A -> 1
  | B -> 2
  | _ -> case x._2 of {
    | A -> 3
    | B -> 4
    }
  }
//│ f: {_1: anything, _2: A | B} -> int

:e
f ({ _1 = A{}; _2 = C{} })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.127: 	f ({ _1 = A{}; _2 = C{} })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `C` does not match type `A | B`
//│ ║  l.127: 	f ({ _1 = A{}; _2 = C{} })
//│ ║         	                    ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.119: 	  | _ -> case x._2 of {
//│ ║         	              ^^^^
//│ ╟── Note: class C is defined at:
//│ ║  l.20: 	class C
//│ ╙──      	      ^
//│ res: int





// x actually has equivalent type {_1: anything; _2: anything}

def t1: {_1: A | B; _2: anything} | {_1: anything; _2: A | B}
//│ t1: {_1: anything, _2: anything}

:e
def f = fun (x: {_1: A | B; _2: anything} | {_1: anything; _2: A | B}) -> case x._1 of {
  | A -> 1
  | B -> 2
  | _ -> case x._2 of {
    | A -> 3
    | B -> 4
    }
  }
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.155: 	  | _ -> case x._2 of {
//│ ║         	         ^^^^^^^^^^^^^^
//│ ║  l.156: 	    | A -> 3
//│ ║         	^^^^^^^^^^^^
//│ ║  l.157: 	    | B -> 4
//│ ║         	^^^^^^^^^^^^
//│ ║  l.158: 	    }
//│ ║         	^^^^^
//│ ╟── type `anything` does not match type `A | B`
//│ ║  l.152: 	def f = fun (x: {_1: A | B; _2: anything} | {_1: anything; _2: A | B}) -> case x._1 of {
//│ ║         	                                ^^^^^^^^
//│ ╟── but it flows into field selection with expected type `A | B`
//│ ║  l.155: 	  | _ -> case x._2 of {
//│ ╙──       	              ^^^^
//│ f: {_1: anything, _2: anything} -> int







// not useful
class Tuple[a, b]: { _1: a; _2: b }
//│ Defined class Tuple[+a, +b]

def t2: Tuple[A | B, anything] | Tuple[anything, A | B] 
//│ t2: Tuple[?, ?]
def t3: Tuple[anything, anything]
//│ t3: Tuple[?, ?]

t3 = t2
t2 = t3
//│ Tuple[?, ?]
//│   <:  t3:
//│ Tuple[?, ?]
//│ Tuple[?, ?]
//│   <:  t2:
//│ Tuple[?, ?]

class L: { _1: A | B; _2: anything }
class R: { _1: anything; _2: A | B }
//│ Defined class L
//│ Defined class R

:e
def f = fun (x: L | R) -> case x._1 of {
  | A -> 1
  | B -> 2
  | _ -> case x._2 of {
    | A -> 3
    | B -> 4
    }
  }
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.210: 	  | _ -> case x._2 of {
//│ ║         	         ^^^^^^^^^^^^^^
//│ ║  l.211: 	    | A -> 3
//│ ║         	^^^^^^^^^^^^
//│ ║  l.212: 	    | B -> 4
//│ ║         	^^^^^^^^^^^^
//│ ║  l.213: 	    }
//│ ║         	^^^^^
//│ ╟── type `anything` does not match type `A | B`
//│ ║  l.207: 	def f = fun (x: L | R) -> case x._1 of {
//│ ║         	                ^
//│ ╟── but it flows into reference with expected type `A | B`
//│ ║  l.210: 	  | _ -> case x._2 of {
//│ ╙──       	              ^
//│ f: (L | R) -> int






f (L { _1 = A{}; _2 = C{} })
//│ res: int
