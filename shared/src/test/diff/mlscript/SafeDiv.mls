
:e
def safeDiv x (y: ~0) = div x y
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.3: 	def safeDiv x (y: ~0) = div x y
//│ ║       	                        ^^^^^^^
//│ ╟── type `~0` is not an instance of type `int`
//│ ║  l.3: 	def safeDiv x (y: ~0) = div x y
//│ ║       	                  ^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.3: 	def safeDiv x (y: ~0) = div x y
//│ ╙──     	                              ^
//│ safeDiv: int -> ~0 -> int




def safeDiv x (y: int & ~0) = div x y
//│ safeDiv: int -> (int & ~0) -> int

:e
safeDiv 1 0
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.22: 	safeDiv 1 0
//│ ║        	^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `~0`
//│ ║  l.22: 	safeDiv 1 0
//│ ║        	          ^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.18: 	def safeDiv x (y: int & ~0) = div x y
//│ ║        	                  ^^^^^^^^
//│ ╟── from type negation:
//│ ║  l.18: 	def safeDiv x (y: int & ~0) = div x y
//│ ╙──      	                        ^^
//│ res: int





fun x -> safeDiv 1 x
//│ res: (int & ~0) -> int


class None: {}
class Some[A]: { value: A }
type Option[A] = Some[A] | None
//│ Defined class None
//│ Defined class Some[+A]
//│ Defined type alias Option[+A]


fun x -> case x of { int -> safeDiv 1 x | _ -> None{} }
//│ res: (int & ~0 | ~int) -> (int | None)

:e // we no longer refine x's type here, as that was rather unexpected
fun (x: int) -> safeDiv 1 x
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.57: 	fun (x: int) -> safeDiv 1 x
//│ ║        	                ^^^^^^^^^^^
//│ ╟── type `int` does not match type `~0`
//│ ║  l.57: 	fun (x: int) -> safeDiv 1 x
//│ ║        	        ^^^
//│ ╟── but it flows into reference with expected type `~0`
//│ ║  l.57: 	fun (x: int) -> safeDiv 1 x
//│ ║        	                          ^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.18: 	def safeDiv x (y: int & ~0) = div x y
//│ ║        	                  ^^^^^^^^
//│ ╟── from type negation:
//│ ║  l.18: 	def safeDiv x (y: int & ~0) = div x y
//│ ╙──      	                        ^^
//│ res: int -> int






fun (x: int & ~0) -> safeDiv 1 x
//│ res: (int & ~0) -> int

def tryDiv: int -> int -> Option[int]
//│ tryDiv: int -> int -> Option[int]

def tryDiv x y = case y of { 0 -> None{} | _ -> Some { value = safeDiv x y } }
//│ int -> (0 | int & ~0) -> (None | Some[int])
//│   <:  tryDiv:
//│ int -> int -> Option[int]
// ^ Note: `0 | int & ~0` could be further simplified

tryDiv 1 1
tryDiv 1 0
//│ res: Option[int]
//│ res: Option[int]


