class Left[A]: { value: A }
//│ Defined class Left[+A]

Left{value=1}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.4: 	Left{value=1}
//│ ║       	^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.4: 	Left{value=1}
//│ ╙──     	    ^^^^^^^^^
//│ res: Left[nothing]

def Left value = Left{ value }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.13: 	def Left value = Left{ value }
//│ ║        	                 ^^^^^^^^^^^^^
//│ ╟── argument of type `({value: ?a},)` does not have field 'value'
//│ ║  l.13: 	def Left value = Left{ value }
//│ ╙──      	                     ^^^^^^^^^
//│ Left: anything -> Left[nothing]

class Right[A]: { value: A }
def Right value = Right{ value }
//│ Defined class Right[+A]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.23: 	def Right value = Right{ value }
//│ ║        	                  ^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: ?a},)` does not have field 'value'
//│ ║  l.23: 	def Right value = Right{ value }
//│ ╙──      	                       ^^^^^^^^^
//│ Right: anything -> Right[nothing]

def testVal = if true then Left 1 else Right 2
//│ testVal: Left[nothing] | Right[nothing]

testVal.value
//│ res: nothing

def res = case testVal of
  { Left -> testVal.value
  | Right -> 1
  }
//│ res: int

res: 1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.45: 	res: 1
//│ ║        	^^^
//│ ╟── integer literal of type `int` does not match type `1`
//│ ║  l.41: 	  | Right -> 1
//│ ║        	             ^
//│ ╟── but it flows into reference with expected type `1`
//│ ║  l.45: 	res: 1
//│ ║        	^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.45: 	res: 1
//│ ╙──      	     ^
//│ res: 1

case res of { 1 -> "ok" }
//│ res: string

def res = case testVal of
  { Left -> testVal
  | Right -> 1
  }
//│ res: int | Left[nothing]

