

def foo: ('a -> (~'a -> 'b) -> 'b) -> 'b
//│ foo: (nothing -> (anything -> 'b) -> 'b) -> 'b

def foo: ('a -> (~'a -> 'a) -> 'a) -> 'a -> 'a
//│ foo: ('a -> (~'a -> 'a) -> 'a) -> 'a -> 'a

:ns
foo
//│ res: ('a -> (~'a -> 'a) -> 'a) -> 'a -> 'a

:ns
r = foo (fun a -> fun f -> f a)
//│ r: 'b
//│   where
//│     'b :> 'a -> 'a
//│     'a <: 'c & 'd
//│     'd <: ~'a
//│     'c <: 'a

r
//│ res: 'a -> 'a

:e
r: anything -> nothing
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.26: 	r: anything -> nothing
//│ ║        	^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.26: 	r: anything -> nothing
//│ ║        	   ^^^^^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.6: 	def foo: ('a -> (~'a -> 'a) -> 'a) -> 'a -> 'a
//│ ║       	                                      ^^
//│ ╟── from type negation:
//│ ║  l.6: 	def foo: ('a -> (~'a -> 'a) -> 'a) -> 'a -> 'a
//│ ╙──     	                 ^^^
//│ res: anything -> nothing







def foo: ('a -> (~'a -> anything) -> anything) -> MutArray['a]
//│ foo: ('a -> (~'a -> anything) -> anything) -> MutArray['a]

:ns
r = foo (fun a -> fun f -> f a)
//│ r: 'b
//│   where
//│     'b :> MutArray['a]
//│     'a <: 'c
//│     'c <: ~'a

:e
r[0] <- "test"
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.59: 	r[0] <- "test"
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `~string`
//│ ║  l.59: 	r[0] <- "test"
//│ ║        	        ^^^^^^
//│ ╟── but it flows into assigned array element with expected type `~string`
//│ ║  l.59: 	r[0] <- "test"
//│ ║        	^^^^
//│ ╟── Note: constraint arises from assigned array element:
//│ ║  l.59: 	r[0] <- "test"
//│ ║        	^^^^
//│ ╟── from type negation:
//│ ║  l.47: 	def foo: ('a -> (~'a -> anything) -> anything) -> MutArray['a]
//│ ╙──      	                 ^^^




:e
r[0] + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.80: 	r[0] + 1
//│ ║        	^^^^^^
//│ ╟── possibly-undefined array access of type `undefined` is not an instance of type `int`
//│ ║  l.80: 	r[0] + 1
//│ ╙──      	^^^^
//│ res: int






:ns
def bar: (('a & ~'a) -> 'b) -> 'b
//│ bar: (nothing -> 'b) -> 'b

def bar: (('a & int & ~'a) -> 'b) -> 'b
//│ bar: ((int & 'a & ~'a) -> 'b) -> 'b

r = bar (fun x -> (x, x + 1, not x, x x))
//│ r: (int & 'a & ~'a, int, bool, nothing,)

:ns
r
//│ res: 'b
//│   where
//│     'b :> ('c, 'd, 'e, 'f,)
//│     'e :> bool
//│     'd :> int
//│     'c :> 'a & int & ~'a
//│        <: 'c -> 'f & bool & int
//│     'a <: (int | ~(int & ~'a)) & (bool | ~(int & ~'a)) & ('c -> 'f | ~(int & ~'a))

r._1 : nothing
//│ res: nothing

def impossible x = case x of {}
//│ impossible: nothing -> nothing

bar impossible
//│ res: nothing


