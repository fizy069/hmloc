
class Integer: { value: int; addOne: Integer -> Integer }
//│ Defined class Integer

class Num: Integer & { addOne: Num -> Num }
//│ Defined class Num

class Str: { value: string; addOne: Str -> Str }
//│ Defined class Str

addOne1 x = case x of {
  | Integer -> x.addOne x
  | Num -> x.addOne x
  }
//│ addOne1: ((Integer\value with {addOne: 'a -> 'b}) & 'a | (Num\value with {addOne: 'c -> 'b}) & 'c) -> 'b


rec def loopy() =
  Integer { value = 1; addOne = fun x -> loopy() }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.19: 	  Integer { value = 1; addOne = fun x -> loopy() }
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: ?a -> ?b, value: int},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.19: 	  Integer { value = 1; addOne = fun x -> loopy() }
//│ ╙──      	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ loopy: () -> (Integer & {addOne: nothing, value: nothing})

addOne1 (loopy())
//│ res: nothing

res : Integer
//│ res: Integer


// * Note: In the type of addOne1, `Integer\value` means we don't use the value field here
// *  so it could be anything; example:

funny = loopy() with { value = "oops!" }
//│ funny: Integer with {addOne: nothing, value: string}

addOne1 funny
//│ res: nothing


:re
addOne1 (Integer { value = 1; addOne = fun x -> (error : Integer) } with { value = "oops!" })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.46: 	addOne1 (Integer { value = 1; addOne = fun x -> (error : Integer) } with { value = "oops!" })
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: ?a -> Integer, value: int},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.46: 	addOne1 (Integer { value = 1; addOne = fun x -> (error : Integer) } with { value = "oops!" })
//│ ╙──      	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: nothing

:e
addOne1 ((Integer { value = 1; addOne = id }) with { value = "oops!" })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.56: 	addOne1 ((Integer { value = 1; addOne = id }) with { value = "oops!" })
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: ?a -> ?a, value: int},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.56: 	addOne1 ((Integer { value = 1; addOne = id }) with { value = "oops!" })
//│ ╙──      	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: nothing





addOne1 (Integer { value = 1; addOne = id })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.69: 	addOne1 (Integer { value = 1; addOne = id })
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: ?a -> ?a, value: int},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.69: 	addOne1 (Integer { value = 1; addOne = id })
//│ ╙──      	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: nothing


// * Now for properly closing the loop with a constructor for Integer:

rec def mkInteger value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.81: 	rec def mkInteger value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ║        	                                                                        ^^^^^^^^^
//│ ╟── argument of type `(?value,)` is not an instance of `int`
//│ ║  l.81: 	rec def mkInteger value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ╙──      	                                                                        ^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.81: 	rec def mkInteger value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ║        	                                                                        ^^^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.81: 	rec def mkInteger value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ╙──      	                                                                                  ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.81: 	rec def mkInteger value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ║        	                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: ?a -> ?b, value: ?c},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.81: 	rec def mkInteger value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ╙──      	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ mkInteger: anything -> (Integer & {addOne: nothing, value: nothing})

n = mkInteger 42
//│ n: Integer & {addOne: nothing, value: nothing}

n : Integer
//│ res: Integer

m = addOne1 n
//│ m: nothing

m : Integer
//│ res: Integer


// * The type of mkInteger above is actually too precise for out taste. We can explicitly restrict it:

def mkInteger2: int -> Integer
def mkInteger2 = mkInteger
//│ mkInteger2: int -> Integer
//│ anything -> (Integer & {addOne: nothing, value: nothing})
//│   <:  mkInteger2:
//│ int -> Integer

addOne1 (mkInteger2 42)
//│ res: Integer

:e
def mkInteger_oops: (int & 'a) -> (Integer & { value: 'a })
rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ mkInteger_oops: (int & 'a) -> (Integer\addOne with {value: 'a})
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.129: 	rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ ║         	                                                                                  ^^^^^^^^^
//│ ╟── argument of type `(?value,)` is not an instance of `int`
//│ ║  l.129: 	rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ ╙──       	                                                                                  ^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.129: 	rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ ║         	                                                                                  ^^^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.129: 	rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ ╙──       	                                                                                            ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.129: 	rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ ║         	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: ?a -> ?b, value: ?c},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.129: 	rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ ╙──       	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ anything -> (Integer & {addOne: nothing, value: nothing})
//│   <:  mkInteger_oops:
//│ (int & 'a) -> (Integer\addOne with {value: 'a})





// * We may still want to retain the precise typing of the `value` part:

def mkIntegerPrecise value = Integer { value; addOne = addOne1 }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.159: 	def mkIntegerPrecise value = Integer { value; addOne = addOne1 }
//│ ║         	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: ?a -> ?b, value: ?c},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.159: 	def mkIntegerPrecise value = Integer { value; addOne = addOne1 }
//│ ╙──       	                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ mkIntegerPrecise: anything -> (Integer & {addOne: nothing, value: nothing})

def mkIntegerPrecise value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.168: 	def mkIntegerPrecise value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ║         	                                                                           ^^^^^^^^^
//│ ╟── argument of type `(?value,)` is not an instance of `int`
//│ ║  l.168: 	def mkIntegerPrecise value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ╙──       	                                                                           ^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.168: 	def mkIntegerPrecise value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ║         	                                                                           ^^^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.168: 	def mkIntegerPrecise value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ╙──       	                                                                                     ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.168: 	def mkIntegerPrecise value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ║         	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: ?a -> ?b, value: ?c},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.168: 	def mkIntegerPrecise value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ╙──       	                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ mkIntegerPrecise: anything -> (Integer & {addOne: nothing, value: nothing})

def mkIntegerPrecise value = Integer { value; addOne = fun (n: Integer) -> mkInteger2 (n.value + 1) }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.189: 	def mkIntegerPrecise value = Integer { value; addOne = fun (n: Integer) -> mkInteger2 (n.value + 1) }
//│ ║         	                                                                                       ^^^^^^^^^
//│ ╟── argument of type `(?value,)` is not an instance of `int`
//│ ║  l.189: 	def mkIntegerPrecise value = Integer { value; addOne = fun (n: Integer) -> mkInteger2 (n.value + 1) }
//│ ╙──       	                                                                                       ^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.189: 	def mkIntegerPrecise value = Integer { value; addOne = fun (n: Integer) -> mkInteger2 (n.value + 1) }
//│ ║         	                                                                                       ^^^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.189: 	def mkIntegerPrecise value = Integer { value; addOne = fun (n: Integer) -> mkInteger2 (n.value + 1) }
//│ ╙──       	                                                                                                 ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.189: 	def mkIntegerPrecise value = Integer { value; addOne = fun (n: Integer) -> mkInteger2 (n.value + 1) }
//│ ║         	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: Integer -> ?a, value: ?b},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.189: 	def mkIntegerPrecise value = Integer { value; addOne = fun (n: Integer) -> mkInteger2 (n.value + 1) }
//│ ╙──       	                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ mkIntegerPrecise: anything -> (Integer & {addOne: nothing, value: nothing})

n = mkIntegerPrecise 42
//│ n: Integer & {addOne: nothing, value: nothing}

addOne1 n
//│ res: nothing

def mkIntegerPrecise2: (int & 'a) -> (Integer & { value: 'a })
def mkIntegerPrecise2 = mkIntegerPrecise
//│ mkIntegerPrecise2: (int & 'a) -> (Integer\addOne with {value: 'a})
//│ anything -> (Integer & {addOne: nothing, value: nothing})
//│   <:  mkIntegerPrecise2:
//│ (int & 'a) -> (Integer\addOne with {value: 'a})

n = mkIntegerPrecise2 42
//│ n: Integer

addOne1 n
//│ res: Integer


// * Note that due to recursive function approximation,
// *  the type of `mkIntegerPrecise` is not an instance of the original `mkInteger` type:
:e
def mkIntegerPrecise3: (int & 'a) -> (Integer & { value: 'a })
def mkIntegerPrecise3 = mkInteger
//│ mkIntegerPrecise3: (int & 'a) -> (Integer\addOne with {value: 'a})
//│ anything -> (Integer & {addOne: nothing, value: nothing})
//│   <:  mkIntegerPrecise3:
//│ (int & 'a) -> (Integer\addOne with {value: 'a})





:e
addOne1 (Str { value = ""; addOne = error })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.245: 	addOne1 (Str { value = ""; addOne = error })
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: nothing, value: string},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.245: 	addOne1 (Str { value = ""; addOne = error })
//│ ╙──       	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.245: 	addOne1 (Str { value = ""; addOne = error })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Str & {addOne: ?addOne, value: ?value}` does not match type `Integer & ?a | Num & ?b`
//│ ║  l.245: 	addOne1 (Str { value = ""; addOne = error })
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `Integer & ?c | Num & ?d`
//│ ║  l.245: 	addOne1 (Str { value = ""; addOne = error })
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.11: 	addOne1 x = case x of {
//│ ╙──      	                 ^
//│ res: nothing





addOne2 x = case x of {
  | Integer -> x.addOne x
  | Num -> x.addOne x
  | Str -> x.addOne x
  }
//│ addOne2: ((Integer\value with {addOne: 'a -> 'b}) & 'a | (Num\value with {addOne: 'c -> 'b}) & 'c | (Str\value with {addOne: 'd -> 'b}) & 'd) -> 'b

addOne2 (mkIntegerPrecise 42)
//│ res: nothing

:re
addOne2 (Str { value = ""; addOne = error })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.281: 	addOne2 (Str { value = ""; addOne = error })
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: nothing, value: string},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.281: 	addOne2 (Str { value = ""; addOne = error })
//│ ╙──       	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: nothing

def mkStr: string -> Str
rec def mkStr value = Str { value; addOne = fun s -> mkStr (concat s.value "1") }
//│ mkStr: string -> Str
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.291: 	rec def mkStr value = Str { value; addOne = fun s -> mkStr (concat s.value "1") }
//│ ║         	                                                            ^^^^^^^^^^^^^^
//│ ╟── argument of type `(?value,)` is not an instance of `string`
//│ ║  l.291: 	rec def mkStr value = Str { value; addOne = fun s -> mkStr (concat s.value "1") }
//│ ╙──       	                                                                   ^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.291: 	rec def mkStr value = Str { value; addOne = fun s -> mkStr (concat s.value "1") }
//│ ║         	                                                            ^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(string,)` is not an instance of `string`
//│ ║  l.291: 	rec def mkStr value = Str { value; addOne = fun s -> mkStr (concat s.value "1") }
//│ ╙──       	                                                                           ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.291: 	rec def mkStr value = Str { value; addOne = fun s -> mkStr (concat s.value "1") }
//│ ║         	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({addOne: ?a -> ?b, value: ?c},)` is not a record (expected a record with fields: value, addOne)
//│ ║  l.291: 	rec def mkStr value = Str { value; addOne = fun s -> mkStr (concat s.value "1") }
//│ ╙──       	                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ anything -> (Str & {addOne: nothing, value: nothing})
//│   <:  mkStr:
//│ string -> Str

addOne2 (mkStr "hello")
//│ res: Str

union = if true then mkIntegerPrecise 42 else mkStr "hello"
//│ union: Integer & {addOne: nothing, value: nothing} | Str

union2 = addOne2 union
//│ union2: Str

addOne2 union2
//│ res: Str

