
class Integer: { value: int; addOne: Integer -> Integer }
//│ Defined class Integer

class Num: Integer & { addOne: Num -> Num }
//│ Defined class Num

class Str: { value: string; addOne: Str -> Str }
//│ Defined class Str

addOne1 x = case x of {
  | Integer -> x.addOne x
  | Num -> x.addOne x
  }
//│ addOne1: ((Integer\value with {addOne: 'a -> 'b}) & 'a | (Num\value with {addOne: 'c -> 'b}) & 'c) -> 'b


rec def loopy() =
  Integer { value = 1; addOne = fun x -> loopy() }
//│ loopy: () -> 'a
//│   where
//│     'a :> Integer with {addOne: anything -> 'a}

addOne1 (loopy())
//│ res: 'a
//│   where
//│     'a :> Integer with {addOne: anything -> 'a}

res : Integer
//│ res: Integer


// * Note: In the type of addOne1, `Integer\value` means we don't use the value field here
// *  so it could be anything; example:

funny = loopy() with { value = "oops!" }
//│ funny: 'a\value & {value: string}
//│   where
//│     'a :> Integer with {addOne: anything -> 'a}

addOne1 funny
//│ res: 'a
//│   where
//│     'a :> Integer with {addOne: anything -> 'a}


:re
addOne1 (Integer { value = 1; addOne = fun x -> (error : Integer) } with { value = "oops!" })
//│ res: Integer

:e
addOne1 ((Integer { value = 1; addOne = id }) with { value = "oops!" })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.52: 	addOne1 ((Integer { value = 1; addOne = id }) with { value = "oops!" })
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` is not an instance of type `int`
//│ ║  l.52: 	addOne1 ((Integer { value = 1; addOne = id }) with { value = "oops!" })
//│ ║        	                                                             ^^^^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.52: 	addOne1 ((Integer { value = 1; addOne = id }) with { value = "oops!" })
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.2: 	class Integer: { value: int; addOne: Integer -> Integer }
//│ ║       	                                                ^^^^^^^
//│ ╟── from type reference:
//│ ║  l.2: 	class Integer: { value: int; addOne: Integer -> Integer }
//│ ╙──     	                        ^^^
//│ res: (Integer with {addOne: 'addOne, value: string}) | Integer
//│   where
//│     'addOne :> 'a -> 'a
//│     'a :> (Integer with {addOne: 'addOne, value: string}) | Integer
//│        <: Integer





addOne1 (Integer { value = 1; addOne = id })
//│ res: (Integer with {addOne: 'addOne}) | Integer
//│   where
//│     'addOne :> 'a -> 'a
//│     'a :> (Integer with {addOne: 'addOne}) | Integer
//│        <: Integer


// * Now for properly closing the loop with a constructor for Integer:

rec def mkInteger value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ mkInteger: int -> 'a
//│   where
//│     'a :> Integer with {addOne: {value: int} -> 'a}

n = mkInteger 42
//│ n: 'a
//│   where
//│     'a :> Integer with {addOne: {value: int} -> 'a}

n : Integer
//│ res: Integer

m = addOne1 n
//│ m: 'a
//│   where
//│     'a :> Integer with {addOne: {value: int} -> 'a}

m : Integer
//│ res: Integer


// * The type of mkInteger above is actually too precise for out taste. We can explicitly restrict it:

def mkInteger2: int -> Integer
def mkInteger2 = mkInteger
//│ mkInteger2: int -> Integer
//│ int -> 'a
//│   where
//│     'a :> Integer with {addOne: {value: int} -> 'a}
//│   <:  mkInteger2:
//│ int -> Integer

addOne1 (mkInteger2 42)
//│ res: Integer

:e
def mkInteger_oops: (int & 'a) -> (Integer & { value: 'a })
rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ mkInteger_oops: (int & 'a) -> (Integer\addOne with {value: 'a})
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.126: 	rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `'a`
//│ ║  l.126: 	rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ ║         	                                                                                  ^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `'a`
//│ ║  l.126: 	rec def mkInteger_oops value = Integer { value; addOne = fun n -> mkInteger_oops (n.value + 1) }
//│ ║         	                                                                                 ^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.125: 	def mkInteger_oops: (int & 'a) -> (Integer & { value: 'a })
//│ ║         	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type variable:
//│ ║  l.125: 	def mkInteger_oops: (int & 'a) -> (Integer & { value: 'a })
//│ ╙──       	                                                      ^^
//│ int -> 'a
//│   where
//│     'a :> Integer with {addOne: {value: int} -> 'a}
//│   <:  mkInteger_oops:
//│ (int & 'a) -> (Integer\addOne with {value: 'a})





// * We may still want to retain the precise typing of the `value` part:

def mkIntegerPrecise value = Integer { value; addOne = addOne1 }
//│ mkIntegerPrecise: (int & 'value) -> (Integer with {addOne: ((Integer\value with {addOne: (Integer | 'a) -> Integer}) & 'a | (Num\value with {addOne: 'b -> Integer}) & 'b) -> Integer, value: 'value})

def mkIntegerPrecise value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ mkIntegerPrecise: (int & 'value) -> (Integer with {addOne: {value: int} -> 'a, value: 'value})
//│   where
//│     'a :> Integer with {addOne: {value: int} -> 'a}

def mkIntegerPrecise value = Integer { value; addOne = fun (n: Integer) -> mkInteger2 (n.value + 1) }
//│ mkIntegerPrecise: (int & 'value) -> (Integer with {value: 'value})

n = mkIntegerPrecise 42
//│ n: Integer

addOne1 n
//│ res: Integer

def mkIntegerPrecise2: (int & 'a) -> (Integer & { value: 'a })
def mkIntegerPrecise2 = mkIntegerPrecise
//│ mkIntegerPrecise2: (int & 'a) -> (Integer\addOne with {value: 'a})
//│ (int & 'value) -> (Integer with {value: 'value})
//│   <:  mkIntegerPrecise2:
//│ (int & 'a) -> (Integer\addOne with {value: 'a})

n = mkIntegerPrecise2 42
//│ n: Integer

addOne1 n
//│ res: Integer


// * Note that due to recursive function approximation,
// *  the type of `mkIntegerPrecise` is not an instance of the original `mkInteger` type:
:e
def mkIntegerPrecise3: (int & 'a) -> (Integer & { value: 'a })
def mkIntegerPrecise3 = mkInteger
//│ mkIntegerPrecise3: (int & 'a) -> (Integer\addOne with {value: 'a})
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.190: 	def mkIntegerPrecise3 = mkInteger
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `'a`
//│ ║  l.88: 	rec def mkInteger value = Integer { value; addOne = fun n -> mkInteger (n.value + 1) }
//│ ║        	                                                                        ^^^^^^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.189: 	def mkIntegerPrecise3: (int & 'a) -> (Integer & { value: 'a })
//│ ║         	                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type variable:
//│ ║  l.189: 	def mkIntegerPrecise3: (int & 'a) -> (Integer & { value: 'a })
//│ ╙──       	                                                         ^^
//│ int -> 'a
//│   where
//│     'a :> Integer with {addOne: {value: int} -> 'a}
//│   <:  mkIntegerPrecise3:
//│ (int & 'a) -> (Integer\addOne with {value: 'a})





:e
addOne1 (Str { value = ""; addOne = error })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.215: 	addOne1 (Str { value = ""; addOne = error })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Str & {addOne: ?addOne}` does not match type `Integer & ?a | Num & ?b`
//│ ║  l.215: 	addOne1 (Str { value = ""; addOne = error })
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `Integer & ?c | Num & ?d`
//│ ║  l.215: 	addOne1 (Str { value = ""; addOne = error })
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.11: 	addOne1 x = case x of {
//│ ╙──      	                 ^
//│ res: nothing





addOne2 x = case x of {
  | Integer -> x.addOne x
  | Num -> x.addOne x
  | Str -> x.addOne x
  }
//│ addOne2: ((Integer\value with {addOne: 'a -> 'b}) & 'a | (Num\value with {addOne: 'c -> 'b}) & 'c | (Str\value with {addOne: 'd -> 'b}) & 'd) -> 'b

addOne2 (mkIntegerPrecise 42)
//│ res: Integer

:re
addOne2 (Str { value = ""; addOne = error })
//│ res: nothing

def mkStr: string -> Str
rec def mkStr value = Str { value; addOne = fun s -> mkStr (concat s.value "1") }
//│ mkStr: string -> Str
//│ string -> 'a
//│   where
//│     'a :> Str with {addOne: {value: string} -> 'a}
//│   <:  mkStr:
//│ string -> Str

addOne2 (mkStr "hello")
//│ res: Str

union = if true then mkIntegerPrecise 42 else mkStr "hello"
//│ union: Integer | Str

union2 = addOne2 union
//│ union2: Integer | Str

addOne2 union2
//│ res: Integer | Str

