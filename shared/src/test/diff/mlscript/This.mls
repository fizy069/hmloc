

class A
  method Boom: int -> this
//│ Defined class A
//│ Declared A.Boom: (A & 'this) -> int -> (A & 'this)

class B: A
  method Boom n = this
//│ Defined class B
//│ Defined B.Boom: (B & 'this) -> anything -> (B & 'this)

a = B{}
//│ a: B

a.Boom 1 // : B
//│ ╔══[ERROR] Implicit call to method Boom is forbidden because it is ambiguous.
//│ ║  l.16: 	a.Boom 1 // : B
//│ ║        	^^^^^^
//│ ╟── Unrelated methods named Boom are defined by:
//│ ╟── • class A
//│ ║  l.3: 	class A
//│ ║       	      ^
//│ ╟── • class B
//│ ║  l.8: 	class B: A
//│ ╙──     	      ^
//│ res: error

def b: A
b = a
b.Boom 1 // : A
//│ b: A
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.30: 	b = a
//│ ║        	^^^^^
//│ ╟── application of type `B` is not an instance of `A`
//│ ║  l.13: 	a = B{}
//│ ║        	    ^^^
//│ ╟── but it flows into reference with expected type `A`
//│ ║  l.30: 	b = a
//│ ║        	    ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.29: 	def b: A
//│ ║        	       ^
//│ ╟── Note: class B is defined at:
//│ ║  l.8: 	class B: A
//│ ╙──     	      ^
//│ B
//│   <:  b:
//│ A
//│ ╔══[ERROR] Implicit call to method Boom is forbidden because it is ambiguous.
//│ ║  l.31: 	b.Boom 1 // : A
//│ ║        	^^^^^^
//│ ╟── Unrelated methods named Boom are defined by:
//│ ╟── • class A
//│ ║  l.3: 	class A
//│ ║       	      ^
//│ ╟── • class B
//│ ║  l.8: 	class B: A
//│ ╙──     	      ^
//│ res: error



:w
class Myself[A]
  method Me = this
//│ Defined class Myself[±A]
//│ Defined Myself.Me: (Myself[?] & 'this) -> (Myself[?] & 'this)
//│ ╔══[WARNING] Type definition Myself has bivariant type parameters:
//│ ║  l.66: 	class Myself[A]
//│ ║        	      ^^^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.66: 	class Myself[A]
//│ ╙──      	             ^

m0 = Myself {}
//│ m0: Myself[?]

m0.Me
//│ res: Myself[?]



:e
class Addable[A]
  method Me = this
  method Oops = this.oops // disallowed if `this` is rigid
  method Add: A -> A
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.88: 	  method Oops = this.oops // disallowed if `this` is rigid
//│ ║        	                ^^^^^^^^^
//│ ╟── reference of type `Addable[A] & this` does not have field 'oops'
//│ ║  l.88: 	  method Oops = this.oops // disallowed if `this` is rigid
//│ ╙──      	                ^^^^
//│ Defined class Addable[=A]
//│ Declared Addable.Add: Addable['A] -> 'A -> 'A
//│ Defined Addable.Me: (Addable['A] & 'this) -> (Addable['A] & 'this)
//│ Defined Addable.Oops: Addable['A] -> nothing



class Base0
  method Foo0: this
//│ Defined class Base0
//│ Declared Base0.Foo0: (Base0 & 'this) -> (Base0 & 'this)

class Derived0: Base0
//│ Defined class Derived0

Derived0.Foo0
//│ res: (Derived0 & 'this) -> (Base0 & 'this)

class Base
  method Foo: this
  method Foo = this
//│ Defined class Base
//│ Declared Base.Foo: (Base & 'this) -> (Base & 'this)
//│ Defined Base.Foo: (Base & 'this) -> (Base & 'this)

class Derived: Base
//│ Defined class Derived

Base.Foo
//│ res: (Base & 'this) -> (Base & 'this)

Derived.Foo
//│ res: (Derived & 'this) -> (Base & 'this)

res (Derived{})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.130: 	res (Derived{})
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── application of type `Derived` is not an instance of type `Base`
//│ ║  l.130: 	res (Derived{})
//│ ║         	     ^^^^^^^^^
//│ ╟── but it flows into argument with expected type `Base`
//│ ║  l.130: 	res (Derived{})
//│ ║         	    ^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.121: 	class Derived: Base
//│ ║         	               ^^^^
//│ ╟── Note: class Derived is defined at:
//│ ║  l.121: 	class Derived: Base
//│ ╙──       	      ^^^^^^^
//│ res: nothing

(error: Derived).Foo
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.148: 	(error: Derived).Foo
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Derived` does not match type `?this`
//│ ║  l.148: 	(error: Derived).Foo
//│ ╙──       	        ^^^^^^^
//│ res: nothing

class Base2
  method Foo2: this
class Derived2: Base2
  method Foo3 = (this.Foo2,)
class DerivedDerived2: Derived2
  method Foo2 = this.Foo3._1
//│ Defined class Base2
//│ Declared Base2.Foo2: (Base2 & 'this) -> (Base2 & 'this)
//│ Defined class Derived2
//│ Defined Derived2.Foo3: Derived2 -> (nothing,)
//│ Defined class DerivedDerived2
//│ Defined DerivedDerived2.Foo2: DerivedDerived2 -> nothing

Derived2.Foo3
//│ res: Derived2 -> (nothing,)

DerivedDerived2.Foo3
//│ res: DerivedDerived2 -> (nothing,)



class NewBase
  method NewFoo: this
  method NewBar = (this.NewFoo,)
//│ Defined class NewBase
//│ Declared NewBase.NewFoo: (NewBase & 'this) -> (NewBase & 'this)
//│ Defined NewBase.NewBar: (NewBase & 'this) -> (NewBase & 'this,)

class NewDerived: NewBase
  method NewQux = this.NewBar._1
//│ Defined class NewDerived
//│ Defined NewDerived.NewQux: NewDerived -> nothing

// Test methods of NewDerived.
NewDerived.NewFoo
NewDerived.NewBar
NewDerived.NewQux
//│ res: (NewDerived & 'this) -> (NewBase & 'this)
//│ res: (NewDerived & 'this) -> (NewBase & 'this,)
//│ res: NewDerived -> nothing

class NewDerivedDerived: NewDerived
  method NewQuz = (this.NewQux)
//│ Defined class NewDerivedDerived
//│ Defined NewDerivedDerived.NewQuz: NewDerivedDerived -> nothing

NewDerivedDerived.NewFoo
NewDerivedDerived.NewBar
NewDerivedDerived.NewQux
NewDerivedDerived.NewQuz
//│ res: (NewDerivedDerived & 'this) -> (NewBase & 'this)
//│ res: (NewDerivedDerived & 'this) -> (NewBase & 'this,)
//│ res: NewDerivedDerived -> nothing
//│ res: NewDerivedDerived -> nothing

:e
class NewDerivedDerivedDerived: NewDerivedDerived
  method NewQux = this.NewBar._1
//│ ╔══[ERROR] Overriding method NewDerived.NewQux without explicit declaration is not allowed.
//│ ║  l.214: 	  method NewQux = this.NewBar._1
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: method definition inherited from
//│ ║  l.186: 	  method NewQux = this.NewBar._1
//│ ╙──       	         ^^^^^^^^^^^^^^^^^^^^^^^
//│ Defined class NewDerivedDerivedDerived
//│ Defined NewDerivedDerivedDerived.NewQux: NewDerivedDerivedDerived -> nothing

// Test methods of NewDerivedDerivedDerived
NewDerivedDerivedDerived.NewBar
NewDerivedDerivedDerived.NewFoo
NewDerivedDerivedDerived.NewQuz
NewDerivedDerivedDerived.NewQux
//│ res: (NewDerivedDerivedDerived & 'this) -> (NewBase & 'this,)
//│ res: (NewDerivedDerivedDerived & 'this) -> (NewBase & 'this)
//│ res: NewDerivedDerivedDerived -> nothing
//│ res: NewDerivedDerivedDerived -> nothing



class Animal
  method Eat = this
//│ Defined class Animal
//│ Defined Animal.Eat: (Animal & 'this) -> (Animal & 'this)

class Cat: Animal
//│ Defined class Cat

Animal.Eat
//│ res: (Animal & 'this) -> (Animal & 'this)

Cat.Eat
//│ res: (Cat & 'this) -> (Animal & 'this)

