
def rcd = { x = 1 }
//│ rcd: {x: int}

rcd.x
//│ res: int

rcd with { y = 2 }
//│ res: {x: int, y: int}

add res.x res.y
//│ res: int

rcd with { x = "oops" }
//│ res: {x: string}

res.x
//│ res: string

id rcd with { x = "oops" }
//│ res: {x: string}

res.x
//│ res: string


def rcd = { }
//│ rcd: anything

id rcd with { x = "oops" }
//│ res: {x: string}

res.x
//│ res: string


def f r = r with { x = "oops" }
//│ f: 'a -> ('a\x & {x: string})

f rcd
//│ res: {x: string}

f (rcd with { y = 2 })
//│ res: {x: string, y: int}


def f a b = if true then a else b
//│ f: 'a -> 'a -> 'a

def f a b = (if true then a else b) with { x = "oops" }
//│ f: 'a -> 'a -> ('a\x & {x: string})

def f a b = let tmp = a.x in (if true then a else b) with { x = "oops" }
//│ f: ({x: anything} & 'a) -> 'a -> ('a\x & {x: string})


({ name = "Bob" } with { age = 123 }).age
//│ res: int

({ name = "Bob" } with { age = 123 }).name
//│ res: string

({ name = "Bob" } with { name = 123 }).name
//│ res: int


def getf { f } = f
//│ getf: {f: 'a} -> 'a

def foo x =
  let xf = x with { f = 42 }
  in getf xf
//│ foo: ({f: 'a} | ~{f: int})\f -> 'a

foo 123
//│ res: int

def fooManual: (~{f: 42} | {f: 'a})\f -> 'a
//│ fooManual: ({f: 'a} | ~{f: 42})\f -> 'a

fooManual 123
//│ res: 42

def foo x =
  let xf = x with { f = 42 }
  in add (getf xf) (getf x)
//│ foo: (anything\f & {f: int}) -> int

def foo x =
  let xf = x with { f = 42 }
  in { l = getf xf; r = getf x; s = x }
//│ foo: (({f: 'a} | ~{f: int})\f & {f: 'b} & 'c) -> {l: 'a, r: 'b, s: 'c}

:e
foo 42
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.95: 	foo 42
//│ ║        	^^^^^^
//│ ╟── integer literal of type `int` does not have field 'f'
//│ ║  l.95: 	foo 42
//│ ║        	    ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.91: 	  in { l = getf xf; r = getf x; s = x }
//│ ║        	                             ^
//│ ╟── from record literal:
//│ ║  l.67: 	def getf { f } = f
//│ ╙──      	         ^^^^^
//│ res: {l: int, r: nothing, s: int}





def r = foo (42 with { f = 1 })
//│ r: {l: int, r: int, s: int & {f: int}}

r.s.f
//│ res: int

add r.s 1
//│ res: int


{} with { x = 1 } with { y = 2 }
//│ res: {x: int, y: int}

:e
res.z
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.128: 	res.z
//│ ║         	^^^^^
//│ ╟── `with` extension of type `{x: int, y: int}` does not have field 'z'
//│ ║  l.124: 	{} with { x = 1 } with { y = 2 }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{z: ?z}`
//│ ║  l.128: 	res.z
//│ ╙──       	^^^
//│ res: nothing






// === With and classes === //

class C[A]: { x: A }
//│ Defined class C[+A]

c = C{x = 1}
//│ c: C[int]

c.x
//│ res: int

d = c with { x = "hi"; y = 2 }
//│ d: C[int] with {x: string, y: int}

d.x
//│ res: string

d: C['a]
//│ res: C[int | string]

res.x
//│ res: int | string


def f x = (x with { a = 1 }).b
//│ f: ({b: 'b} | ~{a: int})\a -> 'b

