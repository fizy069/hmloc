
class None: {}
def None = None{}
//│ Defined class None
//│ None: None

class Some[A]: { value: A }
def Some v = Some { value = v }
//│ Defined class Some[+A]
//│ Some: 'value -> Some['value]

Some 42
(Some 42).value
//│ res: Some[int]
//│ res: int

type Option[A] = Some[A] | None
//│ Defined type alias Option[+A]

None: Option[int]
Some 42 : Option[int]
//│ res: Option[int]
//│ res: Option[int]

:e
res.value
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.26: 	res.value
//│ ║        	^^^^^^^^^
//│ ╟── type `None` does not have field 'value'
//│ ║  l.17: 	type Option[A] = Some[A] | None
//│ ║        	                           ^^^^
//│ ╟── but it flows into reference with expected type `{value: ?value}`
//│ ║  l.26: 	res.value
//│ ╙──      	^^^
//│ res: int




:e
42: Option[int, int]
//│ ╔══[ERROR] Wrong number of type arguments – expected 1, found 2
//│ ║  l.42: 	42: Option[int, int]
//│ ╙──      	    ^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.42: 	42: Option[int, int]
//│ ║        	^^
//│ ╟── integer literal of type `int` does not match type `None | Some[int]`
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.42: 	42: Option[int, int]
//│ ║        	    ^^^^^^^^^^^^^^^^
//│ ╟── from union type:
//│ ║  l.17: 	type Option[A] = Some[A] | None
//│ ╙──      	                 ^^^^^^^^^^^^^^
//│ res: Option[int]







class Foo1[A]: { x: A }
class Bar1: Foo1[int]
//│ Defined class Foo1[+A]
//│ Defined class Bar1

Bar1
//│ res: {x: int & 'x} -> (Bar1 with {x: 'x})

g = Bar1 { x = 42 }
//│ g: Bar1

g: Foo1['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.75: 	g: Foo1['a]
//│ ║        	^
//│ ╟── application of type `Bar1 & {Foo1#A = int}` does not match type `Foo1[?] with {x: ?a}`
//│ ║  l.72: 	g = Bar1 { x = 42 }
//│ ║        	    ^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Foo1[?] with {x: ?a}`
//│ ║  l.75: 	g: Foo1['a]
//│ ║        	^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.75: 	g: Foo1['a]
//│ ╙──      	   ^^^^^^^^
//│ res: Foo1[int]

res.x
//│ res: int

g: Foo1['a]: Foo1[int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.93: 	g: Foo1['a]: Foo1[int]
//│ ║        	^
//│ ╟── application of type `Bar1 & {Foo1#A = int}` does not match type `Foo1[?] with {x: ?a}`
//│ ║  l.72: 	g = Bar1 { x = 42 }
//│ ║        	    ^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Foo1[?] with {x: ?a}`
//│ ║  l.93: 	g: Foo1['a]: Foo1[int]
//│ ║        	^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.93: 	g: Foo1['a]: Foo1[int]
//│ ╙──      	   ^^^^^^^^
//│ res: Foo1[int]

res.x
//│ res: int

:e
g: Foo1['a]: Foo1[string]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.112: 	g: Foo1['a]: Foo1[string]
//│ ║         	^
//│ ╟── application of type `Bar1 & {Foo1#A = int}` does not match type `Foo1[?] with {x: ?a}`
//│ ║  l.72: 	g = Bar1 { x = 42 }
//│ ║        	    ^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Foo1[?] with {x: ?a}`
//│ ║  l.112: 	g: Foo1['a]: Foo1[string]
//│ ║         	^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.112: 	g: Foo1['a]: Foo1[string]
//│ ╙──       	   ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.112: 	g: Foo1['a]: Foo1[string]
//│ ║         	^
//│ ╟── integer literal of type `int` is not an instance of `string`
//│ ║  l.72: 	g = Bar1 { x = 42 }
//│ ║        	               ^^
//│ ╟── but it flows into reference with expected type `string`
//│ ║  l.112: 	g: Foo1['a]: Foo1[string]
//│ ║         	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.112: 	g: Foo1['a]: Foo1[string]
//│ ╙──       	                  ^^^^^^
//│ res: Foo1[string]






class Foo2[A]
  method Foo2: A -> A
  method Foo2 = id
//│ Defined class Foo2[=A]
//│ Declared Foo2.Foo2: Foo2['A] -> 'A -> 'A
//│ Defined Foo2.Foo2: Foo2['A] -> 'a -> 'a

Foo2
//│ res: anything -> Foo2['A]

:re
error: Foo2[int]
//│ res: Foo2[int]

f = fun x -> case x of { Foo2 -> x }
//│ f: (Foo2[?] & 'a) -> 'a

f (Foo2 {})
//│ res: Foo2['A]

:re
error: (Foo2[?] & 'a) -> 'a
//│ res: (Foo2[?] & 'a) -> 'a

f: (Foo2[?] & 'a) -> 'a
//│ res: (Foo2[?] & 'a) -> 'a

:ns
f: (Foo2[?] & 'a) -> 'a
//│ res: (Foo2[?] & 'a) -> 'a
//│   where
//│     'a :> Foo2[?] & 'a
//│        <: (#Foo2 | ~{Foo2#A} | ~#Foo2 | ~(#Foo2 & {Foo2#A})) & (#Foo2 | ~(#Foo2 & {Foo2#A}))

f
//│ res: (Foo2[?] & 'a) -> 'a


def mrg: Foo2[int] & Foo2[string]
//│ mrg: Foo2[in int | string out nothing]

mrg: Foo2[int]
//│ res: Foo2[int]

:e
mrg = Foo2{}
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.189: 	mrg = Foo2{}
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `int`
//│ ║  l.182: 	def mrg: Foo2[int] & Foo2[string]
//│ ║         	                          ^^^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.189: 	mrg = Foo2{}
//│ ║         	      ^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.182: 	def mrg: Foo2[int] & Foo2[string]
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.182: 	def mrg: Foo2[int] & Foo2[string]
//│ ╙──       	              ^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.189: 	mrg = Foo2{}
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `string`
//│ ║  l.182: 	def mrg: Foo2[int] & Foo2[string]
//│ ║         	              ^^^
//│ ╟── but it flows into application with expected type `string`
//│ ║  l.189: 	mrg = Foo2{}
//│ ║         	      ^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.182: 	def mrg: Foo2[int] & Foo2[string]
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.182: 	def mrg: Foo2[int] & Foo2[string]
//│ ╙──       	                          ^^^^^^
//│ Foo2['A]
//│   <:  mrg:
//│ Foo2[in int | string out nothing]








def mrg: Foo2[int] | Foo2[string]
//│ mrg: Foo2[out int | string]



class Foo2_Co[A]
  method Foo2_Co: A
  method Foo2_Co = error
//│ Defined class Foo2_Co[+A]
//│ Declared Foo2_Co.Foo2_Co: Foo2_Co['A] -> 'A
//│ Defined Foo2_Co.Foo2_Co: Foo2_Co[?] -> nothing

Foo2_Co
//│ res: anything -> Foo2_Co[nothing]

:re
error: Foo2_Co[int]
//│ res: Foo2_Co[int]

f = fun x -> case x of { Foo2_Co -> x }
//│ f: (Foo2_Co[?] & 'a) -> 'a

f (Foo2_Co {})
//│ res: Foo2_Co[nothing]

:re
error: (Foo2_Co[?] & 'a) -> 'a
//│ res: (Foo2_Co[nothing] & 'a) -> 'a

f: (Foo2_Co[?] & 'a) -> 'a
//│ res: (Foo2_Co[nothing] & 'a) -> 'a

:ns
f: (Foo2_Co[?] & 'a) -> 'a
//│ res: (Foo2_Co[?] & 'a) -> 'a
//│   where
//│     'a :> Foo2_Co[?] & 'a
//│        <: (#Foo2_Co | ~{Foo2_Co#A} | ~#Foo2_Co | ~(#Foo2_Co & {Foo2_Co#A})) & (#Foo2_Co | ~(#Foo2_Co & {Foo2_Co#A}))

f
//│ res: (Foo2_Co[?] & 'a) -> 'a


def mrg: Foo2_Co[int] & Foo2_Co[string]
//│ mrg: Foo2_Co[nothing]

mrg: Foo2_Co[int]
//│ res: Foo2_Co[int]

mrg = Foo2_Co{}
//│ Foo2_Co[nothing]
//│   <:  mrg:
//│ Foo2_Co[nothing]

def mrg: Foo2_Co[int] | Foo2_Co[string]
//│ mrg: Foo2_Co[int | string]



:w
class Foo2_Bi[A]
//│ Defined class Foo2_Bi[±A]
//│ ╔══[WARNING] Type definition Foo2_Bi has bivariant type parameters:
//│ ║  l.291: 	class Foo2_Bi[A]
//│ ║         	      ^^^^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.291: 	class Foo2_Bi[A]
//│ ╙──       	              ^



Foo2_Bi
//│ res: anything -> Foo2_Bi[?]

:re
error: Foo2_Bi[int]
//│ res: Foo2_Bi[?]

f = fun x -> case x of { Foo2_Bi -> x }
//│ f: (Foo2_Bi[?] & 'a) -> 'a

f (Foo2_Bi {})
//│ res: Foo2_Bi[?]

:re
error: (Foo2_Bi[?] & 'a) -> 'a
//│ res: (Foo2_Bi[?] & 'a) -> 'a

f: (Foo2_Bi[?] & 'a) -> 'a
//│ res: (Foo2_Bi[?] & 'a) -> 'a

:ns
f: (Foo2_Bi[?] & 'a) -> 'a
//│ res: (Foo2_Bi[?] & 'a) -> 'a
//│   where
//│     'a :> Foo2_Bi[?] & 'a
//│        <: (#Foo2_Bi | ~{Foo2_Bi#A} | ~#Foo2_Bi | ~(#Foo2_Bi & {Foo2_Bi#A})) & (#Foo2_Bi | ~(#Foo2_Bi & {Foo2_Bi#A}))

f
//│ res: (Foo2_Bi[?] & 'a) -> 'a


def mrg: Foo2_Bi[int] & Foo2_Bi[string]
//│ mrg: Foo2_Bi[?]

mrg: Foo2_Bi[int]
//│ res: Foo2_Bi[?]

mrg = Foo2_Bi{}
//│ Foo2_Bi[?]
//│   <:  mrg:
//│ Foo2_Bi[?]

def mrg: Foo2_Bi[int] | Foo2_Bi[string]
//│ mrg: Foo2_Bi[?]

