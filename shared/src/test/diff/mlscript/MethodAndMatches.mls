:w
class Base1[A]
  method M1: A -> Base1[A]
class Derived1: Base1[int] & { x: int }
  method M1 y = Derived1 { x = add this.x y }
  method M2 = Derived1 { x = add this.x 1 }
class Derived2[C, D]: Base1[{ c: C; d: D }]
  // method M1 { c, d } = Derived2 { c; d }
  method M1 r = Derived2 { c = r.c; d = r.d }
class Derived3[C, D]: Base1[{ c: C; d: D }] & { c: C; d: D }
  method M1 r = Derived3 { c = r.c; d = r.d }
type Type1[A] = Derived1 | Derived3['a, 'b]
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.5: 	  method M1 y = Derived1 { x = add this.x y }
//│ ║       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Derived1` does not match type `Base1[int]`
//│ ║  l.5: 	  method M1 y = Derived1 { x = add this.x y }
//│ ║       	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.3: 	  method M1: A -> Base1[A]
//│ ╙──     	                  ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.9: 	  method M1 r = Derived2 { c = r.c; d = r.d }
//│ ║       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Derived2[?C, ?D]` does not match type `Base1[{c: C, d: D}]`
//│ ║  l.9: 	  method M1 r = Derived2 { c = r.c; d = r.d }
//│ ║       	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.3: 	  method M1: A -> Base1[A]
//│ ╙──     	                  ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.11: 	  method M1 r = Derived3 { c = r.c; d = r.d }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Derived3[?C, ?D] & {c: ?c, d: ?d}` does not match type `Base1[{c: C, d: D}]`
//│ ║  l.11: 	  method M1 r = Derived3 { c = r.c; d = r.d }
//│ ║        	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.3: 	  method M1: A -> Base1[A]
//│ ╙──     	                  ^^^^^^^^
//│ Defined class Base1[-A]
//│ Declared Base1.M1: Base1['A] -> 'A -> Base1['A]
//│ Defined class Derived1
//│ Defined Derived1.M1: Derived1 -> int -> Derived1
//│ Defined Derived1.M2: Derived1 -> Derived1
//│ Defined class Derived2[-C, -D]
//│ Defined Derived2.M1: Derived2[?, ?] -> {c: anything, d: anything} -> Derived2[anything, anything]
//│ Defined class Derived3[=C, =D]
//│ Defined Derived3.M1: Derived3['C, 'D] -> {c: 'c & 'C0, d: 'd & 'D0} -> (Derived3['C0, 'D0] with {c: 'c, d: 'd})
//│ Defined type alias Type1[±A]
//│ ╔══[WARNING] Type definition Type1 has bivariant type parameters:
//│ ║  l.12: 	type Type1[A] = Derived1 | Derived3['a, 'b]
//│ ║        	     ^^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.12: 	type Type1[A] = Derived1 | Derived3['a, 'b]
//│ ╙──      	           ^


// class Derived2[C, D]: Base1[C -> D]

def foo b x = case b of {
  | Derived1 -> b.M2
  | Base1 -> b.M1 x
  }
//│ ╔══[ERROR] Implicit call to method M1 is forbidden because it is ambiguous.
//│ ║  l.62: 	  | Base1 -> b.M1 x
//│ ║        	             ^^^^
//│ ╟── Unrelated methods named M1 are defined by:
//│ ╟── • class Base1
//│ ║  l.2: 	class Base1[A]
//│ ║       	      ^^^^^
//│ ╟── • class Derived1
//│ ║  l.4: 	class Derived1: Base1[int] & { x: int }
//│ ║       	      ^^^^^^^^
//│ ╟── • class Derived2
//│ ║  l.7: 	class Derived2[C, D]: Base1[{ c: C; d: D }]
//│ ║       	      ^^^^^^^^
//│ ╟── • class Derived3
//│ ║  l.10: 	class Derived3[C, D]: Base1[{ c: C; d: D }] & { c: C; d: D }
//│ ╙──      	      ^^^^^^^^
//│ foo: (Base1[?] | Derived1) -> anything -> (Derived1 | error)

d1 = Derived1 { x = 1 }
//│ d1: Derived1

foo d1
foo d1 0
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.85: 	foo d1
//│ ║        	^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` is not an instance of type `Base1`
//│ ║  l.82: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Base1[?]`
//│ ║  l.85: 	foo d1
//│ ║        	    ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.60: 	def foo b x = case b of {
//│ ║        	                   ^
//│ ╟── from applied type reference:
//│ ║  l.4: 	class Derived1: Base1[int] & { x: int }
//│ ╙──     	                ^^^^^^^^^^
//│ res: anything -> (Derived1 | error)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.86: 	foo d1 0
//│ ║        	^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` is not an instance of type `Base1`
//│ ║  l.82: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Base1[?]`
//│ ║  l.86: 	foo d1 0
//│ ║        	    ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.60: 	def foo b x = case b of {
//│ ║        	                   ^
//│ ╟── from applied type reference:
//│ ║  l.4: 	class Derived1: Base1[int] & { x: int }
//│ ╙──     	                ^^^^^^^^^^
//│ res: Derived1 | error

def bar0: Base1[int] -> int -> Base1[int]
bar0 d1
bar0 d1 0
//│ bar0: Base1[int] -> int -> Base1[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.121: 	bar0 d1
//│ ║         	^^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` is not an instance of type `Base1`
//│ ║  l.82: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Base1[?]`
//│ ║  l.121: 	bar0 d1
//│ ║         	     ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.120: 	def bar0: Base1[int] -> int -> Base1[int]
//│ ╙──       	          ^^^^^^^^^^
//│ res: int -> Base1[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.122: 	bar0 d1 0
//│ ║         	^^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` is not an instance of type `Base1`
//│ ║  l.82: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Base1[?]`
//│ ║  l.122: 	bar0 d1 0
//│ ║         	     ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.120: 	def bar0: Base1[int] -> int -> Base1[int]
//│ ╙──       	          ^^^^^^^^^^
//│ res: Base1[int]

// This is ill-typed because type `Base1[int]` includes things like `Derived1\x` (a `Derived` instance without an `x` field)
:e
def bar0 = foo
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.153: 	def bar0 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` does not match type `Base1[int]`
//│ ║  l.6: 	  method M2 = Derived1 { x = add this.x 1 }
//│ ║       	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.120: 	def bar0: Base1[int] -> int -> Base1[int]
//│ ╙──       	                               ^^^^^^^^^^
//│ (Base1[?] | Derived1) -> anything -> (Derived1 | error)
//│   <:  bar0:
//│ Base1[int] -> int -> Base1[int]




def bar1: Type1[int] -> int -> Type1[int]
bar1 d1
bar1 d1 0
//│ bar1: Type1[?] -> int -> Type1[?]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.171: 	bar1 d1
//│ ║         	^^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` does not match type `Derived1 | Derived3[?a, ?b]`
//│ ║  l.82: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Derived1 | Derived3[?a, ?b]`
//│ ║  l.171: 	bar1 d1
//│ ║         	     ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.170: 	def bar1: Type1[int] -> int -> Type1[int]
//│ ║         	          ^^^^^^^^^^
//│ ╟── from union type:
//│ ║  l.12: 	type Type1[A] = Derived1 | Derived3['a, 'b]
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: int -> Type1[?]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.172: 	bar1 d1 0
//│ ║         	^^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` does not match type `Derived1 | Derived3[?a, ?b]`
//│ ║  l.82: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Derived1 | Derived3[?a, ?b]`
//│ ║  l.172: 	bar1 d1 0
//│ ║         	     ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.170: 	def bar1: Type1[int] -> int -> Type1[int]
//│ ║         	          ^^^^^^^^^^
//│ ╟── from union type:
//│ ║  l.12: 	type Type1[A] = Derived1 | Derived3['a, 'b]
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: Type1[?]

:e
def bar1 = foo
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.208: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` does not match type `Derived1 | Derived3[?a, ?b]`
//│ ║  l.6: 	  method M2 = Derived1 { x = add this.x 1 }
//│ ║       	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.170: 	def bar1: Type1[int] -> int -> Type1[int]
//│ ║         	                               ^^^^^^^^^^
//│ ╟── from union type:
//│ ║  l.12: 	type Type1[A] = Derived1 | Derived3['a, 'b]
//│ ╙──      	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (Base1[?] | Derived1) -> anything -> (Derived1 | error)
//│   <:  bar1:
//│ Type1[?] -> int -> Type1[?]





























def bar2: Base1['a] -> 'a -> Base1['a]
bar2 d1
bar2 d1 0
//│ bar2: Base1['a] -> 'a -> Base1['a]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.254: 	bar2 d1
//│ ║         	^^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` is not an instance of type `Base1`
//│ ║  l.82: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Base1[?]`
//│ ║  l.254: 	bar2 d1
//│ ║         	     ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.253: 	def bar2: Base1['a] -> 'a -> Base1['a]
//│ ╙──       	          ^^^^^^^^^
//│ res: int -> Base1[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.255: 	bar2 d1 0
//│ ║         	^^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` is not an instance of type `Base1`
//│ ║  l.82: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Base1[?]`
//│ ║  l.255: 	bar2 d1 0
//│ ║         	     ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.253: 	def bar2: Base1['a] -> 'a -> Base1['a]
//│ ╙──       	          ^^^^^^^^^
//│ res: Base1[int]

// Note that typing this would require GADT reasoning! Though it also suffers from the previous "Derived1 with missing x field" problem.
:e
def bar2 = foo
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.286: 	def bar2 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── application of type `Derived1 & {Base1#A = int}` does not match type `Base1['a]`
//│ ║  l.6: 	  method M2 = Derived1 { x = add this.x 1 }
//│ ║       	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.253: 	def bar2: Base1['a] -> 'a -> Base1['a]
//│ ╙──       	                             ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.286: 	def bar2 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `'a` is not an instance of type `int`
//│ ║  l.253: 	def bar2: Base1['a] -> 'a -> Base1['a]
//│ ║         	                                   ^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.253: 	def bar2: Base1['a] -> 'a -> Base1['a]
//│ ║         	                             ^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.4: 	class Derived1: Base1[int] & { x: int }
//│ ╙──     	                      ^^^
//│ (Base1[?] | Derived1) -> anything -> (Derived1 | error)
//│   <:  bar2:
//│ Base1['a] -> 'a -> Base1['a]










