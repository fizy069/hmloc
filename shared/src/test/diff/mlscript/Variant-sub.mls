class None: {}
class Some[A]: { v: A }
//│ Defined class None
//│ Defined class Some[+A]

def Some v = Some{v}
def None = None{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.6: 	def Some v = Some{v}
//│ ║       	             ^^^^^^^
//│ ╟── argument of type `({v: ?a},)` does not have field 'v'
//│ ║  l.6: 	def Some v = Some{v}
//│ ╙──     	                 ^^^
//│ Some: anything -> Some[nothing]
//│ None: None

def flatMap = fun f -> fun opt ->
  case opt of { Some -> f opt.v | None -> opt }
//│ flatMap: ('v -> 'a) -> (None & 'a | (Some[?] with {v: 'v})) -> 'a

f x = Some x
flatMap f (Some 1)
flatMap f None
//│ f: anything -> Some[nothing]
//│ res: Some[nothing]
//│ res: None | Some[nothing]

:e
flatMap f "oops"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.29: 	flatMap f "oops"
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `None & ?a | Some[?] & ?b`
//│ ║  l.29: 	flatMap f "oops"
//│ ║        	          ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.18: 	  case opt of { Some -> f opt.v | None -> opt }
//│ ╙──      	       ^^^
//│ res: Some[nothing]




class NoneBecause: None & { reason: string }
flatMap f (NoneBecause { reason = "uh uh" })
//│ Defined class NoneBecause
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.45: 	flatMap f (NoneBecause { reason = "uh uh" })
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({reason: string},)` does not have field 'reason'
//│ ║  l.45: 	flatMap f (NoneBecause { reason = "uh uh" })
//│ ╙──      	                       ^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.45: 	flatMap f (NoneBecause { reason = "uh uh" })
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `NoneBecause & {reason: ?reason}` does not match type `None & ?a | Some[?] & ?b`
//│ ║  l.45: 	flatMap f (NoneBecause { reason = "uh uh" })
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `None & ?a | Some[?] & ?c`
//│ ║  l.45: 	flatMap f (NoneBecause { reason = "uh uh" })
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.18: 	  case opt of { Some -> f opt.v | None -> opt }
//│ ╙──      	       ^^^
//│ res: Some[nothing]

type Expr = Lit | Neg | Var | Plus
class Lit: {v: int}
class Neg: {sub: Expr}
class Var: {nme: string}
class Plus: {lhs: Expr; rhs: Expr}
//│ Defined type alias Expr
//│ Defined class Lit
//│ Defined class Neg
//│ Defined class Var
//│ Defined class Plus

:stats
rec def evalOpt x = case x of {
  | Lit ->
      Some x.v
  | Neg ->
      // flatMap (fun s -> Some (neg x.sub)) (evalOpt x.sub)
      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
  | Var ->
      // None with {err = concat "free var: " x.nme}
      NoneBecause {reason = concat "free var: " x.nme}
      // None
  | Plus ->
      flatMap (fun l -> flatMap (fun r ->
        // Some (add x.lhs x.rhs)
        Some (l + r)
      ) (evalOpt x.rhs)) (evalOpt x.lhs)
  }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.84: 	      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
//│ ║        	                              ^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.84: 	      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
//│ ╙──      	                                     ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	                            ^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(string,)` is not an instance of `string`
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ╙──      	                                   ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	                            ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?nme,)` is not an instance of `string`
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ╙──      	                                                ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({reason: ?a},)` does not have field 'reason'
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ╙──      	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.92: 	        Some (l + r)
//│ ║        	              ^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.92: 	        Some (l + r)
//│ ╙──      	              ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.92: 	        Some (l + r)
//│ ║        	              ^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.92: 	        Some (l + r)
//│ ╙──      	                  ^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.79: 	rec def evalOpt x = case x of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.80: 	  | Lit ->
//│ ║        	^^^^^^^^^^
//│ ║  l.81: 	      Some x.v
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.82: 	  | Neg ->
//│ ║        	^^^^^^^^^^
//│ ║  l.83: 	      // flatMap (fun s -> Some (neg x.sub)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.84: 	      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.85: 	  | Var ->
//│ ║        	^^^^^^^^^^
//│ ║  l.86: 	      // None with {err = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	      // None
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.89: 	  | Plus ->
//│ ║        	^^^^^^^^^^^
//│ ║  l.90: 	      flatMap (fun l -> flatMap (fun r ->
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.91: 	        // Some (add x.lhs x.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.92: 	        Some (l + r)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.93: 	      ) (evalOpt x.rhs)) (evalOpt x.lhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  }
//│ ║        	^^^
//│ ╟── application of type `NoneBecause & {reason: ?reason}` does not match type `None & ?a | Some[?] & ?b`
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into `case` expression with expected type `None & ?c | Some[?] & ?d`
//│ ║  l.79: 	rec def evalOpt x = case x of {
//│ ║        	                    ^^^^^^^^^^^
//│ ║  l.80: 	  | Lit ->
//│ ║        	^^^^^^^^^^
//│ ║  l.81: 	      Some x.v
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.82: 	  | Neg ->
//│ ║        	^^^^^^^^^^
//│ ║  l.83: 	      // flatMap (fun s -> Some (neg x.sub)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.84: 	      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.85: 	  | Var ->
//│ ║        	^^^^^^^^^^
//│ ║  l.86: 	      // None with {err = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	      // None
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.89: 	  | Plus ->
//│ ║        	^^^^^^^^^^^
//│ ║  l.90: 	      flatMap (fun l -> flatMap (fun r ->
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.91: 	        // Some (add x.lhs x.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.92: 	        Some (l + r)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.93: 	      ) (evalOpt x.rhs)) (evalOpt x.lhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.93: 	      ) (evalOpt x.rhs)) (evalOpt x.lhs)
//│ ║        	                          ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.18: 	  case opt of { Some -> f opt.v | None -> opt }
//│ ╙──      	       ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.79: 	rec def evalOpt x = case x of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.80: 	  | Lit ->
//│ ║        	^^^^^^^^^^
//│ ║  l.81: 	      Some x.v
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.82: 	  | Neg ->
//│ ║        	^^^^^^^^^^
//│ ║  l.83: 	      // flatMap (fun s -> Some (neg x.sub)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.84: 	      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.85: 	  | Var ->
//│ ║        	^^^^^^^^^^
//│ ║  l.86: 	      // None with {err = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	      // None
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.89: 	  | Plus ->
//│ ║        	^^^^^^^^^^^
//│ ║  l.90: 	      flatMap (fun l -> flatMap (fun r ->
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.91: 	        // Some (add x.lhs x.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.92: 	        Some (l + r)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.93: 	      ) (evalOpt x.rhs)) (evalOpt x.lhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  }
//│ ║        	^^^
//│ ╟── application of type `NoneBecause & {reason: ?reason}` does not match type `None & ?a | Some[?] & ?b`
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into `case` expression with expected type `None & ?c | Some[?] & ?d`
//│ ║  l.79: 	rec def evalOpt x = case x of {
//│ ║        	                    ^^^^^^^^^^^
//│ ║  l.80: 	  | Lit ->
//│ ║        	^^^^^^^^^^
//│ ║  l.81: 	      Some x.v
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.82: 	  | Neg ->
//│ ║        	^^^^^^^^^^
//│ ║  l.83: 	      // flatMap (fun s -> Some (neg x.sub)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.84: 	      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.85: 	  | Var ->
//│ ║        	^^^^^^^^^^
//│ ║  l.86: 	      // None with {err = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	      // None
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.89: 	  | Plus ->
//│ ║        	^^^^^^^^^^^
//│ ║  l.90: 	      flatMap (fun l -> flatMap (fun r ->
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.91: 	        // Some (add x.lhs x.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.92: 	        Some (l + r)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.93: 	      ) (evalOpt x.rhs)) (evalOpt x.lhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.93: 	      ) (evalOpt x.rhs)) (evalOpt x.lhs)
//│ ║        	         ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.18: 	  case opt of { Some -> f opt.v | None -> opt }
//│ ╙──      	       ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.79: 	rec def evalOpt x = case x of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.80: 	  | Lit ->
//│ ║        	^^^^^^^^^^
//│ ║  l.81: 	      Some x.v
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.82: 	  | Neg ->
//│ ║        	^^^^^^^^^^
//│ ║  l.83: 	      // flatMap (fun s -> Some (neg x.sub)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.84: 	      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.85: 	  | Var ->
//│ ║        	^^^^^^^^^^
//│ ║  l.86: 	      // None with {err = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	      // None
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.89: 	  | Plus ->
//│ ║        	^^^^^^^^^^^
//│ ║  l.90: 	      flatMap (fun l -> flatMap (fun r ->
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.91: 	        // Some (add x.lhs x.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.92: 	        Some (l + r)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.93: 	      ) (evalOpt x.rhs)) (evalOpt x.lhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  }
//│ ║        	^^^
//│ ╟── application of type `NoneBecause & {reason: ?reason}` does not match type `None & ?a | Some[?] & ?b`
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into `case` expression with expected type `None & ?c | Some[?] & ?d`
//│ ║  l.79: 	rec def evalOpt x = case x of {
//│ ║        	                    ^^^^^^^^^^^
//│ ║  l.80: 	  | Lit ->
//│ ║        	^^^^^^^^^^
//│ ║  l.81: 	      Some x.v
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.82: 	  | Neg ->
//│ ║        	^^^^^^^^^^
//│ ║  l.83: 	      // flatMap (fun s -> Some (neg x.sub)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.84: 	      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.85: 	  | Var ->
//│ ║        	^^^^^^^^^^
//│ ║  l.86: 	      // None with {err = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.87: 	      NoneBecause {reason = concat "free var: " x.nme}
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	      // None
//│ ║        	^^^^^^^^^^^^^
//│ ║  l.89: 	  | Plus ->
//│ ║        	^^^^^^^^^^^
//│ ║  l.90: 	      flatMap (fun l -> flatMap (fun r ->
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.91: 	        // Some (add x.lhs x.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.92: 	        Some (l + r)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.93: 	      ) (evalOpt x.rhs)) (evalOpt x.lhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.84: 	      flatMap (fun s -> Some (negate s)) (evalOpt x.sub)
//│ ║        	                                          ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.18: 	  case opt of { Some -> f opt.v | None -> opt }
//│ ╙──      	       ^^^
//│ evalOpt: 'a -> (NoneBecause & {reason: nothing} | Some[nothing])
//│   where
//│     'a <: Lit | (Neg with {sub: 'a}) | (Plus with {lhs: 'a, rhs: 'a}) | Var
//│ constrain calls  : 494
//│ annoying  calls  : 96
//│ subtyping calls  : 1860

:stats
evalOpt (Plus{lhs = Lit{v=2}; rhs = Lit{v=3}})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.364: 	evalOpt (Plus{lhs = Lit{v=2}; rhs = Lit{v=3}})
//│ ║         	                    ^^^^^^^^
//│ ╟── argument of type `({v: int},)` does not have field 'v'
//│ ║  l.364: 	evalOpt (Plus{lhs = Lit{v=2}; rhs = Lit{v=3}})
//│ ╙──       	                       ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.364: 	evalOpt (Plus{lhs = Lit{v=2}; rhs = Lit{v=3}})
//│ ║         	                                    ^^^^^^^^
//│ ╟── argument of type `({v: int},)` does not have field 'v'
//│ ║  l.364: 	evalOpt (Plus{lhs = Lit{v=2}; rhs = Lit{v=3}})
//│ ╙──       	                                       ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.364: 	evalOpt (Plus{lhs = Lit{v=2}; rhs = Lit{v=3}})
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.364: 	evalOpt (Plus{lhs = Lit{v=2}; rhs = Lit{v=3}})
//│ ╙──       	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: NoneBecause & {reason: nothing} | Some[nothing]
//│ constrain calls  : 80
//│ annoying  calls  : 15
//│ subtyping calls  : 111
