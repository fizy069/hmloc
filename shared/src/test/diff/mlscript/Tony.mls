class Some[A]: { value: A }
class None: {}
//│ Defined class Some[+A]
//│ Defined class None



def flatMap3 = fun f -> fun opt -> case opt of { Some -> f opt | _ -> opt }
//│ flatMap3: ('a -> 'b) -> (Some[?] & 'a | 'b & ~#Some) -> 'b


def arg = if true then Some{value = 42} with {payload = 23} else None {}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.12: 	def arg = if true then Some{value = 42} with {payload = 23} else None {}
//│ ║        	                       ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.12: 	def arg = if true then Some{value = 42} with {payload = 23} else None {}
//│ ╙──      	                           ^^^^^^^^^^^^
//│ arg: None | Some[nothing] & {payload: int}

// > TODO don't distribute neg inters + handle better at constraint top level
:stats
flatMap3 (fun x -> add x.value x.payload) arg
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.23: 	flatMap3 (fun x -> add x.value x.payload) arg
//│ ║        	                   ^^^^^^^^^^^
//│ ╟── argument of type `(?value,)` is not an instance of `int`
//│ ║  l.23: 	flatMap3 (fun x -> add x.value x.payload) arg
//│ ╙──      	                       ^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.23: 	flatMap3 (fun x -> add x.value x.payload) arg
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?payload,)` is not an instance of `int`
//│ ║  l.23: 	flatMap3 (fun x -> add x.value x.payload) arg
//│ ╙──      	                               ^^^^^^^^^
//│ res: int | None
//│ constrain calls  : 123
//│ annoying  calls  : 23
//│ subtyping calls  : 59


def arg = if true then Some{value = 42} else None {}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.42: 	def arg = if true then Some{value = 42} else None {}
//│ ║        	                       ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.42: 	def arg = if true then Some{value = 42} else None {}
//│ ╙──      	                           ^^^^^^^^^^^^
//│ arg: None | Some[nothing]

flatMap3 (fun x -> x.value) arg
//│ res: None


def foo = flatMap3 (fun x -> x.value)
//│ foo: ((Some[?] with {value: 'a}) | 'a & ~#Some) -> 'a

foo arg
//│ res: None

foo 1
//│ res: int

def fn = foo None
//│ fn: anything -> None

// :d
fn{} // foo None {}
//│ res: None

// :d
foo (None{})
//│ res: None


fun f -> flatMap3 f arg
//│ res: (Some[nothing] -> 'a) -> (None | 'a)




def foo = flatMap3 (fun x -> x)
//│ foo: ('a & (Some[?] | ~#Some)) -> 'a

foo 1
//│ res: int




def simpler = fun f -> case None{} of { Some -> f 1 | _ -> None{} }
//│ simpler: (int -> 'a) -> (None | 'a)

def simpler = fun f -> fun opt -> case opt of { Some -> f opt | None -> opt }
//│ simpler: ('a -> 'b) -> (None & 'b | Some[?] & 'a) -> 'b

simpler (fun x -> x.value)
//│ res: (None & 'a | (Some[?] with {value: 'a})) -> 'a

:e
res 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.101: 	res 1
//│ ║         	^^^^^
//│ ╟── integer literal of type `int` does not match type `None & ?a | Some[?] & ?b`
//│ ║  l.101: 	res 1
//│ ║         	    ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.94: 	def simpler = fun f -> fun opt -> case opt of { Some -> f opt | None -> opt }
//│ ╙──      	                                       ^^^
//│ res: nothing





def funny = fun f -> case f of { Some -> f f }
//│ funny: nothing -> nothing
