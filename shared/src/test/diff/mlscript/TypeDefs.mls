
class Test1: { x: int }
//│ Defined class Test1

Test1
//│ res: {x: int & 'x} -> (Test1 with {x: 'x})

Test1 { x = 123 }
//│ res: Test1

:e
Test1 { x = "oops" }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.12: 	Test1 { x = "oops" }
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` is not an instance of type `int`
//│ ║  l.12: 	Test1 { x = "oops" }
//│ ║        	            ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.2: 	class Test1: { x: int }
//│ ╙──     	                  ^^^
//│ res: Test1 with {x: string}




def Test1 = fun x -> Test1 { x = x }
//│ Test1: (int & 'x) -> (Test1 with {x: 'x})

class Test11: { x: int }
def Test11 x = Test11 { x }
//│ Defined class Test11
//│ Test11: (int & 'x) -> (Test11 with {x: 'x})


:e
type Test1 = { x: int }
//│ ╔══[ERROR] Type 'Test1' is already defined.
//│ ║  l.37: 	type Test1 = { x: int }
//│ ╙──      	     ^^^^^


type Test2 = { x: int }
//│ Defined type alias Test2

:pe
class Test = { x: int }
//│ /!\ Parse error: Expected end-of-input:1:12, found "= { x: int" at l.47:12: class Test = { x: int }

:pe
type Test: { x: int }
//│ /!\ Parse error: Expected "=":1:10, found ": { x: int" at l.51:10: type Test: { x: int }

type Test3 = int -> int
//│ Defined type alias Test3

type Test4 = int -> int -> int
//│ Defined type alias Test4

type Test5 = (int -> int) -> int
//│ Defined type alias Test5


type T = int
//│ Defined type alias T

:e
type T = int
type T = int
//│ ╔══[ERROR] Type 'T' is already defined.
//│ ║  l.68: 	type T = int
//│ ╙──      	     ^
//│ ╔══[ERROR] Type 'T' is already defined.
//│ ║  l.69: 	type T = int
//│ ╙──      	     ^



:e
:ge
type TypeA = int
foo 42
def foo = 1
foo 42
//│ Defined type alias TypeA
//│ ╔══[ERROR] identifier not found: foo
//│ ║  l.82: 	foo 42
//│ ╙──      	^^^
//│ res: error
//│ foo: int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.84: 	foo 42
//│ ║        	^^^^^^
//│ ╟── integer literal of type `int` is not a function
//│ ║  l.83: 	def foo = 1
//│ ║        	          ^
//│ ╟── but it flows into reference with expected type `int -> ?a`
//│ ║  l.84: 	foo 42
//│ ╙──      	^^^
//│ res: nothing





42: TypeA
//│ res: TypeA

:e
type TypeOops = TypeOops
type TypeB = TypeC
def test = fun x -> (x: TypeB)
test 42
type TypeC = TypeA
//│ ╔══[ERROR] illegal cycle involving type TypeOops
//│ ║  l.110: 	type TypeOops = TypeOops
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^
//│ Defined type alias TypeB
//│ Defined type alias TypeC
//│ test: TypeB -> TypeB
//│ res: TypeB




def test = fun (x: TypeB) -> x
//│ test: TypeB -> TypeB



// Note: type alias definitions can contain type variables,
//   which are refreshed on every use (every expansion) of the alias
type Lol = { x: 'a -> 'a }
//│ Defined type alias Lol

:re
error: Lol -> Lol
//│ res: Lol -> Lol

{ x = id } : Lol
//│ res: Lol


:e
type Runaway[A] = Runaway['a]
//│ ╔══[ERROR] illegal cycle involving type Runaway
//│ ║  l.145: 	type Runaway[A] = Runaway['a]
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^^^^^^


:e
type Runaway[A] = 'a -> Runaway['a]
//│ ╔══[ERROR] Type definition is not regular: it occurs within itself as Runaway['a], but is defined as Runaway['A]
//│ ║  l.152: 	type Runaway[A] = 'a -> Runaway['a]
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



type Runaway2 = Lol -> Runaway2
//│ Defined type alias Runaway2

:e
id: Runaway2
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.163: 	id: Runaway2
//│ ║         	^^
//│ ╟── type `{x: ?a -> ?a}` is not a function
//│ ║  l.133: 	type Lol = { x: 'a -> 'a }
//│ ║         	           ^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.159: 	type Runaway2 = Lol -> Runaway2
//│ ║         	                       ^^^^^^^^
//│ ╟── from function type:
//│ ║  l.159: 	type Runaway2 = Lol -> Runaway2
//│ ╙──       	                ^^^^^^^^^^^^^^^
//│ res: Runaway2





:re
error: Runaway2
//│ res: Runaway2

:e
:re
error: {x: int} -> nothing : Runaway2
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.188: 	error: {x: int} -> nothing : Runaway2
//│ ║         	^^^^^
//│ ╟── type `?a -> ?a` is not an instance of `int`
//│ ║  l.133: 	type Lol = { x: 'a -> 'a }
//│ ║         	                ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.188: 	error: {x: int} -> nothing : Runaway2
//│ ╙──       	           ^^^
//│ res: Runaway2




:re
error: {x: 'x -> 'x} -> nothing : Runaway2
//│ res: Runaway2




type A1[A] = A -> A -> A1[A]
type A2[A] = A -> A2[A]
//│ Defined type alias A1[-A]
//│ Defined type alias A2[-A]

def ty1: A1[anything]
def ty2: A2[anything]
//│ ty1: A1[anything]
//│ ty2: A2[anything]

ty1 = ty2
//│ A2[anything]
//│   <:  ty1:
//│ A1[anything]

ty2 = ty1
//│ A1[anything]
//│   <:  ty2:
//│ A2[anything]


