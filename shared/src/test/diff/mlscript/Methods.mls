class Foo[A, B]: { x: A; y: B }
    method Fun[C]: (A -> B -> C) -> (A -> B -> C)
    method Fun[C, D] (f: C -> D) = f
//│ Defined class Foo[=A, =B]
//│ Declared Foo.Fun: Foo['A, 'B] -> ('A -> 'B -> 'C) -> 'A -> 'B -> 'C
//│ Defined Foo.Fun: Foo['A, 'B] -> ('C -> 'D) -> 'C -> 'D

class Bar: Foo[int, bool]
    method Fun f = f
//│ Defined class Bar
//│ Defined Bar.Fun: Bar -> 'a -> 'a

Foo.Fun
Bar.Fun
//│ res: Foo['A, 'B] -> ('A -> 'B -> 'C) -> 'A -> 'B -> 'C
//│ res: Bar -> 'a -> 'a

f = Foo { x = 1; y = 2 }
//│ f: Foo['A, 'B] & {x: int, y: int}
//│   where
//│     'B :> int
//│     'A :> int

f.(Foo.Fun)
//│ res: ((int | 'A) -> (int | 'B) -> 'C) -> 'A -> 'B -> 'C

:re
Foo.Fun f
//│ res: ((int | 'A) -> (int | 'B) -> 'C) -> 'A -> 'B -> 'C

f.Fun
//│ ╔══[ERROR] Implicit call to method Fun is forbidden because it is ambiguous.
//│ ║  l.31: 	f.Fun
//│ ║        	^^^^^
//│ ╟── Unrelated methods named Fun are defined by:
//│ ╟── • class Foo
//│ ║  l.1: 	class Foo[A, B]: { x: A; y: B }
//│ ║       	      ^^^
//│ ╟── • class Bar
//│ ║  l.8: 	class Bar: Foo[int, bool]
//│ ╙──     	      ^^^
//│ res: error

// :d
Bar
//│ res: {x: int & 'x, y: bool & 'y} -> (Bar with {x: 'x, y: 'y})

g = Bar { x = 42; y = true }
//│ g: Bar & {y: true}

g.(Foo.Fun)
g.(Bar.Fun)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.51: 	g.(Foo.Fun)
//│ ║        	^^^^^^^^^^^
//│ ╟── application of type `Bar & {y: ?y}` does not match type `?this`
//│ ║  l.48: 	g = Bar { x = 42; y = true }
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `?this0`
//│ ║  l.51: 	g.(Foo.Fun)
//│ ╙──      	^
//│ res: (int -> bool -> 'C) -> int -> bool -> 'C
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.52: 	g.(Bar.Fun)
//│ ║        	^^^^^^^^^^^
//│ ╟── application of type `Bar & {y: ?y}` is not an instance of type `Foo`
//│ ║  l.48: 	g = Bar { x = 42; y = true }
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Foo[?, ?]`
//│ ║  l.52: 	g.(Bar.Fun)
//│ ║        	^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.8: 	class Bar: Foo[int, bool]
//│ ╙──     	           ^^^^^^^^^^^^^^
//│ res: 'a -> 'a

:re
Foo.Fun g
Bar.Fun g
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.78: 	Foo.Fun g
//│ ║        	^^^^^^^^^
//│ ╟── application of type `Bar & {y: ?y}` is not a 1-element tuple
//│ ║  l.48: 	g = Bar { x = 42; y = true }
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?this,)`
//│ ║  l.78: 	Foo.Fun g
//│ ╙──      	        ^
//│ res: (int -> bool -> 'C) -> int -> bool -> 'C
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	Bar.Fun g
//│ ║        	^^^^^^^^^
//│ ╟── application of type `Bar & {y: ?y}` is not an instance of type `Foo`
//│ ║  l.48: 	g = Bar { x = 42; y = true }
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Foo[?, ?]`
//│ ║  l.79: 	Bar.Fun g
//│ ║        	        ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.8: 	class Bar: Foo[int, bool]
//│ ╙──     	           ^^^^^^^^^^^^^^
//│ res: 'a -> 'a

g.Fun
//│ ╔══[ERROR] Implicit call to method Fun is forbidden because it is ambiguous.
//│ ║  l.104: 	g.Fun
//│ ║         	^^^^^
//│ ╟── Unrelated methods named Fun are defined by:
//│ ╟── • class Foo
//│ ║  l.1: 	class Foo[A, B]: { x: A; y: B }
//│ ║       	      ^^^
//│ ╟── • class Bar
//│ ║  l.8: 	class Bar: Foo[int, bool]
//│ ╙──     	      ^^^
//│ res: error

h = Bar { x = 43; y = true }
h.Fun
//│ h: Bar & {y: true}
//│ ╔══[ERROR] Implicit call to method Fun is forbidden because it is ambiguous.
//│ ║  l.118: 	h.Fun
//│ ║         	^^^^^
//│ ╟── Unrelated methods named Fun are defined by:
//│ ╟── • class Foo
//│ ║  l.1: 	class Foo[A, B]: { x: A; y: B }
//│ ║       	      ^^^
//│ ╟── • class Bar
//│ ║  l.8: 	class Bar: Foo[int, bool]
//│ ╙──     	      ^^^
//│ res: error




class Wrapper[A]: { x: A }
    method Apply f = Wrapper { x = f this.x }
    method Apply[B]: (A -> B) -> Wrapper[B]
    // method Apply f = Wrapper { x = f this.x }
//│ Defined class Wrapper[+A]
//│ Declared Wrapper.Apply: Wrapper['A] -> ('A -> 'B) -> Wrapper['B]
//│ Defined Wrapper.Apply: Wrapper['A] -> ('A -> 'x) -> Wrapper['x]

class IntWrapper: Wrapper[int]
    method Apply f = Wrapper { x = f this.x }
//│ Defined class IntWrapper
//│ Defined IntWrapper.Apply: IntWrapper -> (nothing -> 'x) -> Wrapper['x]

class Psyduck[B]: Wrapper[B]
    method Apply[A]: (B -> A) -> Psyduck[A]
    method Apply f = Psyduck { x = f this.x }
//│ ╔══[ERROR] Type mismatch in method declaration:
//│ ║  l.149: 	    method Apply[A]: (B -> A) -> Psyduck[A]
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Psyduck[?A]` is not an instance of `Wrapper[B]`
//│ ║  l.149: 	    method Apply[A]: (B -> A) -> Psyduck[A]
//│ ║         	                                 ^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.137: 	    method Apply[B]: (A -> B) -> Wrapper[B]
//│ ╙──       	                                 ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.150: 	    method Apply f = Psyduck { x = f this.x }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Psyduck[?B] & {x: ?x}` is not an instance of type `Wrapper`
//│ ║  l.150: 	    method Apply f = Psyduck { x = f this.x }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.149: 	    method Apply[A]: (B -> A) -> Psyduck[A]
//│ ║         	                                 ^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.148: 	class Psyduck[B]: Wrapper[B]
//│ ╙──       	                  ^^^^^^^^^^
//│ Defined class Psyduck[+B]
//│ Declared Psyduck.Apply: Psyduck['B] -> ('B -> 'A) -> Psyduck['A]
//│ Defined Psyduck.Apply: Psyduck[?] -> (nothing -> 'x) -> Psyduck['x]

class WrapperWrapper[A]: Wrapper[Wrapper[A]]
    method Apply2[B]: (A -> B) -> WrapperWrapper[B]
    method Apply2 f = WrapperWrapper { x = this.x.Apply f }
//│ ╔══[ERROR] Implicit call to method Apply is forbidden because it is ambiguous.
//│ ║  l.178: 	    method Apply2 f = WrapperWrapper { x = this.x.Apply f }
//│ ║         	                                           ^^^^^^^^^^^^
//│ ╟── Unrelated methods named Apply are defined by:
//│ ╟── • class Wrapper
//│ ║  l.135: 	class Wrapper[A]: { x: A }
//│ ║         	      ^^^^^^^
//│ ╟── • class IntWrapper
//│ ║  l.143: 	class IntWrapper: Wrapper[int]
//│ ║         	      ^^^^^^^^^^
//│ ╟── • class Psyduck
//│ ║  l.148: 	class Psyduck[B]: Wrapper[B]
//│ ╙──       	      ^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.178: 	    method Apply2 f = WrapperWrapper { x = this.x.Apply f }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `WrapperWrapper[?A] & {x: ?x}` is not an instance of type `Wrapper`
//│ ║  l.178: 	    method Apply2 f = WrapperWrapper { x = this.x.Apply f }
//│ ║         	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.177: 	    method Apply2[B]: (A -> B) -> WrapperWrapper[B]
//│ ║         	                                  ^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.176: 	class WrapperWrapper[A]: Wrapper[Wrapper[A]]
//│ ╙──       	                         ^^^^^^^^^^^^^^^^^^^
//│ Defined class WrapperWrapper[+A]
//│ Declared WrapperWrapper.Apply2: WrapperWrapper['A] -> ('A -> 'B) -> WrapperWrapper['B]
//│ Defined WrapperWrapper.Apply2: WrapperWrapper[?] -> anything -> (WrapperWrapper[error] with {x: error})

WrapperWrapper { x = Psyduck { x = 0 } }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.208: 	WrapperWrapper { x = Psyduck { x = 0 } }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Psyduck[?B] & {Psyduck#B = ?B, x: ?x}` is not an instance of type `Wrapper`
//│ ║  l.208: 	WrapperWrapper { x = Psyduck { x = 0 } }
//│ ║         	                     ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.176: 	class WrapperWrapper[A]: Wrapper[Wrapper[A]]
//│ ╙──       	                                 ^^^^^^^^^^
//│ res: WrapperWrapper[int] with {x: Psyduck[int]}

res.Apply2 (fun x -> mul x 2)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.220: 	res.Apply2 (fun x -> mul x 2)
//│ ║         	^^^^^^^^^^
//│ ╟── application of type `WrapperWrapper[?A] & {WrapperWrapper#A = ?A, x: ?x}` is not an instance of type `Wrapper`
//│ ║  l.208: 	WrapperWrapper { x = Psyduck { x = 0 } }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Wrapper[?]`
//│ ║  l.220: 	res.Apply2 (fun x -> mul x 2)
//│ ║         	^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.176: 	class WrapperWrapper[A]: Wrapper[Wrapper[A]]
//│ ╙──       	                         ^^^^^^^^^^^^^^^^^^^
//│ res: WrapperWrapper[int]

Wrapper
//│ res: {x: 'x} -> Wrapper['x]




class Asc[A, B]: { x: A; y: B }
    method Left = { x = this.x; y = this.y } : { x: A }
    method Right2 = this : { y: B }
//│ Defined class Asc[+A, +B]
//│ Defined Asc.Left: Asc['A, ?] -> {x: 'A}
//│ Defined Asc.Right2: Asc[?, 'B] -> {y: 'B}




class Simple[A]
    method Get: A
//│ Defined class Simple[+A]
//│ Declared Simple.Get: Simple['A] -> 'A

class Simple2[A]: { a: A }
    method Get: A
//│ Defined class Simple2[+A]
//│ Declared Simple2.Get: Simple2['A] -> 'A




class AbstractPair[A, B]: { x: A; y: B }
    method Test: (A -> B -> bool) -> bool
    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ Defined class AbstractPair[+A, +B]
//│ Declared AbstractPair.Test: AbstractPair['A, 'B] -> ('A -> 'B -> bool) -> bool
//│ Declared AbstractPair.Map: AbstractPair['A, 'B] -> ('A -> 'C) -> ('B -> 'D) -> AbstractPair['C, 'D]

class Pair[A, B]: AbstractPair[A, B]
    method Test(f: A -> B -> bool) = f this.x this.y
    method Map fx fy = Pair { x = fx this.x; y = fy this.y }
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.273: 	    method Map fx fy = Pair { x = fx this.x; y = fy this.y }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Pair[?A, ?B] & {x: ?x, y: ?y}` does not match type `AbstractPair[?, ?] & {x: C, y: D}`
//│ ║  l.273: 	    method Map fx fy = Pair { x = fx this.x; y = fy this.y }
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.266: 	    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ ╙──       	                                              ^^^^^^^^^^^^^^^^^^
//│ Defined class Pair[+A, +B]
//│ Defined Pair.Test: Pair['A, 'B] -> ('A -> 'B -> bool) -> bool
//│ Defined Pair.Map: Pair[?, ?] -> (nothing -> 'x) -> (nothing -> 'y) -> Pair['x, 'y]

class Tru[A, B]: Pair[A, B]
    method Test f = true
    method True = this.Test (fun x -> error)
//│ ╔══[ERROR] Type mismatch in inherited method definition:
//│ ║  l.273: 	    method Map fx fy = Pair { x = fx this.x; y = fy this.y }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Pair[?A, ?B] & {Pair#A = ?A, Pair#B = ?B, x: ?x, y: ?y}` does not match type `AbstractPair[?, ?] & {x: C, y: D}`
//│ ║  l.273: 	    method Map fx fy = Pair { x = fx this.x; y = fy this.y }
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.266: 	    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ ╙──       	                                              ^^^^^^^^^^^^^^^^^^
//│ Defined class Tru[+A, +B]
//│ Defined Tru.Test: Tru[?, ?] -> anything -> true
//│ Defined Tru.True: Tru[?, ?] -> true

class True2[A, B]: Pair[A, B]
    method Test: anything -> bool
    method True = this.Test (fun x -> error)
    method Test f = true
//│ ╔══[ERROR] Type mismatch in inherited method definition:
//│ ║  l.273: 	    method Map fx fy = Pair { x = fx this.x; y = fy this.y }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Pair[?A, ?B] & {Pair#A = ?A, Pair#B = ?B, x: ?x, y: ?y}` does not match type `AbstractPair[?, ?] & {x: C, y: D}`
//│ ║  l.273: 	    method Map fx fy = Pair { x = fx this.x; y = fy this.y }
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.266: 	    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ ╙──       	                                              ^^^^^^^^^^^^^^^^^^
//│ Defined class True2[+A, +B]
//│ Declared True2.Test: True2[?, ?] -> anything -> bool
//│ Defined True2.True: True2[?, ?] -> bool
//│ Defined True2.Test: True2[?, ?] -> anything -> true

p = Pair { x = 42; y = true }
fx = fun x -> mul x 2
fy = fun x -> not x
ft = fun x -> fun y -> if (y) then gt x 0 else y
//│ p: Pair[int, true]
//│ fx: int -> int
//│ fy: bool -> bool
//│ ft: int -> bool -> bool

p.Map fx fy
p.Test ft
(p.Map fx fy).Test ft
//│ ╔══[ERROR] Implicit call to method Map is forbidden because it is ambiguous.
//│ ║  l.330: 	p.Map fx fy
//│ ║         	^^^^^
//│ ╟── Unrelated methods named Map are defined by:
//│ ╟── • class AbstractPair
//│ ║  l.264: 	class AbstractPair[A, B]: { x: A; y: B }
//│ ║         	      ^^^^^^^^^^^^
//│ ╟── • class Pair
//│ ║  l.271: 	class Pair[A, B]: AbstractPair[A, B]
//│ ╙──       	      ^^^^
//│ res: error
//│ ╔══[ERROR] Implicit call to method Test is forbidden because it is ambiguous.
//│ ║  l.331: 	p.Test ft
//│ ║         	^^^^^^
//│ ╟── Unrelated methods named Test are defined by:
//│ ╟── • class AbstractPair
//│ ║  l.264: 	class AbstractPair[A, B]: { x: A; y: B }
//│ ║         	      ^^^^^^^^^^^^
//│ ╟── • class Pair
//│ ║  l.271: 	class Pair[A, B]: AbstractPair[A, B]
//│ ║         	      ^^^^
//│ ╟── • class Tru
//│ ║  l.287: 	class Tru[A, B]: Pair[A, B]
//│ ║         	      ^^^
//│ ╟── • class True2
//│ ║  l.303: 	class True2[A, B]: Pair[A, B]
//│ ╙──       	      ^^^^^
//│ res: error
//│ ╔══[ERROR] Implicit call to method Test is forbidden because it is ambiguous.
//│ ║  l.332: 	(p.Map fx fy).Test ft
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── Unrelated methods named Test are defined by:
//│ ╟── • class AbstractPair
//│ ║  l.264: 	class AbstractPair[A, B]: { x: A; y: B }
//│ ║         	      ^^^^^^^^^^^^
//│ ╟── • class Pair
//│ ║  l.271: 	class Pair[A, B]: AbstractPair[A, B]
//│ ║         	      ^^^^
//│ ╟── • class Tru
//│ ║  l.287: 	class Tru[A, B]: Pair[A, B]
//│ ║         	      ^^^
//│ ╟── • class True2
//│ ║  l.303: 	class True2[A, B]: Pair[A, B]
//│ ╙──       	      ^^^^^
//│ ╔══[ERROR] Implicit call to method Map is forbidden because it is ambiguous.
//│ ║  l.332: 	(p.Map fx fy).Test ft
//│ ║         	 ^^^^^
//│ ╟── Unrelated methods named Map are defined by:
//│ ╟── • class AbstractPair
//│ ║  l.264: 	class AbstractPair[A, B]: { x: A; y: B }
//│ ║         	      ^^^^^^^^^^^^
//│ ╟── • class Pair
//│ ║  l.271: 	class Pair[A, B]: AbstractPair[A, B]
//│ ╙──       	      ^^^^
//│ res: error

t = Tru { x = "foo"; y = false }
t.(Tru.True)
//│ t: Tru[string, false]
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.390: 	t.(Tru.True)
//│ ║         	^^^^^^^^^^^^
//│ ╟── application of type `Tru[?A, ?B] & {Tru#A = ?A, Tru#B = ?B, x: ?x, y: ?y}` is not an instance of type `Pair`
//│ ║  l.389: 	t = Tru { x = "foo"; y = false }
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Pair[?, ?]`
//│ ║  l.390: 	t.(Tru.True)
//│ ║         	^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.287: 	class Tru[A, B]: Pair[A, B]
//│ ╙──       	                 ^^^^^^^^^^
//│ res: true

t = True2 { x = "bar"; y = false }
t.(True2.True)
//│ t: True2[string, false]
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.407: 	t.(True2.True)
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── application of type `True2[?A, ?B] & {True2#A = ?A, True2#B = ?B, x: ?x, y: ?y}` is not an instance of type `Pair`
//│ ║  l.406: 	t = True2 { x = "bar"; y = false }
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Pair[?, ?]`
//│ ║  l.407: 	t.(True2.True)
//│ ║         	^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.303: 	class True2[A, B]: Pair[A, B]
//│ ╙──       	                   ^^^^^^^^^^
//│ res: bool


class Class1A[A]
    method MtdA: A
trait Trait1A[B]
    method MtdA: B
class Class1B: Class1A["a" | "b"] & Trait1A["b" | "c"]
    method MtdA = "b"
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.429: 	    method MtdA = "b"
//│ ║         	           ^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `"a" | "b"`
//│ ║  l.429: 	    method MtdA = "b"
//│ ║         	                  ^^^
//│ ╟── but it flows into method definition with expected type `"a" | "b"`
//│ ║  l.429: 	    method MtdA = "b"
//│ ║         	           ^^^^^^^^^^
//│ ╟── Note: constraint arises from inherited method declaration:
//│ ║  l.425: 	    method MtdA: A
//│ ║         	           ^^^^^^^
//│ ╟── from union type:
//│ ║  l.428: 	class Class1B: Class1A["a" | "b"] & Trait1A["b" | "c"]
//│ ╙──       	                       ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.429: 	    method MtdA = "b"
//│ ║         	           ^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `"b" | "c"`
//│ ║  l.429: 	    method MtdA = "b"
//│ ║         	                  ^^^
//│ ╟── but it flows into method definition with expected type `"b" | "c"`
//│ ║  l.429: 	    method MtdA = "b"
//│ ║         	           ^^^^^^^^^^
//│ ╟── Note: constraint arises from inherited method declaration:
//│ ║  l.425: 	    method MtdA: A
//│ ║         	           ^^^^^^^
//│ ╟── from union type:
//│ ║  l.428: 	class Class1B: Class1A["a" | "b"] & Trait1A["b" | "c"]
//│ ╙──       	                                            ^^^^^^^^^
//│ Defined class Class1A[+A]
//│ Declared Class1A.MtdA: Class1A['A] -> 'A
//│ Defined trait Trait1A[+B]
//│ Declared Trait1A.MtdA: Trait1A['B] -> 'B
//│ Defined class Class1B
//│ Defined Class1B.MtdA: Class1B -> string


trait Trait2A[A]
    method MtdB: A
class Class2B[A, B]: Class1A[A] & Trait2A[B]
    method MtdA: A
    method MtdB: B
class Class2C: Class2B[int, bool]
    method MtdA = 42
    method MtdB = true
//│ Defined trait Trait2A[+A]
//│ Declared Trait2A.MtdB: Trait2A['A] -> 'A
//│ Defined class Class2B[+A, +B]
//│ Declared Class2B.MtdA: Class2B['A, ?] -> 'A
//│ Declared Class2B.MtdB: Class2B[?, 'B] -> 'B
//│ Defined class Class2C
//│ Defined Class2C.MtdA: Class2C -> int
//│ Defined Class2C.MtdB: Class2C -> true


:e
class Class3C: Class2C
    method MtdA = 42
    method MtdB = 42
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.489: 	    method MtdB = 42
//│ ║         	           ^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `bool`
//│ ║  l.489: 	    method MtdB = 42
//│ ║         	                  ^^
//│ ╟── but it flows into method definition with expected type `bool`
//│ ║  l.489: 	    method MtdB = 42
//│ ║         	           ^^^^^^^^^
//│ ╟── Note: constraint arises from inherited method declaration:
//│ ║  l.472: 	    method MtdB: B
//│ ║         	           ^^^^^^^
//│ ╟── from type reference:
//│ ║  l.473: 	class Class2C: Class2B[int, bool]
//│ ╙──       	                            ^^^^
//│ Defined class Class3C
//│ Defined Class3C.MtdA: Class3C -> int
//│ Defined Class3C.MtdB: Class3C -> int






type Id[T] = T
class Test1[A]: { x: A }
    method F: A
class Test2[B]: Test1[Id[B]] & { x: B }
    method F = this.x
//│ Defined type alias Id[+T]
//│ Defined class Test1[+A]
//│ Declared Test1.F: Test1['A] -> 'A
//│ Defined class Test2[+B]
//│ Defined Test2.F: Test2[?] -> nothing


class Test3A: Test1['a -> 'a]
Test3A.F
//│ Defined class Test3A
//│ res: Test3A -> 'a -> 'a

class Test3B: Test1['a -> 'a] & { x: 'a }
Test3B.F
//│ Defined class Test3B
//│ res: Test3B -> 'a -> 'a



:w
class Test4A[A]: { x: A }
    method Mth4A[A]: A
//│ ╔══[WARNING] Method type parameter A
//│ ║  l.539: 	class Test4A[A]: { x: A }
//│ ║         	             ^
//│ ╟── shadows class type parameter A
//│ ║  l.540: 	    method Mth4A[A]: A
//│ ╙──       	                 ^
//│ Defined class Test4A[+A]
//│ Declared Test4A.Mth4A: Test4A[?] -> nothing




class Test[A]: { x: A }
    method Mth[B]: (A -> B) -> B
    method Mth[B] (f: A -> B) = f this.x
//│ Defined class Test[+A]
//│ Declared Test.Mth: Test['A] -> ('A -> 'B) -> 'B
//│ Defined Test.Mth: Test['A] -> ('A -> 'B) -> 'B



trait D
  method G = 1
trait E
  method G: int
class H: D & E
//│ Defined trait D
//│ Defined D.G: D -> int
//│ Defined trait E
//│ Declared E.G: E -> int
//│ Defined class H

((H{}): D).(D.G)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.573: 	((H{}): D).(D.G)
//│ ║         	 ^^^^^
//│ ╟── application of type `H` is not an instance of `D`
//│ ║  l.573: 	((H{}): D).(D.G)
//│ ║         	  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.573: 	((H{}): D).(D.G)
//│ ║         	        ^
//│ ╟── Note: class H is defined at:
//│ ║  l.566: 	class H: D & E
//│ ╙──       	      ^
//│ res: int



class Fee
    method F: 1 | 2
//│ Defined class Fee
//│ Declared Fee.F: Fee -> (1 | 2)

trait Fee2
    method F: 2 | 3
//│ Defined trait Fee2
//│ Declared Fee2.F: Fee2 -> (2 | 3)

class Ber: Fee & Fee2
//│ Defined class Ber

Ber.F
//│ res: Ber -> 2

:e
Ber
//│ ╔══[ERROR] Instantiation of an abstract type is forbidden
//│ ║  l.607: 	Ber
//│ ║         	^^^
//│ ╟── Note that class Ber is abstract:
//│ ║  l.600: 	class Ber: Fee & Fee2
//│ ║         	      ^^^^^^^^^^^^^^^
//│ ╟── Hint: method F is abstract
//│ ║  l.600: 	class Ber: Fee & Fee2
//│ ╙──       	      ^^^^^^^^^^^^^^^
//│ res: error







class Test5A[A]: { a: A }
    method Mth5A[B]: (A -> B) -> B
//│ Defined class Test5A[+A]
//│ Declared Test5A.Mth5A: Test5A['A] -> ('A -> 'B) -> 'B


trait Test5B: { tag: int }
    method Mth5B = this.tag
//│ Defined trait Test5B
//│ Defined Test5B.Mth5B: Test5B -> int


class Test5C[A]: Test5A[A] & Test5B
    method Mth5A f = case this.Mth5B of { 0 -> f this.a | _ -> f this.a }
//│ Defined class Test5C[+A]
//│ Defined Test5C.Mth5A: Test5C[?] -> (nothing -> 'a) -> 'a


class Test5D: Test5A[int] & Test5B
    method Mth5A f = case this.Mth5B of { 0 -> f this.a | _ -> f this.Mth5B }
//│ Defined class Test5D
//│ Defined Test5D.Mth5A: Test5D -> (int -> 'a) -> 'a




class Test6A: { a: int }
    method Add (that: Test6A) = Test6A { a = this.a + that.a }
//│ Defined class Test6A
//│ Defined Test6A.Add: Test6A -> Test6A -> Test6A

class Test6B: { a: Test6A; b: Test6A }
    method Add (that: Test6B) = Test6B { a = this.a.(Test6A.Add) that.a; b = this.b.(Test6A.Add) that.b }
//│ Defined class Test6B
//│ Defined Test6B.Add: Test6B -> Test6B -> Test6B

class Test6C: Test6B
//│ Defined class Test6C




trait Test7A
    method Mth7A: int
    method Mth7A = 0
//│ Defined trait Test7A
//│ Declared Test7A.Mth7A: Test7A -> int
//│ Defined Test7A.Mth7A: Test7A -> int

trait Test7B
    method Mth7A: int
//│ Defined trait Test7B
//│ Declared Test7B.Mth7A: Test7B -> int

class Test7C: Test7A & Test7B
    method Mth7A = 42
//│ Defined class Test7C
//│ Defined Test7C.Mth7A: Test7C -> int
