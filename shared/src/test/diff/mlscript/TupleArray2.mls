
:e
(1,2): (2,1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.3: 	(1,2): (2,1)
//│ ║       	^^^^^
//│ ╟── integer literal of type `int` does not match type `2`
//│ ║  l.3: 	(1,2): (2,1)
//│ ║       	 ^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.3: 	(1,2): (2,1)
//│ ╙──     	        ^
//│ res: (2, 1,)




:e
// FIXME
(1,2): (2,1,0)
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: last of empty list



:e
(1,2) with { x = 1 } : (2,1,0)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.26: 	(1,2) with { x = 1 } : (2,1,0)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── `with` extension of type `(int, int,) & {x: int}` is not a 3-element tuple
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.26: 	(1,2) with { x = 1 } : (2,1,0)
//│ ╙──      	                       ^^^^^^^
//│ res: (2, 1, 0,)



trait T
//│ Defined trait T

:e
(1,2) with { x = 1 } : (2,1,0) | t
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.42: 	(1,2) with { x = 1 } : (2,1,0) | t
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── `with` extension of type `(int, int,) & {x: int}` does not match type `(2, 1, 0,) | #T`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.42: 	(1,2) with { x = 1 } : (2,1,0) | t
//│ ╙──      	                       ^^^^^^^^^^^
//│ res: (2, 1, 0,) | #T



:e
(1,2) with { x = 1 } : (2,1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.55: 	(1,2) with { x = 1 } : (2,1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `2`
//│ ║  l.55: 	(1,2) with { x = 1 } : (2,1)
//│ ║        	 ^
//│ ╟── but it flows into `with` extension with expected type `2`
//│ ║  l.55: 	(1,2) with { x = 1 } : (2,1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.55: 	(1,2) with { x = 1 } : (2,1)
//│ ║        	                       ^^^^^
//│ ╟── from literal type:
//│ ║  l.55: 	(1,2) with { x = 1 } : (2,1)
//│ ╙──      	                        ^
//│ res: (2, 1,)




(1,2) with { x = 1 } : (1,2)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.76: 	(1,2) with { x = 1 } : (1,2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `1`
//│ ║  l.76: 	(1,2) with { x = 1 } : (1,2)
//│ ║        	 ^
//│ ╟── but it flows into `with` extension with expected type `1`
//│ ║  l.76: 	(1,2) with { x = 1 } : (1,2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.76: 	(1,2) with { x = 1 } : (1,2)
//│ ║        	                       ^^^^^
//│ ╟── from literal type:
//│ ║  l.76: 	(1,2) with { x = 1 } : (1,2)
//│ ╙──      	                        ^
//│ res: (1, 2,)


:re
error: (1,2) & t | Array[3]
//│ res: (1, 2,) & #T | Array[3]


def arr: Array[1]
//│ arr: Array[1]

arr: Array[2] | (1, 1)
//│ res: Array[1 | 2]

arr: Array[2] | (1, 2)
//│ res: Array[1 | 2]

:e
arr: Array[2] & t | (1, 1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.110: 	arr: Array[2] & t | (1, 1)
//│ ║         	^^^
//│ ╟── type `Array[1]` does not match type `(1, 1,) | Array[2] & #T`
//│ ║  l.100: 	def arr: Array[1]
//│ ║         	         ^^^^^^^^
//│ ╟── but it flows into reference with expected type `(1, 1,) | Array[2] & #T`
//│ ║  l.110: 	arr: Array[2] & t | (1, 1)
//│ ║         	^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.110: 	arr: Array[2] & t | (1, 1)
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^^^
//│ res: (1, 1,) | Array[2] & #T





def arrt: Array[1] & t
//│ arrt: Array[1] & #T

arrt: Array[2] & t | (1, 1)
//│ res: (1, 1,) | Array[2] & #T


def f_1: 'a -> (Array['a] & t)
//│ f_1: 'a -> (Array['a] & #T)

def f_2: 'a -> (Array['a] & t | (1,))
//│ f_2: 'a -> ((1,) | Array['a] & #T)

:e
f_1 = f_2
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.143: 	f_1 = f_2
//│ ║         	^^^^^^^^^
//│ ╟── type `1` is not an instance of type `'a`
//│ ║  l.139: 	def f_2: 'a -> (Array['a] & t | (1,))
//│ ║         	                                 ^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.136: 	def f_1: 'a -> (Array['a] & t)
//│ ╙──       	                      ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.143: 	f_1 = f_2
//│ ║         	^^^^^^^^^
//│ ╟── type `(1,)` is not an instance of type `T`
//│ ║  l.139: 	def f_2: 'a -> (Array['a] & t | (1,))
//│ ║         	                                ^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.136: 	def f_1: 'a -> (Array['a] & t)
//│ ║         	               ^^^^^^^^^^^^^^^
//│ ╟── from trait tag:
//│ ║  l.136: 	def f_1: 'a -> (Array['a] & t)
//│ ╙──       	                            ^
//│ 'a -> ((1,) | Array['a] & #T)
//│   <:  f_1:
//│ 'a -> (Array['a] & #T)








f_2 = f_1
//│ 'a -> (Array['a] & #T)
//│   <:  f_2:
//│ 'a -> ((1,) | Array['a] & #T)



def test: (string, 1) & { _1: "hello" }
//│ test: ("hello", 1,)

:e
test = ("hi", 1)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.187: 	test = ("hi", 1)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `1`
//│ ║  l.187: 	test = ("hi", 1)
//│ ║         	              ^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.183: 	def test: (string, 1) & { _1: "hello" }
//│ ╙──       	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.187: 	test = ("hi", 1)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `"hello"`
//│ ║  l.187: 	test = ("hi", 1)
//│ ║         	        ^^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.183: 	def test: (string, 1) & { _1: "hello" }
//│ ╙──       	                              ^^^^^^^
//│ (string, int,)
//│   <:  test:
//│ ("hello", 1,)




test = ("hello", 1)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.213: 	test = ("hello", 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `1`
//│ ║  l.213: 	test = ("hello", 1)
//│ ║         	                 ^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.183: 	def test: (string, 1) & { _1: "hello" }
//│ ╙──       	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.213: 	test = ("hello", 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `"hello"`
//│ ║  l.213: 	test = ("hello", 1)
//│ ║         	        ^^^^^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.183: 	def test: (string, 1) & { _1: "hello" }
//│ ╙──       	                              ^^^^^^^
//│ (string, int,)
//│   <:  test:
//│ ("hello", 1,)

(fun ((a, b)) -> a) test
//│ res: string

test: { _1: 'a }
//│ res: {_1: "hello"}

test: ('a, 1)
//│ res: (string, 1,)

:e
class A: (1,2)
//│ ╔══[ERROR] cannot inherit from a tuple type
//│ ║  l.246: 	class A: (1,2)
//│ ╙──       	      ^^^^^^^^



:re
error: Array[1] & { _1: int }
//│ res: Array[1] & {_1: int}
