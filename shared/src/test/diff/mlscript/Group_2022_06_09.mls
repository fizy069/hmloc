
class Exp
//│ Defined class Exp

class Lit: { n: int } & Exp
class Add: { lhs: Exp; rhs: Exp } & Exp
//│ Defined class Lit
//│ Defined class Add

rec def eval e = case e of {
  | Lit -> e.n
  | Add -> eval e.lhs + eval e.rhs
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.12: 	  | Add -> eval e.lhs + eval e.rhs
//│ ║        	           ^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.12: 	  | Add -> eval e.lhs + eval e.rhs
//│ ╙──      	           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.12: 	  | Add -> eval e.lhs + eval e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.12: 	  | Add -> eval e.lhs + eval e.rhs
//│ ╙──      	                        ^^^^^^^^^^
//│ eval: 'a -> (int | 'n)
//│   where
//│     'a <: (Add with {lhs: 'a, rhs: 'a}) | (Lit with {n: 'n})

e = Add { lhs = Lit {n=1}; rhs = Lit {n=2} }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.30: 	e = Add { lhs = Lit {n=1}; rhs = Lit {n=2} }
//│ ║        	                ^^^^^^^^^
//│ ╟── argument of type `({n: int},)` does not have field 'n'
//│ ║  l.30: 	e = Add { lhs = Lit {n=1}; rhs = Lit {n=2} }
//│ ╙──      	                    ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.30: 	e = Add { lhs = Lit {n=1}; rhs = Lit {n=2} }
//│ ║        	                                 ^^^^^^^^^
//│ ╟── argument of type `({n: int},)` does not have field 'n'
//│ ║  l.30: 	e = Add { lhs = Lit {n=1}; rhs = Lit {n=2} }
//│ ╙──      	                                     ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.30: 	e = Add { lhs = Lit {n=1}; rhs = Lit {n=2} }
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.30: 	e = Add { lhs = Lit {n=1}; rhs = Lit {n=2} }
//│ ╙──      	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ e: Add & {lhs: nothing, rhs: nothing}

eval e
//│ res: int


class Neg: { e: Exp } & Exp
//│ Defined class Neg

e2 = Neg { e }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.58: 	e2 = Neg { e }
//│ ║        	     ^^^^^^^^^
//│ ╟── argument of type `({e: ?a},)` does not have field 'e'
//│ ║  l.58: 	e2 = Neg { e }
//│ ╙──      	         ^^^^^
//│ e2: Neg & {e: nothing}

e2.e.lhs.n
//│ res: nothing

:e
eval e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.71: 	eval e2
//│ ║        	^^^^^^^
//│ ╟── application of type `Neg & {e: ?e}` does not match type `Add & ?a | Lit & ?b`
//│ ║  l.58: 	e2 = Neg { e }
//│ ║        	     ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Add & ?c | Lit & ?d`
//│ ║  l.71: 	eval e2
//│ ║        	     ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.10: 	rec def eval e = case e of {
//│ ╙──      	                      ^
//│ res: int






def eval eval e = case e of {
  | Lit -> e.n
  | Add -> eval eval e.lhs + eval eval e.rhs
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.93: 	  | Add -> eval eval e.lhs + eval eval e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.93: 	  | Add -> eval eval e.lhs + eval eval e.rhs
//│ ╙──      	           ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.93: 	  | Add -> eval eval e.lhs + eval eval e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.93: 	  | Add -> eval eval e.lhs + eval eval e.rhs
//│ ╙──      	                             ^^^^^^^^^^^^^^^
//│ eval: ('a -> 'rhs -> anything & 'a) -> ((Add with {lhs: 'rhs, rhs: 'rhs}) | (Lit with {n: 'n})) -> (int | 'n)

eval eval e
//│ res: int


def evalN evalN e = case e of {
  | Neg -> 0 - evalN evalN e.e
  | _ -> eval evalN e
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.114: 	  | Neg -> 0 - evalN evalN e.e
//│ ║         	           ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.114: 	  | Neg -> 0 - evalN evalN e.e
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.114: 	  | Neg -> 0 - evalN evalN e.e
//│ ║         	           ^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.114: 	  | Neg -> 0 - evalN evalN e.e
//│ ╙──       	               ^^^^^^^^^^^^^^^
//│ evalN: ('a -> 'rhs -> anything & 'a) -> ((Add with {lhs: 'rhs, rhs: 'rhs}) | (Lit with {n: 'b}) | (Neg with {e: 'rhs})) -> (int | 'b)

evalN eval e
//│ res: int

evalN eval e2
//│ res: int

ev = evalN evalN
//│ ev: ((Add with {lhs: 'a, rhs: 'a}) | (Lit with {n: 'b}) | (Neg with {e: 'a})) -> (int | 'b)
//│   where
//│     'a <: (Add with {lhs: 'a, rhs: 'a}) | Lit | (Neg with {e: 'a})

(ev e, ev e2)
//│ res: (int, int,)


e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.146: 	e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ ║         	                           ^^^^^^^^^
//│ ╟── argument of type `({n: int},)` does not have field 'n'
//│ ║  l.146: 	e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ ╙──       	                               ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.146: 	e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ ║         	                 ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({e: ?a},)` does not have field 'e'
//│ ║  l.146: 	e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ ╙──       	                     ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.146: 	e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ ║         	                                              ^^^^^^^^^
//│ ╟── argument of type `({n: int},)` does not have field 'n'
//│ ║  l.146: 	e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ ╙──       	                                                  ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.146: 	e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.146: 	e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ ╙──       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ e3: Add & {lhs: nothing, rhs: nothing}

ev e3
//│ res: int


// * With a continuation, to make `evalN` not need to mention `eval` at all:

def evalN evalN k e = case e of {
  | Neg -> 0 - evalN evalN k e.e
  | _ -> k e
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.180: 	  | Neg -> 0 - evalN evalN k e.e
//│ ║         	           ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.180: 	  | Neg -> 0 - evalN evalN k e.e
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.180: 	  | Neg -> 0 - evalN evalN k e.e
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.180: 	  | Neg -> 0 - evalN evalN k e.e
//│ ╙──       	               ^^^^^^^^^^^^^^^^^
//│ evalN: ('a -> 'b -> 'e -> anything & 'a) -> ('c -> 'd & 'b) -> ((Neg with {e: 'e}) | 'c & ~#Neg) -> (int | 'd)


def evalComposed evalComposed = evalN evalN (fun e -> eval evalComposed e)
//│ evalComposed: ('a -> 'rhs -> anything & 'a) -> 'b -> (int | 'c)
//│   where
//│     'b <: (Add with {lhs: 'rhs, rhs: 'rhs}) | (Lit with {n: 'c}) | (Neg with {e: 'b})

def evalComposed evalComposed = evalN evalN (eval evalComposed)
//│ evalComposed: ('a -> 'rhs -> anything & 'a) -> 'b -> (int | 'c)
//│   where
//│     'b <: (Add with {lhs: 'rhs, rhs: 'rhs}) | (Lit with {n: 'c}) | (Neg with {e: 'b})


// * NOTE: This inferred type is a good example
// *    of the need for an algorithm to tie recursive TV knots and inline the rest;
// *    once we inline, `b` we should get the expected simplified recursive type.
ev2 = evalComposed evalComposed
//│ ev2: 'a -> (int | 'b)
//│   where
//│     'a <: (Add with {lhs: 'c, rhs: 'c}) | (Lit with {n: 'b}) | (Neg with {e: 'a})
//│     'c <: (Neg with {e: 'c}) | ((Add with {lhs: 'c, rhs: 'c}) | Lit) & ~#Neg

ev2 e3
//│ res: int


def ev2_ty: (Add & { lhs: 'a; rhs: 'a } | Lit | Neg & { e: 'a } as 'a) -> int
//│ ev2_ty: 'a -> int
//│   where
//│     'a <: (Add with {lhs: 'a, rhs: 'a}) | Lit | (Neg with {e: 'a})

ev2_ty = ev2
//│ 'a -> (int | 'b)
//│   where
//│     'a <: (Add with {lhs: 'c, rhs: 'c}) | (Lit with {n: 'b}) | (Neg with {e: 'a})
//│     'c <: (Neg with {e: 'c}) | ((Add with {lhs: 'c, rhs: 'c}) | Lit) & ~#Neg
//│   <:  ev2_ty:
//│ 'a -> int
//│   where
//│     'a <: (Add with {lhs: 'a, rhs: 'a}) | Lit | (Neg with {e: 'a})

