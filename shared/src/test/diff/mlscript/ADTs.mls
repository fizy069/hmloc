
class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
class Nega[E]: { arg: E }
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
def nega arg = Nega { arg }
//│ Defined class Lit
//│ Defined class Add[+E]
//│ Defined class Nega[+E]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.5: 	def lit val = Lit { val }
//│ ║       	              ^^^^^^^^^^^
//│ ╟── argument of type `({val: ?a},)` does not have field 'val'
//│ ║  l.5: 	def lit val = Lit { val }
//│ ╙──     	                  ^^^^^^^
//│ lit: anything -> (Lit & {val: nothing})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.6: 	def add lhs rhs = Add { lhs; rhs }
//│ ║       	                  ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.6: 	def add lhs rhs = Add { lhs; rhs }
//│ ╙──     	                      ^^^^^^^^^^^^
//│ add: anything -> anything -> Add[nothing]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.7: 	def nega arg = Nega { arg }
//│ ║       	               ^^^^^^^^^^^^
//│ ╟── argument of type `({arg: ?a},)` does not have field 'arg'
//│ ║  l.7: 	def nega arg = Nega { arg }
//│ ╙──     	                    ^^^^^^^
//│ nega: anything -> Nega[nothing]

rec def evalStub1 e = case e of {
  Lit -> e.val
  }
//│ evalStub1: (Lit with {val: 'val}) -> 'val

rec def evalStub2 e = case e of {
  Lit -> e.val | Nega -> 0 - (evalStub2 e.arg)
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.39: 	  Lit -> e.val | Nega -> 0 - (evalStub2 e.arg)
//│ ║        	                         ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.39: 	  Lit -> e.val | Nega -> 0 - (evalStub2 e.arg)
//│ ╙──      	                         ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.39: 	  Lit -> e.val | Nega -> 0 - (evalStub2 e.arg)
//│ ║        	                         ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.39: 	  Lit -> e.val | Nega -> 0 - (evalStub2 e.arg)
//│ ╙──      	                             ^^^^^^^^^^^^^^^^^
//│ evalStub2: 'a -> (int | 'val)
//│   where
//│     'a <: (Lit with {val: 'val}) | Nega[?] & {arg: 'a}

rec def eval e = case e of {
  | Lit -> e.val
  | Add -> eval e.lhs + eval e.rhs
  | Nega -> 0 - (eval e.arg)
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.59: 	  | Add -> eval e.lhs + eval e.rhs
//│ ║        	           ^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.59: 	  | Add -> eval e.lhs + eval e.rhs
//│ ╙──      	           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.59: 	  | Add -> eval e.lhs + eval e.rhs
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.59: 	  | Add -> eval e.lhs + eval e.rhs
//│ ╙──      	                        ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.60: 	  | Nega -> 0 - (eval e.arg)
//│ ║        	            ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.60: 	  | Nega -> 0 - (eval e.arg)
//│ ╙──      	            ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.60: 	  | Nega -> 0 - (eval e.arg)
//│ ║        	            ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.60: 	  | Nega -> 0 - (eval e.arg)
//│ ╙──      	                ^^^^^^^^^^^^
//│ eval: 'a -> (int | 'val)
//│   where
//│     'a <: Add[?] & {lhs: 'a, rhs: 'a} | (Lit with {val: 'val}) | Nega[?] & {arg: 'a}

def ex = add (lit 2) (lit 2)
//│ ex: Add[nothing]

eval ex
//│ res: int

def e: Add['e] as 'e
//│ e: 'e
//│   where
//│     'e :> Add['e]

def e: Lit | Add['e] as 'e
//│ e: 'e
//│   where
//│     'e :> Add['e] | Lit

def e: Lit | Add['e] | Nega['e] as 'e
//│ e: 'e
//│   where
//│     'e :> Add['e] | Lit | Nega['e]

def e = ex
//│ Add[nothing]
//│   <:  e:
//│ 'e
//│   where
//│     'e :> Add['e] | Lit | Nega['e]

eval e
//│ res: int

eval (e : Lit | Add['e] | Nega['e] as 'e)
//│ res: int




// === === === ERROR CASES === === === //


:ShowRelativeLineNums
:AllowTypeErrors


class Automata
class Binding
//│ Defined class Automata
//│ Defined class Binding

def exp: Array[Automata] -> Array[Binding]
eval exp
//│ exp: Array[Automata] -> Array[Binding]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+2: 	eval exp
//│ ║        	^^^^^^^^
//│ ╟── type `Array[Automata] -> Array[Binding]` does not match type `Add[?] & ?a | Lit & ?b | Nega[?] & ?c`
//│ ║  l.+1: 	def exp: Array[Automata] -> Array[Binding]
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Add[?] & ?d | Lit & ?e | Nega[?] & ?f`
//│ ║  l.+2: 	eval exp
//│ ║        	     ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.57: 	rec def eval e = case e of {
//│ ╙──      	                      ^
//│ res: int





:e
eval (e : Lit | Add['e] | Nega[int] as 'e)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.+1: 	eval (e : Lit | Add['e] | Nega[int] as 'e)
//│ ║        	      ^
//│ ╟── type `Lit` is not an instance of type `int`
//│ ║  l.106: 	def e: Lit | Add['e] | Nega['e] as 'e
//│ ║         	       ^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.+1: 	eval (e : Lit | Add['e] | Nega[int] as 'e)
//│ ║        	      ^
//│ ╟── Note: constraint arises from local type binding:
//│ ║  l.+1: 	eval (e : Lit | Add['e] | Nega[int] as 'e)
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.+1: 	eval (e : Lit | Add['e] | Nega[int] as 'e)
//│ ╙──      	                               ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	eval (e : Lit | Add['e] | Nega[int] as 'e)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `Add[?] & ?a | Lit & ?b | Nega[?] & ?c`
//│ ║  l.+1: 	eval (e : Lit | Add['e] | Nega[int] as 'e)
//│ ║        	                               ^^^
//│ ╟── but it flows into applied type reference with expected type `Add[?] & ?d | Lit & ?e | Nega[?] & ?f`
//│ ║  l.+1: 	eval (e : Lit | Add['e] | Nega[int] as 'e)
//│ ║        	                          ^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.57: 	rec def eval e = case e of {
//│ ╙──      	                      ^
//│ res: int









