
// Declare signature:
def f: int -> int
//│ f: int -> int

// Define body:
def f x = x
//│ 'a -> 'a
//│   <:  f:
//│ int -> int

:e
def f = 42
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.13: 	def f = 42
//│ ║        	^^^^^^^^^^
//│ ╟── integer literal of type `int` is not a function
//│ ║  l.13: 	def f = 42
//│ ║        	        ^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.3: 	def f: int -> int
//│ ╙──     	       ^^^^^^^^^^
//│ int
//│   <:  f:
//│ int -> int




:re
f 1
//│ res: int

fun x -> f x
//│ res: int -> int



def boom: anything
//│ boom: anything

def boom = 1
//│ int
//│   <:  boom:
//│ anything

:e
add boom 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.48: 	add boom 1
//│ ║        	^^^^^^^^
//│ ╟── type `anything` is not an instance of type `int`
//│ ║  l.39: 	def boom: anything
//│ ║        	          ^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.48: 	add boom 1
//│ ╙──      	    ^^^^
//│ res: int





def boom: nothing
//│ boom: nothing

:e
def boom = 1
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.68: 	def boom = 1
//│ ║        	^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `nothing`
//│ ║  l.68: 	def boom = 1
//│ ║        	           ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	def boom: nothing
//│ ╙──      	          ^^^^^^^
//│ int
//│   <:  boom:
//│ nothing





def boom: 'a
//│ boom: nothing

:e
def boom = 1
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.90: 	def boom = 1
//│ ║        	^^^^^^^^^^^^
//│ ╟── integer literal of type `int` is not an instance of type `'a`
//│ ║  l.90: 	def boom = 1
//│ ║        	           ^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.86: 	def boom: 'a
//│ ╙──      	          ^^
//│ int
//│   <:  boom:
//│ nothing






def id: 'a -> 'a
//│ id: 'a -> 'a

id 1
id true
//│ res: int
//│ res: true

def id x = x
//│ 'a -> 'a
//│   <:  id:
//│ 'a -> 'a

id 1
id true
//│ res: int
//│ res: true


:e
def id n = add n 1
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.129: 	def id n = add n 1
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── type `'a` is not an instance of type `int`
//│ ║  l.109: 	def id: 'a -> 'a
//│ ║         	        ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.129: 	def id n = add n 1
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.129: 	def id n = add n 1
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `int` is not an instance of type `'a`
//│ ║  l.129: 	def id n = add n 1
//│ ║         	           ^^^^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.109: 	def id: 'a -> 'a
//│ ╙──       	              ^^
//│ int -> int
//│   <:  id:
//│ 'a -> 'a







:e
def id (x: int) = x
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.159: 	def id (x: int) = x
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── type `'a` is not an instance of type `int`
//│ ║  l.109: 	def id: 'a -> 'a
//│ ║         	        ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.159: 	def id (x: int) = x
//│ ╙──       	           ^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.159: 	def id (x: int) = x
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `'a`
//│ ║  l.159: 	def id (x: int) = x
//│ ║         	           ^^^
//│ ╟── but it flows into reference with expected type `'a`
//│ ║  l.159: 	def id (x: int) = x
//│ ║         	                  ^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.109: 	def id: 'a -> 'a
//│ ╙──       	              ^^
//│ int -> int
//│   <:  id:
//│ 'a -> 'a










def f: (int & 'a) -> 'a
//│ f: (int & 'a) -> 'a

def impl a = a a
//│ impl: ('a -> 'b & 'a) -> 'b

:e
def f = impl
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.201: 	def f = impl
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `int & 'a` is not a function
//│ ║  l.194: 	def f: (int & 'a) -> 'a
//│ ║         	       ^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.197: 	def impl a = a a
//│ ╙──       	             ^
//│ ('a -> 'b & 'a) -> 'b
//│   <:  f:
//│ (int & 'a) -> 'a





:re
f 1 
//│ res: int


def f: (int & 'a) -> (int & 'a) -> 'a 
def f a b = if gt a b then a else b
//│ f: (int & 'a) -> (int & 'a) -> 'a
//│ (int & 'a) -> (int & 'a) -> 'a
//│   <:  f:
//│ (int & 'a) -> (int & 'a) -> 'a

f 1 
//│ res: int -> int

:e
def f a b = if gt a b then a else b b // mistake!
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.235: 	def f a b = if gt a b then a else b b // mistake!
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int & 'a` is not a function
//│ ║  l.224: 	def f: (int & 'a) -> (int & 'a) -> 'a 
//│ ║         	                     ^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.235: 	def f a b = if gt a b then a else b b // mistake!
//│ ╙──       	                                  ^
//│ (int & 'a) -> nothing -> 'a
//│   <:  f:
//│ (int & 'a) -> (int & 'a) -> 'a





f 1 
//│ res: int -> int

:re
res 2
//│ res: int


:e
def g: (int & 'a) -> 'a
def g a = add a 1
//│ g: (int & 'a) -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.263: 	def g a = add a 1
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── application of type `int` is not an instance of type `'a`
//│ ║  l.263: 	def g a = add a 1
//│ ║         	          ^^^^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.262: 	def g: (int & 'a) -> 'a
//│ ╙──       	                     ^^
//│ int -> int
//│   <:  g:
//│ (int & 'a) -> 'a






// --- // The Twice Function // --- //


def twice f x = f (f x)
//│ twice: ('a -> ('a & 'b)) -> 'a -> 'b

def ty1: (('b | 'c) -> 'c) -> 'b -> 'c
def ty2: ('b -> ('b & 'd)) -> 'b -> 'd
//│ ty1: (('b | 'c) -> 'c) -> 'b -> 'c
//│ ty2: ('b -> ('b & 'd)) -> 'b -> 'd

ty1 = ty2
//│ ('b -> ('b & 'd)) -> 'b -> 'd
//│   <:  ty1:
//│ (('b | 'c) -> 'c) -> 'b -> 'c

ty2 = ty1
//│ (('b | 'c) -> 'c) -> 'b -> 'c
//│   <:  ty2:
//│ ('b -> ('b & 'd)) -> 'b -> 'd

ty1 = twice
ty2 = twice
//│ ('a -> ('a & 'b)) -> 'a -> 'b
//│   <:  ty1:
//│ (('b | 'c) -> 'c) -> 'b -> 'c
//│ ('a -> ('a & 'b)) -> 'a -> 'b
//│   <:  ty2:
//│ ('b -> ('b & 'd)) -> 'b -> 'd



// --- // Self Application // --- //


def self1: ('a -> 'b & 'a) -> 'b
//│ self1: ('a -> 'b & 'a) -> 'b

def self1 a = a a
//│ ('a -> 'b & 'a) -> 'b
//│   <:  self1:
//│ ('a -> 'b & 'a) -> 'b

fun a -> a a
//│ res: ('a -> 'b & 'a) -> 'b

self1 = res
//│ ('a -> 'b & 'a) -> 'b
//│   <:  self1:
//│ ('a -> 'b & 'a) -> 'b

def self2: 'a -> 'b as 'a
//│ self2: 'a
//│   where
//│     'a := 'a -> 'b

def self2 = self1
//│ ('a -> 'b & 'a) -> 'b
//│   <:  self2:
//│ 'a
//│   where
//│     'a := 'a -> 'b


fun p -> fun q -> p q p
//│ res: ('a -> 'b -> 'c & 'b) -> 'a -> 'c

:ns
fun p -> fun q -> p q p
//│ res: 'a -> 'b -> 'c
//│   where
//│     'a <: 'b -> 'd
//│     'd <: 'a -> 'c

