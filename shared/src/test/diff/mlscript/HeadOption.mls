

:w
class Option[A]
class Some[A]: Option[A] & { payload: A }
class None[A]: Option[A]
//│ Defined class Option[±A]
//│ Defined class Some[+A]
//│ Defined class None[±A]
//│ ╔══[WARNING] Type definition None has bivariant type parameters:
//│ ║  l.6: 	class None[A]: Option[A]
//│ ║       	      ^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.6: 	class None[A]: Option[A]
//│ ╙──     	           ^
//│ ╔══[WARNING] Type definition Option has bivariant type parameters:
//│ ║  l.4: 	class Option[A]
//│ ║       	      ^^^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.4: 	class Option[A]
//│ ╙──     	             ^






:w
class List[A]
    method HeadOption: Option[A]
//│ Defined class List[±A]
//│ Declared List.HeadOption: List[?] -> Option[?]
//│ ╔══[WARNING] Type definition List has bivariant type parameters:
//│ ║  l.29: 	class List[A]
//│ ║        	      ^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.29: 	class List[A]
//│ ╙──      	           ^



:w
class Nil[A]: List[A]
    method HeadOption = None {}
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.44: 	    method HeadOption = None {}
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `None[?] with {None#A = ?A, Option#A = ?A}` is not an instance of type `Option`
//│ ║  l.44: 	    method HeadOption = None {}
//│ ║        	                        ^^^^^^^
//│ ╟── but it flows into method definition with expected type `Option[?]`
//│ ║  l.44: 	    method HeadOption = None {}
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from inherited method declaration:
//│ ║  l.30: 	    method HeadOption: Option[A]
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.30: 	    method HeadOption: Option[A]
//│ ╙──      	                       ^^^^^^^^^
//│ Defined class Nil[±A]
//│ Defined Nil.HeadOption: Nil[?] -> None[?]
//│ ╔══[WARNING] Type definition Nil has bivariant type parameters:
//│ ║  l.43: 	class Nil[A]: List[A]
//│ ║        	      ^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.43: 	class Nil[A]: List[A]
//│ ╙──      	          ^



class Cons[A]: List[A] & { head: A; tail: List[A] }
    method HeadOption = Some { payload = error: A }
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.72: 	    method HeadOption = Some { payload = error: A }
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Some[?A] with {Option#A = ?A, Some#A = ?A, payload: ?payload}` is not an instance of type `Option`
//│ ║  l.72: 	    method HeadOption = Some { payload = error: A }
//│ ║        	                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into method definition with expected type `Option[?]`
//│ ║  l.72: 	    method HeadOption = Some { payload = error: A }
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from inherited method declaration:
//│ ║  l.30: 	    method HeadOption: Option[A]
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.30: 	    method HeadOption: Option[A]
//│ ╙──      	                       ^^^^^^^^^
//│ Defined class Cons[+A]
//│ Defined Cons.HeadOption: Cons['A] -> Some['A]

// * Incur much fewer constraining/subtyping checks:
// class Cons[A]: List[A] & { head: A; tail: list }
// class Cons[A]: List[A] & { head: A; tail: anything }


:stats
l0 = Cons { head = 1; tail = Nil {} }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.97: 	l0 = Cons { head = 1; tail = Nil {} }
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nil[?] with {Nil#A = ?A}` is not an instance of type `List`
//│ ║  l.97: 	l0 = Cons { head = 1; tail = Nil {} }
//│ ║        	                             ^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ l0: Cons[int] with {tail: Nil[?]}
//│ constrain calls  : 20
//│ annoying  calls  : 3
//│ subtyping calls  : 47

:stats
Cons.HeadOption l0
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.113: 	Cons.HeadOption l0
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.97: 	l0 = Cons { head = 1; tail = Nil {} }
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `List[?]`
//│ ║  l.113: 	Cons.HeadOption l0
//│ ║         	                ^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ║        	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	               ^^^^^^^
//│ res: Some[int]
//│ constrain calls  : 41
//│ annoying  calls  : 25
//│ subtyping calls  : 114

:stats
l1 = Cons { head = 1; tail = Cons { head = 2; tail = Cons { head = 3; tail = Nil {} } } }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.135: 	l1 = Cons { head = 1; tail = Cons { head = 2; tail = Cons { head = 3; tail = Nil {} } } }
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nil[?] with {Nil#A = ?A}` is not an instance of type `List`
//│ ║  l.135: 	l1 = Cons { head = 1; tail = Cons { head = 2; tail = Cons { head = 3; tail = Nil {} } } }
//│ ║         	                                                                             ^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.135: 	l1 = Cons { head = 1; tail = Cons { head = 2; tail = Cons { head = 3; tail = Nil {} } } }
//│ ║         	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.135: 	l1 = Cons { head = 1; tail = Cons { head = 2; tail = Cons { head = 3; tail = Nil {} } } }
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.135: 	l1 = Cons { head = 1; tail = Cons { head = 2; tail = Cons { head = 3; tail = Nil {} } } }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.135: 	l1 = Cons { head = 1; tail = Cons { head = 2; tail = Cons { head = 3; tail = Nil {} } } }
//│ ║         	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ l1: Cons[int] with {tail: Cons[int] with {tail: Cons[int] with {tail: Nil[?]}}}
//│ constrain calls  : 52
//│ annoying  calls  : 9
//│ subtyping calls  : 268

:stats
Cons.HeadOption l1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.169: 	Cons.HeadOption l1
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.135: 	l1 = Cons { head = 1; tail = Cons { head = 2; tail = Cons { head = 3; tail = Nil {} } } }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `List[?]`
//│ ║  l.169: 	Cons.HeadOption l1
//│ ║         	                ^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ║        	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	               ^^^^^^^
//│ res: Some[int]
//│ constrain calls  : 41
//│ annoying  calls  : 25
//│ subtyping calls  : 278

:stats
l2 = Cons { head = 0; tail = l1 }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.191: 	l2 = Cons { head = 0; tail = l1 }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.135: 	l1 = Cons { head = 1; tail = Cons { head = 2; tail = Cons { head = 3; tail = Nil {} } } }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `List[?]`
//│ ║  l.191: 	l2 = Cons { head = 0; tail = l1 }
//│ ║         	                             ^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ l2: Cons[int] with {tail: Cons[int] with {tail: Cons[int] with {tail: Cons[int] with {tail: Nil[?]}}}}
//│ constrain calls  : 17
//│ annoying  calls  : 3
//│ subtyping calls  : 268

:stats
Cons.HeadOption l2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.210: 	Cons.HeadOption l2
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.191: 	l2 = Cons { head = 0; tail = l1 }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `List[?]`
//│ ║  l.210: 	Cons.HeadOption l2
//│ ║         	                ^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ║        	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	               ^^^^^^^
//│ res: Some[int]
//│ constrain calls  : 42
//│ annoying  calls  : 25
//│ subtyping calls  : 360

:stats
l3 = Cons { head = 0-1; tail = l2 }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.232: 	l3 = Cons { head = 0-1; tail = l2 }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.191: 	l2 = Cons { head = 0; tail = l1 }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `List[?]`
//│ ║  l.232: 	l3 = Cons { head = 0-1; tail = l2 }
//│ ║         	                               ^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ l3: Cons[int] with {tail: Cons[int] with {tail: Cons[int] with {tail: Cons[int] with {tail: Cons[int] with {tail: Nil[?]}}}}}
//│ constrain calls  : 31
//│ annoying  calls  : 3
//│ subtyping calls  : 341

:stats
Cons.HeadOption l3
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.251: 	Cons.HeadOption l3
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.232: 	l3 = Cons { head = 0-1; tail = l2 }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `List[?]`
//│ ║  l.251: 	Cons.HeadOption l3
//│ ║         	                ^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ║        	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	               ^^^^^^^
//│ res: Some[int]
//│ constrain calls  : 46
//│ annoying  calls  : 25
//│ subtyping calls  : 444


:stats
rec def lr1 = Cons { head = 0; tail = lr1 }
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.274: 	rec def lr1 = Cons { head = 0; tail = lr1 }
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.274: 	rec def lr1 = Cons { head = 0; tail = lr1 }
//│ ║         	                                      ^^^
//│ ╟── from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ lr1: 'tail
//│   where
//│     'tail :> Cons[int] with {tail: 'tail}
//│ constrain calls  : 21
//│ annoying  calls  : 3
//│ subtyping calls  : 120

:stats
Cons.HeadOption lr1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.293: 	Cons.HeadOption lr1
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.274: 	rec def lr1 = Cons { head = 0; tail = lr1 }
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `List[?]`
//│ ║  l.293: 	Cons.HeadOption lr1
//│ ║         	                ^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ║        	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	               ^^^^^^^
//│ res: Some[int]
//│ constrain calls  : 40
//│ annoying  calls  : 22
//│ subtyping calls  : 122

:stats
rec def lr2 = Cons { head = 0; tail = Cons { head = 1; tail = Cons { head = 3; tail = lr2 } } }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.315: 	rec def lr2 = Cons { head = 0; tail = Cons { head = 1; tail = Cons { head = 3; tail = lr2 } } }
//│ ║         	                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.315: 	rec def lr2 = Cons { head = 0; tail = Cons { head = 1; tail = Cons { head = 3; tail = lr2 } } }
//│ ║         	                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.315: 	rec def lr2 = Cons { head = 0; tail = Cons { head = 1; tail = Cons { head = 3; tail = lr2 } } }
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.315: 	rec def lr2 = Cons { head = 0; tail = Cons { head = 1; tail = Cons { head = 3; tail = lr2 } } }
//│ ║         	                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.315: 	rec def lr2 = Cons { head = 0; tail = Cons { head = 1; tail = Cons { head = 3; tail = lr2 } } }
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.315: 	rec def lr2 = Cons { head = 0; tail = Cons { head = 1; tail = Cons { head = 3; tail = lr2 } } }
//│ ║         	                                                                                      ^^^
//│ ╟── from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	                                          ^^^^^^^
//│ lr2: 'tail
//│   where
//│     'tail :> Cons[int] with {tail: Cons[int] with {tail: Cons[int] with {tail: 'tail}}}
//│ constrain calls  : 53
//│ annoying  calls  : 9
//│ subtyping calls  : 387

:stats
Cons.HeadOption lr2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.352: 	Cons.HeadOption lr2
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, tail: ?tail}` is not an instance of type `List`
//│ ║  l.315: 	rec def lr2 = Cons { head = 0; tail = Cons { head = 1; tail = Cons { head = 3; tail = lr2 } } }
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `List[?]`
//│ ║  l.352: 	Cons.HeadOption lr2
//│ ║         	                ^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ║        	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.71: 	class Cons[A]: List[A] & { head: A; tail: List[A] }
//│ ╙──      	               ^^^^^^^
//│ res: Some[int]
//│ constrain calls  : 41
//│ annoying  calls  : 25
//│ subtyping calls  : 378


:e
l1 = Cons { tail = Cons { tail = Cons { tail = Nil {} } } }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.375: 	l1 = Cons { tail = Cons { tail = Cons { tail = Nil {} } } }
//│ ║         	                                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{tail: ?a}` is not a 1-element tuple
//│ ║  l.375: 	l1 = Cons { tail = Cons { tail = Cons { tail = Nil {} } } }
//│ ╙──       	                                      ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.375: 	l1 = Cons { tail = Cons { tail = Cons { tail = Nil {} } } }
//│ ║         	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{tail: ?a}` is not a 1-element tuple
//│ ║  l.375: 	l1 = Cons { tail = Cons { tail = Cons { tail = Nil {} } } }
//│ ╙──       	                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.375: 	l1 = Cons { tail = Cons { tail = Cons { tail = Nil {} } } }
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{tail: ?a}` is not a 1-element tuple
//│ ║  l.375: 	l1 = Cons { tail = Cons { tail = Cons { tail = Nil {} } } }
//│ ╙──       	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ l1: Cons[nothing] with {tail: Cons[nothing] with {tail: Cons[nothing] with {tail: Nil[?]}}}








