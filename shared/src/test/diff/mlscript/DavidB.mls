


tuple1 = (1, 2, 3)
//│ tuple1: (int, int, int,)

tuple2 = (4, 5)
//│ tuple2: (int, int,)

if true then tuple1 else tuple2
//│ res: Array[int] & {_1: int, _2: int}

arr = tuple1 : Array[int]
//│ arr: Array[int]

if true then tuple1 else arr
//│ res: Array[int]



type Cons[H, T] = { h: H; t: T }
type List[A] = Cons[A, List[A]] | ()
//│ Defined type alias Cons[+H, +T]
//│ Defined type alias List[+A]

list1 = { h = 1; t = { h = 2; t = () }}
//│ list1: {h: int, t: {h: int, t: ()}}

list2 = { h = 3; t = () }
//│ list2: {h: int, t: ()}

ls = if true then list1 else list2
//│ ls: {h: int, t: () | {h: int, t: ()}}

ls : List[int]
//│ res: List[int]

type NonEmptyList[A] = Cons[A, List[A]]
//│ Defined type alias NonEmptyList[+A]

ls : NonEmptyList[int]
//│ res: NonEmptyList[int]

:e // TODO improve error message
ls : Cons[int, Cons[int, List[int]]]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.45: 	ls : Cons[int, Cons[int, List[int]]]
//│ ║        	^^
//│ ╟── expression of type `()` is not a record (expected a record with fields: h, t)
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.45: 	ls : Cons[int, Cons[int, List[int]]]
//│ ║        	               ^^^^^^^^^^^^^^^^^^^^
//│ ╟── from record type:
//│ ║  l.21: 	type Cons[H, T] = { h: H; t: T }
//│ ╙──      	                  ^^^^^^^^^^^^^^
//│ res: Cons[int, Cons[int, List[int]]]




ls : { h: int; t: List[int] }
//│ res: {h: int, t: List[int]}

:e
ls : { h: int; t: { h: int; t: List[int] } }
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.65: 	ls : { h: int; t: { h: int; t: List[int] } }
//│ ║        	^^
//│ ╟── expression of type `()` is not a record (expected a record with fields: h, t)
//│ ╟── Note: constraint arises from record type:
//│ ║  l.65: 	ls : { h: int; t: { h: int; t: List[int] } }
//│ ╙──      	                  ^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: {h: int, t: {h: int, t: List[int]}}





class C[A]: { h: A; t: List[A] }
type List0[A] = C[A] | ()
//│ Defined class C[+A]
//│ Defined type alias List0[+A]

list1 = C { h = 1; t = C { h = 2; t = () }}
//│ list1: C[int] with {t: C[int] with {t: ()}}

list2 = C { h = 3; t = () }
//│ list2: C[int] with {t: ()}

ls = if true then list1 else list2
//│ ls: C[int] with {t: () | (C[int] with {t: ()})}

ls : List0[int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.93: 	ls : List0[int]
//│ ║        	^^
//│ ╟── integer literal of type `int` is not an instance of type `int`
//│ ║  l.84: 	list1 = C { h = 1; t = C { h = 2; t = () }}
//│ ║        	                ^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.93: 	ls : List0[int]
//│ ║        	^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.93: 	ls : List0[int]
//│ ║        	     ^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.93: 	ls : List0[int]
//│ ╙──      	           ^^^
//│ res: List0[int]



type List1[A] = (A, List1[A]) | ()
//│ Defined type alias List1[+A]

list1 = (1, (2, (3, ())))
//│ list1: (int, (int, (int, (),),),)

list1: List1[int]
//│ res: List1[int]

list2 = (4, (5, ()))
//│ list2: (int, (int, (),),)

if true then list1 else list2
//│ res: (int, (int, Array[() | int],),)



