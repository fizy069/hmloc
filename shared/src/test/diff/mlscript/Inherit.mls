
class Parent: { name: string }
//│ Defined class Parent

class Child: Parent & { age: int }
//│ Defined class Child

def p = Parent{ name = "Bob" }
//│ p: Parent

p: Parent
//│ res: Parent

:e
def c = Child(Parent { name = "Bob" })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.15: 	def c = Child(Parent { name = "Bob" })
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Parent` is not a 1-element tuple
//│ ║  l.15: 	def c = Child(Parent { name = "Bob" })
//│ ║        	              ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `({age: ?age, name: ?name},)`
//│ ║  l.15: 	def c = Child(Parent { name = "Bob" })
//│ ╙──      	             ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ c: Child & {age: nothing}



def c = Child(Parent { name = "Bob" } with { age = 123 })
//│ c: Child

c: Parent
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.32: 	c: Parent
//│ ║        	^
//│ ╟── application of type `Child` does not match type `Parent`
//│ ║  l.29: 	def c = Child(Parent { name = "Bob" } with { age = 123 })
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Parent`
//│ ║  l.32: 	c: Parent
//│ ║        	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.32: 	c: Parent
//│ ╙──      	   ^^^^^^
//│ res: Parent

c.name
//│ res: string

c: { name: 'a }
//│ res: {name: string}

c: { name: string }
//│ res: {name: string}


def f x = case x of {
  | Parent -> x.name
  }
//│ f: (Parent with {name: 'name}) -> 'name

f c
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.62: 	f c
//│ ║        	^^^
//│ ╟── application of type `Child` is not an instance of type `Parent`
//│ ║  l.29: 	def c = Child(Parent { name = "Bob" } with { age = 123 })
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Parent`
//│ ║  l.62: 	f c
//│ ║        	  ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.57: 	def f x = case x of {
//│ ║        	               ^
//│ ╟── from class pattern:
//│ ║  l.58: 	  | Parent -> x.name
//│ ╙──      	    ^^^^^^
//│ res: string

f (c: Parent)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.80: 	f (c: Parent)
//│ ║        	   ^
//│ ╟── application of type `Child` does not match type `Parent`
//│ ║  l.29: 	def c = Child(Parent { name = "Bob" } with { age = 123 })
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Parent`
//│ ║  l.80: 	f (c: Parent)
//│ ║        	   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.80: 	f (c: Parent)
//│ ╙──      	      ^^^^^^
//│ res: string


def f x = case x of {
  | Child -> x.name
  }
//│ f: (Child\age with {name: 'name}) -> 'name

f c
//│ res: string

:e
f (c: Parent)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.105: 	f (c: Parent)
//│ ║         	   ^
//│ ╟── application of type `Child` does not match type `Parent`
//│ ║  l.29: 	def c = Child(Parent { name = "Bob" } with { age = 123 })
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Parent`
//│ ║  l.105: 	f (c: Parent)
//│ ║         	   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.105: 	f (c: Parent)
//│ ╙──       	      ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.105: 	f (c: Parent)
//│ ║         	^^^^^^^^^^^^^
//│ ╟── type `Parent` is not an instance of type `Child`
//│ ║  l.105: 	f (c: Parent)
//│ ║         	      ^^^^^^
//│ ╟── but it flows into argument with expected type `Child`
//│ ║  l.105: 	f (c: Parent)
//│ ║         	  ^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.96: 	def f x = case x of {
//│ ║        	               ^
//│ ╟── from class pattern:
//│ ║  l.97: 	  | Child -> x.name
//│ ╙──      	    ^^^^^
//│ res: string






def f x = case x of {
  | Parent -> x.name
  | _ -> ""
  }
//│ f: ((Parent with {name: 'name}) | ~Parent) -> ('name | string)

f c
//│ res: string

f (c: Parent)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.149: 	f (c: Parent)
//│ ║         	   ^
//│ ╟── application of type `Child` does not match type `Parent`
//│ ║  l.29: 	def c = Child(Parent { name = "Bob" } with { age = 123 })
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Parent`
//│ ║  l.149: 	f (c: Parent)
//│ ║         	   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.149: 	f (c: Parent)
//│ ╙──       	      ^^^^^^
//│ res: string


def f x = case x of {
  | Parent -> x.name
  | Child -> x.name
  }
//│ f: ((Child\age with {name: 'name}) | (Parent with {name: 'name})) -> 'name

f c
//│ res: string

f (c: Parent)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.174: 	f (c: Parent)
//│ ║         	   ^
//│ ╟── application of type `Child` does not match type `Parent`
//│ ║  l.29: 	def c = Child(Parent { name = "Bob" } with { age = 123 })
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Parent`
//│ ║  l.174: 	f (c: Parent)
//│ ║         	   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.174: 	f (c: Parent)
//│ ╙──       	      ^^^^^^
//│ res: string

