class Undefined2: { x: undefined }
//│ Defined class Undefined2

Undefined2
//│ res: {x: undefined & 'x} -> (Undefined2 with {x: 'x})

Undefined2 { x = undefined }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.7: 	Undefined2 { x = undefined }
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({x: undefined},)` does not have field 'x'
//│ ║  l.7: 	Undefined2 { x = undefined }
//│ ╙──     	           ^^^^^^^^^^^^^^^^^
//│ res: Undefined2 & {x: nothing}

:e
Undefined2 { x = "I am here to make a type mismatch." }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.17: 	Undefined2 { x = "I am here to make a type mismatch." }
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({x: string},)` does not have field 'x'
//│ ║  l.17: 	Undefined2 { x = "I am here to make a type mismatch." }
//│ ╙──      	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: Undefined2 & {x: nothing}




:e
type Undefined2 = { x: string }
//│ ╔══[ERROR] Type 'Undefined2' is already defined.
//│ ║  l.30: 	type Undefined2 = { x: string }
//│ ╙──      	     ^^^^^^^^^^


type AnotherUndefined = { x: undefined }
//│ Defined type alias AnotherUndefined

type MoreOnTypes0 = undefined
//│ Defined type alias MoreOnTypes0

type MoreOnTypes1 = undefined -> undefined
//│ Defined type alias MoreOnTypes1

type MoreOnTypes2 = undefined -> undefined -> undefined
//│ Defined type alias MoreOnTypes2

type MoreOnTypes3 = (undefined -> undefined) -> null
//│ Defined type alias MoreOnTypes3

sample = undefined
sample: undefined
//│ sample: undefined
//│ res: undefined

sample2 = null
sample2: null
//│ sample2: null
//│ res: null

:e
sample: bool
sample2: bool
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.62: 	sample: bool
//│ ║        	^^^^^^
//│ ╟── undefined literal of type `undefined` is not an instance of `bool`
//│ ║  l.51: 	sample = undefined
//│ ║        	         ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `bool`
//│ ║  l.62: 	sample: bool
//│ ║        	^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.62: 	sample: bool
//│ ╙──      	        ^^^^
//│ res: bool
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.63: 	sample2: bool
//│ ║        	^^^^^^^
//│ ╟── null literal of type `null` is not an instance of `bool`
//│ ║  l.56: 	sample2 = null
//│ ║        	          ^^^^
//│ ╟── but it flows into reference with expected type `bool`
//│ ║  l.63: 	sample2: bool
//│ ║        	^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.63: 	sample2: bool
//│ ╙──      	         ^^^^
//│ res: bool









if false then sample else 0
if true then sample2 else 0
//│ res: int | undefined
//│ res: int | null


def bar = fun sample -> (sample: MoreOnTypes0)
bar undefined
//│ bar: MoreOnTypes0 -> MoreOnTypes0
//│ res: MoreOnTypes0

:e
bar "undefined"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.111: 	bar "undefined"
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `undefined`
//│ ║  l.111: 	bar "undefined"
//│ ║         	    ^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.105: 	def bar = fun sample -> (sample: MoreOnTypes0)
//│ ║         	                         ^^^^^^
//│ ╟── from literal type:
//│ ║  l.39: 	type MoreOnTypes0 = undefined
//│ ╙──      	                    ^^^^^^^^^
//│ res: MoreOnTypes0





case (undefined) of { undefined -> "undefined it is" | null -> "null it is"}
//│ res: string

case (null) of { undefined -> "undefined it is" | null -> "null it is" }
//│ res: string


absent = ()[0]
//│ absent: undefined

case absent of { undefined -> 1 }
//│ res: int

case absent of { null -> 0 | undefined -> 1 }
//│ res: int

case absent of { "" -> 0 | undefined -> 1 }
//│ res: int


uw = undefined with { x = 1 }
nw = null with { x = 1 }
uw.x
nw.x
//│ uw: undefined & {x: int}
//│ nw: null & {x: int}
//│ res: int
//│ res: int

:e
undefined.x
null.x
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.160: 	undefined.x
//│ ║         	^^^^^^^^^^^
//│ ╟── undefined literal of type `undefined` does not have field 'x'
//│ ║  l.160: 	undefined.x
//│ ╙──       	^^^^^^^^^
//│ res: nothing
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.161: 	null.x
//│ ║         	^^^^^^
//│ ╟── null literal of type `null` does not have field 'x'
//│ ║  l.161: 	null.x
//│ ╙──       	^^^^
//│ res: nothing





def bypass: nothing
//│ bypass: nothing


:e
bypass = undefined
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.186: 	bypass = undefined
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── undefined literal of type `undefined` does not match type `nothing`
//│ ║  l.186: 	bypass = undefined
//│ ║         	         ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.181: 	def bypass: nothing
//│ ╙──       	            ^^^^^^^
//│ undefined
//│   <:  bypass:
//│ nothing




:re
bypass.x
bypass + 1
//│ res: nothing
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.205: 	bypass + 1
//│ ║         	^^^^^^^^
//│ ╟── argument of type `(nothing,)` is not an instance of `int`
//│ ║  l.205: 	bypass + 1
//│ ╙──       	^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.205: 	bypass + 1
//│ ║         	^^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.205: 	bypass + 1
//│ ╙──       	         ^
//│ res: int

