class Undefined2: { x: undefined }
//│ Defined class Undefined2

Undefined2
//│ res: {x: undefined & 'x} -> (Undefined2 with {x: 'x})

Undefined2 { x = undefined }
//│ res: Undefined2

:e
Undefined2 { x = "I am here to make a type mismatch." }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.11: 	Undefined2 { x = "I am here to make a type mismatch." }
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `undefined`
//│ ║  l.11: 	Undefined2 { x = "I am here to make a type mismatch." }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.1: 	class Undefined2: { x: undefined }
//│ ╙──     	                       ^^^^^^^^^
//│ res: Undefined2 with {x: string}




:e
type Undefined2 = { x: string }
//│ ╔══[ERROR] Type 'Undefined2' is already defined.
//│ ║  l.27: 	type Undefined2 = { x: string }
//│ ╙──      	     ^^^^^^^^^^


type AnotherUndefined = { x: undefined }
//│ Defined type alias AnotherUndefined

type MoreOnTypes0 = undefined
//│ Defined type alias MoreOnTypes0

type MoreOnTypes1 = undefined -> undefined
//│ Defined type alias MoreOnTypes1

type MoreOnTypes2 = undefined -> undefined -> undefined
//│ Defined type alias MoreOnTypes2

type MoreOnTypes3 = (undefined -> undefined) -> null
//│ Defined type alias MoreOnTypes3

sample = undefined
sample: undefined
//│ sample: undefined
//│ res: undefined

sample2 = null
sample2: null
//│ sample2: null
//│ res: null

:e
sample: bool
sample2: bool
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.59: 	sample: bool
//│ ║        	^^^^^^
//│ ╟── undefined literal of type `undefined` is not an instance of `bool`
//│ ║  l.48: 	sample = undefined
//│ ║        	         ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `bool`
//│ ║  l.59: 	sample: bool
//│ ║        	^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.59: 	sample: bool
//│ ╙──      	        ^^^^
//│ res: bool
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.60: 	sample2: bool
//│ ║        	^^^^^^^
//│ ╟── null literal of type `null` is not an instance of `bool`
//│ ║  l.53: 	sample2 = null
//│ ║        	          ^^^^
//│ ╟── but it flows into reference with expected type `bool`
//│ ║  l.60: 	sample2: bool
//│ ║        	^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.60: 	sample2: bool
//│ ╙──      	         ^^^^
//│ res: bool









if false then sample else 0
if true then sample2 else 0
//│ res: int | undefined
//│ res: int | null


def bar = fun sample -> (sample: MoreOnTypes0)
bar undefined
//│ bar: MoreOnTypes0 -> MoreOnTypes0
//│ res: MoreOnTypes0

:e
bar "undefined"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.108: 	bar "undefined"
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `undefined`
//│ ║  l.108: 	bar "undefined"
//│ ║         	    ^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.102: 	def bar = fun sample -> (sample: MoreOnTypes0)
//│ ║         	                         ^^^^^^
//│ ╟── from literal type:
//│ ║  l.36: 	type MoreOnTypes0 = undefined
//│ ╙──      	                    ^^^^^^^^^
//│ res: MoreOnTypes0





case (undefined) of { undefined -> "undefined it is" | null -> "null it is"}
//│ res: string

case (null) of { undefined -> "undefined it is" | null -> "null it is" }
//│ res: string


absent = ()[0]
//│ absent: undefined

case absent of { undefined -> 1 }
//│ res: int

case absent of { null -> 0 | undefined -> 1 }
//│ res: int

case absent of { "" -> 0 | undefined -> 1 }
//│ res: int


uw = undefined with { x = 1 }
nw = null with { x = 1 }
uw.x
nw.x
//│ uw: undefined & {x: int}
//│ nw: null & {x: int}
//│ res: int
//│ res: int

:e
undefined.x
null.x
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.157: 	undefined.x
//│ ║         	^^^^^^^^^^^
//│ ╟── undefined literal of type `undefined` does not have field 'x'
//│ ║  l.157: 	undefined.x
//│ ╙──       	^^^^^^^^^
//│ res: nothing
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.158: 	null.x
//│ ║         	^^^^^^
//│ ╟── null literal of type `null` does not have field 'x'
//│ ║  l.158: 	null.x
//│ ╙──       	^^^^
//│ res: nothing





def bypass: nothing
//│ bypass: nothing


:e
bypass = undefined
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.183: 	bypass = undefined
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── undefined literal of type `undefined` does not match type `nothing`
//│ ║  l.183: 	bypass = undefined
//│ ║         	         ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.178: 	def bypass: nothing
//│ ╙──       	            ^^^^^^^
//│ undefined
//│   <:  bypass:
//│ nothing




:re
bypass.x
bypass + 1
//│ res: nothing
//│ res: int

