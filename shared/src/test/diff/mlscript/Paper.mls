
class None: {}
class Some[A]: { value: A }
type Option[A] = Some[A] | None
//│ Defined class None
//│ Defined class Some[+A]
//│ Defined type alias Option[+A]


def flatMap f opt = case opt of
  Some -> f opt.value,
  None -> None{}
//│ flatMap: ('value -> 'a) -> (None | (Some[?] with {value: 'value})) -> (None | 'a)

res = flatMap (fun x -> x) (Some{value = 42})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.15: 	res = flatMap (fun x -> x) (Some{value = 42})
//│ ║        	                            ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.15: 	res = flatMap (fun x -> x) (Some{value = 42})
//│ ╙──      	                                ^^^^^^^^^^^^
//│ res: None

case res of int -> res, None -> 0
//│ res: int

flatMap (fun x -> None{}) (Some{value = 42})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.27: 	flatMap (fun x -> None{}) (Some{value = 42})
//│ ║        	                           ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.27: 	flatMap (fun x -> None{}) (Some{value = 42})
//│ ╙──      	                               ^^^^^^^^^^^^
//│ res: None


def flatMap2 f opt = case opt of Some -> f opt.value, _ -> opt
//│ flatMap2: ('value -> 'a) -> ((Some[?] with {value: 'value}) | 'a & ~#Some) -> 'a

flatMap2 (fun x -> Some{value = x}) (Some{value = 12})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.40: 	flatMap2 (fun x -> Some{value = x}) (Some{value = 12})
//│ ║        	                   ^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: ?a},)` does not have field 'value'
//│ ║  l.40: 	flatMap2 (fun x -> Some{value = x}) (Some{value = 12})
//│ ╙──      	                       ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.40: 	flatMap2 (fun x -> Some{value = x}) (Some{value = 12})
//│ ║        	                                     ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.40: 	flatMap2 (fun x -> Some{value = x}) (Some{value = 12})
//│ ╙──      	                                         ^^^^^^^^^^^^
//│ res: Some[nothing]

flatMap2 (fun x -> Some{value = x}) 42
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.55: 	flatMap2 (fun x -> Some{value = x}) 42
//│ ║        	                   ^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: ?a},)` does not have field 'value'
//│ ║  l.55: 	flatMap2 (fun x -> Some{value = x}) 42
//│ ╙──      	                       ^^^^^^^^^^^
//│ res: int | Some[nothing]

flatMap2 (fun x -> x) 42
//│ res: int


def mapSome f opt = case opt of Some -> f opt, _ -> opt
//│ mapSome: ('a -> 'b) -> (Some[?] & 'a | 'b & ~#Some) -> 'b


class SomeAnd[A, P]: Some[A] & { payload: P }
//│ Defined class SomeAnd[+A, +P]

let arg = if true then SomeAnd{value = 42; payload = 23} else None{}
  in mapSome (fun x -> x.value + x.payload) arg
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.75: 	let arg = if true then SomeAnd{value = 42; payload = 23} else None{}
//│ ║        	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({payload: int, value: int},)` is not a record (expected a record with fields: payload, value)
//│ ║  l.75: 	let arg = if true then SomeAnd{value = 42; payload = 23} else None{}
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.76: 	  in mapSome (fun x -> x.value + x.payload) arg
//│ ║        	                       ^^^^^^^^^
//│ ╟── argument of type `(?value,)` is not an instance of `int`
//│ ║  l.76: 	  in mapSome (fun x -> x.value + x.payload) arg
//│ ╙──      	                       ^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.76: 	  in mapSome (fun x -> x.value + x.payload) arg
//│ ║        	                       ^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?payload,)` is not an instance of `int`
//│ ║  l.76: 	  in mapSome (fun x -> x.value + x.payload) arg
//│ ╙──      	                                 ^^^^^^^^^
//│ res: int | None | SomeAnd[nothing, nothing]


// * Note: there was a typo in the original paper submission: we used `(m: ~0)` instead of `(m: ~0 & int)`
def div n m = n / (m: ~0 & number)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.99: 	def div n m = n / (m: ~0 & number)
//│ ║        	              ^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.99: 	def div n m = n / (m: ~0 & number)
//│ ╙──      	              ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.99: 	def div n m = n / (m: ~0 & number)
//│ ║        	              ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(number & ~0,)` is not an instance of `int`
//│ ║  l.99: 	def div n m = n / (m: ~0 & number)
//│ ╙──      	                  ^^^^^^^^^^^^^^^^
//│ div: anything -> (number & ~0) -> int

f x = div x 2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.114: 	f x = div x 2
//│ ║         	      ^^^^^^^
//│ ╟── integer literal of type `int` does not match type `~0`
//│ ║  l.114: 	f x = div x 2
//│ ║         	            ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.99: 	def div n m = n / (m: ~0 & number)
//│ ║        	                   ^
//│ ╟── from type negation:
//│ ║  l.99: 	def div n m = n / (m: ~0 & number)
//│ ╙──      	                      ^^
//│ f: anything -> int

:e // `:e` is used to indicate this error is expected
g (x: int) = div 100 x
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.130: 	g (x: int) = div 100 x
//│ ║         	             ^^^^^^^^^
//│ ╟── type `int` does not match type `~0`
//│ ║  l.130: 	g (x: int) = div 100 x
//│ ║         	      ^^^
//│ ╟── but it flows into reference with expected type `~0`
//│ ║  l.130: 	g (x: int) = div 100 x
//│ ║         	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.99: 	def div n m = n / (m: ~0 & number)
//│ ║        	                   ^
//│ ╟── from type negation:
//│ ║  l.99: 	def div n m = n / (m: ~0 & number)
//│ ╙──      	                      ^^
//│ g: int -> int






div_opt n m = case m of 0 -> None{}, _ -> Some{value = div n m}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.153: 	div_opt n m = case m of 0 -> None{}, _ -> Some{value = div n m}
//│ ║         	                                          ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: ?a},)` does not have field 'value'
//│ ║  l.153: 	div_opt n m = case m of 0 -> None{}, _ -> Some{value = div n m}
//│ ╙──       	                                              ^^^^^^^^^^^^^^^^^
//│ div_opt: anything -> (0 | number & ~0) -> (None | Some[nothing])



def capitalize: string -> string
//│ capitalize: string -> string

class Person: {name: string; age: int; isMajor: bool}
//│ Defined class Person

def Person n a = Person{name = capitalize n; age = a; isMajor = a >= 18}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.170: 	def Person n a = Person{name = capitalize n; age = a; isMajor = a >= 18}
//│ ║         	                                                                ^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.170: 	def Person n a = Person{name = capitalize n; age = a; isMajor = a >= 18}
//│ ╙──       	                                                                ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.170: 	def Person n a = Person{name = capitalize n; age = a; isMajor = a >= 18}
//│ ║         	                                                                ^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.170: 	def Person n a = Person{name = capitalize n; age = a; isMajor = a >= 18}
//│ ╙──       	                                                                     ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.170: 	def Person n a = Person{name = capitalize n; age = a; isMajor = a >= 18}
//│ ║         	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({age: ?a, isMajor: ?b, name: ?c},)` is not a record (expected a record with fields: name, age, isMajor)
//│ ║  l.170: 	def Person n a = Person{name = capitalize n; age = a; isMajor = a >= 18}
//│ ╙──       	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ Person: string -> anything -> (Person & {age: nothing, isMajor: nothing, name: nothing})



class Cons[A]: Some[A] & { tail: List[A] }
type List[A] = Cons[A] | None
//│ Defined class Cons[+A]
//│ Defined type alias List[+A]

rec def mapList f ls = case ls of
  Cons -> Cons{value = f ls.value; tail = mapList f ls.tail},
  None -> None{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.199: 	  Cons -> Cons{value = f ls.value; tail = mapList f ls.tail},
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({tail: ?a, value: ?b},)` is not a record (expected a record with fields: tail, value)
//│ ║  l.199: 	  Cons -> Cons{value = f ls.value; tail = mapList f ls.tail},
//│ ╙──       	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ mapList: ('value -> anything) -> 'a -> (Cons[nothing] & {tail: nothing} | None)
//│   where
//│     'a <: (Cons[?] with {tail: 'a, value: 'value}) | None



def Cons head tail = Cons { value = head; tail = tail }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.213: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({tail: ?a, value: ?b},)` is not a record (expected a record with fields: tail, value)
//│ ║  l.213: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ╙──       	                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ Cons: anything -> anything -> (Cons[nothing] & {tail: nothing})

def None = None{}
//│ None: None

rec def unzip xs = case xs of
  None -> { fst = None; snd = None },
  Some -> let tmp = unzip xs.tail in { fst = Cons xs.value.fst tmp.fst ;
                                       snd = Cons xs.value.snd tmp.snd }
//│ unzip: 'a -> {fst: Cons[nothing] & {tail: nothing} | None, snd: Cons[nothing] & {tail: nothing} | None}
//│   where
//│     'a <: None | Some[?] & {tail: 'a, value: {fst: anything, snd: anything}}

// * Declare desired types:
def Cons_ty: 'a -> ('b & List['a]) -> (Cons['a] & { value: 'a; tail: 'b })
def unzip_ty: List[{ fst: 'a; snd: 'b }] -> { fst: List['a]; snd: List['b] }
//│ Cons_ty: 'a -> (List['a] & 'b) -> (Cons['a] with {tail: 'b})
//│ unzip_ty: List[{fst: 'a, snd: 'b}] -> {fst: List['a], snd: List['b]}

// * Assert the inferred types subsume them (the signatures above are checked):
def Cons_ty = Cons
def unzip_ty = unzip
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.240: 	def Cons_ty = Cons
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, tail: ?tail, value: ?value}` is not an instance of type `Some`
//│ ║  l.213: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.234: 	def Cons_ty: 'a -> ('b & List['a]) -> (Cons['a] & { value: 'a; tail: 'b })
//│ ║         	                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.193: 	class Cons[A]: Some[A] & { tail: List[A] }
//│ ╙──       	               ^^^^^^^
//│ anything -> anything -> (Cons[nothing] & {tail: nothing})
//│   <:  Cons_ty:
//│ 'a -> (List['a] & 'b) -> (Cons['a] with {tail: 'b})
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.241: 	def unzip_ty = unzip
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, tail: ?tail, value: ?value}` does not match type `Cons['a] | None`
//│ ║  l.213: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.235: 	def unzip_ty: List[{ fst: 'a; snd: 'b }] -> { fst: List['a]; snd: List['b] }
//│ ║         	                                                   ^^^^^^^^
//│ ╟── from union type:
//│ ║  l.194: 	type List[A] = Cons[A] | None
//│ ╙──       	               ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.241: 	def unzip_ty = unzip
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, tail: ?tail, value: ?value}` does not match type `Cons['b] | None`
//│ ║  l.213: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.235: 	def unzip_ty: List[{ fst: 'a; snd: 'b }] -> { fst: List['a]; snd: List['b] }
//│ ║         	                                                                  ^^^^^^^^
//│ ╟── from union type:
//│ ║  l.194: 	type List[A] = Cons[A] | None
//│ ╙──       	               ^^^^^^^^^^^^^^
//│ 'a -> {fst: Cons[nothing] & {tail: nothing} | None, snd: Cons[nothing] & {tail: nothing} | None}
//│   where
//│     'a <: None | Some[?] & {tail: 'a, value: {fst: anything, snd: anything}}
//│   <:  unzip_ty:
//│ List[{fst: 'a, snd: 'b}] -> {fst: List['a], snd: List['b]}



