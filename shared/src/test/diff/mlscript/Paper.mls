
class None: {}
class Some[A]: { value: A }
type Option[A] = Some[A] | None
//│ Defined class None
//│ Defined class Some[+A]
//│ Defined type alias Option[+A]


def flatMap f opt = case opt of
  Some -> f opt.value,
  None -> None{}
//│ flatMap: ('value -> 'a) -> (None | (Some[?] with {value: 'value})) -> (None | 'a)

res = flatMap (fun x -> x) (Some{value = 42})
//│ res: int | None

case res of int -> res, None -> 0
//│ res: int

flatMap (fun x -> None{}) (Some{value = 42})
//│ res: None


def flatMap2 f opt = case opt of Some -> f opt.value, _ -> opt
//│ flatMap2: ('value -> 'a) -> ((Some[?] with {value: 'value}) | 'a & ~#Some) -> 'a

flatMap2 (fun x -> Some{value = x}) (Some{value = 12})
//│ res: Some[int]

flatMap2 (fun x -> Some{value = x}) 42
//│ res: int | Some[nothing]

flatMap2 (fun x -> x) 42
//│ res: int


def mapSome f opt = case opt of Some -> f opt, _ -> opt
//│ mapSome: ('a -> 'b) -> (Some[?] & 'a | 'b & ~#Some) -> 'b


class SomeAnd[A, P]: Some[A] & { payload: P }
//│ Defined class SomeAnd[+A, +P]

let arg = if true then SomeAnd{value = 42; payload = 23} else None{}
  in mapSome (fun x -> x.value + x.payload) arg
//│ res: int | None | SomeAnd[int, int]


// * Note: there was a typo in the original paper submission: we used `(m: ~0)` instead of `(m: ~0 & int)`
def div n m = n / (m: ~0 & number)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.51: 	def div n m = n / (m: ~0 & number)
//│ ║        	              ^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `number & ~0` is not an instance of `int`
//│ ║  l.51: 	def div n m = n / (m: ~0 & number)
//│ ║        	                      ^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.51: 	def div n m = n / (m: ~0 & number)
//│ ╙──      	                  ^^^^^^^^^^^^^^^^
//│ div: int -> (number & ~0) -> int

f x = div x 2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.63: 	f x = div x 2
//│ ║        	      ^^^^^^^
//│ ╟── integer literal of type `int` does not match type `~0`
//│ ║  l.63: 	f x = div x 2
//│ ║        	            ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.51: 	def div n m = n / (m: ~0 & number)
//│ ║        	                   ^
//│ ╟── from type negation:
//│ ║  l.51: 	def div n m = n / (m: ~0 & number)
//│ ╙──      	                      ^^
//│ f: int -> int

:e // `:e` is used to indicate this error is expected
g (x: int) = div 100 x
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	g (x: int) = div 100 x
//│ ║        	             ^^^^^^^^^
//│ ╟── type `int` does not match type `~0`
//│ ║  l.79: 	g (x: int) = div 100 x
//│ ║        	      ^^^
//│ ╟── but it flows into reference with expected type `~0`
//│ ║  l.79: 	g (x: int) = div 100 x
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.51: 	def div n m = n / (m: ~0 & number)
//│ ║        	                   ^
//│ ╟── from type negation:
//│ ║  l.51: 	def div n m = n / (m: ~0 & number)
//│ ╙──      	                      ^^
//│ g: int -> int






div_opt n m = case m of 0 -> None{}, _ -> Some{value = div n m}
//│ div_opt: int -> (0 | number & ~0) -> (None | Some[int])



def capitalize: string -> string
//│ capitalize: string -> string

class Person: {name: string; age: int; isMajor: bool}
//│ Defined class Person

def Person n a = Person{name = capitalize n; age = a; isMajor = a >= 18}
//│ Person: string -> (int & 'age) -> (Person with {age: 'age})



class Cons[A]: Some[A] & { tail: List[A] }
type List[A] = Cons[A] | None
//│ Defined class Cons[+A]
//│ Defined type alias List[+A]

rec def mapList f ls = case ls of
  Cons -> Cons{value = f ls.value; tail = mapList f ls.tail},
  None -> None{}
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.123: 	rec def mapList f ls = case ls of
//│ ║         	                ^^^^^^^^^^^^^^^^^
//│ ║  l.124: 	  Cons -> Cons{value = f ls.value; tail = mapList f ls.tail},
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.125: 	  None -> None{}
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, tail: ?tail, value: ?value}` does not match type `Cons[?A] | None`
//│ ║  l.124: 	  Cons -> Cons{value = f ls.value; tail = mapList f ls.tail},
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into `case` expression with expected type `Cons[?A] | None`
//│ ║  l.123: 	rec def mapList f ls = case ls of
//│ ║         	                       ^^^^^^^^^^
//│ ║  l.124: 	  Cons -> Cons{value = f ls.value; tail = mapList f ls.tail},
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.125: 	  None -> None{}
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.124: 	  Cons -> Cons{value = f ls.value; tail = mapList f ls.tail},
//│ ║         	                                          ^^^^^^^^^^^^^^^^^
//│ ╟── from union type:
//│ ║  l.119: 	type List[A] = Cons[A] | None
//│ ╙──       	               ^^^^^^^^^^^^^^
//│ mapList: ('value -> 'value0) -> 'a -> (None | 'b)
//│   where
//│     'b :> Cons['value0] with {tail: None | 'b}
//│     'a <: (Cons[?] with {tail: 'a, value: 'value}) | None



def Cons head tail = Cons { value = head; tail = tail }
//│ Cons: ('value & 'A) -> (List['A] & 'tail) -> (Cons['A] with {tail: 'tail, value: 'value})

def None = None{}
//│ None: None

rec def unzip xs = case xs of
  None -> { fst = None; snd = None },
  Some -> let tmp = unzip xs.tail in { fst = Cons xs.value.fst tmp.fst ;
                                       snd = Cons xs.value.snd tmp.snd }
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.162: 	rec def unzip xs = case xs of
//│ ║         	              ^^^^^^^^^^^^^^^
//│ ║  l.163: 	  None -> { fst = None; snd = None },
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.164: 	  Some -> let tmp = unzip xs.tail in { fst = Cons xs.value.fst tmp.fst ;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.165: 	                                       snd = Cons xs.value.snd tmp.snd }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, tail: ?tail, value: ?value}` does not match type `Cons[?A] | None`
//│ ║  l.156: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `Cons[?A] | None`
//│ ║  l.165: 	                                       snd = Cons xs.value.snd tmp.snd }
//│ ║         	                                             ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.165: 	                                       snd = Cons xs.value.snd tmp.snd }
//│ ║         	                                                               ^^^^^^^
//│ ╟── from union type:
//│ ║  l.119: 	type List[A] = Cons[A] | None
//│ ╙──       	               ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.162: 	rec def unzip xs = case xs of
//│ ║         	              ^^^^^^^^^^^^^^^
//│ ║  l.163: 	  None -> { fst = None; snd = None },
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.164: 	  Some -> let tmp = unzip xs.tail in { fst = Cons xs.value.fst tmp.fst ;
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.165: 	                                       snd = Cons xs.value.snd tmp.snd }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, tail: ?tail, value: ?value}` does not match type `Cons[?A] | None`
//│ ║  l.156: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `Cons[?A] | None`
//│ ║  l.164: 	  Some -> let tmp = unzip xs.tail in { fst = Cons xs.value.fst tmp.fst ;
//│ ║         	                                             ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.164: 	  Some -> let tmp = unzip xs.tail in { fst = Cons xs.value.fst tmp.fst ;
//│ ║         	                                                               ^^^^^^^
//│ ╟── from union type:
//│ ║  l.119: 	type List[A] = Cons[A] | None
//│ ╙──       	               ^^^^^^^^^^^^^^
//│ unzip: 'a -> {fst: None | 'b, snd: None | 'c}
//│   where
//│     'c :> Cons['value] with {tail: None | 'c}
//│     'b :> Cons['value0] with {tail: None | 'b}
//│     'a <: None | Some[?] & {tail: 'a, value: {fst: 'value0, snd: 'value}}

// * Declare desired types:
def Cons_ty: 'a -> ('b & List['a]) -> (Cons['a] & { value: 'a; tail: 'b })
def unzip_ty: List[{ fst: 'a; snd: 'b }] -> { fst: List['a]; snd: List['b] }
//│ Cons_ty: 'a -> (List['a] & 'b) -> (Cons['a] with {tail: 'b})
//│ unzip_ty: List[{fst: 'a, snd: 'b}] -> {fst: List['a], snd: List['b]}

// * Assert the inferred types subsume them (the signatures above are checked):
def Cons_ty = Cons
def unzip_ty = unzip
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.221: 	def Cons_ty = Cons
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] & {Cons#A = ?A, tail: ?tail, value: ?value}` is not an instance of type `Some`
//│ ║  l.156: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.215: 	def Cons_ty: 'a -> ('b & List['a]) -> (Cons['a] & { value: 'a; tail: 'b })
//│ ║         	                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.118: 	class Cons[A]: Some[A] & { tail: List[A] }
//│ ╙──       	               ^^^^^^^
//│ ('value & 'A) -> (List['A] & 'tail) -> (Cons['A] with {tail: 'tail, value: 'value})
//│   <:  Cons_ty:
//│ 'a -> (List['a] & 'b) -> (Cons['a] with {tail: 'b})
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.222: 	def unzip_ty = unzip
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, tail: ?tail, value: ?value}` does not match type `Cons['a] | None`
//│ ║  l.156: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.216: 	def unzip_ty: List[{ fst: 'a; snd: 'b }] -> { fst: List['a]; snd: List['b] }
//│ ║         	                                                   ^^^^^^^^
//│ ╟── from union type:
//│ ║  l.119: 	type List[A] = Cons[A] | None
//│ ╙──       	               ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.222: 	def unzip_ty = unzip
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, tail: ?tail, value: ?value}` does not match type `Cons['b] | None`
//│ ║  l.156: 	def Cons head tail = Cons { value = head; tail = tail }
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.216: 	def unzip_ty: List[{ fst: 'a; snd: 'b }] -> { fst: List['a]; snd: List['b] }
//│ ║         	                                                                  ^^^^^^^^
//│ ╟── from union type:
//│ ║  l.119: 	type List[A] = Cons[A] | None
//│ ╙──       	               ^^^^^^^^^^^^^^
//│ 'a -> {fst: None | 'b, snd: None | 'c}
//│   where
//│     'c :> Cons['value] with {tail: None | 'c}
//│     'b :> Cons['value0] with {tail: None | 'b}
//│     'a <: None | Some[?] & {tail: 'a, value: {fst: 'value0, snd: 'value}}
//│   <:  unzip_ty:
//│ List[{fst: 'a, snd: 'b}] -> {fst: List['a], snd: List['b]}



