
def test f = f (fun b -> if b then 1 else 2)
//│ test: ((bool -> int) -> 'a) -> 'a

test (fun k -> (k true, k false))
//│ res: (int, int,)


class Class: {x : int}
  method Test = 12
//│ Defined class Class
//│ Defined Class.Test: Class -> int

c = Class{x = 1}
//│ c: Class

:js
//│ /!\ Unrecognized option :js
def useCls c = case c of { Class -> c.x | int -> "oops" }
//│ useCls: ((Class with {x: 'x}) | int) -> (string | 'x)

useCls c
//│ res: int | string

useCls (c with { x = 2 })
//│ res: int | string

:js
//│ /!\ Unrecognized option :js
trait T
  method Test2: int
  method Test2 = 1
//│ Defined trait T
//│ Declared T.Test2: T -> int
//│ Defined T.Test2: T -> int

:js
//│ /!\ Unrecognized option :js
class D: T & {z: int}
  method Test2 = 2
//│ Defined class D
//│ Defined D.Test2: D -> int

def useTrt t = case t of { T -> t.y | Class -> t.x }
//│ useTrt: ((Class with {x: 'y}) & ~#T | {y: 'y} & #T) -> 'y

:e
useTrt c
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.48: 	useTrt c
//│ ║        	^^^^^^^^
//│ ╟── application of type `Class` does not have field 'y'
//│ ║  l.14: 	c = Class{x = 1}
//│ ║        	    ^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{y: ?y}`
//│ ║  l.48: 	useTrt c
//│ ║        	       ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.44: 	def useTrt t = case t of { T -> t.y | Class -> t.x }
//│ ║        	                    ^
//│ ╟── from receiver:
//│ ║  l.44: 	def useTrt t = case t of { T -> t.y | Class -> t.x }
//│ ╙──      	                                ^
//│ res: int




useTrt (c with { y = 1 })
//│ res: int

:e
useTrt c
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.73: 	useTrt c
//│ ║        	^^^^^^^^
//│ ╟── application of type `Class` does not have field 'y'
//│ ║  l.14: 	c = Class{x = 1}
//│ ║        	    ^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{y: ?y}`
//│ ║  l.73: 	useTrt c
//│ ║        	       ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.44: 	def useTrt t = case t of { T -> t.y | Class -> t.x }
//│ ║        	                    ^
//│ ╟── from receiver:
//│ ║  l.44: 	def useTrt t = case t of { T -> t.y | Class -> t.x }
//│ ╙──      	                                ^
//│ res: int




d = D{z = 1213}
//│ d: D

d: {z: 'a}
//│ res: {z: int}

d.Test2
//│ ╔══[ERROR] Implicit call to method Test2 is forbidden because it is ambiguous.
//│ ║  l.100: 	d.Test2
//│ ║         	^^^^^^^
//│ ╟── Unrelated methods named Test2 are defined by:
//│ ╟── • trait T
//│ ║  l.30: 	trait T
//│ ║        	      ^
//│ ╟── • class D
//│ ║  l.39: 	class D: T & {z: int}
//│ ╙──      	      ^
//│ res: error

trait T1
  method Test3: int
  method Test3 = 1
  method Test4 = 4
//│ Defined trait T1
//│ Declared T1.Test3: T1 -> int
//│ Defined T1.Test3: T1 -> int
//│ Defined T1.Test4: T1 -> int

:js
//│ /!\ Unrecognized option :js
trait T2: T1
  method Test3: int
  method Test3 = 2
//│ Defined trait T2
//│ Declared T2.Test3: T2 -> int
//│ Defined T2.Test3: T2 -> int

:js
//│ /!\ Unrecognized option :js
class C3: T2
//│ Defined class C3

(C3{}).Test3
//│ ╔══[ERROR] Implicit call to method Test3 is forbidden because it is ambiguous.
//│ ║  l.136: 	(C3{}).Test3
//│ ║         	^^^^^^^^^^^^
//│ ╟── Unrelated methods named Test3 are defined by:
//│ ╟── • trait T1
//│ ║  l.113: 	trait T1
//│ ║         	      ^^
//│ ╟── • trait T2
//│ ║  l.124: 	trait T2: T1
//│ ╙──       	      ^^
//│ res: error

(C3{}).Test4
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.149: 	(C3{}).Test4
//│ ║         	^^^^^^^^^^^^
//│ ╟── application of type `C3` does not match type `?this`
//│ ║  l.149: 	(C3{}).Test4
//│ ║         	 ^^^^
//│ ╟── Note: class C3 is defined at:
//│ ║  l.133: 	class C3: T2
//│ ╙──       	      ^^
//│ res: int


:js
//│ /!\ Unrecognized option :js
trait Oops
//│ Defined trait Oops

:js
//│ /!\ Unrecognized option :js
oo = Oops 2
//│ oo: int & #Oops

:js
//│ /!\ Unrecognized option :js
case oo of { Oops -> 1 }
//│ res: int


