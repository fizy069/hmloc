:NoJS

trait A[T]: { fA: T }
trait B[T]: { fB: T }
trait C[T]: { fC: T }
trait D[T]: { fD: T }
trait E[T]: { fE: T }
trait F[T]: { fF: T }
trait G[T]: { fG: T }
trait H[T]: { fH: T }
//│ Defined trait A[+T]
//│ Defined trait B[+T]
//│ Defined trait C[+T]
//│ Defined trait D[+T]
//│ Defined trait E[+T]
//│ Defined trait F[+T]
//│ Defined trait G[+T]
//│ Defined trait H[+T]

:stats
def foo x = case x of {
  | A -> x.fA
  | B -> x.fB
  | C -> x.fC
  | D -> x.fD
  | E -> x.fE
  | F -> x.fF
  | G -> x.fG
  | H -> x.fH
  }
//│ foo: ({fA: 'fA} & #A | ~#A & ({fB: 'fA} & #B | ~#B & ({fC: 'fA} & #C | ~#C & ({fD: 'fA} & #D | ~#D & ({fE: 'fA} & #E | ~#E & ({fF: 'fA} & #F | ~#F & ({fG: 'fA} & #G | {fH: 'fA} & #H & ~#G))))))) -> 'fA
//│ constrain calls  : 26
//│ annoying  calls  : 0
//│ subtyping calls  : 550


// ====== 1 & all ====== //

:stats
def arg: A[int]
foo arg
//│ arg: A[int]
//│ res: int
//│ constrain calls  : 17
//│ annoying  calls  : 9
//│ subtyping calls  : 640

:stats
:e
def arg: A[int] | B[int]
foo arg
//│ arg: A[int] | B[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.51: 	foo arg
//│ ║        	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.50: 	def arg: A[int] | B[int]
//│ ║        	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.51: 	foo arg
//│ ║        	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.21: 	def foo x = case x of {
//│ ║        	                 ^
//│ ╟── from receiver:
//│ ║  l.22: 	  | A -> x.fA
//│ ╙──      	         ^
//│ res: error | int
//│ constrain calls  : 37
//│ annoying  calls  : 32
//│ subtyping calls  : 1901




:stats
:e
def arg: A[int] | B[int] | C[int]
foo arg
//│ arg: A[int] | B[int] | C[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	foo arg
//│ ║        	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.78: 	def arg: A[int] | B[int] | C[int]
//│ ║        	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.79: 	foo arg
//│ ║        	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.21: 	def foo x = case x of {
//│ ║        	                 ^
//│ ╟── from receiver:
//│ ║  l.22: 	  | A -> x.fA
//│ ╙──      	         ^
//│ res: error | int
//│ constrain calls  : 81
//│ annoying  calls  : 96
//│ subtyping calls  : 5455




:stats
:e
def arg: A[int] | B[int] | D[int]
foo arg
//│ arg: A[int] | B[int] | D[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.107: 	foo arg
//│ ║         	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.106: 	def arg: A[int] | B[int] | D[int]
//│ ║         	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.107: 	foo arg
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.21: 	def foo x = case x of {
//│ ║        	                 ^
//│ ╟── from receiver:
//│ ║  l.22: 	  | A -> x.fA
//│ ╙──      	         ^
//│ res: error
//│ constrain calls  : 120
//│ annoying  calls  : 228
//│ subtyping calls  : 19329





// ====== 2 ====== //

:stats
:e
def foo x = case x of {
  | A -> x.fA
  | B -> x.fB
  }
def arg: A[int] | B[int]
foo arg
//│ foo: ({fA: 'fA} & #A | {fB: 'fA} & #B & ~#A) -> 'fA
//│ arg: A[int] | B[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.142: 	foo arg
//│ ║         	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.141: 	def arg: A[int] | B[int]
//│ ║         	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.142: 	foo arg
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.137: 	def foo x = case x of {
//│ ║         	                 ^
//│ ╟── from receiver:
//│ ║  l.138: 	  | A -> x.fA
//│ ╙──       	         ^
//│ res: error | int
//│ constrain calls  : 45
//│ annoying  calls  : 32
//│ subtyping calls  : 210





// ====== 3 ====== //

:stats
:e
def foo x = case x of {
  | A -> x.fA
  | B -> x.fB
  | C -> x.fC
  }
def arg: A[int] | B[int] | C[int]
foo arg
//│ foo: ({fA: 'fA} & #A | ~#A & ({fB: 'fA} & #B | {fC: 'fA} & #C & ~#B)) -> 'fA
//│ arg: A[int] | B[int] | C[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.179: 	foo arg
//│ ║         	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.178: 	def arg: A[int] | B[int] | C[int]
//│ ║         	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.179: 	foo arg
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.173: 	def foo x = case x of {
//│ ║         	                 ^
//│ ╟── from receiver:
//│ ║  l.174: 	  | A -> x.fA
//│ ╙──       	         ^
//│ res: error | int
//│ constrain calls  : 92
//│ annoying  calls  : 96
//│ subtyping calls  : 2350





// ====== 4 ====== //

:stats
:e
def foo x = case x of {
  | A -> x.fA
  | B -> x.fB
  | C -> x.fC
  | D -> x.fD
  }
def arg: A[int] | B[int] | C[int] | D[int]
foo arg
//│ foo: ({fA: 'fA} & #A | ~#A & ({fB: 'fA} & #B | ~#B & ({fC: 'fA} & #C | {fD: 'fA} & #D & ~#C))) -> 'fA
//│ arg: A[int] | B[int] | C[int] | D[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.217: 	foo arg
//│ ║         	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.216: 	def arg: A[int] | B[int] | C[int] | D[int]
//│ ║         	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.217: 	foo arg
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.210: 	def foo x = case x of {
//│ ║         	                 ^
//│ ╟── from receiver:
//│ ║  l.211: 	  | A -> x.fA
//│ ╙──       	         ^
//│ res: error
//│ constrain calls  : 113
//│ annoying  calls  : 138
//│ subtyping calls  : 4434




:stats
:e
foo (arg with { x = 1} with { y = 2 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.245: 	foo (arg with { x = 1} with { y = 2 })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `with` extension of type `#B & ({fB: int, x: 1, y: 2} & #A | {fB: int, x: 1, y: 2} & ~?a)` is not a 1-element tuple
//│ ║  l.245: 	foo (arg with { x = 1} with { y = 2 })
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `(?b,)`
//│ ║  l.245: 	foo (arg with { x = 1} with { y = 2 })
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.210: 	def foo x = case x of {
//│ ║         	                 ^
//│ ╟── from receiver:
//│ ║  l.211: 	  | A -> x.fA
//│ ╙──       	         ^
//│ res: error
//│ constrain calls  : 88
//│ annoying  calls  : 135
//│ subtyping calls  : 5671




:stats
:e
foo (arg with { x = 1; y = 2; z = 3 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.271: 	foo (arg with { x = 1; y = 2; z = 3 })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `with` extension of type `#B & ({fB: int, x: 1, y: 2, z: 3} & #A | {fB: int, x: 1, y: 2, z: 3} & ~?a)` is not a 1-element tuple
//│ ║  l.271: 	foo (arg with { x = 1; y = 2; z = 3 })
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `(?b,)`
//│ ║  l.271: 	foo (arg with { x = 1; y = 2; z = 3 })
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.210: 	def foo x = case x of {
//│ ║         	                 ^
//│ ╟── from receiver:
//│ ║  l.211: 	  | A -> x.fA
//│ ╙──       	         ^
//│ res: error
//│ constrain calls  : 88
//│ annoying  calls  : 135
//│ subtyping calls  : 5515





// ====== 5 ====== //

:stats
:e
def foo x = case x of {
  | A -> x.fA
  | B -> x.fB
  | C -> x.fC
  | D -> x.fD
  | E -> x.fE
  }
def arg: A[int] | B[int] | C[int] | D[int] | E[int]
foo arg
//│ foo: ({fA: 'fA} & #A | ~#A & ({fB: 'fA} & #B | ~#B & ({fC: 'fA} & #C | ~#C & ({fD: 'fA} & #D | {fE: 'fA} & #E & ~#D)))) -> 'fA
//│ arg: A[int] | B[int] | C[int] | D[int] | E[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.308: 	foo arg
//│ ║         	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.307: 	def arg: A[int] | B[int] | C[int] | D[int] | E[int]
//│ ║         	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.308: 	foo arg
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.300: 	def foo x = case x of {
//│ ║         	                 ^
//│ ╟── from receiver:
//│ ║  l.301: 	  | A -> x.fA
//│ ╙──       	         ^
//│ res: error
//│ constrain calls  : 117
//│ annoying  calls  : 138
//│ subtyping calls  : 5218





// ====== 6 ====== //

:stats
:e
def foo x = case x of {
  | A -> x.fA
  | B -> x.fB
  | C -> x.fC
  | D -> x.fD
  | E -> x.fE
  | F -> x.fF
  }
def arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int]
foo arg
//│ foo: ({fA: 'fA} & #A | ~#A & ({fB: 'fA} & #B | ~#B & ({fC: 'fA} & #C | ~#C & ({fD: 'fA} & #D | ~#D & ({fE: 'fA} & #E | {fF: 'fA} & #F & ~#E))))) -> 'fA
//│ arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.348: 	foo arg
//│ ║         	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.347: 	def arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int]
//│ ║         	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.348: 	foo arg
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.339: 	def foo x = case x of {
//│ ║         	                 ^
//│ ╟── from receiver:
//│ ║  l.340: 	  | A -> x.fA
//│ ╙──       	         ^
//│ res: error
//│ constrain calls  : 121
//│ annoying  calls  : 138
//│ subtyping calls  : 6331





// ====== 7 ====== //

:stats
:e
def foo x = case x of {
  | A -> x.fA
  | B -> x.fB
  | C -> x.fC
  | D -> x.fD
  | E -> x.fE
  | F -> x.fF
  | G -> x.fG
  }
def arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int] | G[int]
foo arg
//│ foo: ({fA: 'fA} & #A | ~#A & ({fB: 'fA} & #B | ~#B & ({fC: 'fA} & #C | ~#C & ({fD: 'fA} & #D | ~#D & ({fE: 'fA} & #E | ~#E & ({fF: 'fA} & #F | {fG: 'fA} & #G & ~#F)))))) -> 'fA
//│ arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int] | G[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.389: 	foo arg
//│ ║         	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.388: 	def arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int] | G[int]
//│ ║         	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.389: 	foo arg
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.379: 	def foo x = case x of {
//│ ║         	                 ^
//│ ╟── from receiver:
//│ ║  l.380: 	  | A -> x.fA
//│ ╙──       	         ^
//│ res: error
//│ constrain calls  : 125
//│ annoying  calls  : 138
//│ subtyping calls  : 7826




def foo_manual: ({fA: 'a} & a | {fB: 'a} & b & ~a | {fC: 'a} & c & ~a & ~b | {fD: 'a} & d & ~a & ~b & ~c | {fE: 'a} & e & ~a & ~b & ~c & ~d | {fF: 'a} & f & ~a & ~b & ~c & ~d & ~e | {fG: 'a} & g & ~a & ~b & ~c & ~d & ~e & ~f) -> 'a
//│ foo_manual: ({fA: 'a} & #A | ~#A & ({fB: 'a} & #B | ~#B & ({fC: 'a} & #C | ~#C & ({fD: 'a} & #D | ~#D & ({fE: 'a} & #E | ~#E & ({fF: 'a} & #F | {fG: 'a} & #G & ~#F)))))) -> 'a

:stats
:e
foo_manual arg
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.420: 	foo_manual arg
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.388: 	def arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int] | G[int]
//│ ║         	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `({fA: ?a} & #A | ~#A & ({fB: ?a} & #B | ~#B & ({fC: ?a} & #C | ~#C & ({fD: ?a} & #D | ~#D & ({fE: ?a} & #E | ~#E & ({fF: ?a} & #F | {fG: ?a} & #G & ~#F))))),)`
//│ ║  l.420: 	foo_manual arg
//│ ║         	           ^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.415: 	def foo_manual: ({fA: 'a} & a | {fB: 'a} & b & ~a | {fC: 'a} & c & ~a & ~b | {fD: 'a} & d & ~a & ~b & ~c | {fE: 'a} & e & ~a & ~b & ~c & ~d | {fF: 'a} & f & ~a & ~b & ~c & ~d & ~e | {fG: 'a} & g & ~a & ~b & ~c & ~d & ~e & ~f) -> 'a
//│ ╙──       	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: error
//│ constrain calls  : 22
//│ annoying  calls  : 67
//│ subtyping calls  : 3584





:stats
foo_manual = foo
//│ ({fA: 'fA} & #A | ~#A & ({fB: 'fA} & #B | ~#B & ({fC: 'fA} & #C | ~#C & ({fD: 'fA} & #D | ~#D & ({fE: 'fA} & #E | ~#E & ({fF: 'fA} & #F | {fG: 'fA} & #G & ~#F)))))) -> 'fA
//│   <:  foo_manual:
//│ ({fA: 'a} & #A | ~#A & ({fB: 'a} & #B | ~#B & ({fC: 'a} & #C | ~#C & ({fD: 'a} & #D | ~#D & ({fE: 'a} & #E | ~#E & ({fF: 'a} & #F | {fG: 'a} & #G & ~#F)))))) -> 'a
//│ constrain calls  : 89
//│ annoying  calls  : 183
//│ subtyping calls  : 4292


// ====== 8 ====== //

:stats
:e
def foo x = case x of {
  | A -> x.fA
  | B -> x.fB
  | C -> x.fC
  | D -> x.fD
  | E -> x.fE
  | F -> x.fF
  | G -> x.fG
  | H -> x.fH
  }
def arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int] | G[int] | H[int]
foo arg
//│ foo: ({fA: 'fA} & #A | ~#A & ({fB: 'fA} & #B | ~#B & ({fC: 'fA} & #C | ~#C & ({fD: 'fA} & #D | ~#D & ({fE: 'fA} & #E | ~#E & ({fF: 'fA} & #F | ~#F & ({fG: 'fA} & #G | {fH: 'fA} & #H & ~#G))))))) -> 'fA
//│ arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int] | G[int] | H[int]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.467: 	foo arg
//│ ║         	^^^^^^^
//│ ╟── type `{fB: int} & #B` is not a 1-element tuple
//│ ║  l.466: 	def arg: A[int] | B[int] | C[int] | D[int] | E[int] | F[int] | G[int] | H[int]
//│ ║         	                  ^^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.467: 	foo arg
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.456: 	def foo x = case x of {
//│ ║         	                 ^
//│ ╟── from receiver:
//│ ║  l.457: 	  | A -> x.fA
//│ ╙──       	         ^
//│ res: error
//│ constrain calls  : 129
//│ annoying  calls  : 138
//│ subtyping calls  : 9756





