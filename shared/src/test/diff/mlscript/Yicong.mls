
trait T1
trait T2
//│ Defined trait T1
//│ Defined trait T2

r = if true then T1 1 else T2 2
//│ r: (int,) & #T1 | (int,) & #T2

case r of { T1 -> r | _ -> 0 }
//│ res: (int,) & #T1 | int

// TODO also factor ClassTag-s like `2`:
case r of { T1 -> r | T2 -> r }
//│ res: (int,) & #T1 | 'a | #T2 & ((int,) & ~#T1 | (int,) & ~#T2 | (int,) & ~'a)

r = if true then T1 ((1,2,3)) else T2 ((3,4,5,4))
//│ r: ((int, int, int, int,),) & #T2 | ((int, int, int,),) & #T1

case r of { T1 -> r | _ -> 0 }
//│ res: int | #T1 & (((int, int, int, int,),) & #T2 | ((int, int, int,),))

case r of { T1 -> r | T2 -> r }
//│ res: ((int, int, int,),) & #T1 | 'a | #T2 & (((int, int, int, int,),) & #T1 | ((int, int, int, int,),) & ~#T1 | ((int, int, int, int,),) & ~#T2 | ((int, int, int, int,),) & ~'a)


x = 1
//│ x: int

t2 = T2 x
//│ t2: (int,) & #T2

t1 = T1 t2
//│ t1: ((int,) & #T2,) & #T1

t1: T1
t1: T2
//│ res: T1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.37: 	t1: T2
//│ ║        	^^
//│ ╟── argument of type `(?a,)` does not match type `#T2 | ~#T1`
//│ ║  l.33: 	t1 = T1 t2
//│ ║        	        ^^
//│ ╟── but it flows into reference with expected type `#T2 | ~#T1`
//│ ║  l.37: 	t1: T2
//│ ║        	^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.37: 	t1: T2
//│ ╙──      	    ^^
//│ res: T2


class C1[A]: { a: A }
class C2[A]: { a: A }
//│ Defined class C1[+A]
//│ Defined class C2[+A]

r = if true then C1 {a=x} else C2 {a=(3,4,5,4)}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.59: 	r = if true then C1 {a=x} else C2 {a=(3,4,5,4)}
//│ ║        	                 ^^^^^^^^
//│ ╟── argument of type `({a: int},)` does not have field 'a'
//│ ║  l.59: 	r = if true then C1 {a=x} else C2 {a=(3,4,5,4)}
//│ ╙──      	                    ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.59: 	r = if true then C1 {a=x} else C2 {a=(3,4,5,4)}
//│ ║        	                               ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({a: (int, int, int, int,)},)` does not have field 'a'
//│ ║  l.59: 	r = if true then C1 {a=x} else C2 {a=(3,4,5,4)}
//│ ╙──      	                                  ^^^^^^^^^^^^^
//│ r: C1[nothing] | C2[nothing]

case r of { C1 -> r.a | _ -> 0 }
//│ res: int

def x1: (int, bool)
def x2: (string, unit)
//│ x1: (int, bool,)
//│ x2: (string, unit,)


if true then x1 else x2
//│ res: (int | string, bool | unit,)



def f: ((1,2) | (3,4)) -> anything
//│ f: (1 | 3, 2 | 4,) -> anything

fun (x, y) -> f ((x,y))
//│ res: (1 | 3, 2 | 4,) -> anything

def f: ((1,2)&t1 | (3,4)&t2) -> anything
//│ f: ((1, 2,) & #T1 | (3, 4,) & #T2) -> anything

:e
f ((true,false))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.98: 	f ((true,false))
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── reference of type `bool` does not match type `1 | 3`
//│ ║  l.98: 	f ((true,false))
//│ ║        	    ^^^^
//│ ╟── but it flows into tuple literal with expected type `1 | 3`
//│ ║  l.98: 	f ((true,false))
//│ ║        	   ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.94: 	def f: ((1,2)&t1 | (3,4)&t2) -> anything
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^
//│ res: nothing



:e
fun (x, y) -> f ((x,y))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.116: 	fun (x, y) -> f ((x,y))
//│ ║         	              ^^^^^^^^^
//│ ╟── tuple literal of type `(?a, ?b,)` does not match type `(1, 2,) & #T1 | (3, 4,) & #T2`
//│ ║  l.116: 	fun (x, y) -> f ((x,y))
//│ ║         	                 ^^^^^
//│ ╟── but it flows into argument with expected type `(1, 2,) & #T1 | (3, 4,) & #T2`
//│ ║  l.116: 	fun (x, y) -> f ((x,y))
//│ ║         	                ^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.94: 	def f: ((1,2)&t1 | (3,4)&t2) -> anything
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^
//│ res: (nothing, nothing,) -> anything




fun (x, y) -> f (T1 ((x,y)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.134: 	fun (x, y) -> f (T1 ((x,y)))
//│ ║         	              ^^^^^^^^^^^^^^
//│ ╟── argument of type `((?a, ?b,),)` does not match type `(1, 2,) & #T1 | (3, 4,) & #T2 | ~#T1`
//│ ║  l.134: 	fun (x, y) -> f (T1 ((x,y)))
//│ ║         	                    ^^^^^^^
//│ ╟── but it flows into application with expected type `(1, 2,) & #T1 | (3, 4,) & #T2 | ~#T1`
//│ ║  l.134: 	fun (x, y) -> f (T1 ((x,y)))
//│ ║         	                 ^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.94: 	def f: ((1,2)&t1 | (3,4)&t2) -> anything
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^
//│ res: (anything, anything,) -> anything

fun (x, y) -> f (T2 ((x,y)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.149: 	fun (x, y) -> f (T2 ((x,y)))
//│ ║         	              ^^^^^^^^^^^^^^
//│ ╟── argument of type `((?a, ?b,),)` does not match type `(1, 2,) & #T1 | (3, 4,) & #T2 | ~#T2`
//│ ║  l.149: 	fun (x, y) -> f (T2 ((x,y)))
//│ ║         	                    ^^^^^^^
//│ ╟── but it flows into application with expected type `(1, 2,) & #T1 | (3, 4,) & #T2 | ~#T2`
//│ ║  l.149: 	fun (x, y) -> f (T2 ((x,y)))
//│ ║         	                 ^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.94: 	def f: ((1,2)&t1 | (3,4)&t2) -> anything
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^
//│ res: (anything, anything,) -> anything

:ns
res = if true then (1,2, "hello") else (true, 3)
//│ res: 'a
//│   where
//│     'a :> (int, int, string,) | (bool, int,)

res = if true then (1, 2, 3, 'hello') else (true, 4, false)
hhh = if false then (45,345, 'bye', true) else (false, 3)
t = if false then res else hhh
g = if true then (6,6,6) else res
gwx = g with {x=123}
gwx.x with {y = gwx}
//│ res: Array[bool | int | string] & {_1: bool | int, _2: int, _3: bool | int}
//│ hhh: Array[bool | int | string] & {_1: bool | int, _2: int}
//│ t: Array[bool | int | string] & {_1: bool | int, _2: int}
//│ g: Array[bool | int | string] & {_1: bool | int, _2: int, _3: bool | int}
//│ gwx: Array[bool | int | string] & {_1: bool | int, _2: int, _3: bool | int, x: int}
//│ res: int & {y: Array[bool | int | string] & {_1: bool | int, _2: int, _3: bool | int, x: int}}

def f: (int, bool) -> int
def g: (bool, string, int) -> int
// def h x = (f(x), g(x))
//│ f: (int, bool,) -> int
//│ g: (bool, string, int,) -> int

p1 = if true then (1, 2, 2) else (true, false)
//│ p1: Array[bool | int] & {_1: bool | int, _2: bool | int}

def q: Array[int]
q = if true then (1,1) else (1,1,1)
//│ q: Array[int]
//│ Array[int] & {_1: int, _2: int}
//│   <:  q:
//│ Array[int]

// Note: function with non-tuple domain
def h f = (f (1,2,false), f (1,true))
//│ h: ((Array[bool | int] & {_1: int, _2: bool | int}) -> 'a) -> ('a, 'a,)

:e
h (fun x -> x[0])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.204: 	h (fun x -> x[0])
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(int, bool,)` does not match type `(?a,)`
//│ ║  l.200: 	def h f = (f (1,2,false), f (1,true))
//│ ╙──       	                            ^^^^^^^^
//│ res: (undefined, undefined,)



:e
h (fun (x, y) -> x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.216: 	h (fun (x, y) -> x)
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(int, int, bool,)` does not match type `(?a, ?b,)`
//│ ║  l.200: 	def h f = (f (1,2,false), f (1,true))
//│ ║         	             ^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.216: 	h (fun (x, y) -> x)
//│ ╙──       	       ^^^^^^
//│ res: (int, int,)




def h f = (f ((1,2,false)), f ((1,true)))
//│ h: ((Array[bool | int] & {_1: int, _2: bool | int}) -> 'a) -> ('a, 'a,)

h (fun x -> x[0])
h (fun x -> x._1)
//│ res: (bool | int | undefined, bool | int | undefined,)
//│ res: (int, int,)


q1 = (1,1,1,1)
q2 = (1,1)
fx ((a,b,c)) = a + b + c
//│ q1: (int, int, int, int,)
//│ q2: (int, int,)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ║         	               ^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ║         	               ^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ╙──       	                   ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ║         	               ^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ╙──       	               ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ║         	               ^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ╙──       	                       ^
//│ fx: (anything, anything, anything,) -> int

:e
fx q1
fx q2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.272: 	fx q1
//│ ║         	^^^^^
//│ ╟── tuple literal of type `(int, int, int, int,)` does not match type `(?a, ?b, ?c,)`
//│ ║  l.240: 	q1 = (1,1,1,1)
//│ ║         	     ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?a, ?b, ?c,)`
//│ ║  l.272: 	fx q1
//│ ║         	   ^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ╙──       	    ^^^^^^^
//│ res: int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.273: 	fx q2
//│ ║         	^^^^^
//│ ╟── tuple literal of type `(int, int,)` does not match type `(?a, ?b, ?c,)`
//│ ║  l.241: 	q2 = (1,1)
//│ ║         	     ^^^^^
//│ ╟── but it flows into reference with expected type `(?a, ?b, ?c,)`
//│ ║  l.273: 	fx q2
//│ ║         	   ^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.242: 	fx ((a,b,c)) = a + b + c
//│ ╙──       	    ^^^^^^^
//│ res: int










// :d
q = (1,1)
//│ (int, int,)
//│   <:  q:
//│ Array[int]

def sum: Array[int] -> int
t1 = (1,2,3,4,5,6)
sum t1
//│ sum: Array[int] -> int
//│ t1: (int, int, int, int, int, int,)
//│ res: int

:e
t2 = (1,1,2,true)
sum t2
//│ t2: (int, int, int, bool,)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.325: 	sum t2
//│ ║         	^^^^^^
//│ ╟── reference of type `bool` is not an instance of `int`
//│ ║  l.324: 	t2 = (1,1,2,true)
//│ ║         	            ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.316: 	def sum: Array[int] -> int
//│ ╙──       	               ^^^
//│ res: int




t2: (1, 1, 2, bool)
t2: Array[int | bool]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.341: 	t2: (1, 1, 2, bool)
//│ ║         	^^
//│ ╟── integer literal of type `int` does not match type `1`
//│ ║  l.324: 	t2 = (1,1,2,true)
//│ ║         	      ^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.341: 	t2: (1, 1, 2, bool)
//│ ╙──       	     ^
//│ res: (1, 1, 2, bool,)
//│ res: Array[bool | int]

class Wrapped[A]: {len: int; inner: Array[A]}
//│ Defined class Wrapped[+A]

def tk: Array['a] -> Wrapped['a]
tk ((1,2,3,true,false))
//│ tk: Array['a] -> Wrapped['a]
//│ res: Wrapped[bool | int]

class Two[A, B]: {fst: Array[A]; snd: Array[B]}
two = Two {fst=(1,2,3); snd=(true,false)}
two.fst
tk (two.snd)
//│ Defined class Two[+A, +B]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.364: 	two = Two {fst=(1,2,3); snd=(true,false)}
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({fst: (int, int, int,), snd: (bool, bool,)},)` is not a record (expected a record with fields: fst, snd)
//│ ║  l.364: 	two = Two {fst=(1,2,3); snd=(true,false)}
//│ ╙──       	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ two: Two[nothing, nothing] & {fst: nothing, snd: nothing}
//│ res: nothing
//│ res: Wrapped[nothing]

:e
def a1: Array[int]
a1 = (1,2,true,'hello')
a1._2
//│ a1: Array[int]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.380: 	a1 = (1,2,true,'hello')
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `bool` is not an instance of `int`
//│ ║  l.380: 	a1 = (1,2,true,'hello')
//│ ║         	          ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.379: 	def a1: Array[int]
//│ ╙──       	              ^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.380: 	a1 = (1,2,true,'hello')
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` is not an instance of `int`
//│ ║  l.380: 	a1 = (1,2,true,'hello')
//│ ║         	               ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.379: 	def a1: Array[int]
//│ ╙──       	              ^^^
//│ (int, int, bool, string,)
//│   <:  a1:
//│ Array[int]
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.381: 	a1._2
//│ ║         	^^^^^
//│ ╟── type `Array[int]` does not have field '_2'
//│ ║  l.379: 	def a1: Array[int]
//│ ║         	        ^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{_2: ?a}`
//│ ║  l.381: 	a1._2
//│ ╙──       	^^
//│ res: nothing










def getx p = p.x
def a123: Array[int]
a123 = (1,2,3)
getx (a123 with {x=('hello', a123)})
//│ getx: {x: 'x} -> 'x
//│ a123: Array[int]
//│ (int, int, int,)
//│   <:  a123:
//│ Array[int]
//│ res: (string, Array[int],)

def append: Array['a] -> Array['b] -> Array['a | 'b]
append ((1,2,false)) (((), 'hi'))
//│ append: Array['a] -> Array['a] -> Array['a]
//│ res: Array[() | bool | int | string]

def append2: MutArray['aa] -> MutArray['bb] -> MutArray['aa | 'bb]
append2 ((mut 1, mut 2, mut false)) ((mut (), mut 'hi'))
//│ append2: MutArray['aa] -> MutArray['bb] -> MutArray['aa | 'bb]
//│ res: MutArray['a | 'b]
//│   where
//│     'b :> () | string
//│     'a :> bool | int

:e
append2 ((mut 1, mut 2, mut false)) ((mut (), 'hi'))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.449: 	append2 ((mut 1, mut 2, mut false)) ((mut (), 'hi'))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(mut ?a, string,)` does not match type `MutArray[?bb]`
//│ ║  l.449: 	append2 ((mut 1, mut 2, mut false)) ((mut (), 'hi'))
//│ ║         	                                     ^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `MutArray[?bb]`
//│ ║  l.449: 	append2 ((mut 1, mut 2, mut false)) ((mut (), 'hi'))
//│ ║         	                                    ^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.440: 	def append2: MutArray['aa] -> MutArray['bb] -> MutArray['aa | 'bb]
//│ ╙──       	                              ^^^^^^^^^^^^^
//│ res: MutArray['bb | 'a]
//│   where
//│     'a :> bool | int
//│     'bb :> () | string




def ta: T1 & Array[int]
ta = T1 a123
//│ ta: T1 & Array[int]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.471: 	ta = T1 a123
//│ ║         	^^^^^^^^^^^^
//│ ╟── reference of type `Array[int]` is not an instance of type `int`
//│ ║  l.471: 	ta = T1 a123
//│ ║         	        ^^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.471: 	ta = T1 a123
//│ ║         	     ^^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.470: 	def ta: T1 & Array[int]
//│ ║         	        ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.470: 	def ta: T1 & Array[int]
//│ ╙──       	                   ^^^
//│ (Array[int],) & #T1
//│   <:  ta:
//│ T1 & Array[int]

def tb: T2 & Array[int]
tb = T2 ((1,2,3))
def tba: (T2 & Array[int | bool]) -> (T2 & int)
tba tb
//│ tb: T2 & Array[int]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.493: 	tb = T2 ((1,2,3))
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(int, int, int,)` is not an instance of type `int`
//│ ║  l.493: 	tb = T2 ((1,2,3))
//│ ║         	         ^^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.493: 	tb = T2 ((1,2,3))
//│ ║         	        ^^^^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.492: 	def tb: T2 & Array[int]
//│ ║         	        ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.492: 	def tb: T2 & Array[int]
//│ ╙──       	                   ^^^
//│ ((int, int, int,),) & #T2
//│   <:  tb:
//│ T2 & Array[int]
//│ tba: (T2 & Array[bool | int]) -> (T2 & int)
//│ res: T2 & int

def k: (true, false, 3) & Array[int | true]
def k2: Array[1 | 2 | 3] & (true, 'hi', 2, 3)
//│ k: (true, nothing, 3,)
//│ k2: (nothing, nothing, 2, 3,)

def gett1 p q = case p of {T1 -> p | _ -> q}
gett1 ta (T1 123)
def gt: (T1 & Array[int | bool]) -> Array[int]
gt ta
def tg: ((T1 & Array[int]) | (T2 & Array[bool])) -> (T1 | T2)
//│ gett1: (#T1 & 'a | ~#T1) -> 'a -> 'a
//│ res: Array[int] & #T1
//│ gt: (T1 & Array[bool | int]) -> Array[int]
//│ res: Array[int]
//│ tg: (T2 & Array[bool] | T1 & Array[int]) -> (T1 | T2)

gett1 ta (T1 123)
tg (T1 ((1,2,3,4)))
tg (T2 ((true,false,false)))
//│ res: Array[int] & #T1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.535: 	tg (T1 ((1,2,3,4)))
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(int, int, int, int,)` does not match type `bool | int`
//│ ║  l.535: 	tg (T1 ((1,2,3,4)))
//│ ║         	        ^^^^^^^^^
//│ ╟── but it flows into argument with expected type `bool | int`
//│ ║  l.535: 	tg (T1 ((1,2,3,4)))
//│ ║         	       ^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.527: 	def tg: ((T1 & Array[int]) | (T2 & Array[bool])) -> (T1 | T2)
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: T1 | T2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.536: 	tg (T2 ((true,false,false)))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(bool, bool, bool,)` does not match type `bool | int`
//│ ║  l.536: 	tg (T2 ((true,false,false)))
//│ ║         	        ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `bool | int`
//│ ║  l.536: 	tg (T2 ((true,false,false)))
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.527: 	def tg: ((T1 & Array[int]) | (T2 & Array[bool])) -> (T1 | T2)
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: T1 | T2

def fst ((a, b)) = a
def snd ((a, b)) = b
def get: Array['a] -> int -> 'a
//│ fst: ('a, anything,) -> 'a
//│ snd: (anything, 'a,) -> 'a
//│ get: Array['a] -> int -> 'a

fst ((1,2))
snd ((1,2))
get ((1,2,3)) 1
//│ res: int
//│ res: int
//│ res: int

def intersect: Array['a] -> Array['b] -> Array['a & 'b]
iarr = intersect ((1,2,3,false)) ((1,5,true,'hi',false))
//│ intersect: Array['a] -> Array['b] -> Array['a & 'b]
//│ iarr: Array[bool | int]

:e
fst iarr
snd (T1 ((1,2,3)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.585: 	fst iarr
//│ ║         	^^^^^^^^
//│ ╟── type `Array[?a & ?b]` is not a 2-element tuple
//│ ║  l.579: 	def intersect: Array['a] -> Array['b] -> Array['a & 'b]
//│ ║         	                                         ^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?c, ?d,)`
//│ ║  l.585: 	fst iarr
//│ ║         	    ^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.565: 	def fst ((a, b)) = a
//│ ╙──       	         ^^^^^^
//│ res: nothing
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.586: 	snd (T1 ((1,2,3)))
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `((int, int, int,),)` does not match type `(?a, ?b,)`
//│ ║  l.586: 	snd (T1 ((1,2,3)))
//│ ║         	        ^^^^^^^^^
//│ ╟── but it flows into application with expected type `(?a, ?b,)`
//│ ║  l.586: 	snd (T1 ((1,2,3)))
//│ ║         	     ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.566: 	def snd ((a, b)) = b
//│ ╙──       	         ^^^^^^
//│ res: nothing









v1 = T1 (T2 ((1,2,true)))
v2 = T2 (v1 with {x=v1})
def inn: (T1 & T2 & Array['a]) -> 'a
def inn2: (T2 & Array[Array['a]]) -> Array[T1 & 'a]
inn v1
inn (v2 with {y= T1 ((1,2,3))})
def v3: Array[Array[(int, true)]]
r1 = inn2 (T2 v3)
inn (T1 (T2 v3))
//│ v1: (((int, int, bool,),) & #T2,) & #T1
//│ v2: ((((int, int, bool,),) & #T2,) & {x: (((int, int, bool,),) & #T2,) & #T1} & #T1,) & #T2
//│ inn: (T1 & T2 & Array['a]) -> 'a
//│ inn2: (T2 & Array[Array['a]]) -> Array[T1 & 'a]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.626: 	inn v1
//│ ║         	^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `#T2 | ~#T1`
//│ ║  l.622: 	v1 = T1 (T2 ((1,2,true)))
//│ ║         	        ^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `#T2 | ~#T1`
//│ ║  l.626: 	inn v1
//│ ║         	    ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.624: 	def inn: (T1 & T2 & Array['a]) -> 'a
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.624: 	def inn: (T1 & T2 & Array['a]) -> 'a
//│ ╙──       	               ^^
//│ res: ((int, int, bool,),) & #T2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.627: 	inn (v2 with {y= T1 ((1,2,3))})
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a\x & {x: ?b},)` does not match type `#T1 | ~({y: ?c} & #T2)`
//│ ║  l.623: 	v2 = T2 (v1 with {x=v1})
//│ ║         	        ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into `with` extension with expected type `#T1 | ~({y: ?d} & #T2)`
//│ ║  l.627: 	inn (v2 with {y= T1 ((1,2,3))})
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.624: 	def inn: (T1 & T2 & Array['a]) -> 'a
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.624: 	def inn: (T1 & T2 & Array['a]) -> 'a
//│ ╙──       	          ^^
//│ res: (((int, int, bool,),) & #T2,) & {x: (((int, int, bool,),) & #T2,) & #T1} & #T1
//│ v3: Array[Array[(int, true,)]]
//│ r1: Array[T1 & Array[(int, true,)]]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.630: 	inn (T1 (T2 v3))
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `#T2 | ~#T1`
//│ ║  l.630: 	inn (T1 (T2 v3))
//│ ║         	        ^^^^^^^
//│ ╟── but it flows into application with expected type `#T2 | ~#T1`
//│ ║  l.630: 	inn (T1 (T2 v3))
//│ ║         	     ^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.624: 	def inn: (T1 & T2 & Array['a]) -> 'a
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.624: 	def inn: (T1 & T2 & Array['a]) -> 'a
//│ ╙──       	               ^^
//│ res: (Array[Array[(int, true,)]],) & #T2

v3: Array[Array[Array[int | bool]]]
inn2 (T2 r1)
//│ res: Array[Array[Array[bool | int]]]
//│ res: Array[T1 & Array[(int, true,)]]

:e
inn (T1 v3)
inn2 v1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.692: 	inn (T1 v3)
//│ ║         	^^^^^^^^^^^
//│ ╟── argument of type `(Array[Array[(int, true,)]],)` does not match type `#T2 | ~#T1`
//│ ║  l.692: 	inn (T1 v3)
//│ ║         	        ^^
//│ ╟── but it flows into application with expected type `#T2 | ~#T1`
//│ ║  l.692: 	inn (T1 v3)
//│ ║         	     ^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.624: 	def inn: (T1 & T2 & Array['a]) -> 'a
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.624: 	def inn: (T1 & T2 & Array['a]) -> 'a
//│ ╙──       	               ^^
//│ res: Array[Array[(int, true,)]]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.693: 	inn2 v1
//│ ║         	^^^^^^^
//│ ╟── argument of type `(?a,)` does not match type `#T2 | ~#T1`
//│ ║  l.622: 	v1 = T1 (T2 ((1,2,true)))
//│ ║         	        ^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `#T2 | ~#T1`
//│ ║  l.693: 	inn2 v1
//│ ║         	     ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.625: 	def inn2: (T2 & Array[Array['a]]) -> Array[T1 & 'a]
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.625: 	def inn2: (T2 & Array[Array['a]]) -> Array[T1 & 'a]
//│ ╙──       	           ^^
//│ res: Array[T1 & (int, int, bool,)]








def ra: ('a, 'a) as 'a
ra: Array[Array['a]] as 'a
ra: Array[('a, 'a)] as 'a
ra: (Array['a], Array['a]) as 'a
//│ ra: 'a
//│   where
//│     'a :> ('a, 'a,)
//│ res: 'a
//│   where
//│     'a :> 'a0 | Array[Array['a]]
//│     'a0 :> ('a0, 'a0,)
//│ res: 'a
//│   where
//│     'a :> 'a0 | Array[('a, 'a,)]
//│     'a0 :> ('a0, 'a0,)
//│ res: 'a
//│   where
//│     'a :> ('a0 | Array['a], 'a0 | Array['a],)
//│     'a0 :> ('a0, 'a0,)

:e
ra: ('a, 'a, 'a) as 'a
ra: (Array['a], Array['a], Array['a]) as 'a
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.755: 	ra: ('a, 'a, 'a) as 'a
//│ ║         	^^
//│ ╟── type `(?a, ?a,)` does not match type `?a0`
//│ ║  l.734: 	def ra: ('a, 'a) as 'a
//│ ║         	        ^^^^^^^^
//│ ╟── but it flows into reference with expected type `?a1`
//│ ║  l.755: 	ra: ('a, 'a, 'a) as 'a
//│ ║         	^^
//│ ╟── Note: constraint arises from local type binding:
//│ ║  l.755: 	ra: ('a, 'a, 'a) as 'a
//│ ╙──       	    ^^^^^^^^^^^^
//│ res: 'a
//│   where
//│     'a :> 'a0 | ('a, 'a, 'a,)
//│     'a0 :> ('a0, 'a0,)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.756: 	ra: (Array['a], Array['a], Array['a]) as 'a
//│ ║         	^^
//│ ╟── type `(?a, ?a,)` does not match type `?a0`
//│ ║  l.734: 	def ra: ('a, 'a) as 'a
//│ ║         	        ^^^^^^^^
//│ ╟── but it flows into reference with expected type `?a1`
//│ ║  l.756: 	ra: (Array['a], Array['a], Array['a]) as 'a
//│ ║         	^^
//│ ╟── Note: constraint arises from local type binding:
//│ ║  l.756: 	ra: (Array['a], Array['a], Array['a]) as 'a
//│ ╙──       	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: 'a
//│   where
//│     'a :> 'a0 | (Array['a], Array['a], Array['a],)
//│     'a0 :> ('a0, 'a0,)









def tktup t = (t._2, t._3)
tktup ((1,2,3,true))
//│ tktup: {_2: 'a, _3: 'b} -> ('a, 'b,)
//│ res: (int, int,)

:e
tktup a123
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.804: 	tktup a123
//│ ║         	^^^^^^^^^^
//│ ╟── type `Array[int]` does not have field '_3'
//│ ║  l.425: 	def a123: Array[int]
//│ ║         	          ^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{_3: ?a}`
//│ ║  l.804: 	tktup a123
//│ ║         	      ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.798: 	def tktup t = (t._2, t._3)
//│ ╙──       	                     ^
//│ res: (nothing, nothing,)







def definedOr x els = case x of {
  | undefined -> els()
  | _ -> x
  }
def defined x = definedOr x (fun () -> error)
def ornull x = definedOr x (fun () -> null)
//│ definedOr: (undefined | 'a & ~undefined) -> (() -> 'a) -> 'a
//│ defined: (undefined | 'a & ~undefined) -> 'a
//│ ornull: (undefined | 'a & ~undefined) -> (null | 'a)

:re
defined ()[0]
//│ res: nothing


ta1 = (2,3,4,5)
ta1[1]
ta2 = ((1,2,4), (true, false))
(ornull (defined ta2[0])[1+4], defined ta[1])[0]
ta3 = ((1,2,3), "hello", false)
ta3[1-2]
(1,2,3)[4]
//│ ta1: (int, int, int, int,)
//│ res: int | undefined
//│ ta2: ((int, int, int,), (bool, bool,),)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.843: 	(ornull (defined ta2[0])[1+4], defined ta[1])[0]
//│ ║         	                         ^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.843: 	(ornull (defined ta2[0])[1+4], defined ta[1])[0]
//│ ╙──       	                         ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.843: 	(ornull (defined ta2[0])[1+4], defined ta[1])[0]
//│ ║         	                         ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.843: 	(ornull (defined ta2[0])[1+4], defined ta[1])[0]
//│ ╙──       	                           ^
//│ res: bool | int | null | undefined
//│ ta3: ((int, int, int,), string, bool,)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.845: 	ta3[1-2]
//│ ║         	    ^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.845: 	ta3[1-2]
//│ ╙──       	    ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.845: 	ta3[1-2]
//│ ║         	    ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.845: 	ta3[1-2]
//│ ╙──       	      ^
//│ res: (int, int, int,) | bool | string | undefined
//│ res: int | undefined

:e
((defined ta2[0])[1+4], ta[1])[0]
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.880: 	((defined ta2[0])[1+4], ta[1])[0]
//│ ║         	                  ^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.880: 	((defined ta2[0])[1+4], ta[1])[0]
//│ ╙──       	                  ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.880: 	((defined ta2[0])[1+4], ta[1])[0]
//│ ║         	                  ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.880: 	((defined ta2[0])[1+4], ta[1])[0]
//│ ╙──       	                    ^
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.880: 	((defined ta2[0])[1+4], ta[1])[0]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── possibly-undefined array access of type `undefined` does not match type `~undefined`
//│ ║  l.880: 	((defined ta2[0])[1+4], ta[1])[0]
//│ ╙──       	 ^^^^^^^^^^^^^^^^^^^^^
//│ res: bool | int | undefined



:e
def ge x = x + 1
ta3[ge 3][ge (1+2)]
true[false]
4["hello"]
ge[2]
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.904: 	def ge x = x + 1
//│ ║         	           ^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.904: 	def ge x = x + 1
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.904: 	def ge x = x + 1
//│ ║         	           ^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.904: 	def ge x = x + 1
//│ ╙──       	               ^
//│ ge: anything -> int
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.905: 	ta3[ge 3][ge (1+2)]
//│ ║         	              ^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.905: 	ta3[ge 3][ge (1+2)]
//│ ╙──       	              ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.905: 	ta3[ge 3][ge (1+2)]
//│ ║         	              ^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.905: 	ta3[ge 3][ge (1+2)]
//│ ╙──       	                ^
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.905: 	ta3[ge 3][ge (1+2)]
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `Array[?a]`
//│ ║  l.844: 	ta3 = ((1,2,3), "hello", false)
//│ ║         	                ^^^^^^^
//│ ╟── but it flows into array access with expected type `Array[?b]`
//│ ║  l.905: 	ta3[ge 3][ge (1+2)]
//│ ╙──       	^^^^^^^^^
//│ res: int | undefined
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.906: 	true[false]
//│ ║         	^^^^^^^^^^^
//│ ╟── reference of type `bool` is not an instance of `int`
//│ ║  l.906: 	true[false]
//│ ╙──       	     ^^^^^
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.906: 	true[false]
//│ ║         	^^^^^^^^^^^
//│ ╟── reference of type `bool` does not match type `Array[?a]`
//│ ║  l.906: 	true[false]
//│ ╙──       	^^^^
//│ res: undefined
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.907: 	4["hello"]
//│ ║         	^^^^^^^^^^
//│ ╟── string literal of type `string` is not an instance of `int`
//│ ║  l.907: 	4["hello"]
//│ ╙──       	  ^^^^^^^
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.907: 	4["hello"]
//│ ║         	^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `Array[?a]`
//│ ║  l.907: 	4["hello"]
//│ ╙──       	^
//│ res: undefined
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.908: 	ge[2]
//│ ║         	^^^^^
//│ ╟── function of type `?a -> ?b` does not match type `Array[?c]`
//│ ║  l.904: 	def ge x = x + 1
//│ ║         	       ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Array[?d]`
//│ ║  l.908: 	ge[2]
//│ ╙──       	^^
//│ res: undefined















def mkarr: 'a -> Array['a]
def mkarr x = (x,x,x,x,x)
mk1 = defined (mkarr 6)[ 0]
(mkarr (mk1/3))[(3)]
mkarr (1,true,"hi")[0]
//│ mkarr: 'a -> Array['a]
//│ 'a -> ('a, 'a, 'a, 'a, 'a,)
//│   <:  mkarr:
//│ 'a -> Array['a]
//│ mk1: int
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.998: 	(mkarr (mk1/3))[(3)]
//│ ║         	        ^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.998: 	(mkarr (mk1/3))[(3)]
//│ ╙──       	        ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.998: 	(mkarr (mk1/3))[(3)]
//│ ║         	        ^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.998: 	(mkarr (mk1/3))[(3)]
//│ ╙──       	            ^
//│ res: int | undefined
//│ res: Array[bool | int | string | undefined]

:e 
mkarr 3 [  1]
mk1[2  ]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.1021: 	mkarr 3 [  1]
//│ ║          	      ^^^^^^^
//│ ╟── integer literal of type `int` does not match type `Array[?a]`
//│ ║  l.1021: 	mkarr 3 [  1]
//│ ╙──        	      ^
//│ res: Array[undefined]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.1022: 	mk1[2  ]
//│ ║          	^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `Array[?a]`
//│ ║  l.997: 	mk1 = defined (mkarr 6)[ 0]
//│ ║         	                     ^
//│ ╟── but it flows into reference with expected type `Array[?b]`
//│ ║  l.1022: 	mk1[2  ]
//│ ╙──        	^^^
//│ res: undefined






def s1 a = (defined a[1] + defined a[2], a[(1,2)._2])
def s2 a = (defined (defined a[1])[0])._2 + (defined a[2])._1
def s3 a = defined a._1.t[0] + defined (defined a.x[1])[2]
(defined ((1, "hello"),(2, true, false),(3,3,4))[0])._1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1046: 	def s1 a = (defined a[1] + defined a[2], a[(1,2)._2])
//│ ║          	            ^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1046: 	def s1 a = (defined a[1] + defined a[2], a[(1,2)._2])
//│ ╙──        	            ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1046: 	def s1 a = (defined a[1] + defined a[2], a[(1,2)._2])
//│ ║          	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1046: 	def s1 a = (defined a[1] + defined a[2], a[(1,2)._2])
//│ ╙──        	                           ^^^^^^^^^^^^
//│ s1: Array['a & ~undefined] -> (int, undefined | 'a,)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1047: 	def s2 a = (defined (defined a[1])[0])._2 + (defined a[2])._1
//│ ║          	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1047: 	def s2 a = (defined (defined a[1])[0])._2 + (defined a[2])._1
//│ ╙──        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1047: 	def s2 a = (defined (defined a[1])[0])._2 + (defined a[2])._1
//│ ║          	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1047: 	def s2 a = (defined (defined a[1])[0])._2 + (defined a[2])._1
//│ ╙──        	                                            ^^^^^^^^^^^^^^^^^
//│ s2: Array[Array[{_2: anything} & ~undefined] & {_1: anything}] -> int
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1048: 	def s3 a = defined a._1.t[0] + defined (defined a.x[1])[2]
//│ ║          	           ^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1048: 	def s3 a = defined a._1.t[0] + defined (defined a.x[1])[2]
//│ ╙──        	           ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1048: 	def s3 a = defined a._1.t[0] + defined (defined a.x[1])[2]
//│ ║          	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1048: 	def s3 a = defined a._1.t[0] + defined (defined a.x[1])[2]
//│ ╙──        	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ s3: {_1: {t: Array[~undefined]}, x: Array[Array[~undefined]]} -> int
//│ res: int

def ara: Array[(int, bool)]
def arb: Array[Array[(int, int)]]
(defined ara[1])._1
(defined (defined arb[0])[1])._2
def s4 arr = (defined (defined (defined arr.x[0])._3[6])[7])._h.hello
//│ ara: Array[(int, bool,)]
//│ arb: Array[Array[(int, int,)]]
//│ res: int
//│ res: int
//│ s4: {x: Array[{_3: Array[Array[{_h: {hello: 'hello}} & ~undefined]]} & ~undefined]} -> 'hello

def at1 xs = (defined xs[0])._1
def dup a b = a * 2 + b
dup (defined ara[1])._1 (defined (defined arb[10])[8])._2 + 1
//│ at1: Array[{_1: 'a} & ~undefined] -> 'a
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1103: 	def dup a b = a * 2 + b
//│ ║          	              ^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1103: 	def dup a b = a * 2 + b
//│ ╙──        	              ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1103: 	def dup a b = a * 2 + b
//│ ║          	              ^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.1103: 	def dup a b = a * 2 + b
//│ ╙──        	                  ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1103: 	def dup a b = a * 2 + b
//│ ║          	              ^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1103: 	def dup a b = a * 2 + b
//│ ╙──        	              ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1103: 	def dup a b = a * 2 + b
//│ ║          	              ^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1103: 	def dup a b = a * 2 + b
//│ ╙──        	                      ^
//│ dup: anything -> anything -> int
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1104: 	dup (defined ara[1])._1 (defined (defined arb[10])[8])._2 + 1
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.1104: 	dup (defined ara[1])._1 (defined (defined arb[10])[8])._2 + 1
//│ ╙──        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.1104: 	dup (defined ara[1])._1 (defined (defined arb[10])[8])._2 + 1
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.1104: 	dup (defined ara[1])._1 (defined (defined arb[10])[8])._2 + 1
//│ ╙──        	                                                            ^
//│ res: int

:e
(1,2,3)._1[1]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.1146: 	(1,2,3)._1[1]
//│ ║          	^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `Array[?a]`
//│ ║  l.1146: 	(1,2,3)._1[1]
//│ ║          	 ^
//│ ╟── but it flows into field selection with expected type `Array[?b]`
//│ ║  l.1146: 	(1,2,3)._1[1]
//│ ╙──        	^^^^^^^^^^
//│ res: undefined



