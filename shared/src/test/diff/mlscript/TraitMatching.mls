
trait MyTrait[A]: { value: A }
//│ Defined trait MyTrait[+A]


def test1 x = case x of { MyTrait -> x.value | _ -> 0 }
//│ test1: ({value: 'value} & #MyTrait | ~#MyTrait) -> (int | 'value)

:e
test1 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.10: 	test1 1
//│ ║        	^^^^^^^
//│ ╟── integer literal of type `int & #MyTrait | int & ~?a` does not have field 'value'
//│ ║  l.10: 	test1 1
//│ ║        	      ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.6: 	def test1 x = case x of { MyTrait -> x.value | _ -> 0 }
//│ ║       	                   ^
//│ ╟── from receiver:
//│ ║  l.6: 	def test1 x = case x of { MyTrait -> x.value | _ -> 0 }
//│ ╙──     	                                     ^
//│ res: int




test1 { value = 1 }
//│ res: int

def mt = MyTrait { value = 1 }
//│ mt: {value: int} & #MyTrait

test1 mt
//│ res: int

class C1: MyTrait[int]
//│ Defined class C1

test1 (C1 { value = 1 })
//│ res: int


def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ test2: ({default: 'value} & ~#MyTrait | {value: 'value} & #MyTrait) -> 'value

:e
test2 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.48: 	test2 1
//│ ║        	^^^^^^^
//│ ╟── integer literal of type `int & ~#MyTrait` does not have field 'default'
//│ ║  l.48: 	test2 1
//│ ║        	      ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ║        	                   ^
//│ ╟── from receiver:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ╙──      	                                                    ^
//│ res: nothing



:e
test2 { value = 1 }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.66: 	test2 { value = 1 }
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{value: int} & ~#MyTrait` does not have field 'default'
//│ ║  l.66: 	test2 { value = 1 }
//│ ║        	      ^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ║        	                   ^
//│ ╟── from receiver:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ╙──      	                                                    ^
//│ res: int



test2 { value = 1; default = "hi" }
//│ res: int | string

test2 mt
//│ res: int

test2 (C1 { value = 1 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.89: 	test2 (C1 { value = 1 })
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `C1` does not have field 'default'
//│ ║  l.89: 	test2 (C1 { value = 1 })
//│ ║        	       ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `{default: ?default}`
//│ ║  l.89: 	test2 (C1 { value = 1 })
//│ ║        	      ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ║        	                   ^
//│ ╟── from receiver:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ╙──      	                                                    ^
//│ res: int


// TODO: ability to declare classes as `final` so they can be assumed _not_ to inherit from a trait?
class C2: { default: string }
//│ Defined class C2

:e
test2 (C2 { default = "oops" })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.113: 	test2 (C2 { default = "oops" })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `C2` does not have field 'value'
//│ ║  l.113: 	test2 (C2 { default = "oops" })
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `{value: ?value}`
//│ ║  l.113: 	test2 (C2 { default = "oops" })
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ║        	                   ^
//│ ╟── from receiver:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ╙──      	                                     ^
//│ res: string




// Note: `value` is unused here; would deserve a warning
def c2 = C2 { value = 1; default = "oops" }
//│ c2: C2

:e
test2 c2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.139: 	test2 c2
//│ ║         	^^^^^^^^
//│ ╟── application of type `C2` does not have field 'value'
//│ ║  l.135: 	def c2 = C2 { value = 1; default = "oops" }
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{value: ?value}`
//│ ║  l.139: 	test2 c2
//│ ║         	      ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ║        	                   ^
//│ ╟── from receiver:
//│ ║  l.44: 	def test2 x = case x of { MyTrait -> x.value | _ -> x.default }
//│ ╙──      	                                     ^
//│ res: string




test2 (c2 with { value = 1 })
//│ res: int | string


// Note: if we allowed this, we'd have to be careful in the semantics of trait ctors!
:e
class C3: { default: string } & ~myTrait
//│ ╔══[ERROR] cannot inherit from a type negation
//│ ║  l.166: 	class C3: { default: string } & ~myTrait
//│ ╙──       	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


:e
class C3: { default: string } & ~MyTrait[anything]
//│ ╔══[ERROR] cannot inherit from a type negation
//│ ║  l.173: 	class C3: { default: string } & ~MyTrait[anything]
//│ ╙──       	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


def strawman: C2 & ~MyTrait[anything]
//│ strawman: C2 & ~MyTrait[?]

test2 strawman
//│ res: string

strawman: C2
//│ res: C2

:e
strawman: ~{ value: anything }
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.189: 	strawman: ~{ value: anything }
//│ ║         	^^^^^^^^
//│ ╟── type `C2 & ~MyTrait[?]` does not match type `~{value: anything}`
//│ ║  l.179: 	def strawman: C2 & ~MyTrait[anything]
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `~{value: anything}`
//│ ║  l.189: 	strawman: ~{ value: anything }
//│ ║         	^^^^^^^^
//│ ╟── Note: constraint arises from type negation:
//│ ║  l.189: 	strawman: ~{ value: anything }
//│ ╙──       	          ^^^^^^^^^^^^^^^^^^^^
//│ res: nothing





