
t = (1, 2, 3)
//│ t: (int, int, int,)

{} with {}
//│ res: anything


tx = t with { x = 1 }
//│ tx: (int, int, int,) & {x: int}

tx.x
//│ res: int

trait Hey: { x: int }
//│ Defined trait Hey

:e
Hey t
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.19: 	Hey t
//│ ║        	^^^^^
//│ ╟── argument of type `((int, int, int,),)` does not have field 'x'
//│ ║  l.19: 	Hey t
//│ ║        	    ^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.15: 	trait Hey: { x: int }
//│ ╙──      	           ^^^^^^^^^^
//│ res: ((int, int, int,),) & #Hey





htx = Hey tx
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.35: 	htx = Hey tx
//│ ║        	      ^^^^^^
//│ ╟── argument of type `((int, int, int,) & {x: int},)` does not have field 'x'
//│ ║  l.35: 	htx = Hey tx
//│ ║        	          ^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.15: 	trait Hey: { x: int }
//│ ╙──      	           ^^^^^^^^^^
//│ htx: ((int, int, int,) & {x: int},) & #Hey

htx.x
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.47: 	htx.x
//│ ║        	^^^^^
//│ ╟── argument of type `((int, int, int,) & {x: int},)` does not have field 'x'
//│ ║  l.35: 	htx = Hey tx
//│ ║        	          ^^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.47: 	htx.x
//│ ╙──      	^^^
//│ res: nothing

f ((a, b, c)) = { a; b; c }
//│ f: ('a, 'b, 'c,) -> {a: 'a, b: 'b, c: 'c}

f t
//│ res: {a: int, b: int, c: int}

f tx
//│ res: {a: int, b: int, c: int}

f htx
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.68: 	f htx
//│ ║        	^^^^^
//│ ╟── argument of type `((int, int, int,) & {x: int},)` does not match type `(?a, ?b, ?c,)`
//│ ║  l.35: 	htx = Hey tx
//│ ║        	          ^^
//│ ╟── but it flows into reference with expected type `(?a, ?b, ?c,)`
//│ ║  l.68: 	f htx
//│ ║        	  ^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.59: 	f ((a, b, c)) = { a; b; c }
//│ ╙──      	   ^^^^^^^^^
//│ res: {a: nothing, b: nothing, c: nothing}

f ((a, b)) = add a b
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.83: 	f ((a, b)) = add a b
//│ ║        	             ^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.83: 	f ((a, b)) = add a b
//│ ╙──      	                 ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.83: 	f ((a, b)) = add a b
//│ ║        	             ^^^^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.83: 	f ((a, b)) = add a b
//│ ╙──      	                   ^
//│ f: (anything, anything,) -> int

:e
f t
f tx
f htx
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.99: 	f t
//│ ║        	^^^
//│ ╟── tuple literal of type `(int, int, int,)` does not match type `(?a, ?b,)`
//│ ║  l.2: 	t = (1, 2, 3)
//│ ║       	    ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?a, ?b,)`
//│ ║  l.99: 	f t
//│ ║        	  ^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.83: 	f ((a, b)) = add a b
//│ ╙──      	   ^^^^^^
//│ res: int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.100: 	f tx
//│ ║         	^^^^
//│ ╟── `with` extension of type `(int, int, int,) & {x: int}` is not a 2-element tuple
//│ ║  l.9: 	tx = t with { x = 1 }
//│ ║       	     ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?a, ?b,)`
//│ ║  l.100: 	f tx
//│ ║         	  ^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.83: 	f ((a, b)) = add a b
//│ ╙──      	   ^^^^^^
//│ res: int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.101: 	f htx
//│ ║         	^^^^^
//│ ╟── argument of type `((int, int, int,) & {x: int},)` does not match type `(?a, ?b,)`
//│ ║  l.35: 	htx = Hey tx
//│ ║        	          ^^
//│ ╟── but it flows into reference with expected type `(?a, ?b,)`
//│ ║  l.101: 	f htx
//│ ║         	  ^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.83: 	f ((a, b)) = add a b
//│ ╙──      	   ^^^^^^
//│ res: int














g arg = case arg of { Hey -> arg.x | _ -> () }
//│ g: ({x: 'x} & #Hey | ~#Hey) -> (() | 'x)

g htx
g tx
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.158: 	g htx
//│ ║         	^^^^^
//│ ╟── argument of type `((int, int, int,) & {x: int},)` does not have field 'x'
//│ ║  l.35: 	htx = Hey tx
//│ ║        	          ^^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.158: 	g htx
//│ ║         	  ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.155: 	g arg = case arg of { Hey -> arg.x | _ -> () }
//│ ║         	             ^^^
//│ ╟── from receiver:
//│ ║  l.155: 	g arg = case arg of { Hey -> arg.x | _ -> () }
//│ ╙──       	                             ^^^
//│ res: ()
//│ res: () | int

// TODO: pattern match for traits in JavaScript
g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ g: ({x: 'x} & #Hey | {y: 'x} & ~#Hey) -> 'x

g htx
g (tx with { y = 2 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.182: 	g htx
//│ ║         	^^^^^
//│ ╟── argument of type `((int, int, int,) & {x: int},)` does not have field 'x'
//│ ║  l.35: 	htx = Hey tx
//│ ║        	          ^^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.182: 	g htx
//│ ║         	  ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.179: 	g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ ║         	             ^^^
//│ ╟── from receiver:
//│ ║  l.179: 	g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ ╙──       	                             ^^^
//│ res: nothing
//│ res: int

:e
g tx
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.203: 	g tx
//│ ║         	^^^^
//│ ╟── `with` extension of type `(int, int, int,) & {x: int} & ~#Hey` does not have field 'y'
//│ ║  l.9: 	tx = t with { x = 1 }
//│ ║       	     ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{y: ?y}`
//│ ║  l.203: 	g tx
//│ ║         	  ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.179: 	g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ ║         	             ^^^
//│ ╟── from receiver:
//│ ║  l.179: 	g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ ╙──       	                                          ^^^
//│ res: int



:ge
if bool then (1,) else (2,)
//│ res: (int,)

:ge
if bool then (1,) else (2, 3)
//│ res: Array[int] & {_1: int}

:ge
if bool then (1,) with { a = 1; b = 2 } else (2, 3) with { b = 3; c = 4 }
//│ res: Array[int] & {_1: int, b: int}

:ge
if bool then (1,) else fun x -> x
//│ res: anything



t._1
t._2
//│ res: int
//│ res: int


t = (1, 2, 3) with {x = 1}
// t = (1, 2, 3)
//│ t: (int, int, int,) & {x: int}

t.x
//│ res: int

t._1
t._2
//│ res: int
//│ res: int


t = (1, 2, 3) with {_1 = "oops"}
//│ t: {_1: string, _2: int, _3: int}

// TODO (https://github.com/hkust-taco/mlscript/issues/69)
:e
(t: ("oops",int,int,))._1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.265: 	(t: ("oops",int,int,))._1
//│ ║         	 ^
//│ ╟── `with` extension of type `{_1: string, _2: int, _3: int}` is not a 3-element tuple
//│ ║  l.260: 	t = (1, 2, 3) with {_1 = "oops"}
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `("oops", int, int,)`
//│ ║  l.265: 	(t: ("oops",int,int,))._1
//│ ║         	 ^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.265: 	(t: ("oops",int,int,))._1
//│ ╙──       	    ^^^^^^^^^^^^^^^^^
//│ res: "oops"






def f: (1, 2, 3) & (2, 2 | 3, 3 | 4)
//│ f: (nothing, 2, 3,)

def f: (1, 2, 3) & (2, 3)
//│ f: nothing

def f: (1, 2, 3) & Array[2 | 3 | 4]
//│ f: (nothing, 2, 3,)


