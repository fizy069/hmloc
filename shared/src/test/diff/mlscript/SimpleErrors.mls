:AllowTypeErrors

succ false
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.3: 	succ false
//│ ║       	^^^^^^^^^^
//│ ╟── reference of type `false` is not an instance of type `int`
//│ ║  l.3: 	succ false
//│ ╙──     	     ^^^^^
//│ res: int



x = "oops"
//│ x: string

f y = succ y
//│ f: int -> int

:e
f x
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.21: 	f x
//│ ║        	^^^
//│ ╟── string literal of type `string` is not an instance of type `int`
//│ ║  l.14: 	x = "oops"
//│ ║        	    ^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.21: 	f x
//│ ║        	  ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.17: 	f y = succ y
//│ ╙──      	           ^
//│ res: int







trait MyTrait: { value: anything }
//│ Defined trait MyTrait

def test1 x = case x of { MyTrait -> x.value | _ -> 0 }
//│ test1: ({value: 'value} & #MyTrait | ~#MyTrait) -> (int | 'value)

:e
test1 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.49: 	test1 1
//│ ║        	^^^^^^^
//│ ╟── integer literal of type `int & #MyTrait | int & ~?a` does not have field 'value'
//│ ║  l.49: 	test1 1
//│ ║        	      ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.45: 	def test1 x = case x of { MyTrait -> x.value | _ -> 0 }
//│ ║        	                   ^
//│ ╟── from receiver:
//│ ║  l.45: 	def test1 x = case x of { MyTrait -> x.value | _ -> 0 }
//│ ╙──      	                                     ^
//│ res: int





def map: 'a -> 'a
def map f = f map (fun x -> map)
//│ map: 'a -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.69: 	def map f = f map (fun x -> map)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `'a` is not a function
//│ ║  l.68: 	def map: 'a -> 'a
//│ ║        	         ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.69: 	def map f = f map (fun x -> map)
//│ ╙──      	            ^
//│ (('a -> 'a) -> (anything -> 'a0 -> 'a0) -> 'b) -> 'b
//│   <:  map:
//│ 'a -> 'a






class Bar
    method Map[B]: B -> B
    rec method Map f = f 1
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.91: 	    rec method Map f = f 1
//│ ║        	               ^^^^^^^^^^^
//│ ╟── type `B` is not a function
//│ ║  l.90: 	    method Map[B]: B -> B
//│ ║        	               ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.91: 	    rec method Map f = f 1
//│ ╙──      	                       ^
//│ Defined class Bar
//│ Declared Bar.Map: Bar -> 'B -> 'B
//│ Defined Bar.Map: Bar -> (int -> 'a) -> 'a






def boom: anything
//│ boom: anything

// :d
:e
add boom 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.115: 	add boom 1
//│ ║         	^^^^^^^^
//│ ╟── type `anything` is not an instance of type `int`
//│ ║  l.110: 	def boom: anything
//│ ║         	          ^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.115: 	add boom 1
//│ ╙──       	    ^^^^
//│ res: int





