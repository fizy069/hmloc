
1 + 2
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.2: 	1 + 2
//│ ║       	^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.2: 	1 + 2
//│ ╙──     	^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.2: 	1 + 2
//│ ║       	^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.2: 	1 + 2
//│ ╙──     	    ^
//│ res: int

def foo(x) = x + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.17: 	def foo(x) = x + 1
//│ ║        	             ^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.17: 	def foo(x) = x + 1
//│ ╙──      	             ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.17: 	def foo(x) = x + 1
//│ ║        	             ^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.17: 	def foo(x) = x + 1
//│ ╙──      	                 ^
//│ foo: anything -> int

class A: { x: number }
//│ Defined class A

def f v = v.x
//│ f: {x: 'x} -> 'x

// def f: (A & {x: int} | anything) -> int

def f v = case v of {
    A -> (v.x : int)
  | _ -> 0
 }
//│ f: ((A with {x: int}) | ~A) -> int

a1 = A { x = 0 }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.46: 	a1 = A { x = 0 }
//│ ║        	     ^^^^^^^^^^^
//│ ╟── argument of type `({x: int},)` does not have field 'x'
//│ ║  l.46: 	a1 = A { x = 0 }
//│ ╙──      	       ^^^^^^^^^
//│ a1: A & {x: nothing}

f a1
//│ res: int

a2 = A { x = 0: number }
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.58: 	a2 = A { x = 0: number }
//│ ║        	             ^
//│ ╟── integer literal of type `int` is not an instance of `number`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.58: 	a2 = A { x = 0: number }
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.58: 	a2 = A { x = 0: number }
//│ ║        	     ^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({x: number},)` does not have field 'x'
//│ ║  l.58: 	a2 = A { x = 0: number }
//│ ╙──      	       ^^^^^^^^^^^^^^^^^
//│ a2: A & {x: nothing}

:e
f a2
//│ res: int





def f2: (A & {x: int} | anything) -> int
//│ f2: anything -> int

f2 a2
//│ res: int


// const x: [0, 1] = [0, 1]

a = (0, 1)
//│ a: (int, int,)


1 : 1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.95: 	1 : 1
//│ ║        	^
//│ ╟── integer literal of type `int` does not match type `1`
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.95: 	1 : 1
//│ ╙──      	    ^
//│ res: 1

// def f(x) =
//   x : x
//   f2 x : f2 x

:w
class Expr[A]
//│ Defined class Expr[±A]
//│ ╔══[WARNING] Type definition Expr has bivariant type parameters:
//│ ║  l.110: 	class Expr[A]
//│ ║         	      ^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.110: 	class Expr[A]
//│ ╙──       	           ^



class IntLit: Expr[int] & { value: int }
//│ Defined class IntLit

:w
class Pair[A, B]: Expr[(A, B)] & { lhs: Expr[A]; rhs: Expr[B] }
//│ Defined class Pair[±A, ±B]
//│ ╔══[WARNING] Type definition Pair has bivariant type parameters:
//│ ║  l.125: 	class Pair[A, B]: Expr[(A, B)] & { lhs: Expr[A]; rhs: Expr[B] }
//│ ║         	      ^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.125: 	class Pair[A, B]: Expr[(A, B)] & { lhs: Expr[A]; rhs: Expr[B] }
//│ ║         	           ^
//│ ╟── B is irrelevant and may be removed
//│ ║  l.125: 	class Pair[A, B]: Expr[(A, B)] & { lhs: Expr[A]; rhs: Expr[B] }
//│ ╙──       	              ^




rec def eval(e) = case e of
  { IntLit -> e.value
  | Pair -> (eval e.lhs, eval e.rhs)
  }
//│ eval: 'a -> (('b, 'b,) | 'value)
//│   where
//│     'a <: (IntLit with {value: 'value & 'b}) | (Pair[?, ?] with {lhs: 'a, rhs: 'a})
//│     'b :> ('b, 'b,)

rec def eval(e) = case e of
  { IntLit -> e.value
  | Pair -> (eval e.lhs, eval e.rhs)
  | _ -> error
  }
//│ eval: 'a -> (('b, 'b,) | 'value)
//│   where
//│     'a <: (IntLit with {value: 'value & 'b}) | (Pair[?, ?] with {lhs: 'a, rhs: 'a}) | ~IntLit & ~Pair[?, ?]
//│     'b :> ('b, 'b,)

eval (IntLit { value = 1 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.159: 	eval (IntLit { value = 1 })
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.159: 	eval (IntLit { value = 1 })
//│ ╙──       	             ^^^^^^^^^^^^^
//│ res: 'a
//│   where
//│     'a :> ('a, 'a,)

eval (Pair {
  lhs = IntLit { value = 1 };
  rhs = IntLit { value = 2 } })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.171: 	  lhs = IntLit { value = 1 };
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.171: 	  lhs = IntLit { value = 1 };
//│ ╙──       	               ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.172: 	  rhs = IntLit { value = 2 } })
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.172: 	  rhs = IntLit { value = 2 } })
//│ ╙──       	               ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.170: 	eval (Pair {
//│ ║         	      ^^^^^^
//│ ║  l.171: 	  lhs = IntLit { value = 1 };
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.172: 	  rhs = IntLit { value = 2 } })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.170: 	eval (Pair {
//│ ║         	           ^
//│ ║  l.171: 	  lhs = IntLit { value = 1 };
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.172: 	  rhs = IntLit { value = 2 } })
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: 'a
//│   where
//│     'a :> ('a, 'a,)

p = Pair {
  lhs = IntLit { value = 1 };
  rhs = Pair {
    lhs = IntLit { value = 2 };
    rhs = IntLit { value = 3 } } }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.204: 	  lhs = IntLit { value = 1 };
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.204: 	  lhs = IntLit { value = 1 };
//│ ╙──       	               ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.206: 	    lhs = IntLit { value = 2 };
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.206: 	    lhs = IntLit { value = 2 };
//│ ╙──       	                 ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.207: 	    rhs = IntLit { value = 3 } } }
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.207: 	    rhs = IntLit { value = 3 } } }
//│ ╙──       	                 ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.205: 	  rhs = Pair {
//│ ║         	        ^^^^^^
//│ ║  l.206: 	    lhs = IntLit { value = 2 };
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.207: 	    rhs = IntLit { value = 3 } } }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.205: 	  rhs = Pair {
//│ ║         	             ^
//│ ║  l.206: 	    lhs = IntLit { value = 2 };
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.207: 	    rhs = IntLit { value = 3 } } }
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.203: 	p = Pair {
//│ ║         	    ^^^^^^
//│ ║  l.204: 	  lhs = IntLit { value = 1 };
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.205: 	  rhs = Pair {
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.206: 	    lhs = IntLit { value = 2 };
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.207: 	    rhs = IntLit { value = 3 } } }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.203: 	p = Pair {
//│ ║         	         ^
//│ ║  l.204: 	  lhs = IntLit { value = 1 };
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.205: 	  rhs = Pair {
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.206: 	    lhs = IntLit { value = 2 };
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.207: 	    rhs = IntLit { value = 3 } } }
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ p: Pair[?, ?] & {lhs: nothing, rhs: nothing}

ep = eval p
//│ ep: 'a
//│   where
//│     'a :> ('a, 'a,)


// FUTURE:

// class Expr[type A]

// def eval['a]: Expr['a] -> 'a
// rec def eval(e: Expr['a]) = case e of
//   { IntLit -> e.value
//   | Pair -> (eval e.lhs, eval[e.rhs] (e.rhs: Expr[e.rhs.A]))
//   | _ -> error
//   }

// class Vector[A, N: nat]
// class Nil: Vector['a, 0]
// class Cons[A, m]: Vector[A, S m]



// === === === ERROR CASES === === === //



:w
class Pair2[A, B]: Expr[(A, B)] & { lhs: Expr[A]; rhs: Expr[A] }
//│ Defined class Pair2[±A, ±B]
//│ ╔══[WARNING] Type definition Pair2 has bivariant type parameters:
//│ ║  l.292: 	class Pair2[A, B]: Expr[(A, B)] & { lhs: Expr[A]; rhs: Expr[A] }
//│ ║         	      ^^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.292: 	class Pair2[A, B]: Expr[(A, B)] & { lhs: Expr[A]; rhs: Expr[A] }
//│ ║         	            ^
//│ ╟── B is irrelevant and may be removed
//│ ║  l.292: 	class Pair2[A, B]: Expr[(A, B)] & { lhs: Expr[A]; rhs: Expr[A] }
//│ ╙──       	               ^






:ShowRelativeLineNums
:AllowTypeErrors



ep + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+1: 	ep + 1
//│ ║        	^^^^
//│ ╟── argument of type `(?a,)` is not an instance of `int`
//│ ║  l.+1: 	ep + 1
//│ ╙──      	^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+1: 	ep + 1
//│ ║        	^^^^^^
//│ ╟── argument of type `(int,)` is not an instance of `int`
//│ ║  l.+1: 	ep + 1
//│ ╙──      	     ^
//│ res: int




ep[0]
//│ res: undefined | 'a
//│   where
//│     'a :> ('a, 'a,)





eval (Pair {
  lhs = IntLit { value = 1 };
  rhs = IntLit { value = Pair {
    lhs = IntLit { value = 2 };
    rhs = IntLit { value = 3 } } } })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+2: 	  lhs = IntLit { value = 1 };
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.+2: 	  lhs = IntLit { value = 1 };
//│ ╙──      	               ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ╙──      	                 ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } } })
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } } })
//│ ╙──      	                 ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+3: 	  rhs = IntLit { value = Pair {
//│ ║        	                         ^^^^^^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } } })
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.+3: 	  rhs = IntLit { value = Pair {
//│ ║        	                              ^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } } })
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+3: 	  rhs = IntLit { value = Pair {
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } } })
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: ?a},)` does not have field 'value'
//│ ║  l.+3: 	  rhs = IntLit { value = Pair {
//│ ║        	               ^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } } })
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	eval (Pair {
//│ ║        	      ^^^^^^
//│ ║  l.+2: 	  lhs = IntLit { value = 1 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  rhs = IntLit { value = Pair {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } } })
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.+1: 	eval (Pair {
//│ ║        	           ^
//│ ║  l.+2: 	  lhs = IntLit { value = 1 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  rhs = IntLit { value = Pair {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } } })
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: 'a
//│   where
//│     'a :> ('a, 'a,)









p = Pair2 {
  lhs = IntLit { value = 1 };
  rhs = Pair2 {
    lhs = IntLit { value = 2 };
    rhs = IntLit { value = 3 } } }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+2: 	  lhs = IntLit { value = 1 };
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.+2: 	  lhs = IntLit { value = 1 };
//│ ╙──      	               ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ╙──      	                 ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } }
//│ ║        	          ^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({value: int},)` does not have field 'value'
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } }
//│ ╙──      	                 ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+3: 	  rhs = Pair2 {
//│ ║        	        ^^^^^^^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } }
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.+3: 	  rhs = Pair2 {
//│ ║        	              ^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } }
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	p = Pair2 {
//│ ║        	    ^^^^^^^
//│ ║  l.+2: 	  lhs = IntLit { value = 1 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  rhs = Pair2 {
//│ ║        	^^^^^^^^^^^^^^^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } }
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.+1: 	p = Pair2 {
//│ ║        	          ^
//│ ║  l.+2: 	  lhs = IntLit { value = 1 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  rhs = Pair2 {
//│ ║        	^^^^^^^^^^^^^^^
//│ ║  l.+4: 	    lhs = IntLit { value = 2 };
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+5: 	    rhs = IntLit { value = 3 } } }
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ p: Pair2[?, ?] & {lhs: nothing, rhs: nothing}



def eval: Expr['a] -> 'a
//│ eval: Expr[?] -> nothing

rec def eval(e) = case e of
  { IntLit -> e.value
  | Pair -> (eval e.lhs, eval e.rhs)
  }
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.+1: 	rec def eval(e) = case e of
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+2: 	  { IntLit -> e.value
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  | Pair -> (eval e.lhs, eval e.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	  }
//│ ║        	^^^
//│ ╟── type `Expr[?]` does not match type `IntLit & ?a | Pair[?, ?] & ?b`
//│ ║  l.489: 	def eval: Expr['a] -> 'a
//│ ║         	          ^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.+1: 	rec def eval(e) = case e of
//│ ╙──      	                       ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.+1: 	rec def eval(e) = case e of
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+2: 	  { IntLit -> e.value
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  | Pair -> (eval e.lhs, eval e.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	  }
//│ ║        	^^^
//│ ╟── tuple literal of type `(?a, ?b,)` is not an instance of type `'a`
//│ ║  l.+3: 	  | Pair -> (eval e.lhs, eval e.rhs)
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into `case` expression with expected type `'a`
//│ ║  l.+1: 	rec def eval(e) = case e of
//│ ║        	                  ^^^^^^^^^
//│ ║  l.+2: 	  { IntLit -> e.value
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  | Pair -> (eval e.lhs, eval e.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.489: 	def eval: Expr['a] -> 'a
//│ ╙──       	                      ^^
//│ 'a -> (('b, 'b,) | 'value)
//│   where
//│     'a <: (IntLit with {value: 'value & 'b}) | (Pair[?, ?] with {lhs: 'a, rhs: 'a})
//│     'b :> ('b, 'b,)
//│   <:  eval:
//│ Expr[?] -> nothing































rec def eval(e) = case e of
  { IntLit -> e.value
  | Pair -> (eval e.lhs, eval e.rhs)
  | _ -> error
  }
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.+1: 	rec def eval(e) = case e of
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+2: 	  { IntLit -> e.value
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  | Pair -> (eval e.lhs, eval e.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	  | _ -> error
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.+5: 	  }
//│ ║        	^^^
//│ ╟── tuple literal of type `(?a, ?b,)` is not an instance of type `'a`
//│ ║  l.+3: 	  | Pair -> (eval e.lhs, eval e.rhs)
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into `case` expression with expected type `'a`
//│ ║  l.+1: 	rec def eval(e) = case e of
//│ ║        	                  ^^^^^^^^^
//│ ║  l.+2: 	  { IntLit -> e.value
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+3: 	  | Pair -> (eval e.lhs, eval e.rhs)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.+4: 	  | _ -> error
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.+5: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.489: 	def eval: Expr['a] -> 'a
//│ ╙──       	                      ^^
//│ 'a -> (('b, 'b,) | 'value)
//│   where
//│     'a <: (IntLit with {value: 'value & 'b}) | (Pair[?, ?] with {lhs: 'a, rhs: 'a}) | ~IntLit & ~Pair[?, ?]
//│     'b :> ('b, 'b,)
//│   <:  eval:
//│ Expr[?] -> nothing




























