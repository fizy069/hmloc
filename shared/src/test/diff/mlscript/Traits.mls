trait A: { x: int }
trait B: { y: string }
class C: { x: 0 | 1 }
//│ Defined trait A
//│ Defined trait B
//│ Defined class C


A { x = 1 }
//│ res: {x: int} & #A

:e
A {}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.13: 	A {}
//│ ║        	^^^^
//│ ╟── record literal of type `anything` does not have field 'x'
//│ ║  l.13: 	A {}
//│ ║        	  ^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.1: 	trait A: { x: int }
//│ ╙──     	         ^^^^^^^^^^
//│ res: #A





class D: C & A & B
//│ Defined class D

D
//│ res: {x: 'x & (0 | 1), y: string & 'y} -> (D with {x: 'x, y: 'y})

:re
error: A & B
//│ res: A & B

:e
def dv = D{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.40: 	def dv = D{}
//│ ║        	         ^^^
//│ ╟── record literal of type `anything` is not a 1-element tuple
//│ ║  l.40: 	def dv = D{}
//│ ╙──      	          ^^
//│ dv: D & {x: nothing, y: nothing}



def dv = D { x = 0; y = "hello" }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.51: 	def dv = D { x = 0; y = "hello" }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `0 | 1`
//│ ║  l.51: 	def dv = D { x = 0; y = "hello" }
//│ ║        	                 ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.3: 	class C: { x: 0 | 1 }
//│ ╙──     	              ^^^^^
//│ dv: D

:e
dv: nothing
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.64: 	dv: nothing
//│ ║        	^^
//│ ╟── application of type `D` does not match type `nothing`
//│ ║  l.51: 	def dv = D { x = 0; y = "hello" }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `nothing`
//│ ║  l.64: 	dv: nothing
//│ ║        	^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	dv: nothing
//│ ╙──      	    ^^^^^^^
//│ res: nothing





dv: A & B
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.83: 	dv: A & B
//│ ║        	^^
//│ ╟── application of type `D` is not an instance of type `A`
//│ ║  l.51: 	def dv = D { x = 0; y = "hello" }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `#A`
//│ ║  l.83: 	dv: A & B
//│ ║        	^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.83: 	dv: A & B
//│ ║        	    ^^^^^
//│ ╟── from type reference:
//│ ║  l.83: 	dv: A & B
//│ ╙──      	    ^
//│ res: A & B

:e
dv: A & B: nothing
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.102: 	dv: A & B: nothing
//│ ║         	^^
//│ ╟── application of type `D` is not an instance of type `A`
//│ ║  l.51: 	def dv = D { x = 0; y = "hello" }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `#A`
//│ ║  l.102: 	dv: A & B: nothing
//│ ║         	^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.102: 	dv: A & B: nothing
//│ ║         	    ^^^^^
//│ ╟── from type reference:
//│ ║  l.102: 	dv: A & B: nothing
//│ ╙──       	    ^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.102: 	dv: A & B: nothing
//│ ║         	^^
//│ ╟── type `A & B` does not match type `nothing`
//│ ║  l.102: 	dv: A & B: nothing
//│ ║         	    ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.102: 	dv: A & B: nothing
//│ ╙──       	           ^^^^^^^
//│ res: nothing





trait Indirect: C
//│ Defined trait Indirect

class E: Indirect
//│ Defined class E

:e
E{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.140: 	E{}
//│ ║         	^^^
//│ ╟── record literal of type `anything` is not a 1-element tuple
//│ ║  l.140: 	E{}
//│ ╙──       	 ^^
//│ res: E & {x: nothing}



def ev = E { x = 1 }
ev: C
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.151: 	def ev = E { x = 1 }
//│ ║         	         ^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `0 | 1`
//│ ║  l.151: 	def ev = E { x = 1 }
//│ ║         	                 ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.3: 	class C: { x: 0 | 1 }
//│ ╙──     	              ^^^^^
//│ ev: E
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.152: 	ev: C
//│ ║         	^^
//│ ╟── application of type `E` does not match type `C`
//│ ║  l.151: 	def ev = E { x = 1 }
//│ ║         	         ^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `C`
//│ ║  l.152: 	ev: C
//│ ║         	^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.152: 	ev: C
//│ ╙──       	    ^
//│ res: C


trait T1: C & A
//│ Defined trait T1

:e
def t = T1 (A { x = 1 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.182: 	def t = T1 (A { x = 1 })
//│ ║         	        ^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{x: int}` is not an instance of type `C`
//│ ║  l.182: 	def t = T1 (A { x = 1 })
//│ ║         	              ^^^^^^^^^
//│ ╟── but it flows into application with expected type `C`
//│ ║  l.182: 	def t = T1 (A { x = 1 })
//│ ║         	            ^^^^^^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.178: 	trait T1: C & A
//│ ║         	          ^^^^^
//│ ╟── from type reference:
//│ ║  l.178: 	trait T1: C & A
//│ ╙──       	          ^
//│ t: {x: int} & #A & #T1






def t = T1 (A (C { x = 1 }))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.205: 	def t = T1 (A (C { x = 1 }))
//│ ║         	               ^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `0 | 1`
//│ ║  l.205: 	def t = T1 (A (C { x = 1 }))
//│ ║         	                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.3: 	class C: { x: 0 | 1 }
//│ ╙──     	              ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.205: 	def t = T1 (A (C { x = 1 }))
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not have field 'x'
//│ ║  l.205: 	def t = T1 (A (C { x = 1 }))
//│ ║         	                       ^
//│ ╟── but it flows into application with expected type `{x: 0 | 1}`
//│ ║  l.205: 	def t = T1 (A (C { x = 1 }))
//│ ║         	               ^^^^^^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.178: 	trait T1: C & A
//│ ║         	          ^^^^^
//│ ╟── from record type:
//│ ║  l.3: 	class C: { x: 0 | 1 }
//│ ╙──     	         ^^^^^^^^^^^^
//│ t: C & #A & #T1

class CA: C & A
//│ Defined class CA

def t = T1 (CA { x = 1 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.235: 	def t = T1 (CA { x = 1 })
//│ ║         	            ^^^^^^^^^^^^
//│ ╟── integer literal of type `int` does not match type `0 | 1`
//│ ║  l.235: 	def t = T1 (CA { x = 1 })
//│ ║         	                     ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.3: 	class C: { x: 0 | 1 }
//│ ╙──     	              ^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.235: 	def t = T1 (CA { x = 1 })
//│ ║         	        ^^^^^^^^^^^^^^^^^
//│ ╟── application of type `CA` is not an instance of type `C`
//│ ║  l.235: 	def t = T1 (CA { x = 1 })
//│ ║         	            ^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `C`
//│ ║  l.235: 	def t = T1 (CA { x = 1 })
//│ ║         	           ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.178: 	trait T1: C & A
//│ ║         	          ^^^^^
//│ ╟── from type reference:
//│ ║  l.178: 	trait T1: C & A
//│ ╙──       	          ^
//│ t: CA & #T1


class C1: B & T1 & { y: "hi" | "hello" }
//│ Defined class C1

:e
def c1 = C1 { }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.267: 	def c1 = C1 { }
//│ ║         	         ^^^^^^
//│ ╟── record literal of type `anything` is not a 1-element tuple
//│ ║  l.267: 	def c1 = C1 { }
//│ ╙──       	            ^^^
//│ c1: C1 & {x: nothing, y: nothing}



def c1 = C1 { x = 1; y = "hi" }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.278: 	def c1 = C1 { x = 1; y = "hi" }
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `string` does not match type `"hello" | "hi"`
//│ ║  l.278: 	def c1 = C1 { x = 1; y = "hi" }
//│ ║         	                         ^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.263: 	class C1: B & T1 & { y: "hi" | "hello" }
//│ ╙──       	                        ^^^^^^^^^^^^^^
//│ c1: C1

c1: T1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.290: 	c1: T1
//│ ║         	^^
//│ ╟── application of type `C1` does not match type `C & #T1`
//│ ║  l.278: 	def c1 = C1 { x = 1; y = "hi" }
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `C & #T1`
//│ ║  l.290: 	c1: T1
//│ ║         	^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.290: 	c1: T1
//│ ╙──       	    ^^
//│ res: T1

c1: A
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.305: 	c1: A
//│ ║         	^^
//│ ╟── application of type `C1` does not match type `{x: int} & #A`
//│ ║  l.278: 	def c1 = C1 { x = 1; y = "hi" }
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{x: int} & #A`
//│ ║  l.305: 	c1: A
//│ ║         	^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.305: 	c1: A
//│ ╙──       	    ^
//│ res: A

c1.x
c1.y
//│ res: int
//│ res: string

