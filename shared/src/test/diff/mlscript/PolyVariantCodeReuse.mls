// Example from Code reuse through polymorphic variants

//************************** PRELIMINARIES *************************

class NotFound
class Success: { result: anything }
//│ Defined class NotFound
//│ Defined class Success

def NotFound = NotFound {}
def Success result = Success { result }
//│ NotFound: NotFound
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.11: 	def Success result = Success { result }
//│ ║        	                     ^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({result: ?a},)` does not have field 'result'
//│ ║  l.11: 	def Success result = Success { result }
//│ ╙──      	                             ^^^^^^^^^^
//│ Success: anything -> (Success & {result: nothing})

type Tuple[A, B] = (A, B)
//│ Defined type alias Tuple[+A, +B]

def Tuple l r = (l, r)
//│ Tuple: 'a -> 'b -> ('a, 'b,)

class Nil
class Cons[A]: { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons[+A]
//│ Defined type alias List[+A]

def Nil = Nil {}
//│ Nil: Nil

def Cons head tail = Cons { head; tail }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.37: 	def Cons head tail = Cons { head; tail }
//│ ║        	                     ^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({head: ?a, tail: ?b},)` is not a record (expected a record with fields: head, tail)
//│ ║  l.37: 	def Cons head tail = Cons { head; tail }
//│ ╙──      	                          ^^^^^^^^^^^^^^
//│ Cons: anything -> anything -> (Cons[nothing] & {tail: nothing})

def eq: string -> string -> bool
//│ eq: string -> string -> bool

rec def list_assoc s l = case l of {
  | Cons ->
      if eq l.head._1 s then Success l.head._2
      else list_assoc s l.tail
  | Nil -> NotFound
  }
//│ list_assoc: string -> 'a -> (NotFound | Success & {result: nothing})
//│   where
//│     'a <: (Cons[?] with {head: {_1: string, _2: anything}, tail: 'a}) | Nil

list_assoc "2" (Cons (Tuple "2" 1) Nil )
//│ res: NotFound | Success & {result: nothing}

// ***************************** Var *******************************

class Expr
class Lambda
//│ Defined class Expr
//│ Defined class Lambda

class Var: Lambda & { name: string }
//│ Defined class Var

def eval_var sub v = case v of {
  | Var -> let res = list_assoc v.name sub in case res of {
          | NotFound -> v
          | Success -> res.result
          }
  }
//│ eval_var: 'a -> (Var & 'b) -> 'b
//│   where
//│     'a <: (Cons[?] with {head: {_1: string, _2: anything}, tail: 'a}) | Nil

// *************************** Lambda ********************************

class Abs[a]: Lambda & { name: string; body: a }
class App[a]: Lambda & { lhs: a; rhs: a }
//│ Defined class Abs[+a]
//│ Defined class App[+a]


def incr: {a: int} -> unit
// def incr x = x.a <- x.a + 1
//│ incr: {a: int} -> unit


def gensym: () -> (unit, {a: 'a},)
// def gensym = let n = { mut a = 0 } in fun () -> (incr n, n)
//│ gensym: () -> (unit, {a: nothing},)

def int_to_string: int -> string
//│ int_to_string: int -> string

def eval_lambda eval_rec subst v = case v of {
  | Var -> eval_var subst v
  | App -> let l2 = eval_rec subst v.lhs in
    let l1 = eval_rec subst v.rhs in
    case l1 of {
    | Abs -> eval_rec (Cons (Tuple l1.name l2) Nil) l1.body
    | _ -> App { lhs = l1; rhs = l2 }
    }
  | Abs -> let new_name = int_to_string ((gensym ())._2.a) in
    Abs { name = new_name;
          body = eval_rec (Cons (Tuple v.name (Var { name = new_name })) subst) v.body }
  }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.108: 	    | _ -> App { lhs = l1; rhs = l2 }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.108: 	    | _ -> App { lhs = l1; rhs = l2 }
//│ ╙──       	               ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.112: 	          body = eval_rec (Cons (Tuple v.name (Var { name = new_name })) subst) v.body }
//│ ║         	                                               ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({name: ?a},)` does not have field 'name'
//│ ║  l.112: 	          body = eval_rec (Cons (Tuple v.name (Var { name = new_name })) subst) v.body }
//│ ╙──       	                                                   ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.111: 	    Abs { name = new_name;
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.112: 	          body = eval_rec (Cons (Tuple v.name (Var { name = new_name })) subst) v.body }
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({body: ?a, name: ?b},)` is not a record (expected a record with fields: name, body)
//│ ║  l.111: 	    Abs { name = new_name;
//│ ║         	        ^^^^^^^^^^^^^^^^^^
//│ ║  l.112: 	          body = eval_rec (Cons (Tuple v.name (Var { name = new_name })) subst) v.body }
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ eval_lambda: ((Cons[nothing] & {tail: nothing} | 'a) -> 'body -> ('b & ((Abs[?] with {body: 'body}) | ~#Abs))) -> ('a & 'c) -> ((Abs[?] with {body: 'body}) | (App[?] with {lhs: 'body, rhs: 'body}) | Var & 'b) -> (Abs[nothing] & {name: nothing} | App[nothing] | 'b)
//│   where
//│     'c <: (Cons[?] with {head: {_1: string, _2: anything}, tail: 'c}) | Nil

rec def eval1 subst = eval_lambda eval1 subst
//│ eval1: 'a -> 'b -> (Abs[nothing] & {name: nothing} | 'c)
//│   where
//│     'b <: (Abs[?] with {body: 'b}) | App[?] & {lhs: 'b, rhs: 'b} | Var & 'd
//│     'd <: ((Abs[?] with {body: 'b}) | ~Abs[?]) & 'c
//│     'c :> Abs[nothing] & {name: nothing} | App[nothing]
//│        <: 'd
//│     'a <: (Cons[?] with {head: {_1: string, _2: anything}, tail: 'a}) | Nil

// ------------- OCaml's type -------------
// val eval_lambda :
//   ((string *
//     ([> `Abs of string * 'a | `App of 'a * 'a | `Var of string ] as 'a))
//   list -> 'a -> 'a) ->
//   (string * 'a) list ->
//   [< `Abs of string * 'a | `App of 'a * 'a | `Var of string ] -> 'a = <fun>
//
//   val eval1 :
//   (string * ([ `Abs of string * 'a | `App of 'a * 'a | `Var of string ] as 'a))
//   list -> 'a -> 'a = <fun>

// ************************* Expr ******************************

class Num: Expr & { num: int }
class Add[a]: Expr & { lhs: a; rhs: a }
class Mul[a]: Expr & { lhs: a; rhs: a }
//│ Defined class Num
//│ Defined class Add[+a]
//│ Defined class Mul[+a]

def map_expr f v = case v of {
  | Var -> v
  | Num -> v
  | Add -> Add { lhs = f v.lhs; rhs = f v.rhs }
  | Mul -> Mul { lhs = f v.lhs; rhs = f v.rhs }
  }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.173: 	  | Add -> Add { lhs = f v.lhs; rhs = f v.rhs }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.173: 	  | Add -> Add { lhs = f v.lhs; rhs = f v.rhs }
//│ ╙──       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.174: 	  | Mul -> Mul { lhs = f v.lhs; rhs = f v.rhs }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.174: 	  | Mul -> Mul { lhs = f v.lhs; rhs = f v.rhs }
//│ ╙──       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ map_expr: ('rhs -> anything) -> ((Add[?] with {lhs: 'rhs, rhs: 'rhs}) | (Mul[?] with {lhs: 'rhs, rhs: 'rhs}) | 'a & (Num | Var)) -> (Add[nothing] | Mul[nothing] | 'a)

rec def eval_expr eval_rec subst v =
  let vv = map_expr (eval_rec subst) v in
  case vv of {
    | Var -> eval_var subst vv
    | Add -> let vv1 = vv.lhs in
              let vv2 = vv.rhs in
              case vv1 of {
              | Num -> case vv2 of {
                | Num -> Num { num = vv1.num + vv2.num }
                | _ -> vv
                }
              | _ -> vv
              }
    | Mul -> let vv1 = vv.lhs in
              let vv2 = vv.rhs in
              case vv1 of {
              | Num -> case vv2 of {
                | Num -> Num { num = vv1.num * vv2.num }
                | _ -> vv
                }
              | _ -> vv
              }
    | Num -> vv // _ -> vv
    }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.198: 	                | Num -> Num { num = vv1.num + vv2.num }
//│ ║         	                                     ^^^^^^^^^
//│ ╟── argument of type `(?num,)` is not an instance of `int`
//│ ║  l.198: 	                | Num -> Num { num = vv1.num + vv2.num }
//│ ╙──       	                                     ^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.198: 	                | Num -> Num { num = vv1.num + vv2.num }
//│ ║         	                                     ^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?num,)` is not an instance of `int`
//│ ║  l.198: 	                | Num -> Num { num = vv1.num + vv2.num }
//│ ╙──       	                                               ^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.198: 	                | Num -> Num { num = vv1.num + vv2.num }
//│ ║         	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({num: ?a},)` does not have field 'num'
//│ ║  l.198: 	                | Num -> Num { num = vv1.num + vv2.num }
//│ ╙──       	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.207: 	                | Num -> Num { num = vv1.num * vv2.num }
//│ ║         	                                     ^^^^^^^^^
//│ ╟── argument of type `(?num,)` is not an instance of `int`
//│ ║  l.207: 	                | Num -> Num { num = vv1.num * vv2.num }
//│ ╙──       	                                     ^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.207: 	                | Num -> Num { num = vv1.num * vv2.num }
//│ ║         	                                     ^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?num,)` is not an instance of `int`
//│ ║  l.207: 	                | Num -> Num { num = vv1.num * vv2.num }
//│ ╙──       	                                               ^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.207: 	                | Num -> Num { num = vv1.num * vv2.num }
//│ ║         	                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({num: ?a},)` does not have field 'num'
//│ ║  l.207: 	                | Num -> Num { num = vv1.num * vv2.num }
//│ ╙──       	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ eval_expr: ('a -> 'lhs -> anything) -> ('a & 'b) -> ((Add[?] with {lhs: 'lhs, rhs: 'lhs}) | (Mul[?] with {lhs: 'lhs, rhs: 'lhs}) | 'c & (Num | Var)) -> (Add[nothing] | Mul[nothing] | Num & {num: nothing} | 'c)
//│   where
//│     'b <: (Cons[?] with {head: {_1: string, _2: anything}, tail: 'b}) | Nil

rec def eval2 subst = eval_expr eval2 subst
//│ eval2: 'a -> 'b -> (Add[nothing] | Mul[nothing] | Num & {num: nothing} | 'c)
//│   where
//│     'b <: Add[?] & {lhs: 'b, rhs: 'b} | Mul[?] & {lhs: 'b, rhs: 'b} | 'c & (Num | Var)
//│     'a <: (Cons[?] with {head: {_1: string, _2: anything}, tail: 'a}) | Nil


// ------------- OCaml's type -------------
// val map_expr :
//   ('a -> 'b) ->
//   [< `Add of 'a * 'a | `Mult of 'a * 'a | `Num of 'c | `Var of string ] ->
//   [> `Add of 'b * 'b | `Mult of 'b * 'b | `Num of 'c | `Var of string ] = <fun>

// val eval_expr :
//   ((string *
//     ([> `Add of ([> `Num of int ] as 'b) * 'b
//       | `Mult of 'b * 'b
//       | `Num of int
//       | `Var of string ]
//      as 'a))
//    list -> 'c -> 'b) ->
//   (string * 'a) list ->
//   [< `Add of 'c * 'c | `Mult of 'c * 'c | `Num of int | `Var of string ] -> 'a =
//   <fun>
// val eval2 :
//   (string *
//    ([> `Add of 'a * 'a | `Mult of 'a * 'a | `Num of int | `Var of string ]
//     as 'a))
//   list ->
//   ([< `Add of 'b * 'b | `Mult of 'b * 'b | `Num of int | `Var of string ] as 'b) ->
//   'a = <fun>


// ************************** Mix things *******************************

def eval_lexpr eval_rec subst v = case v of {
  | Lambda -> eval_lambda eval_rec subst v
  | Expr -> eval_expr eval_rec subst v
  }
//│ eval_lexpr: ((Cons[nothing] & {tail: nothing} | 'a) -> 'body -> ('b & ((Abs[?] with {body: 'body}) | ~#Abs))) -> ('a & 'c) -> nothing -> (Abs[nothing] & {name: nothing} | Add[nothing] | App[nothing] | Mul[nothing] | Num & {num: nothing} | 'b)
//│   where
//│     'c <: (Cons[?] with {head: {_1: string, _2: anything}, tail: 'c}) | Nil

rec def eval3 subst = eval_lexpr eval3 subst
//│ eval3: 'a -> nothing -> (Add[nothing] | Mul[nothing] | Num & {num: nothing} | Abs[nothing] & {name: nothing} | App[nothing])
//│   where
//│     'a <: (Cons[?] with {head: {_1: string, _2: anything}, tail: 'a}) | Nil

// ------------- OCaml's type -------------
// val eval_lexpr :
//   ((string *
//     ([> `Abs of string * 'a
//       | `Add of 'a * 'a
//       | `App of 'a * 'a
//       | `Mult of 'a * 'a
//       | `Num of int
//       | `Var of string ]
//      as 'a))
//    list -> 'a -> 'a) ->
//   (string * 'a) list ->
//   [< `Abs of string * 'a
//    | `Add of 'a * 'a
//    | `App of 'a * 'a
//    | `Mult of 'a * 'a
//    | `Num of int
//    | `Var of string ] ->
//   'a = <fun>
//
// val eval3 :
//   (string *
//    ([ `Abs of string * 'a
//     | `Add of 'a * 'a
//     | `App of 'a * 'a
//     | `Mult of 'a * 'a
//     | `Num of int
//     | `Var of string ] as 'a))
//   list -> 'a -> 'a = <fun>

// ************************** Tests *******************************

eval3 Nil (Var { name = "s" })
// ------------- OCaml's type -------------
// - : [ `Abs of string * 'a
//     | `Add of 'a * 'a
//     | `App of 'a * 'a
//     | `Mult of 'a * 'a
//     | `Num of int
//     | `Var of string ] as 'a
// = `Var "s"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.334: 	eval3 Nil (Var { name = "s" })
//│ ║         	           ^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({name: string},)` does not have field 'name'
//│ ║  l.334: 	eval3 Nil (Var { name = "s" })
//│ ╙──       	               ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.334: 	eval3 Nil (Var { name = "s" })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Var & {name: ?name}` does not match type `Expr & ?a | Lambda & ?b`
//│ ║  l.334: 	eval3 Nil (Var { name = "s" })
//│ ║         	           ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `Expr & ?c | Lambda & ?d`
//│ ║  l.334: 	eval3 Nil (Var { name = "s" })
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.289: 	def eval_lexpr eval_rec subst v = case v of {
//│ ╙──       	                                       ^
//│ res: Abs[nothing] & {name: nothing} | Add[nothing] | App[nothing] | Mul[nothing] | Num & {num: nothing}


eval3 Nil (Abs { name = "s"; body = Var { name = "s" } })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.364: 	eval3 Nil (Abs { name = "s"; body = Var { name = "s" } })
//│ ║         	                                    ^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({name: string},)` does not have field 'name'
//│ ║  l.364: 	eval3 Nil (Abs { name = "s"; body = Var { name = "s" } })
//│ ╙──       	                                        ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.364: 	eval3 Nil (Abs { name = "s"; body = Var { name = "s" } })
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({body: ?a, name: string},)` is not a record (expected a record with fields: name, body)
//│ ║  l.364: 	eval3 Nil (Abs { name = "s"; body = Var { name = "s" } })
//│ ╙──       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.364: 	eval3 Nil (Abs { name = "s"; body = Var { name = "s" } })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Abs[?a] with {Abs#a = ?a, body: ?body, name: ?name}` does not match type `Expr & ?b | Lambda & ?c`
//│ ║  l.364: 	eval3 Nil (Abs { name = "s"; body = Var { name = "s" } })
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `Expr & ?d | Lambda & ?e`
//│ ║  l.364: 	eval3 Nil (Abs { name = "s"; body = Var { name = "s" } })
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.289: 	def eval_lexpr eval_rec subst v = case v of {
//│ ╙──       	                                       ^
//│ res: Abs[nothing] & {name: nothing} | Add[nothing] | App[nothing] | Mul[nothing] | Num & {num: nothing}

eval2 Nil (Num { num = 1 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.391: 	eval2 Nil (Num { num = 1 })
//│ ║         	           ^^^^^^^^^^^^^^^
//│ ╟── argument of type `({num: int},)` does not have field 'num'
//│ ║  l.391: 	eval2 Nil (Num { num = 1 })
//│ ╙──       	               ^^^^^^^^^^^
//│ res: Add[nothing] | Mul[nothing] | Num & {num: nothing}

eval3 Nil (Num { num = 1 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.400: 	eval3 Nil (Num { num = 1 })
//│ ║         	           ^^^^^^^^^^^^^^^
//│ ╟── argument of type `({num: int},)` does not have field 'num'
//│ ║  l.400: 	eval3 Nil (Num { num = 1 })
//│ ╙──       	               ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.400: 	eval3 Nil (Num { num = 1 })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Num & {num: ?num}` does not match type `Expr & ?a | Lambda & ?b`
//│ ║  l.400: 	eval3 Nil (Num { num = 1 })
//│ ║         	           ^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `Expr & ?c | Lambda & ?d`
//│ ║  l.400: 	eval3 Nil (Num { num = 1 })
//│ ║         	          ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.289: 	def eval_lexpr eval_rec subst v = case v of {
//│ ╙──       	                                       ^
//│ res: Abs[nothing] & {name: nothing} | Add[nothing] | App[nothing] | Mul[nothing] | Num & {num: nothing}

eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.421: 	eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ║         	                       ^^^^^^^^^^^^^
//│ ╟── argument of type `({num: int},)` does not have field 'num'
//│ ║  l.421: 	eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ╙──       	                           ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.421: 	eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ║         	                                            ^^^^^^^^^^^^^
//│ ╟── argument of type `({num: int},)` does not have field 'num'
//│ ║  l.421: 	eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ╙──       	                                                ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.421: 	eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.421: 	eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ╙──       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.421: 	eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `App[?a] with {App#a = ?a, lhs: ?lhs, rhs: ?rhs}` does not match type `Expr & ?b | Lambda & ?c`
//│ ║  l.421: 	eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `Expr & ?d | Lambda & ?e`
//│ ║  l.421: 	eval3 Nil (App { lhs = Num {num = 0}; rhs = Num {num = 0}})
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.289: 	def eval_lexpr eval_rec subst v = case v of {
//│ ╙──       	                                       ^
//│ res: Abs[nothing] & {name: nothing} | Add[nothing] | App[nothing] | Mul[nothing] | Num & {num: nothing}

eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ║         	                                                ^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({name: string},)` does not have field 'name'
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ╙──       	                                                    ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ║         	                                                                          ^^^^^^^^^^^^^^^
//│ ╟── argument of type `({num: int},)` does not have field 'num'
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ╙──       	                                                                              ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ║         	                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({lhs: ?a, rhs: ?b},)` is not a record (expected a record with fields: lhs, rhs)
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ╙──       	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({body: ?a, name: string},)` is not a record (expected a record with fields: name, body)
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ╙──       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Abs[?a] with {Abs#a = ?a, body: ?body, name: ?name}` does not match type `Expr & ?b | Lambda & ?c`
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into argument with expected type `Expr & ?d | Lambda & ?e`
//│ ║  l.454: 	eval3 Nil (Abs { name = "s"; body = Add { lhs = Var { name = "s" }; rhs = Num { num = 1 } } })
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.289: 	def eval_lexpr eval_rec subst v = case v of {
//│ ╙──       	                                       ^
//│ res: Abs[nothing] & {name: nothing} | Add[nothing] | App[nothing] | Mul[nothing] | Num & {num: nothing}


// *************************************

def eval_lexpr' eval_rec subst v = case v of {
  | Var -> eval_var eval_rec subst v
  | Abs -> eval_lambda eval_rec subst v
  | App -> eval_lambda eval_rec subst v
  | Num -> eval_expr eval_rec subst v
  | Add -> eval_expr eval_rec subst v
  | Mul -> eval_expr eval_rec subst v
  }
//│ eval_lexpr': ((Cons[nothing] & {tail: nothing}) -> 'lhs -> ('a & ((Abs[?] with {body: 'lhs}) | ~#Abs)) & 'b) -> nothing -> ((Abs[?] with {body: 'lhs}) | (Add[?] with {lhs: 'lhs, rhs: 'lhs}) | (App[?] with {lhs: 'lhs, rhs: 'lhs}) | (Mul[?] with {lhs: 'lhs, rhs: 'lhs}) | Num & 'a | Var) -> (Abs[nothing] & {name: nothing} | Add[nothing] | App[nothing] | Mul[nothing] | Num & {num: nothing} | 'a)
//│   where
//│     'b <: (Cons[?] with {head: {_1: string, _2: anything}, tail: 'b}) | Nil
