
class A
class B: A
class C: B
c = C{}
//│ Defined class A
//│ Defined class B
//│ Defined class C
//│ c: C

c: C
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.11: 	c: C
//│ ║        	^
//│ ╟── application of type `C` is not an instance of type `B`
//│ ║  l.5: 	c = C{}
//│ ║       	    ^^^
//│ ╟── but it flows into reference with expected type `B`
//│ ║  l.11: 	c: C
//│ ║        	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.11: 	c: C
//│ ║        	   ^
//│ ╟── from type reference:
//│ ║  l.4: 	class C: B
//│ ║       	         ^
//│ ╟── Note: class C is defined at:
//│ ║  l.4: 	class C: B
//│ ╙──     	      ^
//│ res: C

c: B
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.32: 	c: B
//│ ║        	^
//│ ╟── application of type `C` does not match type `nothing`
//│ ║  l.5: 	c = C{}
//│ ║       	    ^^^
//│ ╟── but it flows into reference with expected type `nothing`
//│ ║  l.32: 	c: B
//│ ║        	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.32: 	c: B
//│ ║        	   ^
//│ ╟── Note: class C is defined at:
//│ ║  l.4: 	class C: B
//│ ╙──     	      ^
//│ res: B

res: A
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.50: 	res: A
//│ ║        	^^^
//│ ╟── type `B` is not an instance of `A`
//│ ║  l.32: 	c: B
//│ ║        	   ^
//│ ╟── but it flows into reference with expected type `A`
//│ ║  l.50: 	res: A
//│ ║        	^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.50: 	res: A
//│ ╙──      	     ^
//│ res: A

c: A
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.65: 	c: A
//│ ║        	^
//│ ╟── application of type `C` is not an instance of `A`
//│ ║  l.5: 	c = C{}
//│ ║       	    ^^^
//│ ╟── but it flows into reference with expected type `A`
//│ ║  l.65: 	c: A
//│ ║        	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.65: 	c: A
//│ ║        	   ^
//│ ╟── Note: class C is defined at:
//│ ║  l.4: 	class C: B
//│ ╙──     	      ^
//│ res: A

a = res
//│ a: A

:e
a: B
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.87: 	a: B
//│ ║        	^
//│ ╟── type `A` is not an instance of `B`
//│ ║  l.65: 	c: A
//│ ║        	   ^
//│ ╟── but it flows into reference with expected type `B`
//│ ║  l.87: 	a: B
//│ ║        	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.87: 	a: B
//│ ╙──      	   ^
//│ res: B





:e
a: C
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.107: 	a: C
//│ ║         	^
//│ ╟── type `A` is not an instance of `C`
//│ ║  l.65: 	c: A
//│ ║        	   ^
//│ ╟── but it flows into reference with expected type `C`
//│ ║  l.107: 	a: C
//│ ║         	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.107: 	a: C
//│ ╙──       	   ^
//│ res: C






// Transitivity is currently broken for primitive literals:

42: int
res: number
//│ res: int
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.130: 	res: number
//│ ║         	^^^
//│ ╟── type `int` is not an instance of `number`
//│ ║  l.129: 	42: int
//│ ║         	    ^^^
//│ ╟── but it flows into reference with expected type `number`
//│ ║  l.130: 	res: number
//│ ║         	^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.130: 	res: number
//│ ╙──       	     ^^^^^^
//│ res: number

42: number
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.146: 	42: number
//│ ║         	^^
//│ ╟── integer literal of type `int` is not an instance of `number`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.146: 	42: number
//│ ╙──       	    ^^^^^^
//│ res: number

