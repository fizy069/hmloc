:w
class Seq[A]: { size: int }
//│ Defined class Seq[±A]
//│ ╔══[WARNING] Type definition Seq has bivariant type parameters:
//│ ║  l.2: 	class Seq[A]: { size: int }
//│ ║       	      ^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.2: 	class Seq[A]: { size: int }
//│ ╙──     	          ^



:w
class ListBase[A]: Seq[A]
//│ Defined class ListBase[±A]
//│ ╔══[WARNING] Type definition ListBase has bivariant type parameters:
//│ ║  l.14: 	class ListBase[A]: Seq[A]
//│ ║        	      ^^^^^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.14: 	class ListBase[A]: Seq[A]
//│ ╙──      	               ^



class Nil: ListBase[nothing] & {}
class Cons[A]: ListBase[A] & { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons[+A]
//│ Defined type alias List[+A]

:e
Nil{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.33: 	Nil{}
//│ ║        	^^^^^
//│ ╟── argument of type `(anything,)` does not have field 'size'
//│ ║  l.33: 	Nil{}
//│ ╙──      	   ^^
//│ res: Nil & {size: nothing}



def Nil = Nil { size = 0 }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.44: 	def Nil = Nil { size = 0 }
//│ ║        	          ^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({size: int},)` does not have field 'size'
//│ ║  l.44: 	def Nil = Nil { size = 0 }
//│ ╙──      	              ^^^^^^^^^^^^
//│ Nil: Nil & {size: nothing}

:e
:re
Cons 1 Nil
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.55: 	Cons 1 Nil
//│ ║        	^^^^^^
//│ ╟── argument of type `(int,)` is not a record (expected a record with fields: size, tail, head)
//│ ║  l.55: 	Cons 1 Nil
//│ ╙──      	     ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.55: 	Cons 1 Nil
//│ ║        	^^^^^^^^^^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, size: ?size, tail: ?tail}` is not a function
//│ ║  l.55: 	Cons 1 Nil
//│ ╙──      	^^^^^^
//│ res: nothing





Cons
//│ res: {head: 'A & 'head, size: int & 'size, tail: List['A] & 'tail} -> (Cons['A] with {head: 'head, size: 'size, tail: 'tail})

// In the old inheritance semantics, this used to be required:
def Cons_old head tail =
  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ ║        	                               ^^^^^^^^^^^^^^
//│ ╟── argument of type `(?size,)` is not an instance of `int`
//│ ║  l.79: 	  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ ╙──      	                                    ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({size: ?a},)` does not have field 'size'
//│ ║  l.79: 	  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ ╙──      	                      ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a,)` does not have field 'size'
//│ ║  l.79: 	  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ ╙──      	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?a\head\tail & {head: ?b, tail: ?c},)` is not a record (expected a record with fields: size, tail, head)
//│ ║  l.79: 	  Cons (ListBase (Seq { size = succ tail.size }) with { head; tail })
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ Cons_old: anything -> {size: anything} -> (Cons[nothing] & {size: nothing, tail: nothing})

def Cons head tail =
  Cons { size = succ tail.size; head; tail }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.107: 	  Cons { size = succ tail.size; head; tail }
//│ ║         	                ^^^^^^^^^^^^^^
//│ ╟── argument of type `(?size,)` is not an instance of `int`
//│ ║  l.107: 	  Cons { size = succ tail.size; head; tail }
//│ ╙──       	                     ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.107: 	  Cons { size = succ tail.size; head; tail }
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({head: ?a, size: ?b, tail: ?c},)` is not a record (expected a record with fields: size, tail, head)
//│ ║  l.107: 	  Cons { size = succ tail.size; head; tail }
//│ ╙──       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ Cons: anything -> {size: anything} -> (Cons[nothing] & {size: nothing, tail: nothing})

// * Works thanks to variance analysis
Nil: ListBase[anything]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.123: 	Nil: ListBase[anything]
//│ ║         	^^^
//│ ╟── application of type `Nil & {size: ?size}` does not match type `nothing`
//│ ║  l.44: 	def Nil = Nil { size = 0 }
//│ ║        	          ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `nothing`
//│ ║  l.123: 	Nil: ListBase[anything]
//│ ║         	^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.123: 	Nil: ListBase[anything]
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^
//│ res: ListBase[?]

def c = Cons 1 Nil
//│ c: Cons[nothing] & {size: nothing, tail: nothing}

c: ListBase[int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.141: 	c: ListBase[int]
//│ ║         	^
//│ ╟── application of type `Cons[?A] with {Cons#A = ?A, head: ?head, size: ?size, tail: ?tail}` does not match type `nothing`
//│ ║  l.107: 	  Cons { size = succ tail.size; head; tail }
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `nothing`
//│ ║  l.141: 	c: ListBase[int]
//│ ║         	^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.141: 	c: ListBase[int]
//│ ╙──       	   ^^^^^^^^^^^^^
//│ res: ListBase[?]

c.head
//│ res: nothing

c.tail
//│ res: nothing

c.size
//│ res: nothing

def d = Cons 2 c
//│ d: Cons[nothing] & {size: nothing, tail: nothing}

d.head
//│ res: nothing

d.size
//│ res: nothing

d.tail
//│ res: nothing

d.tail.size
//│ res: nothing

d.tail.head
d.tail.tail
//│ res: nothing
//│ res: nothing

