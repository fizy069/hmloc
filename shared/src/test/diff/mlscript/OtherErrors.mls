:AllowTypeErrors

// Multiline error:
id
  id
  id
  3 2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.4: 	id
//│ ║       	^^
//│ ║  l.5: 	  id
//│ ║       	^^^^
//│ ║  l.6: 	  id
//│ ║       	^^^^
//│ ╟── argument of type `(?a -> ?a,)` is not a function
//│ ║  l.5: 	  id
//│ ║       	  ^^
//│ ╟── but it flows into application with expected type `(?b -> ?b) -> ?c`
//│ ║  l.4: 	id
//│ ║       	^^
//│ ║  l.5: 	  id
//│ ╙──     	^^^^
//│ res: nothing











1: 1 & int: { x: int; y: string }
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.35: 	1: 1 & int: { x: int; y: string }
//│ ║        	^
//│ ╟── integer literal of type `int` does not match type `1`
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.35: 	1: 1 & int: { x: int; y: string }
//│ ║        	   ^^^^^^^
//│ ╟── from literal type:
//│ ║  l.35: 	1: 1 & int: { x: int; y: string }
//│ ╙──      	   ^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.35: 	1: 1 & int: { x: int; y: string }
//│ ║        	^
//│ ╟── type `1` is not a record (expected a record with fields: x, y)
//│ ║  l.35: 	1: 1 & int: { x: int; y: string }
//│ ║        	   ^^^^^^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.35: 	1: 1 & int: { x: int; y: string }
//│ ╙──      	            ^^^^^^^^^^^^^^^^^^^^^
//│ res: {x: int, y: string}




1: 1 & int: { x: int; y: string } | string
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.60: 	1: 1 & int: { x: int; y: string } | string
//│ ║        	^
//│ ╟── integer literal of type `int` does not match type `1`
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.60: 	1: 1 & int: { x: int; y: string } | string
//│ ║        	   ^^^^^^^
//│ ╟── from literal type:
//│ ║  l.60: 	1: 1 & int: { x: int; y: string } | string
//│ ╙──      	   ^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.60: 	1: 1 & int: { x: int; y: string } | string
//│ ║        	^
//│ ╟── type `1` does not match type `string | {x: int, y: string}`
//│ ║  l.60: 	1: 1 & int: { x: int; y: string } | string
//│ ║        	   ^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.60: 	1: 1 & int: { x: int; y: string } | string
//│ ╙──      	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: string | {x: int, y: string}




