
def incr x = x.a <- x.a + 1
//│ incr: {mut a: int} -> unit


:p

def gensym = let n = { mut a = 0 } in fun () -> (incr n, n)
//│ gensym: () -> (unit, {mut a: 'a},)
//│   where
//│     'a :> int


:p
gensym1 = let n = { mut a = 0 } in fun () -> (incr n, n)
//│ gensym1: () -> (unit, {mut a: 'a},)
//│   where
//│     'a :> int


gensym ()
//│ res: (unit, {mut a: 'a},)
//│   where
//│     'a :> int


gensym ()
//│ res: (unit, {mut a: 'a},)
//│   where
//│     'a :> int


gensym1 ()
//│ res: (unit, {mut a: 'a},)
//│   where
//│     'a :> int

gensym1 ()
//│ res: (unit, {mut a: 'a},)
//│   where
//│     'a :> int


gensym1 ()
//│ res: (unit, {mut a: 'a},)
//│   where
//│     'a :> int


def f x = x
//│ f: 'a -> 'a


f 1
//│ res: int


rec def xx = xx
//│ xx: nothing

class Nil: {}
class Cons[A]: { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons[+A]
//│ Defined type alias List[+A]

def Nil = Nil {}
def Cons head tail = Cons { head; tail }
//│ Nil: Nil
//│ Cons: ('head & 'A) -> (List['A] & 'tail) -> (Cons['A] with {head: 'head, tail: 'tail})


rec def xs = Cons 0 (Cons 1 xs)
//│ xs: 'tail
//│   where
//│     'tail :> Cons[int] with {tail: Cons[int] with {tail: 'tail}}

:re
xs
//│ res: 'tail
//│   where
//│     'tail :> Cons[int] with {tail: Cons[int] with {tail: 'tail}}
