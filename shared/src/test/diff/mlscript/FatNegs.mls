
class Lit: { n: int }
//│ Defined class Lit

// TODO should eventually print these differently or make them truly equivalent
//  by making #Lit <: Lit, i.e. making the tags include the fields implicitly.

// * Q: What happens if one writes ~Lit instead of ~#Lit?
def nc: ~Lit
def nt: ~#Lit
//│ nc: ~Lit
//│ nt: ~Lit

// * A: It's not equivalent.

// * Demonstrates that the negated tag is a subtype of the whole negated class:
nc = nt
//│ ~Lit
//│   <:  nc:
//│ ~Lit

// * Demonstrates that the negated tag is not a supertype of the whole negated class:
:e
nt = nc
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.24: 	nt = nc
//│ ║        	^^^^^^^
//│ ╟── type `Lit` does not have field 'n'
//│ ║  l.9: 	def nc: ~Lit
//│ ║       	        ^^^^
//│ ╟── but it flows into reference with expected type `{n: int}`
//│ ║  l.24: 	nt = nc
//│ ║        	     ^^
//│ ╟── Note: constraint arises from type negation:
//│ ║  l.10: 	def nt: ~#Lit
//│ ║        	        ^^^^^
//│ ╟── from record type:
//│ ║  l.2: 	class Lit: { n: int }
//│ ╙──     	           ^^^^^^^^^^
//│ ~Lit
//│   <:  nt:
//│ ~Lit






nc = nc
//│ ~Lit
//│   <:  nc:
//│ ~Lit

nt = nt
//│ ~Lit
//│   <:  nt:
//│ ~Lit

