

class Foo[A]: { x: A; y: A }
//│ Defined class Foo[+A]

def foo: #Foo
//│ foo: Foo[?]

foo12 = Foo { x = 1; y = 2 }
//│ foo12: Foo[int]

foo = foo12
//│ Foo[int]
//│   <:  foo:
//│ Foo[?]

def test1 f = case f of { Foo -> f }
//│ test1: (Foo[?] & 'a) -> 'a

test1 foo
//│ res: Foo[?]

def test2 f = case f of { Foo -> f.x }
//│ test2: (Foo[?]\y with {x: 'x}) -> 'x

test2 foo12
//│ res: int


// * Only has the tag in its type, not the field
:e
test2 foo
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.32: 	test2 foo
//│ ║        	^^^^^^^^^
//│ ╟── reference of type `Foo[?]` does not have field 'x'
//│ ║  l.32: 	test2 foo
//│ ║        	      ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.23: 	def test2 f = case f of { Foo -> f.x }
//│ ║        	                   ^
//│ ╟── from receiver:
//│ ║  l.23: 	def test2 f = case f of { Foo -> f.x }
//│ ╙──      	                                 ^
//│ res: nothing





// * Mistakenly passing the constructor
:e
foo = Foo
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.53: 	foo = Foo
//│ ║        	^^^^^^^^^
//│ ╟── reference of type `{x: ?x, y: ?y} -> (Foo[?A] with {Foo#A = ?A, x: ?x, y: ?y})` is not an instance of type `Foo`
//│ ║  l.53: 	foo = Foo
//│ ║        	      ^^^
//│ ╟── Note: class constructor Foo is defined at:
//│ ║  l.3: 	class Foo[A]: { x: A; y: A }
//│ ╙──     	      ^^^
//│ {x: 'x & 'A, y: 'A & 'y} -> (Foo['A] with {x: 'x, y: 'y})
//│   <:  foo:
//│ Foo[?]





