:ShowRepl
class A: { fA: int }
class B: { fB: string }
class C: { fC: bool }
//│ Defined class A
//│ Defined class B
//│ Defined class C

def foo x = case x of {
  | A -> x.fA
  | B -> x.fB
  | C -> x.fC
  }
//│ foo: ((A with {fA: 'fA}) | (B with {fB: 'fA}) | (C with {fC: 'fA})) -> 'fA

:ShowRepl
b = B { fB = "test" }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.17: 	b = B { fB = "test" }
//│ ║        	    ^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `({fB: string},)` does not have field 'fB'
//│ ║  l.17: 	b = B { fB = "test" }
//│ ╙──      	      ^^^^^^^^^^^^^^^
//│ b: B & {fB: nothing}

:stats
foo b
//│ res: nothing
//│ constrain calls  : 22
//│ annoying  calls  : 10
//│ subtyping calls  : 22


def arg: A | B | C
//│ arg: A | B | C

:stats
foo arg
//│ res: bool | int | string
//│ constrain calls  : 88
//│ annoying  calls  : 30
//│ subtyping calls  : 81

:stats
foo (arg with { fC = true })
//│ res: bool | int | string
//│ constrain calls  : 72
//│ annoying  calls  : 28
//│ subtyping calls  : 109

def foo x = case x of {
  | A -> add x.fA x.payload
  | B -> x.fB
  | C -> { l = x.fC; r = x.payload }
  }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.52: 	  | A -> add x.fA x.payload
//│ ║        	         ^^^^^^^^
//│ ╟── argument of type `(?fA,)` is not an instance of `int`
//│ ║  l.52: 	  | A -> add x.fA x.payload
//│ ╙──      	             ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.52: 	  | A -> add x.fA x.payload
//│ ║        	         ^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `(?payload,)` is not an instance of `int`
//│ ║  l.52: 	  | A -> add x.fA x.payload
//│ ╙──      	                  ^^^^^^^^^
//│ foo: ((A with {payload: anything}) | (B with {fB: 'fB}) | (C with {fC: 'fC, payload: 'payload})) -> ('fB | int | {l: 'fC, r: 'payload})

:e
:stats
foo arg
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.72: 	foo arg
//│ ║        	^^^^^^^
//│ ╟── type `A` does not have field 'payload'
//│ ║  l.34: 	def arg: A | B | C
//│ ║        	         ^
//│ ╟── but it flows into reference with expected type `{payload: ?payload}`
//│ ║  l.72: 	foo arg
//│ ║        	    ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.51: 	def foo x = case x of {
//│ ║        	                 ^
//│ ╟── from receiver:
//│ ║  l.52: 	  | A -> add x.fA x.payload
//│ ╙──      	                  ^
//│ res: int | string | {l: bool, r: nothing}
//│ constrain calls  : 67
//│ annoying  calls  : 40
//│ subtyping calls  : 102






:stats
foo (arg with { payload = 1 })
//│ res: int | string | {l: bool, r: int}
//│ constrain calls  : 57
//│ annoying  calls  : 38
//│ subtyping calls  : 123

