:NewParser

class Option
class Some(value): Option
class None: Option
//│ Defined class Option
//│ Defined class Some
//│ Defined class None
//│ Option: () -> Option
//│ Some: 'value -> (Some with {value: 'value})
//│ None: () -> None

class Either
class Left(leftValue): Either
class Right(rightValue): Either
//│ Defined class Either
//│ Defined class Left
//│ Defined class Right
//│ Either: () -> Either
//│ Left: 'leftValue -> (Left with {leftValue: 'leftValue})
//│ Right: 'rightValue -> (Right with {rightValue: 'rightValue})

:e
:ge
fun f(x, y) =
  if x is
    Left(xv) and y is Left(yv) then xv + yv
    Right(xv) and y is Right(yv) then xv * yv
    None() and y is None() then 0
//│ ╔══[ERROR] The match is not exhaustive.
//│ ║  l.27: 	    Left(xv) and y is Left(yv) then xv + yv
//│ ║        	                 ^^^^^^^^^^^^^
//│ ╟── The scrutinee at this position misses 2 cases.
//│ ║  l.27: 	    Left(xv) and y is Left(yv) then xv + yv
//│ ║        	                 ^
//│ ╟── [Missing Case 1/2] `None`
//│ ╟── It first appears here.
//│ ║  l.29: 	    None() and y is None() then 0
//│ ║        	                    ^^^^^^
//│ ╟── [Missing Case 2/2] `Right`
//│ ╟── It first appears here.
//│ ║  l.28: 	    Right(xv) and y is Right(yv) then xv * yv
//│ ╙──      	                       ^^^^^^^^^
//│ f: (anything, anything,) -> error

fun f(x, y) =
  if x is
    Left(xv) and y is Left(yv) then xv + yv
    None() then 0
//│ f: (Left & {leftValue: int} | None, Left & {leftValue: int},) -> int

fun f(x, y) =
  if x is
    Left(xv) and y is
      Left(yv) then xv + yv
      Right(yv) then xv * yv
    None() then 0
//│ f: (Left & {leftValue: int} | None, Left & {leftValue: int} | Right & {rightValue: int},) -> int

fun f(x) =
  if x is
    Some(v) and
      v < 0 then "negative"
      v > 0 then "positive"
      _     then "zero"
    None() then "nothing"
//│ f: (None | Some & {value: int}) -> string

fun f(x, y) =
  if x is
    Some(x) and y is
      Some(y) then 0
//│ f: (Some, Some,) -> int

class A(value)
class B(value)
//│ Defined class A
//│ Defined class B
//│ A: 'value -> (A with {value: 'value})
//│ B: 'value -> (B with {value: 'value})

fun f(x, y, u, v) =
  if x is
    A(a) and y ==
      u then 0
      v then 1
    A(a) and y is
      B(0) then 0
      B(1) then 1
    A(_) then 99
//│ f: (A, int, int, int,) -> int

fun f(x) =
  if x is
    A(_) then "A"
    B(_) then "B"
//│ f: (A | B) -> string

:e
:ge
fun f(x, y) =
  if x is
    Some(xv) and y is Some(yv) then xv + yv
    None() and y is None() then 0
//│ ╔══[ERROR] The match is not exhaustive.
//│ ║  l.103: 	    Some(xv) and y is Some(yv) then xv + yv
//│ ║         	                 ^^^^^^^^^^^^^
//│ ╟── The scrutinee at this position misses 1 case.
//│ ║  l.103: 	    Some(xv) and y is Some(yv) then xv + yv
//│ ║         	                 ^
//│ ╟── [Missing Case 1/1] `None`
//│ ╟── It first appears here.
//│ ║  l.104: 	    None() and y is None() then 0
//│ ╙──       	                    ^^^^^^
//│ f: (anything, anything,) -> error

:e
:ge
fun f(x, y) =
  if x is
    Some(xv) and y is
      Some(yv) then xv + yv
      None() then xv * 2
    None() and y is
      Some(yv) then yv * 3
//│ ╔══[ERROR] The match is not exhaustive.
//│ ║  l.124: 	    None() and y is
//│ ║         	               ^^^^
//│ ╟── The scrutinee at this position misses 1 case.
//│ ║  l.124: 	    None() and y is
//│ ║         	               ^
//│ ╟── [Missing Case 1/1] `None`
//│ ╟── It first appears here.
//│ ║  l.123: 	      None() then xv * 2
//│ ╙──       	      ^^^^^^
//│ f: (anything, anything,) -> error

fun f(x, y) =
  if x is
    A and y is
      B then "bruh"
//│ f: (A, B,) -> string

fun f(x, y, z) =
  if x is
    A and z == 0 and y == 0 and y is
      B then "bruh"
    A then "oui"
//│ f: (A, int, int,) -> string

// We do need a syntax to specify default branch in IfOpsApp...
:e
:ge
fun f(x, y) =
  if x is
    Some(x) and y
      >  0 then "gt"
      <  0 then "le"
      == 0 then "eq"
//│ ╔══[ERROR] Missing the otherwise case of test == (y,) (0,)
//│ ║  l.156: 	    Some(x) and y
//│ ║         	                ^
//│ ║  l.157: 	      >  0 then "gt"
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.158: 	      <  0 then "le"
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.159: 	      == 0 then "eq"
//│ ╙──       	^^^^^^^^^^
//│ f: (anything, anything,) -> error

fun isValid(x) = if x then false else true
//│ isValid: anything -> bool

fun f(x, allowNone) =
  if x is
    Some(x) and isValid(x) then "good"
    None() and allowNone then "okay"
    else "bad"
//│ f: (anything, anything,) -> string

fun f(x) =
  if x is
    None then "bruh"
    Some(x) then "roll"
    _ and x == 0 then 0
    _ then "rock"
//│ f: (int | None | Some) -> (int | string)

fun f(x, a, b) =
  if x is
    A(aa) and a then aa
    B(bb) and b then bb
    _           then 0
//│ f: ((A with {value: 'value}) | (B with {value: 'value}) | ~A & ~B, anything, anything,) -> (int | 'value)

fun f(x, y, b) =
  if x is
    Some(xv) and y
      is Some(yv) then "bruh"
      is None() then "bruh"
    Some(xv) and b then xv + b
    _ then "roll"
//│ f: (Some & {value: int} | ~Some, anything, ~true,) -> (int | string)

fun g(x, y, b) =
  if x is
    Some(xv) and y
      is Some(yv) then yv
      is None() then "bruh"
    Some(xv) and b then xv + b
    _ then "roll"
//│ g: (Some & {value: int} | ~Some, (Some with {value: 'value}) | ~Some, ~true,) -> (int | string | 'value)

fun foo(x, y, z) =
  if x - y > 0 then Some(x + y + z) else None()
//│ foo: (int, int, int,) -> (None | Some & {value: int})

// Uncomment this block to make the following block work.
// fun foo(x, y, z) =
//   if x - y > 0 then Some(
//     if x % 2 == 0 then Left(x) else Right(x)
//   ) else None()

:e
fun f(u, v, w) =
  if foo(u, v, w) is
    Some(x) and x is
      Left(_) then "left-defined"
      Right(_) then "right-defined"
    None then "undefined"
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.226: 	  if foo(u, v, w) is
//│ ║         	     ^^^^^^^^^^^^^^^
//│ ║  l.227: 	    Some(x) and x is
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.228: 	      Left(_) then "left-defined"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.229: 	      Right(_) then "right-defined"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.230: 	    None then "undefined"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `Left & ?a | Right & ?b`
//│ ║  l.215: 	  if x - y > 0 then Some(x + y + z) else None()
//│ ║         	                         ^^^^^^^^^
//│ ╟── but it flows into application with expected type `Left & ?a | Right & ?b`
//│ ║  l.226: 	  if foo(u, v, w) is
//│ ║         	     ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from refined scrutinee:
//│ ║  l.226: 	  if foo(u, v, w) is
//│ ║         	     ^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.227: 	    Some(x) and x is
//│ ╙──       	                ^
//│ f: (int, int, int,) -> string

fun p(x) = if x >= 0 then Right(x) else Left(x)
//│ p: (int & 'leftValue) -> ((Left with {leftValue: 'leftValue}) | (Right with {rightValue: 'leftValue}))

fun g(a, b) =
  if p(a) is
    Left(x) and b is
      Some(y) then x + y
      None    then x * a
    Right(x) and b is
      Some(y) then x * y
      None    then x
//│ g: (int, None | Some & {value: int},) -> int

// TODO: Fix the NaN.
g(5, None())
g(5, Some(7))
g(0 - 5, None())
g(0 - 5, Some(9))
//│ res: int
//│ res: int
//│ res: int
//│ res: int

class Var(name)
class ValBase
class IntVal(value): ValBase
class BoolVal(value): ValBase
class Lit(val)
//│ Defined class Var
//│ Defined class ValBase
//│ Defined class IntVal
//│ Defined class BoolVal
//│ Defined class Lit
//│ Var: 'name -> (Var with {name: 'name})
//│ ValBase: () -> ValBase
//│ IntVal: 'value -> (IntVal with {value: 'value})
//│ BoolVal: 'value -> (BoolVal with {value: 'value})
//│ Lit: 'val -> (Lit with {val: 'val})

fun p(e, context) =
  if e is
    Var(x) and context.get(x) is
      Some(IntVal(v)) then Left(v)
      Some(BoolVal(v)) then Right(v)
    Lit(IntVal(v)) then Left(v)
    Lit(BoolVal(v)) then Right(v)
//│ p: (Lit & {val: (BoolVal with {value: 'rightValue}) | (IntVal with {value: 'leftValue})} | (Var with {name: 'name}), {get: 'name -> (Some & {value: (BoolVal with {value: 'rightValue}) | (IntVal with {value: 'leftValue})})},) -> ((Left with {leftValue: 'leftValue}) | (Right with {rightValue: 'rightValue}))

class Nil()
//│ Defined class Nil
//│ Nil: () -> Nil

// Support operator constructor like ::
:e
:ge
fun f(x) =
  if x is
    0 ::
      Nil() then "oh"
//│ ╔══[ERROR] Cannot find operator `::` in the context
//│ ║  l.313: 	    0 ::
//│ ╙──       	      ^^
//│ f: anything -> error

fun f(x) =
  if x == 0 and x is
    A(_) then "A"
    B(_) then "B"
  else "bruh"
//│ f: int -> string

fun helper(x) =
  if x == 0 then None() else Some(x)
//│ helper: (int & 'value) -> (None | (Some with {value: 'value}))

fun g(x, y) =
  if x == 0 and helper(x) is
    Some(a) and helper(y) is
      Some(b) then a + b
      None() then a + 1
    None() and helper(y) is
      Some(b) then 2 + b
      None() then 1
  else
    0
//│ g: (int, int,) -> int
